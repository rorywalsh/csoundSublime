{
    "ArithmeticError": {
        "descr": "The base class for those built-in exceptions that are raised for various arithmetic errors: OverflowError, ZeroDivisionError, FloatingPointError.", 
        "name": "ArithmeticError", 
        "params": [], 
        "path": "python/library/exceptions#ArithmeticError", 
        "syntax": "exception ArithmeticError", 
        "type": "Built-in Exceptions"
    }, 
    "AssertionError": {
        "descr": "", 
        "name": "AssertionError", 
        "params": [], 
        "path": "python/library/exceptions#AssertionError", 
        "syntax": "exception AssertionError", 
        "type": "Built-in Exceptions"
    }, 
    "AttributeError": {
        "descr": "Raised when an attribute reference (see Attribute references) or assignment fails. (When an object does not support attribute references or attribute assignments at all, TypeError is raised.)", 
        "name": "AttributeError", 
        "params": [], 
        "path": "python/library/exceptions#AttributeError", 
        "syntax": "exception AttributeError", 
        "type": "Built-in Exceptions"
    }, 
    "BaseException": {
        "descr": "The base class for all built-in exceptions. It is not meant to be directly inherited by user-defined classes (for that, use Exception). If str() is called on an instance of this class, the representation of the argument(s) to the instance are returned, or the empty string when there were no arguments.", 
        "name": "BaseException", 
        "params": [], 
        "path": "python/library/exceptions#BaseException", 
        "syntax": "exception BaseException", 
        "type": "Built-in Exceptions"
    }, 
    "BaseException.args": {
        "descr": "The tuple of arguments given to the exception constructor. Some built-in exceptions (like IOError) expect a certain number of arguments and assign a special meaning to the elements of this tuple, while others are usually called only with a single string giving an error message.", 
        "name": "BaseException.args", 
        "params": [], 
        "path": "python/library/exceptions#BaseException.args", 
        "syntax": "args", 
        "type": "Built-in Exceptions"
    }, 
    "BaseException.with_traceback": {
        "descr": "This method sets tb as the new traceback for the exception and returns the exception object. It is usually used in exception handling code like this:", 
        "name": "BaseException.with_traceback", 
        "params": [], 
        "path": "python/library/exceptions#BaseException.with_traceback", 
        "syntax": "with_traceback(tb)", 
        "type": "Built-in Exceptions"
    }, 
    "BlockingIOError": {
        "descr": "Raised when an operation would block on an object (e.g. socket) set for non-blocking operation. Corresponds to errno EAGAIN, EALREADY, EWOULDBLOCK and EINPROGRESS.", 
        "name": "BlockingIOError", 
        "params": [], 
        "path": "python/library/exceptions#BlockingIOError", 
        "syntax": "exception BlockingIOError", 
        "type": "Built-in Exceptions"
    }, 
    "BlockingIOError.characters_written": {
        "descr": "An integer containing the number of characters written to the stream before it blocked. This attribute is available when using the buffered I/O classes from the io module.", 
        "name": "BlockingIOError.characters_written", 
        "params": [], 
        "path": "python/library/exceptions#BlockingIOError.characters_written", 
        "syntax": "characters_written", 
        "type": "Built-in Exceptions"
    }, 
    "BrokenPipeError": {
        "descr": "A subclass of ConnectionError, raised when trying to write on a pipe while the other end has been closed, or trying to write on a socket which has been shutdown for writing. Corresponds to errno EPIPE and ESHUTDOWN.", 
        "name": "BrokenPipeError", 
        "params": [], 
        "path": "python/library/exceptions#BrokenPipeError", 
        "syntax": "exception BrokenPipeError", 
        "type": "Built-in Exceptions"
    }, 
    "BufferError": {
        "descr": "Raised when a buffer related operation cannot be performed.", 
        "name": "BufferError", 
        "params": [], 
        "path": "python/library/exceptions#BufferError", 
        "syntax": "exception BufferError", 
        "type": "Built-in Exceptions"
    }, 
    "BytesWarning": {
        "descr": "Base class for warnings related to bytes and bytearray.", 
        "name": "BytesWarning", 
        "params": [], 
        "path": "python/library/exceptions#BytesWarning", 
        "syntax": "exception BytesWarning", 
        "type": "Built-in Exceptions"
    }, 
    "ChildProcessError": {
        "descr": "Raised when an operation on a child process failed. Corresponds to errno ECHILD.", 
        "name": "ChildProcessError", 
        "params": [], 
        "path": "python/library/exceptions#ChildProcessError", 
        "syntax": "exception ChildProcessError", 
        "type": "Built-in Exceptions"
    }, 
    "ConnectionAbortedError": {
        "descr": "A subclass of ConnectionError, raised when a connection attempt is aborted by the peer. Corresponds to errno ECONNABORTED.", 
        "name": "ConnectionAbortedError", 
        "params": [], 
        "path": "python/library/exceptions#ConnectionAbortedError", 
        "syntax": "exception ConnectionAbortedError", 
        "type": "Built-in Exceptions"
    }, 
    "ConnectionError": {
        "descr": "A base class for connection-related issues.", 
        "name": "ConnectionError", 
        "params": [], 
        "path": "python/library/exceptions#ConnectionError", 
        "syntax": "exception ConnectionError", 
        "type": "Built-in Exceptions"
    }, 
    "ConnectionRefusedError": {
        "descr": "A subclass of ConnectionError, raised when a connection attempt is refused by the peer. Corresponds to errno ECONNREFUSED.", 
        "name": "ConnectionRefusedError", 
        "params": [], 
        "path": "python/library/exceptions#ConnectionRefusedError", 
        "syntax": "exception ConnectionRefusedError", 
        "type": "Built-in Exceptions"
    }, 
    "ConnectionResetError": {
        "descr": "A subclass of ConnectionError, raised when a connection is reset by the peer. Corresponds to errno ECONNRESET.", 
        "name": "ConnectionResetError", 
        "params": [], 
        "path": "python/library/exceptions#ConnectionResetError", 
        "syntax": "exception ConnectionResetError", 
        "type": "Built-in Exceptions"
    }, 
    "DeprecationWarning": {
        "descr": "Base class for warnings about deprecated features.", 
        "name": "DeprecationWarning", 
        "params": [], 
        "path": "python/library/exceptions#DeprecationWarning", 
        "syntax": "exception DeprecationWarning", 
        "type": "Built-in Exceptions"
    }, 
    "EOFError": {
        "descr": "Raised when the input() function hits an end-of-file condition (EOF) without reading any data. (N.B.: the io.IOBase.read() and io.IOBase.readline() methods return an empty string when they hit EOF.)", 
        "name": "EOFError", 
        "params": [], 
        "path": "python/library/exceptions#EOFError", 
        "syntax": "exception EOFError", 
        "type": "Built-in Exceptions"
    }, 
    "Ellipsis": {
        "descr": "The same as .... Special value used mostly in conjunction with extended slicing syntax for user-defined container data types.", 
        "name": "Ellipsis", 
        "params": [], 
        "path": "python/library/constants#Ellipsis", 
        "syntax": "Ellipsis", 
        "type": "Built-in Constants"
    }, 
    "EnvironmentError": {
        "descr": "Only available on VMS.", 
        "name": "EnvironmentError", 
        "params": [], 
        "path": "python/library/exceptions#EnvironmentError", 
        "syntax": "exception EnvironmentError", 
        "type": "Built-in Exceptions"
    }, 
    "Exception": {
        "descr": "All built-in, non-system-exiting exceptions are derived from this class. All user-defined exceptions should also be derived from this class.", 
        "name": "Exception", 
        "params": [], 
        "path": "python/library/exceptions#Exception", 
        "syntax": "exception Exception", 
        "type": "Built-in Exceptions"
    }, 
    "False": {
        "descr": "The false value of the bool type. Assignments to False are illegal and raise a SyntaxError.", 
        "name": "False", 
        "params": [], 
        "path": "python/library/constants#False", 
        "syntax": "False", 
        "type": "Built-in Constants"
    }, 
    "FileExistsError": {
        "descr": "Raised when trying to create a file or directory which already exists. Corresponds to errno EEXIST.", 
        "name": "FileExistsError", 
        "params": [], 
        "path": "python/library/exceptions#FileExistsError", 
        "syntax": "exception FileExistsError", 
        "type": "Built-in Exceptions"
    }, 
    "FileNotFoundError": {
        "descr": "Raised when a file or directory is requested but doesn\u2019t exist. Corresponds to errno ENOENT.", 
        "name": "FileNotFoundError", 
        "params": [], 
        "path": "python/library/exceptions#FileNotFoundError", 
        "syntax": "exception FileNotFoundError", 
        "type": "Built-in Exceptions"
    }, 
    "FloatingPointError": {
        "descr": "Raised when a floating point operation fails. This exception is always defined, but can only be raised when Python is configured with the --with-fpectl option, or the WANT_SIGFPE_HANDLER symbol is defined in the pyconfig.h file.", 
        "name": "FloatingPointError", 
        "params": [], 
        "path": "python/library/exceptions#FloatingPointError", 
        "syntax": "exception FloatingPointError", 
        "type": "Built-in Exceptions"
    }, 
    "FutureWarning": {
        "descr": "Base class for warnings about constructs that will change semantically in the future.", 
        "name": "FutureWarning", 
        "params": [], 
        "path": "python/library/exceptions#FutureWarning", 
        "syntax": "exception FutureWarning", 
        "type": "Built-in Exceptions"
    }, 
    "GeneratorExit": {
        "descr": "Raise when a generator\u2018s close() method is called. It directly inherits from BaseException instead of Exception since it is technically not an error.", 
        "name": "GeneratorExit", 
        "params": [], 
        "path": "python/library/exceptions#GeneratorExit", 
        "syntax": "exception GeneratorExit", 
        "type": "Built-in Exceptions"
    }, 
    "IOError": {
        "descr": "Only available on VMS.", 
        "name": "IOError", 
        "params": [], 
        "path": "python/library/exceptions#IOError", 
        "syntax": "exception IOError", 
        "type": "Built-in Exceptions"
    }, 
    "ImportError": {
        "descr": "Raised when an import statement fails to find the module definition or when a from ... import fails to find a name that is to be imported.", 
        "name": "ImportError", 
        "params": [], 
        "path": "python/library/exceptions#ImportError", 
        "syntax": "exception ImportError", 
        "type": "Built-in Exceptions"
    }, 
    "ImportWarning": {
        "descr": "Base class for warnings about probable mistakes in module imports.", 
        "name": "ImportWarning", 
        "params": [], 
        "path": "python/library/exceptions#ImportWarning", 
        "syntax": "exception ImportWarning", 
        "type": "Built-in Exceptions"
    }, 
    "IndentationError": {
        "descr": "Base class for syntax errors related to incorrect indentation. This is a subclass of SyntaxError.", 
        "name": "IndentationError", 
        "params": [], 
        "path": "python/library/exceptions#IndentationError", 
        "syntax": "exception IndentationError", 
        "type": "Built-in Exceptions"
    }, 
    "IndexError": {
        "descr": "Raised when a sequence subscript is out of range. (Slice indices are silently truncated to fall in the allowed range; if an index is not an integer, TypeError is raised.)", 
        "name": "IndexError", 
        "params": [], 
        "path": "python/library/exceptions#IndexError", 
        "syntax": "exception IndexError", 
        "type": "Built-in Exceptions"
    }, 
    "InterruptedError": {
        "descr": "Raised when a system call is interrupted by an incoming signal. Corresponds to errno EINTR.", 
        "name": "InterruptedError", 
        "params": [], 
        "path": "python/library/exceptions#InterruptedError", 
        "syntax": "exception InterruptedError", 
        "type": "Built-in Exceptions"
    }, 
    "IsADirectoryError": {
        "descr": "Raised when a file operation (such as os.remove()) is requested on a directory. Corresponds to errno EISDIR.", 
        "name": "IsADirectoryError", 
        "params": [], 
        "path": "python/library/exceptions#IsADirectoryError", 
        "syntax": "exception IsADirectoryError", 
        "type": "Built-in Exceptions"
    }, 
    "KeyError": {
        "descr": "Raised when a mapping (dictionary) key is not found in the set of existing keys.", 
        "name": "KeyError", 
        "params": [], 
        "path": "python/library/exceptions#KeyError", 
        "syntax": "exception KeyError", 
        "type": "Built-in Exceptions"
    }, 
    "KeyboardInterrupt": {
        "descr": "Raised when the user hits the interrupt key (normally Control-C or Delete). During execution, a check for interrupts is made regularly. The exception inherits from BaseException so as to not be accidentally caught by code that catches Exception and thus prevent the interpreter from exiting.", 
        "name": "KeyboardInterrupt", 
        "params": [], 
        "path": "python/library/exceptions#KeyboardInterrupt", 
        "syntax": "exception KeyboardInterrupt", 
        "type": "Built-in Exceptions"
    }, 
    "LookupError": {
        "descr": "The base class for the exceptions that are raised when a key or index used on a mapping or sequence is invalid: IndexError, KeyError. This can be raised directly by codecs.lookup().", 
        "name": "LookupError", 
        "params": [], 
        "path": "python/library/exceptions#LookupError", 
        "syntax": "exception LookupError", 
        "type": "Built-in Exceptions"
    }, 
    "MemoryError": {
        "descr": "Raised when an operation runs out of memory but the situation may still be rescued (by deleting some objects). The associated value is a string indicating what kind of (internal) operation ran out of memory. Note that because of the underlying memory management architecture (C\u2019s malloc() function), the interpreter may not always be able to completely recover from this situation; it nevertheless raises an exception so that a stack traceback can be printed, in case a run-away program was the cause.", 
        "name": "MemoryError", 
        "params": [], 
        "path": "python/library/exceptions#MemoryError", 
        "syntax": "exception MemoryError", 
        "type": "Built-in Exceptions"
    }, 
    "NameError": {
        "descr": "Raised when a local or global name is not found. This applies only to unqualified names. The associated value is an error message that includes the name that could not be found.", 
        "name": "NameError", 
        "params": [], 
        "path": "python/library/exceptions#NameError", 
        "syntax": "exception NameError", 
        "type": "Built-in Exceptions"
    }, 
    "None": {
        "descr": "The sole value of the type NoneType. None is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Assignments to None are illegal and raise a SyntaxError.", 
        "name": "None", 
        "params": [], 
        "path": "python/library/constants#None", 
        "syntax": "None", 
        "type": "Built-in Constants"
    }, 
    "NotADirectoryError": {
        "descr": "Raised when a directory operation (such as os.listdir()) is requested on something which is not a directory. Corresponds to errno ENOTDIR.", 
        "name": "NotADirectoryError", 
        "params": [], 
        "path": "python/library/exceptions#NotADirectoryError", 
        "syntax": "exception NotADirectoryError", 
        "type": "Built-in Exceptions"
    }, 
    "NotImplemented": {
        "descr": "Special value which can be returned by the \u201crich comparison\u201d special methods (__eq__(), __lt__(), and friends), to indicate that the comparison is not implemented with respect to the other type.", 
        "name": "NotImplemented", 
        "params": [], 
        "path": "python/library/constants#NotImplemented", 
        "syntax": "NotImplemented", 
        "type": "Built-in Constants"
    }, 
    "NotImplementedError": {
        "descr": "This exception is derived from RuntimeError. In user defined base classes, abstract methods should raise this exception when they require derived classes to override the method.", 
        "name": "NotImplementedError", 
        "params": [], 
        "path": "python/library/exceptions#NotImplementedError", 
        "syntax": "exception NotImplementedError", 
        "type": "Built-in Exceptions"
    }, 
    "OSError": {
        "descr": "Under Windows, the winerror attribute gives you the native Windows error code. The errno attribute is then an approximate translation, in POSIX terms, of that native error code.", 
        "name": "OSError", 
        "params": [], 
        "path": "python/library/exceptions#OSError", 
        "syntax": "exception OSError", 
        "type": "Built-in Exceptions"
    }, 
    "OverflowError": {
        "descr": "Raised when the result of an arithmetic operation is too large to be represented. This cannot occur for integers (which would rather raise MemoryError than give up). Because of the lack of standardization of floating point exception handling in C, most floating point operations also aren\u2019t checked.", 
        "name": "OverflowError", 
        "params": [], 
        "path": "python/library/exceptions#OverflowError", 
        "syntax": "exception OverflowError", 
        "type": "Built-in Exceptions"
    }, 
    "PendingDeprecationWarning": {
        "descr": "Base class for warnings about features which will be deprecated in the future.", 
        "name": "PendingDeprecationWarning", 
        "params": [], 
        "path": "python/library/exceptions#PendingDeprecationWarning", 
        "syntax": "exception PendingDeprecationWarning", 
        "type": "Built-in Exceptions"
    }, 
    "PermissionError": {
        "descr": "Raised when trying to run an operation without the adequate access rights - for example filesystem permissions. Corresponds to errno EACCES and EPERM.", 
        "name": "PermissionError", 
        "params": [], 
        "path": "python/library/exceptions#PermissionError", 
        "syntax": "exception PermissionError", 
        "type": "Built-in Exceptions"
    }, 
    "ProcessLookupError": {
        "descr": "Raised when a given process doesn\u2019t exist. Corresponds to errno ESRCH.", 
        "name": "ProcessLookupError", 
        "params": [], 
        "path": "python/library/exceptions#ProcessLookupError", 
        "syntax": "exception ProcessLookupError", 
        "type": "Built-in Exceptions"
    }, 
    "ReferenceError": {
        "descr": "This exception is raised when a weak reference proxy, created by the weakref.proxy() function, is used to access an attribute of the referent after it has been garbage collected. For more information on weak references, see the weakref module.", 
        "name": "ReferenceError", 
        "params": [], 
        "path": "python/library/exceptions#ReferenceError", 
        "syntax": "exception ReferenceError", 
        "type": "Built-in Exceptions"
    }, 
    "ResourceWarning": {
        "descr": "Base class for warnings related to resource usage.", 
        "name": "ResourceWarning", 
        "params": [], 
        "path": "python/library/exceptions#ResourceWarning", 
        "syntax": "exception ResourceWarning", 
        "type": "Built-in Exceptions"
    }, 
    "RuntimeError": {
        "descr": "Raised when an error is detected that doesn\u2019t fall in any of the other categories. The associated value is a string indicating what precisely went wrong.", 
        "name": "RuntimeError", 
        "params": [], 
        "path": "python/library/exceptions#RuntimeError", 
        "syntax": "exception RuntimeError", 
        "type": "Built-in Exceptions"
    }, 
    "RuntimeWarning": {
        "descr": "Base class for warnings about dubious runtime behavior.", 
        "name": "RuntimeWarning", 
        "params": [], 
        "path": "python/library/exceptions#RuntimeWarning", 
        "syntax": "exception RuntimeWarning", 
        "type": "Built-in Exceptions"
    }, 
    "StopIteration": {
        "descr": "Raised by built-in function next() and an iterator\u2018s __next__() method to signal that there are no further items produced by the iterator.", 
        "name": "StopIteration", 
        "params": [], 
        "path": "python/library/exceptions#StopIteration", 
        "syntax": "exception StopIteration", 
        "type": "Built-in Exceptions"
    }, 
    "SyntaxError": {
        "descr": "Raised when the parser encounters a syntax error. This may occur in an import statement, in a call to the built-in functions exec() or eval(), or when reading the initial script or standard input (also interactively).", 
        "name": "SyntaxError", 
        "params": [], 
        "path": "python/library/exceptions#SyntaxError", 
        "syntax": "exception SyntaxError", 
        "type": "Built-in Exceptions"
    }, 
    "SyntaxWarning": {
        "descr": "Base class for warnings about dubious syntax", 
        "name": "SyntaxWarning", 
        "params": [], 
        "path": "python/library/exceptions#SyntaxWarning", 
        "syntax": "exception SyntaxWarning", 
        "type": "Built-in Exceptions"
    }, 
    "SystemError": {
        "descr": "Raised when the interpreter finds an internal error, but the situation does not look so serious to cause it to abandon all hope. The associated value is a string indicating what went wrong (in low-level terms).", 
        "name": "SystemError", 
        "params": [], 
        "path": "python/library/exceptions#SystemError", 
        "syntax": "exception SystemError", 
        "type": "Built-in Exceptions"
    }, 
    "SystemExit": {
        "descr": "This exception is raised by the sys.exit() function. When it is not handled, the Python interpreter exits; no stack traceback is printed. If the associated value is an integer, it specifies the system exit status (passed to C\u2019s exit() function); if it is None, the exit status is zero; if it has another type (such as a string), the object\u2019s value is printed and the exit status is one.", 
        "name": "SystemExit", 
        "params": [], 
        "path": "python/library/exceptions#SystemExit", 
        "syntax": "exception SystemExit", 
        "type": "Built-in Exceptions"
    }, 
    "TabError": {
        "descr": "Raised when indentation contains an inconsistent use of tabs and spaces. This is a subclass of IndentationError.", 
        "name": "TabError", 
        "params": [], 
        "path": "python/library/exceptions#TabError", 
        "syntax": "exception TabError", 
        "type": "Built-in Exceptions"
    }, 
    "TimeoutError": {
        "descr": "Raised when a system function timed out at the system level. Corresponds to errno ETIMEDOUT.", 
        "name": "TimeoutError", 
        "params": [], 
        "path": "python/library/exceptions#TimeoutError", 
        "syntax": "exception TimeoutError", 
        "type": "Built-in Exceptions"
    }, 
    "True": {
        "descr": "The true value of the bool type. Assignments to True are illegal and raise a SyntaxError.", 
        "name": "True", 
        "params": [], 
        "path": "python/library/constants#True", 
        "syntax": "True", 
        "type": "Built-in Constants"
    }, 
    "TypeError": {
        "descr": "Raised when an operation or function is applied to an object of inappropriate type. The associated value is a string giving details about the type mismatch.", 
        "name": "TypeError", 
        "params": [], 
        "path": "python/library/exceptions#TypeError", 
        "syntax": "exception TypeError", 
        "type": "Built-in Exceptions"
    }, 
    "UnboundLocalError": {
        "descr": "Raised when a reference is made to a local variable in a function or method, but no value has been bound to that variable. This is a subclass of NameError.", 
        "name": "UnboundLocalError", 
        "params": [], 
        "path": "python/library/exceptions#UnboundLocalError", 
        "syntax": "exception UnboundLocalError", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeDecodeError": {
        "descr": "Raised when a Unicode-related error occurs during decoding. It is a subclass of UnicodeError.", 
        "name": "UnicodeDecodeError", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeDecodeError", 
        "syntax": "exception UnicodeDecodeError", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeEncodeError": {
        "descr": "Raised when a Unicode-related error occurs during encoding. It is a subclass of UnicodeError.", 
        "name": "UnicodeEncodeError", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeEncodeError", 
        "syntax": "exception UnicodeEncodeError", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeError": {
        "descr": "Raised when a Unicode-related encoding or decoding error occurs. It is a subclass of ValueError.", 
        "name": "UnicodeError", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeError", 
        "syntax": "exception UnicodeError", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeError.encoding": {
        "descr": "The name of the encoding that raised the error.", 
        "name": "UnicodeError.encoding", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeError.encoding", 
        "syntax": "encoding", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeError.end": {
        "descr": "The index after the last invalid data in object.", 
        "name": "UnicodeError.end", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeError.end", 
        "syntax": "end", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeError.object": {
        "descr": "The object the codec was attempting to encode or decode.", 
        "name": "UnicodeError.object", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeError.object", 
        "syntax": "object", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeError.reason": {
        "descr": "A string describing the specific codec error.", 
        "name": "UnicodeError.reason", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeError.reason", 
        "syntax": "reason", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeError.start": {
        "descr": "The first index of invalid data in object.", 
        "name": "UnicodeError.start", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeError.start", 
        "syntax": "start", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeTranslateError": {
        "descr": "Raised when a Unicode-related error occurs during translating. It is a subclass of UnicodeError.", 
        "name": "UnicodeTranslateError", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeTranslateError", 
        "syntax": "exception UnicodeTranslateError", 
        "type": "Built-in Exceptions"
    }, 
    "UnicodeWarning": {
        "descr": "Base class for warnings related to Unicode.", 
        "name": "UnicodeWarning", 
        "params": [], 
        "path": "python/library/exceptions#UnicodeWarning", 
        "syntax": "exception UnicodeWarning", 
        "type": "Built-in Exceptions"
    }, 
    "UserWarning": {
        "descr": "Base class for warnings generated by user code.", 
        "name": "UserWarning", 
        "params": [], 
        "path": "python/library/exceptions#UserWarning", 
        "syntax": "exception UserWarning", 
        "type": "Built-in Exceptions"
    }, 
    "VMSError": {
        "descr": "Only available on VMS.", 
        "name": "VMSError", 
        "params": [], 
        "path": "python/library/exceptions#VMSError", 
        "syntax": "exception VMSError", 
        "type": "Built-in Exceptions"
    }, 
    "ValueError": {
        "descr": "Raised when a built-in operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError.", 
        "name": "ValueError", 
        "params": [], 
        "path": "python/library/exceptions#ValueError", 
        "syntax": "exception ValueError", 
        "type": "Built-in Exceptions"
    }, 
    "Warning": {
        "descr": "Base class for warning categories.", 
        "name": "Warning", 
        "params": [], 
        "path": "python/library/exceptions#Warning", 
        "syntax": "exception Warning", 
        "type": "Built-in Exceptions"
    }, 
    "WindowsError": {
        "descr": "Only available on Windows.", 
        "name": "WindowsError", 
        "params": [], 
        "path": "python/library/exceptions#WindowsError", 
        "syntax": "exception WindowsError", 
        "type": "Built-in Exceptions"
    }, 
    "ZeroDivisionError": {
        "descr": "Raised when the second argument of a division or modulo operation is zero. The associated value is a string indicating the type of the operands and the operation.", 
        "name": "ZeroDivisionError", 
        "params": [], 
        "path": "python/library/exceptions#ZeroDivisionError", 
        "syntax": "exception ZeroDivisionError", 
        "type": "Built-in Exceptions"
    }, 
    "__debug__": {
        "descr": "This constant is true if Python was not started with an -O option. See also the assert statement.", 
        "name": "__debug__", 
        "params": [], 
        "path": "python/library/constants#__debug__", 
        "syntax": "__debug__", 
        "type": "Built-in Constants"
    }, 
    "__import__": {
        "descr": "This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module().", 
        "name": "__import__", 
        "params": [], 
        "path": "python/library/functions#__import__", 
        "syntax": "__import__(name, globals=None, locals=None, fromlist=(), level=0)", 
        "type": "Built-in Functions"
    }, 
    "_thread.LockType": {
        "descr": "This is the type of lock objects.", 
        "name": "_thread.LockType", 
        "params": [], 
        "path": "python/library/_thread#_thread.LockType", 
        "syntax": "_thread.LockType", 
        "type": "Concurrent Execution"
    }, 
    "_thread.allocate_lock": {
        "descr": "Return a new lock object. Methods of locks are described below. The lock is initially unlocked.", 
        "name": "_thread.allocate_lock", 
        "params": [], 
        "path": "python/library/_thread#_thread.allocate_lock", 
        "syntax": "_thread.allocate_lock()", 
        "type": "Concurrent Execution"
    }, 
    "_thread.error": {
        "descr": "Raised on thread-specific errors.", 
        "name": "_thread.error", 
        "params": [], 
        "path": "python/library/_thread#_thread.error", 
        "syntax": "exception _thread.error", 
        "type": "Concurrent Execution"
    }, 
    "_thread.exit": {
        "descr": "Raise the SystemExit exception. When not caught, this will cause the thread to exit silently.", 
        "name": "_thread.exit", 
        "params": [], 
        "path": "python/library/_thread#_thread.exit", 
        "syntax": "_thread.exit()", 
        "type": "Concurrent Execution"
    }, 
    "_thread.get_ident": {
        "descr": "Return the \u2018thread identifier\u2019 of the current thread. This is a nonzero integer. Its value has no direct meaning; it is intended as a magic cookie to be used e.g. to index a dictionary of thread-specific data. Thread identifiers may be recycled when a thread exits and another thread is created.", 
        "name": "_thread.get_ident", 
        "params": [], 
        "path": "python/library/_thread#_thread.get_ident", 
        "syntax": "_thread.get_ident()", 
        "type": "Concurrent Execution"
    }, 
    "_thread.interrupt_main": {
        "descr": "Raise a KeyboardInterrupt exception in the main thread. A subthread can use this function to interrupt the main thread.", 
        "name": "_thread.interrupt_main", 
        "params": [], 
        "path": "python/library/_thread#_thread.interrupt_main", 
        "syntax": "_thread.interrupt_main()", 
        "type": "Concurrent Execution"
    }, 
    "_thread.lock.acquire": {
        "descr": "Without any optional argument, this method acquires the lock unconditionally, if necessary waiting until it is released by another thread (only one thread at a time can acquire a lock \u2014 that\u2019s their reason for existence).", 
        "name": "_thread.lock.acquire", 
        "params": [], 
        "path": "python/library/_thread#_thread.lock.acquire", 
        "syntax": "lock.acquire(waitflag=1, timeout=-1)", 
        "type": "Concurrent Execution"
    }, 
    "_thread.lock.locked": {
        "descr": "Return the status of the lock: True if it has been acquired by some thread, False if not.", 
        "name": "_thread.lock.locked", 
        "params": [], 
        "path": "python/library/_thread#_thread.lock.locked", 
        "syntax": "lock.locked()", 
        "type": "Concurrent Execution"
    }, 
    "_thread.lock.release": {
        "descr": "Releases the lock. The lock must have been acquired earlier, but not necessarily by the same thread.", 
        "name": "_thread.lock.release", 
        "params": [], 
        "path": "python/library/_thread#_thread.lock.release", 
        "syntax": "lock.release()", 
        "type": "Concurrent Execution"
    }, 
    "_thread.stack_size": {
        "descr": "Return the thread stack size used when creating new threads. The optional size argument specifies the stack size to be used for subsequently created threads, and must be 0 (use platform or configured default) or a positive integer value of at least 32,768 (32 KiB). If changing the thread stack size is unsupported, a RuntimeError is raised. If the specified stack size is invalid, a ValueError is raised and the stack size is unmodified. 32 KiB is currently the minimum supported stack size value to guarantee sufficient stack space for the interpreter itself. Note that some platforms may have particular restrictions on values for the stack size, such as requiring a minimum stack size > 32 KiB or requiring allocation in multiples of the system memory page size - platform documentation should be referred to for more information (4 KiB pages are common; using multiples of 4096 for the stack size is the suggested approach in the absence of more specific information). Availability: Windows, systems with POSIX threads.", 
        "name": "_thread.stack_size", 
        "params": [], 
        "path": "python/library/_thread#_thread.stack_size", 
        "syntax": "_thread.stack_size([size])", 
        "type": "Concurrent Execution"
    }, 
    "_thread.start_new_thread": {
        "descr": "Start a new thread and return its identifier. The thread executes the function function with the argument list args (which must be a tuple). The optional kwargs argument specifies a dictionary of keyword arguments. When the function returns, the thread silently exits. When the function terminates with an unhandled exception, a stack trace is printed and then the thread exits (but other threads continue to run).", 
        "name": "_thread.start_new_thread", 
        "params": [], 
        "path": "python/library/_thread#_thread.start_new_thread", 
        "syntax": "_thread.start_new_thread(function, args[, kwargs])", 
        "type": "Concurrent Execution"
    }, 
    "abc.ABCMeta": {
        "descr": "Metaclass for defining Abstract Base Classes (ABCs).", 
        "name": "abc.ABCMeta", 
        "params": [], 
        "path": "python/library/abc#abc.ABCMeta", 
        "syntax": "class abc.ABCMeta", 
        "type": "Runtime"
    }, 
    "abc.ABCMeta.__subclasshook__": {
        "descr": "(Must be defined as a class method.)", 
        "name": "abc.ABCMeta.__subclasshook__", 
        "params": [], 
        "path": "python/library/abc#abc.ABCMeta.__subclasshook__", 
        "syntax": "__subclasshook__(subclass)", 
        "type": "Runtime"
    }, 
    "abc.ABCMeta.register": {
        "descr": "Register subclass as a \u201cvirtual subclass\u201d of this ABC. For example:", 
        "name": "abc.ABCMeta.register", 
        "params": [], 
        "path": "python/library/abc#abc.ABCMeta.register", 
        "syntax": "register(subclass)", 
        "type": "Runtime"
    }, 
    "abc.abstractclassmethod": {
        "descr": "A subclass of the built-in classmethod(), indicating an abstract classmethod. Otherwise it is similar to abstractmethod().", 
        "name": "abc.abstractclassmethod", 
        "params": [], 
        "path": "python/library/abc#abc.abstractclassmethod", 
        "syntax": "@abc.abstractclassmethod", 
        "type": "Runtime"
    }, 
    "abc.abstractmethod": {
        "descr": "A decorator indicating abstract methods.", 
        "name": "abc.abstractmethod", 
        "params": [], 
        "path": "python/library/abc#abc.abstractmethod", 
        "syntax": "@abc.abstractmethod", 
        "type": "Runtime"
    }, 
    "abc.abstractproperty": {
        "descr": "A subclass of the built-in property(), indicating an abstract property.", 
        "name": "abc.abstractproperty", 
        "params": [], 
        "path": "python/library/abc#abc.abstractproperty", 
        "syntax": "@abc.abstractproperty(fget=None, fset=None, fdel=None, doc=None)", 
        "type": "Runtime"
    }, 
    "abc.abstractstaticmethod": {
        "descr": "A subclass of the built-in staticmethod(), indicating an abstract staticmethod. Otherwise it is similar to abstractmethod().", 
        "name": "abc.abstractstaticmethod", 
        "params": [], 
        "path": "python/library/abc#abc.abstractstaticmethod", 
        "syntax": "@abc.abstractstaticmethod", 
        "type": "Runtime"
    }, 
    "abs": {
        "descr": "Return the absolute value of a number. The argument may be an integer or a floating point number. If the argument is a complex number, its magnitude is returned.", 
        "name": "abs", 
        "params": [], 
        "path": "python/library/functions#abs", 
        "syntax": "abs(x)", 
        "type": "Built-in Functions"
    }, 
    "aifc.aifc.aifc": {
        "descr": "Create an AIFF-C file. The default is that an AIFF-C file is created, unless the name of the file ends in '.aiff' in which case the default is an AIFF file.", 
        "name": "aifc.aifc.aifc", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.aifc", 
        "syntax": "aifc.aifc()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.aiff": {
        "descr": "Create an AIFF file. The default is that an AIFF-C file is created, unless the name of the file ends in '.aiff' in which case the default is an AIFF file.", 
        "name": "aifc.aifc.aiff", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.aiff", 
        "syntax": "aifc.aiff()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.close": {
        "descr": "Close the AIFF file. After calling this method, the object can no longer be used.", 
        "name": "aifc.aifc.close", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.close", 
        "syntax": "aifc.close()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getcompname": {
        "descr": "Return a bytes array convertible to a human-readable description of the type of compression used in the audio file. For AIFF files, the returned value is b'not compressed'.", 
        "name": "aifc.aifc.getcompname", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getcompname", 
        "syntax": "aifc.getcompname()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getcomptype": {
        "descr": "Return a bytes array of length 4 describing the type of compression used in the audio file. For AIFF files, the returned value is b'NONE'.", 
        "name": "aifc.aifc.getcomptype", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getcomptype", 
        "syntax": "aifc.getcomptype()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getframerate": {
        "descr": "Return the sampling rate (number of audio frames per second).", 
        "name": "aifc.aifc.getframerate", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getframerate", 
        "syntax": "aifc.getframerate()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getmark": {
        "descr": "Return the tuple as described in getmarkers() for the mark with the given id.", 
        "name": "aifc.aifc.getmark", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getmark", 
        "syntax": "aifc.getmark(id)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getmarkers": {
        "descr": "Return a list of markers in the audio file. A marker consists of a tuple of three elements. The first is the mark ID (an integer), the second is the mark position in frames from the beginning of the data (an integer), the third is the name of the mark (a string).", 
        "name": "aifc.aifc.getmarkers", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getmarkers", 
        "syntax": "aifc.getmarkers()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getnchannels": {
        "descr": "Return the number of audio channels (1 for mono, 2 for stereo).", 
        "name": "aifc.aifc.getnchannels", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getnchannels", 
        "syntax": "aifc.getnchannels()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getnframes": {
        "descr": "Return the number of audio frames in the file.", 
        "name": "aifc.aifc.getnframes", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getnframes", 
        "syntax": "aifc.getnframes()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getparams": {
        "descr": "Return a tuple consisting of all of the above values in the above order.", 
        "name": "aifc.aifc.getparams", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getparams", 
        "syntax": "aifc.getparams()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.getsampwidth": {
        "descr": "Return the size in bytes of individual samples.", 
        "name": "aifc.aifc.getsampwidth", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.getsampwidth", 
        "syntax": "aifc.getsampwidth()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.readframes": {
        "descr": "Read and return the next nframes frames from the audio file. The returned data is a string containing for each frame the uncompressed samples of all channels.", 
        "name": "aifc.aifc.readframes", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.readframes", 
        "syntax": "aifc.readframes(nframes)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.rewind": {
        "descr": "Rewind the read pointer. The next readframes() will start from the beginning.", 
        "name": "aifc.aifc.rewind", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.rewind", 
        "syntax": "aifc.rewind()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setcomptype": {
        "descr": "", 
        "name": "aifc.aifc.setcomptype", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setcomptype", 
        "syntax": "aifc.setcomptype(type, name)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setframerate": {
        "descr": "Specify the sampling frequency in frames per second.", 
        "name": "aifc.aifc.setframerate", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setframerate", 
        "syntax": "aifc.setframerate(rate)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setmark": {
        "descr": "Add a mark with the given id (larger than 0), and the given name at the given position. This method can be called at any time before close().", 
        "name": "aifc.aifc.setmark", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setmark", 
        "syntax": "aifc.setmark(id, pos, name)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setnchannels": {
        "descr": "Specify the number of channels in the audio file.", 
        "name": "aifc.aifc.setnchannels", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setnchannels", 
        "syntax": "aifc.setnchannels(nchannels)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setnframes": {
        "descr": "Specify the number of frames that are to be written to the audio file. If this parameter is not set, or not set correctly, the file needs to support seeking.", 
        "name": "aifc.aifc.setnframes", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setnframes", 
        "syntax": "aifc.setnframes(nframes)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setparams": {
        "descr": "Set all the above parameters at once. The argument is a tuple consisting of the various parameters. This means that it is possible to use the result of a getparams() call as argument to setparams().", 
        "name": "aifc.aifc.setparams", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setparams", 
        "syntax": "aifc.setparams(nchannels, sampwidth, framerate, comptype, compname)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setpos": {
        "descr": "Seek to the specified frame number.", 
        "name": "aifc.aifc.setpos", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setpos", 
        "syntax": "aifc.setpos(pos)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.setsampwidth": {
        "descr": "Specify the size in bytes of audio samples.", 
        "name": "aifc.aifc.setsampwidth", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.setsampwidth", 
        "syntax": "aifc.setsampwidth(width)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.tell": {
        "descr": "Return the current frame number.", 
        "name": "aifc.aifc.tell", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.tell", 
        "syntax": "aifc.tell()", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.writeframes": {
        "descr": "Write data to the output file. This method can only be called after the audio file parameters have been set.", 
        "name": "aifc.aifc.writeframes", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.writeframes", 
        "syntax": "aifc.writeframes(data)", 
        "type": "Multimedia"
    }, 
    "aifc.aifc.writeframesraw": {
        "descr": "Like writeframes(), except that the header of the audio file is not updated.", 
        "name": "aifc.aifc.writeframesraw", 
        "params": [], 
        "path": "python/library/aifc#aifc.aifc.writeframesraw", 
        "syntax": "aifc.writeframesraw(data)", 
        "type": "Multimedia"
    }, 
    "aifc.open": {
        "descr": "Open an AIFF or AIFF-C file and return an object instance with methods that are described below. The argument file is either a string naming a file or a file object. mode must be 'r' or 'rb' when the file must be opened for reading, or 'w' or 'wb' when the file must be opened for writing. If omitted, file.mode is used if it exists, otherwise 'rb' is used. When used for writing, the file object should be seekable, unless you know ahead of time how many samples you are going to write in total and use writeframesraw() and setnframes().", 
        "name": "aifc.open", 
        "params": [], 
        "path": "python/library/aifc#aifc.open", 
        "syntax": "aifc.open(file, mode=None)", 
        "type": "Multimedia"
    }, 
    "all": {
        "descr": "Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to:", 
        "name": "all", 
        "params": [], 
        "path": "python/library/functions#all", 
        "syntax": "all(iterable)", 
        "type": "Built-in Functions"
    }, 
    "any": {
        "descr": "Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to:", 
        "name": "any", 
        "params": [], 
        "path": "python/library/functions#any", 
        "syntax": "any(iterable)", 
        "type": "Built-in Functions"
    }, 
    "append": {
        "descr": "Append a new item with value x to the end of the array.", 
        "name": "array.array.append", 
        "params": [], 
        "path": "python/library/array#array.array.append", 
        "syntax": "array.append(x)", 
        "type": "Data Types"
    }, 
    "argparse.ArgumentDefaultsHelpFormatter": {
        "descr": "RawDescriptionHelpFormatter and RawTextHelpFormatter give more control over how textual descriptions are displayed. By default, ArgumentParser objects line-wrap the description and epilog texts in command-line help messages:", 
        "name": "argparse.ArgumentDefaultsHelpFormatter", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentDefaultsHelpFormatter", 
        "syntax": "class argparse.ArgumentDefaultsHelpFormatter", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser": {
        "descr": "Create a new ArgumentParser object. All parameters should be passed as keyword arguments. Each parameter has its own more detailed description below, but in short they are:", 
        "name": "argparse.ArgumentParser", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser", 
        "syntax": "class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.add_argument": {
        "descr": "Define how a single command-line argument should be parsed. Each parameter has its own more detailed description below, but in short they are:", 
        "name": "argparse.ArgumentParser.add_argument", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.add_argument", 
        "syntax": "ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.add_argument_group": {
        "descr": "By default, ArgumentParser groups command-line arguments into \u201cpositional arguments\u201d and \u201coptional arguments\u201d when displaying help messages. When there is a better conceptual grouping of arguments than this default one, appropriate groups can be created using the add_argument_group() method:", 
        "name": "argparse.ArgumentParser.add_argument_group", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.add_argument_group", 
        "syntax": "ArgumentParser.add_argument_group(title=None, description=None)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.add_mutually_exclusive_group": {
        "descr": "Create a mutually exclusive group. argparse will make sure that only one of the arguments in the mutually exclusive group was present on the command line:", 
        "name": "argparse.ArgumentParser.add_mutually_exclusive_group", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.add_mutually_exclusive_group", 
        "syntax": "ArgumentParser.add_mutually_exclusive_group(required=False)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.add_subparsers": {
        "descr": "Many programs split up their functionality into a number of sub-commands, for example, the svn program can invoke sub-commands like svn checkout, svn update, and svn commit. Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. ArgumentParser supports the creation of such sub-commands with the add_subparsers() method. The add_subparsers() method is normally called with no arguments and returns a special action object. This object has a single method, add_parser(), which takes a command name and any ArgumentParser constructor arguments, and returns an ArgumentParser object that can be modified as usual.", 
        "name": "argparse.ArgumentParser.add_subparsers", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.add_subparsers", 
        "syntax": "ArgumentParser.add_subparsers([title][, description][, prog][, parser_class][, action][, option_string][, dest][, help][, metavar])", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.convert_arg_line_to_args": {
        "descr": "Arguments that are read from a file (see the fromfile_prefix_chars keyword argument to the ArgumentParser constructor) are read one argument per line. convert_arg_line_to_args() can be overriden for fancier reading.", 
        "name": "argparse.ArgumentParser.convert_arg_line_to_args", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.convert_arg_line_to_args", 
        "syntax": "ArgumentParser.convert_arg_line_to_args(arg_line)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.error": {
        "descr": "This method prints a usage message including the message to the standard error and terminates the program with a status code of 2.", 
        "name": "argparse.ArgumentParser.error", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.error", 
        "syntax": "ArgumentParser.error(message)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.exit": {
        "descr": "This method terminates the program, exiting with the specified status and, if given, it prints a message before that.", 
        "name": "argparse.ArgumentParser.exit", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.exit", 
        "syntax": "ArgumentParser.exit(status=0, message=None)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.format_help": {
        "descr": "Return a string containing a help message, including the program usage and information about the arguments registered with the ArgumentParser.", 
        "name": "argparse.ArgumentParser.format_help", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.format_help", 
        "syntax": "ArgumentParser.format_help()", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.format_usage": {
        "descr": "Return a string containing a brief description of how the ArgumentParser should be invoked on the command line.", 
        "name": "argparse.ArgumentParser.format_usage", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.format_usage", 
        "syntax": "ArgumentParser.format_usage()", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.get_default": {
        "descr": "Get the default value for a namespace attribute, as set by either add_argument() or by set_defaults():", 
        "name": "argparse.ArgumentParser.get_default", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.get_default", 
        "syntax": "ArgumentParser.get_default(dest)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.parse_args": {
        "descr": "Convert argument strings to objects and assign them as attributes of the namespace. Return the populated namespace.", 
        "name": "argparse.ArgumentParser.parse_args", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.parse_args", 
        "syntax": "ArgumentParser.parse_args(args=None, namespace=None)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.parse_known_args": {
        "descr": "Sometimes a script may only parse a few of the command-line arguments, passing the remaining arguments on to another script or program. In these cases, the parse_known_args() method can be useful. It works much like parse_args() except that it does not produce an error when extra arguments are present. Instead, it returns a two item tuple containing the populated namespace and the list of remaining argument strings.", 
        "name": "argparse.ArgumentParser.parse_known_args", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.parse_known_args", 
        "syntax": "ArgumentParser.parse_known_args(args=None, namespace=None)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.print_help": {
        "descr": "Print a help message, including the program usage and information about the arguments registered with the ArgumentParser. If file is None, sys.stdout is assumed.", 
        "name": "argparse.ArgumentParser.print_help", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.print_help", 
        "syntax": "ArgumentParser.print_help(file=None)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.print_usage": {
        "descr": "Print a brief description of how the ArgumentParser should be invoked on the command line. If file is None, sys.stdout is assumed.", 
        "name": "argparse.ArgumentParser.print_usage", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.print_usage", 
        "syntax": "ArgumentParser.print_usage(file=None)", 
        "type": "Operating System"
    }, 
    "argparse.ArgumentParser.set_defaults": {
        "descr": "Most of the time, the attributes of the object returned by parse_args() will be fully determined by inspecting the command-line arguments and the argument actions. set_defaults() allows some additional attributes that are determined without any inspection of the command line to be added:", 
        "name": "argparse.ArgumentParser.set_defaults", 
        "params": [], 
        "path": "python/library/argparse#argparse.ArgumentParser.set_defaults", 
        "syntax": "ArgumentParser.set_defaults(**kwargs)", 
        "type": "Operating System"
    }, 
    "argparse.FileType": {
        "descr": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument(). Arguments that have FileType objects as their type will open command-line arguments as files with the requested modes and buffer sizes:", 
        "name": "argparse.FileType", 
        "params": [], 
        "path": "python/library/argparse#argparse.FileType", 
        "syntax": "class argparse.FileType(mode='r', bufsize=None)", 
        "type": "Operating System"
    }, 
    "argparse.MetavarTypeHelpFormatter": {
        "descr": "RawDescriptionHelpFormatter and RawTextHelpFormatter give more control over how textual descriptions are displayed. By default, ArgumentParser objects line-wrap the description and epilog texts in command-line help messages:", 
        "name": "argparse.MetavarTypeHelpFormatter", 
        "params": [], 
        "path": "python/library/argparse#argparse.MetavarTypeHelpFormatter", 
        "syntax": "class argparse.MetavarTypeHelpFormatter", 
        "type": "Operating System"
    }, 
    "argparse.Namespace": {
        "descr": "Simple class used by default by parse_args() to create an object holding attributes and return it.", 
        "name": "argparse.Namespace", 
        "params": [], 
        "path": "python/library/argparse#argparse.Namespace", 
        "syntax": "class argparse.Namespace", 
        "type": "Operating System"
    }, 
    "argparse.RawDescriptionHelpFormatter": {
        "descr": "RawDescriptionHelpFormatter and RawTextHelpFormatter give more control over how textual descriptions are displayed. By default, ArgumentParser objects line-wrap the description and epilog texts in command-line help messages:", 
        "name": "argparse.RawDescriptionHelpFormatter", 
        "params": [], 
        "path": "python/library/argparse#argparse.RawDescriptionHelpFormatter", 
        "syntax": "class argparse.RawDescriptionHelpFormatter", 
        "type": "Operating System"
    }, 
    "argparse.RawTextHelpFormatter": {
        "descr": "RawDescriptionHelpFormatter and RawTextHelpFormatter give more control over how textual descriptions are displayed. By default, ArgumentParser objects line-wrap the description and epilog texts in command-line help messages:", 
        "name": "argparse.RawTextHelpFormatter", 
        "params": [], 
        "path": "python/library/argparse#argparse.RawTextHelpFormatter", 
        "syntax": "class argparse.RawTextHelpFormatter", 
        "type": "Operating System"
    }, 
    "array": {
        "descr": "A new array whose items are restricted by typecode, and initialized from the optional initializer value, which must be a list, a bytes-like object, or iterable over elements of the appropriate type.", 
        "name": "array.array", 
        "params": [], 
        "path": "python/library/array#array.array", 
        "syntax": "class array.array(typecode[, initializer])", 
        "type": "Data Types"
    }, 
    "array.array": {
        "descr": "A new array whose items are restricted by typecode, and initialized from the optional initializer value, which must be a list, a bytes-like object, or iterable over elements of the appropriate type.", 
        "name": "array.array", 
        "params": [], 
        "path": "python/library/array#array.array", 
        "syntax": "class array.array(typecode[, initializer])", 
        "type": "Data Types"
    }, 
    "array.array.append": {
        "descr": "Append a new item with value x to the end of the array.", 
        "name": "array.array.append", 
        "params": [], 
        "path": "python/library/array#array.array.append", 
        "syntax": "array.append(x)", 
        "type": "Data Types"
    }, 
    "array.array.buffer_info": {
        "descr": "Return a tuple (address, length) giving the current memory address and the length in elements of the buffer used to hold array\u2019s contents. The size of the memory buffer in bytes can be computed as array.buffer_info()[1] * array.itemsize. This is occasionally useful when working with low-level (and inherently unsafe) I/O interfaces that require memory addresses, such as certain ioctl() operations. The returned numbers are valid as long as the array exists and no length-changing operations are applied to it.", 
        "name": "array.array.buffer_info", 
        "params": [], 
        "path": "python/library/array#array.array.buffer_info", 
        "syntax": "array.buffer_info()", 
        "type": "Data Types"
    }, 
    "array.array.byteswap": {
        "descr": "\u201cByteswap\u201d all items of the array. This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, RuntimeError is raised. It is useful when reading data from a file written on a machine with a different byte order.", 
        "name": "array.array.byteswap", 
        "params": [], 
        "path": "python/library/array#array.array.byteswap", 
        "syntax": "array.byteswap()", 
        "type": "Data Types"
    }, 
    "array.array.count": {
        "descr": "Return the number of occurrences of x in the array.", 
        "name": "array.array.count", 
        "params": [], 
        "path": "python/library/array#array.array.count", 
        "syntax": "array.count(x)", 
        "type": "Data Types"
    }, 
    "array.array.extend": {
        "descr": "Append items from iterable to the end of the array. If iterable is another array, it must have exactly the same type code; if not, TypeError will be raised. If iterable is not an array, it must be iterable and its elements must be the right type to be appended to the array.", 
        "name": "array.array.extend", 
        "params": [], 
        "path": "python/library/array#array.array.extend", 
        "syntax": "array.extend(iterable)", 
        "type": "Data Types"
    }, 
    "array.array.frombytes": {
        "descr": "Appends items from the string, interpreting the string as an array of machine values (as if it had been read from a file using the fromfile() method).", 
        "name": "array.array.frombytes", 
        "params": [], 
        "path": "python/library/array#array.array.frombytes", 
        "syntax": "array.frombytes(s)", 
        "type": "Data Types"
    }, 
    "array.array.fromfile": {
        "descr": "Read n items (as machine values) from the file object f and append them to the end of the array. If less than n items are available, EOFError is raised, but the items that were available are still inserted into the array. f must be a real built-in file object; something else with a read() method won\u2019t do.", 
        "name": "array.array.fromfile", 
        "params": [], 
        "path": "python/library/array#array.array.fromfile", 
        "syntax": "array.fromfile(f, n)", 
        "type": "Data Types"
    }, 
    "array.array.fromlist": {
        "descr": "Append items from the list. This is equivalent to for x in list: a.append(x) except that if there is a type error, the array is unchanged.", 
        "name": "array.array.fromlist", 
        "params": [], 
        "path": "python/library/array#array.array.fromlist", 
        "syntax": "array.fromlist(list)", 
        "type": "Data Types"
    }, 
    "array.array.fromstring": {
        "descr": "Deprecated alias for frombytes().", 
        "name": "array.array.fromstring", 
        "params": [], 
        "path": "python/library/array#array.array.fromstring", 
        "syntax": "array.fromstring()", 
        "type": "Data Types"
    }, 
    "array.array.fromunicode": {
        "descr": "Extends this array with data from the given unicode string. The array must be a type 'u' array; otherwise a ValueError is raised. Use array.frombytes(unicodestring.encode(enc)) to append Unicode data to an array of some other type.", 
        "name": "array.array.fromunicode", 
        "params": [], 
        "path": "python/library/array#array.array.fromunicode", 
        "syntax": "array.fromunicode(s)", 
        "type": "Data Types"
    }, 
    "array.array.index": {
        "descr": "Return the smallest i such that i is the index of the first occurrence of x in the array.", 
        "name": "array.array.index", 
        "params": [], 
        "path": "python/library/array#array.array.index", 
        "syntax": "array.index(x)", 
        "type": "Data Types"
    }, 
    "array.array.insert": {
        "descr": "Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", 
        "name": "array.array.insert", 
        "params": [], 
        "path": "python/library/array#array.array.insert", 
        "syntax": "array.insert(i, x)", 
        "type": "Data Types"
    }, 
    "array.array.itemsize": {
        "descr": "The length in bytes of one array item in the internal representation.", 
        "name": "array.array.itemsize", 
        "params": [], 
        "path": "python/library/array#array.array.itemsize", 
        "syntax": "array.itemsize", 
        "type": "Data Types"
    }, 
    "array.array.pop": {
        "descr": "Removes the item with the index i from the array and returns it. The optional argument defaults to -1, so that by default the last item is removed and returned.", 
        "name": "array.array.pop", 
        "params": [], 
        "path": "python/library/array#array.array.pop", 
        "syntax": "array.pop([i])", 
        "type": "Data Types"
    }, 
    "array.array.remove": {
        "descr": "Remove the first occurrence of x from the array.", 
        "name": "array.array.remove", 
        "params": [], 
        "path": "python/library/array#array.array.remove", 
        "syntax": "array.remove(x)", 
        "type": "Data Types"
    }, 
    "array.array.reverse": {
        "descr": "Reverse the order of the items in the array.", 
        "name": "array.array.reverse", 
        "params": [], 
        "path": "python/library/array#array.array.reverse", 
        "syntax": "array.reverse()", 
        "type": "Data Types"
    }, 
    "array.array.tobytes": {
        "descr": "Convert the array to an array of machine values and return the bytes representation (the same sequence of bytes that would be written to a file by the tofile() method.)", 
        "name": "array.array.tobytes", 
        "params": [], 
        "path": "python/library/array#array.array.tobytes", 
        "syntax": "array.tobytes()", 
        "type": "Data Types"
    }, 
    "array.array.tofile": {
        "descr": "Write all items (as machine values) to the file object f.", 
        "name": "array.array.tofile", 
        "params": [], 
        "path": "python/library/array#array.array.tofile", 
        "syntax": "array.tofile(f)", 
        "type": "Data Types"
    }, 
    "array.array.tolist": {
        "descr": "Convert the array to an ordinary list with the same items.", 
        "name": "array.array.tolist", 
        "params": [], 
        "path": "python/library/array#array.array.tolist", 
        "syntax": "array.tolist()", 
        "type": "Data Types"
    }, 
    "array.array.tostring": {
        "descr": "Deprecated alias for tobytes().", 
        "name": "array.array.tostring", 
        "params": [], 
        "path": "python/library/array#array.array.tostring", 
        "syntax": "array.tostring()", 
        "type": "Data Types"
    }, 
    "array.array.tounicode": {
        "descr": "Convert the array to a unicode string. The array must be a type 'u' array; otherwise a ValueError is raised. Use array.tobytes().decode(enc) to obtain a unicode string from an array of some other type.", 
        "name": "array.array.tounicode", 
        "params": [], 
        "path": "python/library/array#array.array.tounicode", 
        "syntax": "array.tounicode()", 
        "type": "Data Types"
    }, 
    "array.array.typecode": {
        "descr": "The typecode character used to create the array.", 
        "name": "array.array.typecode", 
        "params": [], 
        "path": "python/library/array#array.array.typecode", 
        "syntax": "array.typecode", 
        "type": "Data Types"
    }, 
    "array.typecodes": {
        "descr": "A string with all available type codes.", 
        "name": "array.typecodes", 
        "params": [], 
        "path": "python/library/array#array.typecodes", 
        "syntax": "array.typecodes", 
        "type": "Data Types"
    }, 
    "as_integer_ratio": {
        "descr": "Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs.", 
        "name": "float.as_integer_ratio", 
        "params": [], 
        "path": "python/library/stdtypes#float.as_integer_ratio", 
        "syntax": "float.as_integer_ratio()", 
        "type": "Built-in Types"
    }, 
    "ascii": {
        "descr": "As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u or \\U escapes. This generates a string similar to that returned by repr() in Python 2.", 
        "name": "ascii", 
        "params": [], 
        "path": "python/library/functions#ascii", 
        "syntax": "ascii(object)", 
        "type": "Built-in Functions"
    }, 
    "asynchat.async_chat": {
        "descr": "This class is an abstract subclass of asyncore.dispatcher. To make practical use of the code you must subclass async_chat, providing meaningful collect_incoming_data() and found_terminator() methods. The asyncore.dispatcher methods can be used, although not all make sense in a message/response context.", 
        "name": "asynchat.async_chat", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat", 
        "syntax": "class asynchat.async_chat", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.ac_in_buffer_size": {
        "descr": "The asynchronous input buffer size (default 4096).", 
        "name": "asynchat.async_chat.ac_in_buffer_size", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.ac_in_buffer_size", 
        "syntax": "ac_in_buffer_size", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.ac_out_buffer_size": {
        "descr": "The asynchronous output buffer size (default 4096).", 
        "name": "asynchat.async_chat.ac_out_buffer_size", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.ac_out_buffer_size", 
        "syntax": "ac_out_buffer_size", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.close_when_done": {
        "descr": "Pushes a None on to the producer fifo. When this producer is popped off the fifo it causes the channel to be closed.", 
        "name": "asynchat.async_chat.close_when_done", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.close_when_done", 
        "syntax": "async_chat.close_when_done()", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.collect_incoming_data": {
        "descr": "Called with data holding an arbitrary amount of received data. The default method, which must be overridden, raises a NotImplementedError exception.", 
        "name": "asynchat.async_chat.collect_incoming_data", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.collect_incoming_data", 
        "syntax": "async_chat.collect_incoming_data(data)", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.discard_buffers": {
        "descr": "In emergencies this method will discard any data held in the input and/or output buffers and the producer fifo.", 
        "name": "asynchat.async_chat.discard_buffers", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.discard_buffers", 
        "syntax": "async_chat.discard_buffers()", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.found_terminator": {
        "descr": "Called when the incoming data stream matches the termination condition set by set_terminator(). The default method, which must be overridden, raises a NotImplementedError exception. The buffered input data should be available via an instance attribute.", 
        "name": "asynchat.async_chat.found_terminator", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.found_terminator", 
        "syntax": "async_chat.found_terminator()", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.get_terminator": {
        "descr": "Returns the current terminator for the channel.", 
        "name": "asynchat.async_chat.get_terminator", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.get_terminator", 
        "syntax": "async_chat.get_terminator()", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.push": {
        "descr": "Pushes data on to the channel\u2019s fifo to ensure its transmission. This is all you need to do to have the channel write the data out to the network, although it is possible to use your own producers in more complex schemes to implement encryption and chunking, for example.", 
        "name": "asynchat.async_chat.push", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.push", 
        "syntax": "async_chat.push(data)", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.push_with_producer": {
        "descr": "Takes a producer object and adds it to the producer fifo associated with the channel. When all currently-pushed producers have been exhausted the channel will consume this producer\u2019s data by calling its more() method and send the data to the remote endpoint.", 
        "name": "asynchat.async_chat.push_with_producer", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.push_with_producer", 
        "syntax": "async_chat.push_with_producer(producer)", 
        "type": "Networking"
    }, 
    "asynchat.async_chat.set_terminator": {
        "descr": "Sets the terminating condition to be recognized on the channel. term may be any of three types of value, corresponding to three different ways to handle incoming protocol data.", 
        "name": "asynchat.async_chat.set_terminator", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.async_chat.set_terminator", 
        "syntax": "async_chat.set_terminator(term)", 
        "type": "Networking"
    }, 
    "asynchat.fifo": {
        "descr": "A fifo holding data which has been pushed by the application but not yet popped for writing to the channel. A fifo is a list used to hold data and/or producers until they are required. If the list argument is provided then it should contain producers or data items to be written to the channel.", 
        "name": "asynchat.fifo", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.fifo", 
        "syntax": "class asynchat.fifo(list=None)", 
        "type": "Networking"
    }, 
    "asynchat.fifo.first": {
        "descr": "Returns the least-recently push()ed item from the fifo.", 
        "name": "asynchat.fifo.first", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.fifo.first", 
        "syntax": "first()", 
        "type": "Networking"
    }, 
    "asynchat.fifo.is_empty": {
        "descr": "Returns True if and only if the fifo is empty.", 
        "name": "asynchat.fifo.is_empty", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.fifo.is_empty", 
        "syntax": "is_empty()", 
        "type": "Networking"
    }, 
    "asynchat.fifo.pop": {
        "descr": "If the fifo is not empty, returns True, first(), deleting the popped item. Returns False, None for an empty fifo.", 
        "name": "asynchat.fifo.pop", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.fifo.pop", 
        "syntax": "pop()", 
        "type": "Networking"
    }, 
    "asynchat.fifo.push": {
        "descr": "Adds the given data (which may be a string or a producer object) to the producer fifo.", 
        "name": "asynchat.fifo.push", 
        "params": [], 
        "path": "python/library/asynchat#asynchat.fifo.push", 
        "syntax": "push(data)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher": {
        "descr": "The dispatcher class is a thin wrapper around a low-level socket object. To make it more useful, it has a few methods for event-handling which are called from the asynchronous loop. Otherwise, it can be treated as a normal non-blocking socket object.", 
        "name": "asyncore.dispatcher", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher", 
        "syntax": "class asyncore.dispatcher", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.accept": {
        "descr": "Accept a connection. The socket must be bound to an address and listening for connections. The return value can be either None or a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection. When None is returned it means the connection didn\u2019t take place, in which case the server should just ignore this event and keep listening for further incoming connections.", 
        "name": "asyncore.dispatcher.accept", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.accept", 
        "syntax": "accept()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.bind": {
        "descr": "Bind the socket to address. The socket must not already be bound. (The format of address depends on the address family \u2014 refer to the socket documentation for more information.) To mark the socket as re-usable (setting the SO_REUSEADDR option), call the dispatcher object\u2019s set_reuse_addr() method.", 
        "name": "asyncore.dispatcher.bind", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.bind", 
        "syntax": "bind(address)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.close": {
        "descr": "Close the socket. All future operations on the socket object will fail. The remote end-point will receive no more data (after queued data is flushed). Sockets are automatically closed when they are garbage-collected.", 
        "name": "asyncore.dispatcher.close", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.close", 
        "syntax": "close()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.connect": {
        "descr": "As with the normal socket object, address is a tuple with the first element the host to connect to, and the second the port number.", 
        "name": "asyncore.dispatcher.connect", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.connect", 
        "syntax": "connect(address)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.create_socket": {
        "descr": "This is identical to the creation of a normal socket, and will use the same options for creation. Refer to the socket documentation for information on creating sockets.", 
        "name": "asyncore.dispatcher.create_socket", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.create_socket", 
        "syntax": "create_socket(family=socket.AF_INET, type=socket.SOCK_STREAM)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_accept": {
        "descr": "Called on listening channels (passive openers) when a connection can be established with a new remote endpoint that has issued a connect() call for the local endpoint. Deprecated in version 3.2; use handle_accepted() instead.", 
        "name": "asyncore.dispatcher.handle_accept", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_accept", 
        "syntax": "handle_accept()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_accepted": {
        "descr": "Called on listening channels (passive openers) when a connection has been established with a new remote endpoint that has issued a connect() call for the local endpoint. sock is a new socket object usable to send and receive data on the connection, and addr is the address bound to the socket on the other end of the connection.", 
        "name": "asyncore.dispatcher.handle_accepted", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_accepted", 
        "syntax": "handle_accepted(sock, addr)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_close": {
        "descr": "Called when the socket is closed.", 
        "name": "asyncore.dispatcher.handle_close", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_close", 
        "syntax": "handle_close()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_connect": {
        "descr": "Called when the active opener\u2019s socket actually makes a connection. Might send a \u201cwelcome\u201d banner, or initiate a protocol negotiation with the remote endpoint, for example.", 
        "name": "asyncore.dispatcher.handle_connect", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_connect", 
        "syntax": "handle_connect()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_error": {
        "descr": "Called when an exception is raised and not otherwise handled. The default version prints a condensed traceback.", 
        "name": "asyncore.dispatcher.handle_error", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_error", 
        "syntax": "handle_error()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_expt": {
        "descr": "Called when there is out of band (OOB) data for a socket connection. This will almost never happen, as OOB is tenuously supported and rarely used.", 
        "name": "asyncore.dispatcher.handle_expt", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_expt", 
        "syntax": "handle_expt()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_read": {
        "descr": "Called when the asynchronous loop detects that a read() call on the channel\u2019s socket will succeed.", 
        "name": "asyncore.dispatcher.handle_read", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_read", 
        "syntax": "handle_read()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.handle_write": {
        "descr": "Called when the asynchronous loop detects that a writable socket can be written. Often this method will implement the necessary buffering for performance. For example:", 
        "name": "asyncore.dispatcher.handle_write", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.handle_write", 
        "syntax": "handle_write()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.listen": {
        "descr": "Listen for connections made to the socket. The backlog argument specifies the maximum number of queued connections and should be at least 1; the maximum value is system-dependent (usually 5).", 
        "name": "asyncore.dispatcher.listen", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.listen", 
        "syntax": "listen(backlog)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.readable": {
        "descr": "Called each time around the asynchronous loop to determine whether a channel\u2019s socket should be added to the list on which read events can occur. The default method simply returns True, indicating that by default, all channels will be interested in read events.", 
        "name": "asyncore.dispatcher.readable", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.readable", 
        "syntax": "readable()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.recv": {
        "descr": "Read at most buffer_size bytes from the socket\u2019s remote end-point. An empty bytes object implies that the channel has been closed from the other end.", 
        "name": "asyncore.dispatcher.recv", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.recv", 
        "syntax": "recv(buffer_size)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.send": {
        "descr": "Send data to the remote end-point of the socket.", 
        "name": "asyncore.dispatcher.send", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.send", 
        "syntax": "send(data)", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher.writable": {
        "descr": "Called each time around the asynchronous loop to determine whether a channel\u2019s socket should be added to the list on which write events can occur. The default method simply returns True, indicating that by default, all channels will be interested in write events.", 
        "name": "asyncore.dispatcher.writable", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher.writable", 
        "syntax": "writable()", 
        "type": "Networking"
    }, 
    "asyncore.dispatcher_with_send": {
        "descr": "A dispatcher subclass which adds simple buffered output capability, useful for simple clients. For more sophisticated usage use asynchat.async_chat.", 
        "name": "asyncore.dispatcher_with_send", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.dispatcher_with_send", 
        "syntax": "class asyncore.dispatcher_with_send", 
        "type": "Networking"
    }, 
    "asyncore.file_dispatcher": {
        "descr": "A file_dispatcher takes a file descriptor or file object along with an optional map argument and wraps it for use with the poll() or loop() functions. If provided a file object or anything with a fileno() method, that method will be called and passed to the file_wrapper constructor. Availability: UNIX.", 
        "name": "asyncore.file_dispatcher", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.file_dispatcher", 
        "syntax": "class asyncore.file_dispatcher", 
        "type": "Networking"
    }, 
    "asyncore.file_wrapper": {
        "descr": "A file_wrapper takes an integer file descriptor and calls os.dup() to duplicate the handle so that the original handle may be closed independently of the file_wrapper. This class implements sufficient methods to emulate a socket for use by the file_dispatcher class. Availability: UNIX.", 
        "name": "asyncore.file_wrapper", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.file_wrapper", 
        "syntax": "class asyncore.file_wrapper", 
        "type": "Networking"
    }, 
    "asyncore.loop": {
        "descr": "Enter a polling loop that terminates after count passes or all open channels have been closed. All arguments are optional. The count parameter defaults to None, resulting in the loop terminating only when all channels have been closed. The timeout argument sets the timeout parameter for the appropriate select() or poll() call, measured in seconds; the default is 30 seconds. The use_poll parameter, if true, indicates that poll() should be used in preference to select() (the default is False).", 
        "name": "asyncore.loop", 
        "params": [], 
        "path": "python/library/asyncore#asyncore.loop", 
        "syntax": "asyncore.loop([timeout[, use_poll[, map[, count]]]])", 
        "type": "Networking"
    }, 
    "atexit.register": {
        "descr": "Register func as a function to be executed at termination. Any optional arguments that are to be passed to func must be passed as arguments to register(). It is possible to register the same function and arguments more than once.", 
        "name": "atexit.register", 
        "params": [], 
        "path": "python/library/atexit#atexit.register", 
        "syntax": "atexit.register(func, *args, **kargs)", 
        "type": "Runtime"
    }, 
    "atexit.unregister": {
        "descr": "Remove func from the list of functions to be run at interpreter shutdown. After calling unregister(), func is guaranteed not to be called when the interpreter shuts down, even if it was registered more than once. unregister() silently does nothing if func was not previously registered.", 
        "name": "atexit.unregister", 
        "params": [], 
        "path": "python/library/atexit#atexit.unregister", 
        "syntax": "atexit.unregister(func)", 
        "type": "Runtime"
    }, 
    "audioop.add": {
        "descr": "Return a fragment which is the addition of the two samples passed as parameters. width is the sample width in bytes, either 1, 2 or 4. Both fragments should have the same length. Samples are truncated in case of overflow.", 
        "name": "audioop.add", 
        "params": [], 
        "path": "python/library/audioop#audioop.add", 
        "syntax": "audioop.add(fragment1, fragment2, width)", 
        "type": "Multimedia"
    }, 
    "audioop.adpcm2lin": {
        "descr": "Decode an Intel/DVI ADPCM coded fragment to a linear fragment. See the description of lin2adpcm() for details on ADPCM coding. Return a tuple (sample, newstate) where the sample has the width specified in width.", 
        "name": "audioop.adpcm2lin", 
        "params": [], 
        "path": "python/library/audioop#audioop.adpcm2lin", 
        "syntax": "audioop.adpcm2lin(adpcmfragment, width, state)", 
        "type": "Multimedia"
    }, 
    "audioop.alaw2lin": {
        "descr": "Convert sound fragments in a-LAW encoding to linearly encoded sound fragments. a-LAW encoding always uses 8 bits samples, so width refers only to the sample width of the output fragment here.", 
        "name": "audioop.alaw2lin", 
        "params": [], 
        "path": "python/library/audioop#audioop.alaw2lin", 
        "syntax": "audioop.alaw2lin(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.avg": {
        "descr": "Return the average over all samples in the fragment.", 
        "name": "audioop.avg", 
        "params": [], 
        "path": "python/library/audioop#audioop.avg", 
        "syntax": "audioop.avg(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.avgpp": {
        "descr": "Return the average peak-peak value over all samples in the fragment. No filtering is done, so the usefulness of this routine is questionable.", 
        "name": "audioop.avgpp", 
        "params": [], 
        "path": "python/library/audioop#audioop.avgpp", 
        "syntax": "audioop.avgpp(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.bias": {
        "descr": "Return a fragment that is the original fragment with a bias added to each sample. Samples wrap around in case of overflow.", 
        "name": "audioop.bias", 
        "params": [], 
        "path": "python/library/audioop#audioop.bias", 
        "syntax": "audioop.bias(fragment, width, bias)", 
        "type": "Multimedia"
    }, 
    "audioop.cross": {
        "descr": "Return the number of zero crossings in the fragment passed as an argument.", 
        "name": "audioop.cross", 
        "params": [], 
        "path": "python/library/audioop#audioop.cross", 
        "syntax": "audioop.cross(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.error": {
        "descr": "This exception is raised on all errors, such as unknown number of bytes per sample, etc.", 
        "name": "audioop.error", 
        "params": [], 
        "path": "python/library/audioop#audioop.error", 
        "syntax": "exception audioop.error", 
        "type": "Multimedia"
    }, 
    "audioop.findfactor": {
        "descr": "Return a factor F such that rms(add(fragment, mul(reference, -F))) is minimal, i.e., return the factor with which you should multiply reference to make it match as well as possible to fragment. The fragments should both contain 2-byte samples.", 
        "name": "audioop.findfactor", 
        "params": [], 
        "path": "python/library/audioop#audioop.findfactor", 
        "syntax": "audioop.findfactor(fragment, reference)", 
        "type": "Multimedia"
    }, 
    "audioop.findfit": {
        "descr": "Try to match reference as well as possible to a portion of fragment (which should be the longer fragment). This is (conceptually) done by taking slices out of fragment, using findfactor() to compute the best match, and minimizing the result. The fragments should both contain 2-byte samples. Return a tuple (offset, factor) where offset is the (integer) offset into fragment where the optimal match started and factor is the (floating-point) factor as per findfactor().", 
        "name": "audioop.findfit", 
        "params": [], 
        "path": "python/library/audioop#audioop.findfit", 
        "syntax": "audioop.findfit(fragment, reference)", 
        "type": "Multimedia"
    }, 
    "audioop.findmax": {
        "descr": "Search fragment for a slice of length length samples (not bytes!) with maximum energy, i.e., return i for which rms(fragment[i*2:(i+length)*2]) is maximal. The fragments should both contain 2-byte samples.", 
        "name": "audioop.findmax", 
        "params": [], 
        "path": "python/library/audioop#audioop.findmax", 
        "syntax": "audioop.findmax(fragment, length)", 
        "type": "Multimedia"
    }, 
    "audioop.getsample": {
        "descr": "Return the value of sample index from the fragment.", 
        "name": "audioop.getsample", 
        "params": [], 
        "path": "python/library/audioop#audioop.getsample", 
        "syntax": "audioop.getsample(fragment, width, index)", 
        "type": "Multimedia"
    }, 
    "audioop.lin2adpcm": {
        "descr": "Convert samples to 4 bit Intel/DVI ADPCM encoding. ADPCM coding is an adaptive coding scheme, whereby each 4 bit number is the difference between one sample and the next, divided by a (varying) step. The Intel/DVI ADPCM algorithm has been selected for use by the IMA, so it may well become a standard.", 
        "name": "audioop.lin2adpcm", 
        "params": [], 
        "path": "python/library/audioop#audioop.lin2adpcm", 
        "syntax": "audioop.lin2adpcm(fragment, width, state)", 
        "type": "Multimedia"
    }, 
    "audioop.lin2alaw": {
        "descr": "Convert samples in the audio fragment to a-LAW encoding and return this as a bytes object. a-LAW is an audio encoding format whereby you get a dynamic range of about 13 bits using only 8 bit samples. It is used by the Sun audio hardware, among others.", 
        "name": "audioop.lin2alaw", 
        "params": [], 
        "path": "python/library/audioop#audioop.lin2alaw", 
        "syntax": "audioop.lin2alaw(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.lin2lin": {
        "descr": "Convert samples between 1-, 2- and 4-byte formats.", 
        "name": "audioop.lin2lin", 
        "params": [], 
        "path": "python/library/audioop#audioop.lin2lin", 
        "syntax": "audioop.lin2lin(fragment, width, newwidth)", 
        "type": "Multimedia"
    }, 
    "audioop.lin2ulaw": {
        "descr": "Convert samples in the audio fragment to u-LAW encoding and return this as a bytes object. u-LAW is an audio encoding format whereby you get a dynamic range of about 14 bits using only 8 bit samples. It is used by the Sun audio hardware, among others.", 
        "name": "audioop.lin2ulaw", 
        "params": [], 
        "path": "python/library/audioop#audioop.lin2ulaw", 
        "syntax": "audioop.lin2ulaw(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.max": {
        "descr": "Return the maximum of the absolute value of all samples in a fragment.", 
        "name": "audioop.max", 
        "params": [], 
        "path": "python/library/audioop#audioop.max", 
        "syntax": "audioop.max(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.maxpp": {
        "descr": "Return the maximum peak-peak value in the sound fragment.", 
        "name": "audioop.maxpp", 
        "params": [], 
        "path": "python/library/audioop#audioop.maxpp", 
        "syntax": "audioop.maxpp(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.minmax": {
        "descr": "Return a tuple consisting of the minimum and maximum values of all samples in the sound fragment.", 
        "name": "audioop.minmax", 
        "params": [], 
        "path": "python/library/audioop#audioop.minmax", 
        "syntax": "audioop.minmax(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.mul": {
        "descr": "Return a fragment that has all samples in the original fragment multiplied by the floating-point value factor. Samples are truncated in case of overflow.", 
        "name": "audioop.mul", 
        "params": [], 
        "path": "python/library/audioop#audioop.mul", 
        "syntax": "audioop.mul(fragment, width, factor)", 
        "type": "Multimedia"
    }, 
    "audioop.ratecv": {
        "descr": "Convert the frame rate of the input fragment.", 
        "name": "audioop.ratecv", 
        "params": [], 
        "path": "python/library/audioop#audioop.ratecv", 
        "syntax": "audioop.ratecv(fragment, width, nchannels, inrate, outrate, state[, weightA[, weightB]])", 
        "type": "Multimedia"
    }, 
    "audioop.reverse": {
        "descr": "Reverse the samples in a fragment and returns the modified fragment.", 
        "name": "audioop.reverse", 
        "params": [], 
        "path": "python/library/audioop#audioop.reverse", 
        "syntax": "audioop.reverse(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.rms": {
        "descr": "Return the root-mean-square of the fragment, i.e. sqrt(sum(S_i^2)/n).", 
        "name": "audioop.rms", 
        "params": [], 
        "path": "python/library/audioop#audioop.rms", 
        "syntax": "audioop.rms(fragment, width)", 
        "type": "Multimedia"
    }, 
    "audioop.tomono": {
        "descr": "Convert a stereo fragment to a mono fragment. The left channel is multiplied by lfactor and the right channel by rfactor before adding the two channels to give a mono signal.", 
        "name": "audioop.tomono", 
        "params": [], 
        "path": "python/library/audioop#audioop.tomono", 
        "syntax": "audioop.tomono(fragment, width, lfactor, rfactor)", 
        "type": "Multimedia"
    }, 
    "audioop.tostereo": {
        "descr": "Generate a stereo fragment from a mono fragment. Each pair of samples in the stereo fragment are computed from the mono sample, whereby left channel samples are multiplied by lfactor and right channel samples by rfactor.", 
        "name": "audioop.tostereo", 
        "params": [], 
        "path": "python/library/audioop#audioop.tostereo", 
        "syntax": "audioop.tostereo(fragment, width, lfactor, rfactor)", 
        "type": "Multimedia"
    }, 
    "audioop.ulaw2lin": {
        "descr": "Convert sound fragments in u-LAW encoding to linearly encoded sound fragments. u-LAW encoding always uses 8 bits samples, so width refers only to the sample width of the output fragment here.", 
        "name": "audioop.ulaw2lin", 
        "params": [], 
        "path": "python/library/audioop#audioop.ulaw2lin", 
        "syntax": "audioop.ulaw2lin(fragment, width)", 
        "type": "Multimedia"
    }, 
    "base64.b16decode": {
        "descr": "Decode a Base16 encoded byte string.", 
        "name": "base64.b16decode", 
        "params": [], 
        "path": "python/library/base64#base64.b16decode", 
        "syntax": "base64.b16decode(s, casefold=False)", 
        "type": "Internet Data"
    }, 
    "base64.b16encode": {
        "descr": "Encode a byte string using Base16.", 
        "name": "base64.b16encode", 
        "params": [], 
        "path": "python/library/base64#base64.b16encode", 
        "syntax": "base64.b16encode(s)", 
        "type": "Internet Data"
    }, 
    "base64.b32decode": {
        "descr": "Decode a Base32 encoded byte string.", 
        "name": "base64.b32decode", 
        "params": [], 
        "path": "python/library/base64#base64.b32decode", 
        "syntax": "base64.b32decode(s, casefold=False, map01=None)", 
        "type": "Internet Data"
    }, 
    "base64.b32encode": {
        "descr": "Encode a byte string using Base32. s is the string to encode. The encoded string is returned.", 
        "name": "base64.b32encode", 
        "params": [], 
        "path": "python/library/base64#base64.b32encode", 
        "syntax": "base64.b32encode(s)", 
        "type": "Internet Data"
    }, 
    "base64.b64decode": {
        "descr": "Decode a Base64 encoded byte string.", 
        "name": "base64.b64decode", 
        "params": [], 
        "path": "python/library/base64#base64.b64decode", 
        "syntax": "base64.b64decode(s, altchars=None, validate=False)", 
        "type": "Internet Data"
    }, 
    "base64.b64encode": {
        "descr": "Encode a byte string using Base64.", 
        "name": "base64.b64encode", 
        "params": [], 
        "path": "python/library/base64#base64.b64encode", 
        "syntax": "base64.b64encode(s, altchars=None)", 
        "type": "Internet Data"
    }, 
    "base64.decode": {
        "descr": "Decode the contents of the binary input file and write the resulting binary data to the output file. input and output must be file objects. input will be read until input.read() returns an empty bytes object.", 
        "name": "base64.decode", 
        "params": [], 
        "path": "python/library/base64#base64.decode", 
        "syntax": "base64.decode(input, output)", 
        "type": "Internet Data"
    }, 
    "base64.decodebytes": {
        "descr": "Decode the byte string s, which must contain one or more lines of base64 encoded data, and return a byte string containing the resulting binary data. decodestring is a deprecated alias.", 
        "name": "base64.decodebytes", 
        "params": [], 
        "path": "python/library/base64#base64.decodebytes", 
        "syntax": "base64.decodebytes(s)", 
        "type": "Internet Data"
    }, 
    "base64.decodestring": {
        "descr": "Decode the byte string s, which must contain one or more lines of base64 encoded data, and return a byte string containing the resulting binary data. decodestring is a deprecated alias.", 
        "name": "base64.decodestring", 
        "params": [], 
        "path": "python/library/base64#base64.decodestring", 
        "syntax": "base64.decodestring(s)", 
        "type": "Internet Data"
    }, 
    "base64.encode": {
        "descr": "Encode the contents of the binary input file and write the resulting base64 encoded data to the output file. input and output must be file objects. input will be read until input.read() returns an empty bytes object. encode() returns the encoded data plus a trailing newline character (b'\\n').", 
        "name": "base64.encode", 
        "params": [], 
        "path": "python/library/base64#base64.encode", 
        "syntax": "base64.encode(input, output)", 
        "type": "Internet Data"
    }, 
    "base64.encodebytes": {
        "descr": "Encode the byte string s, which can contain arbitrary binary data, and return a byte string containing one or more lines of base64-encoded data. encodebytes() returns a string containing one or more lines of base64-encoded data always including an extra trailing newline (b'\\n'). encodestring is a deprecated alias.", 
        "name": "base64.encodebytes", 
        "params": [], 
        "path": "python/library/base64#base64.encodebytes", 
        "syntax": "base64.encodebytes(s)", 
        "type": "Internet Data"
    }, 
    "base64.encodestring": {
        "descr": "Encode the byte string s, which can contain arbitrary binary data, and return a byte string containing one or more lines of base64-encoded data. encodebytes() returns a string containing one or more lines of base64-encoded data always including an extra trailing newline (b'\\n'). encodestring is a deprecated alias.", 
        "name": "base64.encodestring", 
        "params": [], 
        "path": "python/library/base64#base64.encodestring", 
        "syntax": "base64.encodestring(s)", 
        "type": "Internet Data"
    }, 
    "base64.standard_b64decode": {
        "descr": "Decode byte string s using the standard Base64 alphabet.", 
        "name": "base64.standard_b64decode", 
        "params": [], 
        "path": "python/library/base64#base64.standard_b64decode", 
        "syntax": "base64.standard_b64decode(s)", 
        "type": "Internet Data"
    }, 
    "base64.standard_b64encode": {
        "descr": "Encode byte string s using the standard Base64 alphabet.", 
        "name": "base64.standard_b64encode", 
        "params": [], 
        "path": "python/library/base64#base64.standard_b64encode", 
        "syntax": "base64.standard_b64encode(s)", 
        "type": "Internet Data"
    }, 
    "base64.urlsafe_b64decode": {
        "descr": "Decode byte string s using a URL-safe alphabet, which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.", 
        "name": "base64.urlsafe_b64decode", 
        "params": [], 
        "path": "python/library/base64#base64.urlsafe_b64decode", 
        "syntax": "base64.urlsafe_b64decode(s)", 
        "type": "Internet Data"
    }, 
    "base64.urlsafe_b64encode": {
        "descr": "Encode byte string s using a URL-safe alphabet, which substitutes - instead of + and _ instead of / in the standard Base64 alphabet. The result can still contain =.", 
        "name": "base64.urlsafe_b64encode", 
        "params": [], 
        "path": "python/library/base64#base64.urlsafe_b64encode", 
        "syntax": "base64.urlsafe_b64encode(s)", 
        "type": "Internet Data"
    }, 
    "bdb.Bdb": {
        "descr": "The Bdb class acts as a generic Python debugger base class.", 
        "name": "bdb.Bdb", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb", 
        "syntax": "class bdb.Bdb(skip=None)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.break_anywhere": {
        "descr": "This method checks if there is a breakpoint in the filename of the current frame.", 
        "name": "bdb.Bdb.break_anywhere", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.break_anywhere", 
        "syntax": "break_anywhere(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.break_here": {
        "descr": "This method checks if there is a breakpoint in the filename and line belonging to frame or, at least, in the current function. If the breakpoint is a temporary one, this method deletes it.", 
        "name": "bdb.Bdb.break_here", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.break_here", 
        "syntax": "break_here(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.canonic": {
        "descr": "Auxiliary method for getting a filename in a canonical form, that is, as a case-normalized (on case-insensitive filesystems) absolute path, stripped of surrounding angle brackets.", 
        "name": "bdb.Bdb.canonic", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.canonic", 
        "syntax": "canonic(filename)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.clear_all_breaks": {
        "descr": "Delete all existing breakpoints.", 
        "name": "bdb.Bdb.clear_all_breaks", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.clear_all_breaks", 
        "syntax": "clear_all_breaks()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.clear_all_file_breaks": {
        "descr": "Delete all breakpoints in filename. If none were set, an error message is returned.", 
        "name": "bdb.Bdb.clear_all_file_breaks", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.clear_all_file_breaks", 
        "syntax": "clear_all_file_breaks(filename)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.clear_bpbynumber": {
        "descr": "Delete the breakpoint which has the index arg in the Breakpoint.bpbynumber. If arg is not numeric or out of range, return an error message.", 
        "name": "bdb.Bdb.clear_bpbynumber", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.clear_bpbynumber", 
        "syntax": "clear_bpbynumber(arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.clear_break": {
        "descr": "Delete the breakpoints in filename and lineno. If none were set, an error message is returned.", 
        "name": "bdb.Bdb.clear_break", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.clear_break", 
        "syntax": "clear_break(filename, lineno)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.dispatch_call": {
        "descr": "If the debugger should stop on this function call, invoke the user_call() method (which should be overridden in subclasses). Raise a BdbQuit exception if the Bdb.quitting flag is set (which can be set from user_call()). Return a reference to the trace_dispatch() method for further tracing in that scope.", 
        "name": "bdb.Bdb.dispatch_call", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.dispatch_call", 
        "syntax": "dispatch_call(frame, arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.dispatch_exception": {
        "descr": "If the debugger should stop at this exception, invokes the user_exception() method (which should be overridden in subclasses). Raise a BdbQuit exception if the Bdb.quitting flag is set (which can be set from user_exception()). Return a reference to the trace_dispatch() method for further tracing in that scope.", 
        "name": "bdb.Bdb.dispatch_exception", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.dispatch_exception", 
        "syntax": "dispatch_exception(frame, arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.dispatch_line": {
        "descr": "If the debugger should stop on the current line, invoke the user_line() method (which should be overridden in subclasses). Raise a BdbQuit exception if the Bdb.quitting flag is set (which can be set from user_line()). Return a reference to the trace_dispatch() method for further tracing in that scope.", 
        "name": "bdb.Bdb.dispatch_line", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.dispatch_line", 
        "syntax": "dispatch_line(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.dispatch_return": {
        "descr": "If the debugger should stop on this function return, invoke the user_return() method (which should be overridden in subclasses). Raise a BdbQuit exception if the Bdb.quitting flag is set (which can be set from user_return()). Return a reference to the trace_dispatch() method for further tracing in that scope.", 
        "name": "bdb.Bdb.dispatch_return", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.dispatch_return", 
        "syntax": "dispatch_return(frame, arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.do_clear": {
        "descr": "Handle how a breakpoint must be removed when it is a temporary one.", 
        "name": "bdb.Bdb.do_clear", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.do_clear", 
        "syntax": "do_clear(arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.format_stack_entry": {
        "descr": "Return a string with information about a stack entry, identified by a (frame, lineno) tuple:", 
        "name": "bdb.Bdb.format_stack_entry", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.format_stack_entry", 
        "syntax": "format_stack_entry(frame_lineno, lprefix=': ')", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.get_all_breaks": {
        "descr": "Return all breakpoints that are set.", 
        "name": "bdb.Bdb.get_all_breaks", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.get_all_breaks", 
        "syntax": "get_all_breaks()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.get_bpbynumber": {
        "descr": "Return a breakpoint specified by the given number. If arg is a string, it will be converted to a number. If arg is a non-numeric string, if the given breakpoint never existed or has been deleted, a ValueError is raised.", 
        "name": "bdb.Bdb.get_bpbynumber", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.get_bpbynumber", 
        "syntax": "get_bpbynumber(arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.get_break": {
        "descr": "Check if there is a breakpoint for lineno of filename.", 
        "name": "bdb.Bdb.get_break", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.get_break", 
        "syntax": "get_break(filename, lineno)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.get_breaks": {
        "descr": "Return all breakpoints for lineno in filename, or an empty list if none are set.", 
        "name": "bdb.Bdb.get_breaks", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.get_breaks", 
        "syntax": "get_breaks(filename, lineno)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.get_file_breaks": {
        "descr": "Return all breakpoints in filename, or an empty list if none are set.", 
        "name": "bdb.Bdb.get_file_breaks", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.get_file_breaks", 
        "syntax": "get_file_breaks(filename)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.get_stack": {
        "descr": "Get a list of records for a frame and all higher (calling) and lower frames, and the size of the higher part.", 
        "name": "bdb.Bdb.get_stack", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.get_stack", 
        "syntax": "get_stack(f, t)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.reset": {
        "descr": "Set the botframe, stopframe, returnframe and quitting attributes with values ready to start debugging.", 
        "name": "bdb.Bdb.reset", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.reset", 
        "syntax": "reset()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.run": {
        "descr": "Debug a statement executed via the exec() function. globals defaults to __main__.__dict__, locals defaults to globals.", 
        "name": "bdb.Bdb.run", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.run", 
        "syntax": "run(cmd, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.runcall": {
        "descr": "Debug a single function call, and return its result.", 
        "name": "bdb.Bdb.runcall", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.runcall", 
        "syntax": "runcall(func, *args, **kwds)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.runctx": {
        "descr": "For backwards compatibility. Calls the run() method.", 
        "name": "bdb.Bdb.runctx", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.runctx", 
        "syntax": "runctx(cmd, globals, locals)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.runeval": {
        "descr": "Debug an expression executed via the eval() function. globals and locals have the same meaning as in run().", 
        "name": "bdb.Bdb.runeval", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.runeval", 
        "syntax": "runeval(expr, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_break": {
        "descr": "Set a new breakpoint. If the lineno line doesn\u2019t exist for the filename passed as argument, return an error message. The filename should be in canonical form, as described in the canonic() method.", 
        "name": "bdb.Bdb.set_break", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_break", 
        "syntax": "set_break(filename, lineno, temporary=0, cond, funcname)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_continue": {
        "descr": "Stop only at breakpoints or when finished. If there are no breakpoints, set the system trace function to None.", 
        "name": "bdb.Bdb.set_continue", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_continue", 
        "syntax": "set_continue()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_next": {
        "descr": "Stop on the next line in or below the given frame.", 
        "name": "bdb.Bdb.set_next", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_next", 
        "syntax": "set_next(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_quit": {
        "descr": "Set the quitting attribute to True. This raises BdbQuit in the next call to one of the dispatch_*() methods.", 
        "name": "bdb.Bdb.set_quit", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_quit", 
        "syntax": "set_quit()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_return": {
        "descr": "Stop when returning from the given frame.", 
        "name": "bdb.Bdb.set_return", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_return", 
        "syntax": "set_return(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_step": {
        "descr": "Stop after one line of code.", 
        "name": "bdb.Bdb.set_step", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_step", 
        "syntax": "set_step()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_trace": {
        "descr": "Start debugging from frame. If frame is not specified, debugging starts from caller\u2019s frame.", 
        "name": "bdb.Bdb.set_trace", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_trace", 
        "syntax": "set_trace([frame])", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.set_until": {
        "descr": "Stop when the line with the line no greater than the current one is reached or when returning from current frame", 
        "name": "bdb.Bdb.set_until", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.set_until", 
        "syntax": "set_until(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.stop_here": {
        "descr": "This method checks if the frame is somewhere below botframe in the call stack. botframe is the frame in which debugging started.", 
        "name": "bdb.Bdb.stop_here", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.stop_here", 
        "syntax": "stop_here(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.trace_dispatch": {
        "descr": "This function is installed as the trace function of debugged frames. Its return value is the new trace function (in most cases, that is, itself).", 
        "name": "bdb.Bdb.trace_dispatch", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.trace_dispatch", 
        "syntax": "trace_dispatch(frame, event, arg)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.user_call": {
        "descr": "This method is called from dispatch_call() when there is the possibility that a break might be necessary anywhere inside the called function.", 
        "name": "bdb.Bdb.user_call", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.user_call", 
        "syntax": "user_call(frame, argument_list)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.user_exception": {
        "descr": "This method is called from dispatch_exception() when stop_here() yields True.", 
        "name": "bdb.Bdb.user_exception", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.user_exception", 
        "syntax": "user_exception(frame, exc_info)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.user_line": {
        "descr": "This method is called from dispatch_line() when either stop_here() or break_here() yields True.", 
        "name": "bdb.Bdb.user_line", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.user_line", 
        "syntax": "user_line(frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Bdb.user_return": {
        "descr": "This method is called from dispatch_return() when stop_here() yields True.", 
        "name": "bdb.Bdb.user_return", 
        "params": [], 
        "path": "python/library/bdb#bdb.Bdb.user_return", 
        "syntax": "user_return(frame, return_value)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.BdbQuit": {
        "descr": "Exception raised by the Bdb class for quitting the debugger.", 
        "name": "bdb.BdbQuit", 
        "params": [], 
        "path": "python/library/bdb#bdb.BdbQuit", 
        "syntax": "exception bdb.BdbQuit", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Breakpoint": {
        "descr": "This class implements temporary breakpoints, ignore counts, disabling and (re-)enabling, and conditionals.", 
        "name": "bdb.Breakpoint", 
        "params": [], 
        "path": "python/library/bdb#bdb.Breakpoint", 
        "syntax": "class bdb.Breakpoint(self, file, line, temporary=0, cond=None, funcname=None)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Breakpoint.bpformat": {
        "descr": "Return a string with all the information about the breakpoint, nicely formatted:", 
        "name": "bdb.Breakpoint.bpformat", 
        "params": [], 
        "path": "python/library/bdb#bdb.Breakpoint.bpformat", 
        "syntax": "bpformat()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Breakpoint.bpprint": {
        "descr": "Print the output of bpformat() to the file out, or if it is None, to standard output.", 
        "name": "bdb.Breakpoint.bpprint", 
        "params": [], 
        "path": "python/library/bdb#bdb.Breakpoint.bpprint", 
        "syntax": "bpprint(out=None)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Breakpoint.deleteMe": {
        "descr": "Delete the breakpoint from the list associated to a file/line. If it is the last breakpoint in that position, it also deletes the entry for the file/line.", 
        "name": "bdb.Breakpoint.deleteMe", 
        "params": [], 
        "path": "python/library/bdb#bdb.Breakpoint.deleteMe", 
        "syntax": "deleteMe()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Breakpoint.disable": {
        "descr": "Mark the breakpoint as disabled.", 
        "name": "bdb.Breakpoint.disable", 
        "params": [], 
        "path": "python/library/bdb#bdb.Breakpoint.disable", 
        "syntax": "disable()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.Breakpoint.enable": {
        "descr": "Mark the breakpoint as enabled.", 
        "name": "bdb.Breakpoint.enable", 
        "params": [], 
        "path": "python/library/bdb#bdb.Breakpoint.enable", 
        "syntax": "enable()", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.checkfuncname": {
        "descr": "Check whether we should break here, depending on the way the breakpoint b was set.", 
        "name": "bdb.checkfuncname", 
        "params": [], 
        "path": "python/library/bdb#bdb.checkfuncname", 
        "syntax": "bdb.checkfuncname(b, frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.effective": {
        "descr": "Determine if there is an effective (active) breakpoint at this line of code. Return a tuple of the breakpoint and a boolean that indicates if it is ok to delete a temporary breakpoint. Return (None, None) if there is no matching breakpoint.", 
        "name": "bdb.effective", 
        "params": [], 
        "path": "python/library/bdb#bdb.effective", 
        "syntax": "bdb.effective(file, line, frame)", 
        "type": "Debugging & Profiling"
    }, 
    "bdb.set_trace": {
        "descr": "Start debugging with a Bdb instance from caller\u2019s frame.", 
        "name": "bdb.set_trace", 
        "params": [], 
        "path": "python/library/bdb#bdb.set_trace", 
        "syntax": "bdb.set_trace()", 
        "type": "Debugging & Profiling"
    }, 
    "bin": {
        "descr": "Convert an integer number to a binary string. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer.", 
        "name": "bin", 
        "params": [], 
        "path": "python/library/functions#bin", 
        "syntax": "bin(x)", 
        "type": "Built-in Functions"
    }, 
    "binascii.Error": {
        "descr": "Exception raised on errors. These are usually programming errors.", 
        "name": "binascii.Error", 
        "params": [], 
        "path": "python/library/binascii#binascii.Error", 
        "syntax": "exception binascii.Error", 
        "type": "Internet Data"
    }, 
    "binascii.Incomplete": {
        "descr": "Exception raised on incomplete data. These are usually not programming errors, but may be handled by reading a little more data and trying again.", 
        "name": "binascii.Incomplete", 
        "params": [], 
        "path": "python/library/binascii#binascii.Incomplete", 
        "syntax": "exception binascii.Incomplete", 
        "type": "Internet Data"
    }, 
    "binascii.a2b_base64": {
        "descr": "Convert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time.", 
        "name": "binascii.a2b_base64", 
        "params": [], 
        "path": "python/library/binascii#binascii.a2b_base64", 
        "syntax": "binascii.a2b_base64(string)", 
        "type": "Internet Data"
    }, 
    "binascii.a2b_hex": {
        "descr": "Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise a TypeError is raised.", 
        "name": "binascii.a2b_hex", 
        "params": [], 
        "path": "python/library/binascii#binascii.a2b_hex", 
        "syntax": "binascii.a2b_hex(hexstr)", 
        "type": "Internet Data"
    }, 
    "binascii.a2b_hqx": {
        "descr": "Convert binhex4 formatted ASCII data to binary, without doing RLE-decompression. The string should contain a complete number of binary bytes, or (in case of the last portion of the binhex4 data) have the remaining bits zero.", 
        "name": "binascii.a2b_hqx", 
        "params": [], 
        "path": "python/library/binascii#binascii.a2b_hqx", 
        "syntax": "binascii.a2b_hqx(string)", 
        "type": "Internet Data"
    }, 
    "binascii.a2b_qp": {
        "descr": "Convert a block of quoted-printable data back to binary and return the binary data. More than one line may be passed at a time. If the optional argument header is present and true, underscores will be decoded as spaces.", 
        "name": "binascii.a2b_qp", 
        "params": [], 
        "path": "python/library/binascii#binascii.a2b_qp", 
        "syntax": "binascii.a2b_qp(string, header=False)", 
        "type": "Internet Data"
    }, 
    "binascii.a2b_uu": {
        "descr": "Convert a single line of uuencoded data back to binary and return the binary data. Lines normally contain 45 (binary) bytes, except for the last line. Line data may be followed by whitespace.", 
        "name": "binascii.a2b_uu", 
        "params": [], 
        "path": "python/library/binascii#binascii.a2b_uu", 
        "syntax": "binascii.a2b_uu(string)", 
        "type": "Internet Data"
    }, 
    "binascii.b2a_base64": {
        "descr": "Convert binary data to a line of ASCII characters in base64 coding. The return value is the converted line, including a newline char. The length of data should be at most 57 to adhere to the base64 standard.", 
        "name": "binascii.b2a_base64", 
        "params": [], 
        "path": "python/library/binascii#binascii.b2a_base64", 
        "syntax": "binascii.b2a_base64(data)", 
        "type": "Internet Data"
    }, 
    "binascii.b2a_hex": {
        "descr": "Return the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data.", 
        "name": "binascii.b2a_hex", 
        "params": [], 
        "path": "python/library/binascii#binascii.b2a_hex", 
        "syntax": "binascii.b2a_hex(data)", 
        "type": "Internet Data"
    }, 
    "binascii.b2a_hqx": {
        "descr": "Perform hexbin4 binary-to-ASCII translation and return the resulting string. The argument should already be RLE-coded, and have a length divisible by 3 (except possibly the last fragment).", 
        "name": "binascii.b2a_hqx", 
        "params": [], 
        "path": "python/library/binascii#binascii.b2a_hqx", 
        "syntax": "binascii.b2a_hqx(data)", 
        "type": "Internet Data"
    }, 
    "binascii.b2a_qp": {
        "descr": "Convert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument quotetabs is present and true, all tabs and spaces will be encoded. If the optional argument istext is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument header is present and true, spaces will be encoded as underscores per RFC1522. If the optional argument header is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream.", 
        "name": "binascii.b2a_qp", 
        "params": [], 
        "path": "python/library/binascii#binascii.b2a_qp", 
        "syntax": "binascii.b2a_qp(data, quotetabs=False, istext=True, header=False)", 
        "type": "Internet Data"
    }, 
    "binascii.b2a_uu": {
        "descr": "Convert binary data to a line of ASCII characters, the return value is the converted line, including a newline char. The length of data should be at most 45.", 
        "name": "binascii.b2a_uu", 
        "params": [], 
        "path": "python/library/binascii#binascii.b2a_uu", 
        "syntax": "binascii.b2a_uu(data)", 
        "type": "Internet Data"
    }, 
    "binascii.crc32": {
        "descr": "Compute CRC-32, the 32-bit checksum of data, starting with an initial crc. This is consistent with the ZIP file checksum. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm. Use as follows:", 
        "name": "binascii.crc32", 
        "params": [], 
        "path": "python/library/binascii#binascii.crc32", 
        "syntax": "binascii.crc32(data[, crc])", 
        "type": "Internet Data"
    }, 
    "binascii.crc_hqx": {
        "descr": "Compute the binhex4 crc value of data, starting with an initial crc and returning the result.", 
        "name": "binascii.crc_hqx", 
        "params": [], 
        "path": "python/library/binascii#binascii.crc_hqx", 
        "syntax": "binascii.crc_hqx(data, crc)", 
        "type": "Internet Data"
    }, 
    "binascii.hexlify": {
        "descr": "Return the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data.", 
        "name": "binascii.hexlify", 
        "params": [], 
        "path": "python/library/binascii#binascii.hexlify", 
        "syntax": "binascii.hexlify(data)", 
        "type": "Internet Data"
    }, 
    "binascii.rlecode_hqx": {
        "descr": "Perform binhex4 style RLE-compression on data and return the result.", 
        "name": "binascii.rlecode_hqx", 
        "params": [], 
        "path": "python/library/binascii#binascii.rlecode_hqx", 
        "syntax": "binascii.rlecode_hqx(data)", 
        "type": "Internet Data"
    }, 
    "binascii.rledecode_hqx": {
        "descr": "Perform RLE-decompression on the data, as per the binhex4 standard. The algorithm uses 0x90 after a byte as a repeat indicator, followed by a count. A count of 0 specifies a byte value of 0x90. The routine returns the decompressed data, unless data input data ends in an orphaned repeat indicator, in which case the Incomplete exception is raised.", 
        "name": "binascii.rledecode_hqx", 
        "params": [], 
        "path": "python/library/binascii#binascii.rledecode_hqx", 
        "syntax": "binascii.rledecode_hqx(data)", 
        "type": "Internet Data"
    }, 
    "binascii.unhexlify": {
        "descr": "Return the binary data represented by the hexadecimal string hexstr. This function is the inverse of b2a_hex(). hexstr must contain an even number of hexadecimal digits (which can be upper or lower case), otherwise a TypeError is raised.", 
        "name": "binascii.unhexlify", 
        "params": [], 
        "path": "python/library/binascii#binascii.unhexlify", 
        "syntax": "binascii.unhexlify(hexstr)", 
        "type": "Internet Data"
    }, 
    "binhex.Error": {
        "descr": "Exception raised when something can\u2019t be encoded using the binhex format (for example, a filename is too long to fit in the filename field), or when input is not properly encoded binhex data.", 
        "name": "binhex.Error", 
        "params": [], 
        "path": "python/library/binhex#binhex.Error", 
        "syntax": "exception binhex.Error", 
        "type": "Internet Data"
    }, 
    "binhex.binhex": {
        "descr": "Convert a binary file with filename input to binhex file output. The output parameter can either be a filename or a file-like object (any object supporting a write() and close() method).", 
        "name": "binhex.binhex", 
        "params": [], 
        "path": "python/library/binhex#binhex.binhex", 
        "syntax": "binhex.binhex(input, output)", 
        "type": "Internet Data"
    }, 
    "binhex.hexbin": {
        "descr": "Decode a binhex file input. input may be a filename or a file-like object supporting read() and close() methods. The resulting file is written to a file named output, unless the argument is None in which case the output filename is read from the binhex file.", 
        "name": "binhex.hexbin", 
        "params": [], 
        "path": "python/library/binhex#binhex.hexbin", 
        "syntax": "binhex.hexbin(input, output)", 
        "type": "Internet Data"
    }, 
    "bisect.bisect": {
        "descr": "Similar to bisect_left(), but returns an insertion point which comes after (to the right of) any existing entries of x in a.", 
        "name": "bisect.bisect", 
        "params": [], 
        "path": "python/library/bisect#bisect.bisect", 
        "syntax": "bisect.bisect(a, x, lo=0, hi=len(a))", 
        "type": "Data Types"
    }, 
    "bisect.bisect_left": {
        "descr": "Locate the insertion point for x in a to maintain sorted order. The parameters lo and hi may be used to specify a subset of the list which should be considered; by default the entire list is used. If x is already present in a, the insertion point will be before (to the left of) any existing entries. The return value is suitable for use as the first parameter to list.insert() assuming that a is already sorted.", 
        "name": "bisect.bisect_left", 
        "params": [], 
        "path": "python/library/bisect#bisect.bisect_left", 
        "syntax": "bisect.bisect_left(a, x, lo=0, hi=len(a))", 
        "type": "Data Types"
    }, 
    "bisect.bisect_right": {
        "descr": "Similar to bisect_left(), but returns an insertion point which comes after (to the right of) any existing entries of x in a.", 
        "name": "bisect.bisect_right", 
        "params": [], 
        "path": "python/library/bisect#bisect.bisect_right", 
        "syntax": "bisect.bisect_right(a, x, lo=0, hi=len(a))", 
        "type": "Data Types"
    }, 
    "bisect.insort": {
        "descr": "Similar to insort_left(), but inserting x in a after any existing entries of x.", 
        "name": "bisect.insort", 
        "params": [], 
        "path": "python/library/bisect#bisect.insort", 
        "syntax": "bisect.insort(a, x, lo=0, hi=len(a))", 
        "type": "Data Types"
    }, 
    "bisect.insort_left": {
        "descr": "Insert x in a in sorted order. This is equivalent to a.insert(bisect.bisect_left(a, x, lo, hi), x) assuming that a is already sorted. Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step.", 
        "name": "bisect.insort_left", 
        "params": [], 
        "path": "python/library/bisect#bisect.insort_left", 
        "syntax": "bisect.insort_left(a, x, lo=0, hi=len(a))", 
        "type": "Data Types"
    }, 
    "bisect.insort_right": {
        "descr": "Similar to insort_left(), but inserting x in a after any existing entries of x.", 
        "name": "bisect.insort_right", 
        "params": [], 
        "path": "python/library/bisect#bisect.insort_right", 
        "syntax": "bisect.insort_right(a, x, lo=0, hi=len(a))", 
        "type": "Data Types"
    }, 
    "bit_length": {
        "descr": "Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros:", 
        "name": "int.bit_length", 
        "params": [], 
        "path": "python/library/stdtypes#int.bit_length", 
        "syntax": "int.bit_length()", 
        "type": "Built-in Types"
    }, 
    "bool": {
        "descr": "Convert a value to a Boolean, using the standard truth testing procedure. If x is false or omitted, this returns False; otherwise it returns True. bool is also a class, which is a subclass of int (see Numeric Types \u2014 int, float, complex). Class bool cannot be subclassed further. Its only instances are False and True (see Boolean Values).", 
        "name": "bool", 
        "params": [], 
        "path": "python/library/functions#bool", 
        "syntax": "bool([x])", 
        "type": "Built-in Functions"
    }, 
    "buffer_info": {
        "descr": "Return a tuple (address, length) giving the current memory address and the length in elements of the buffer used to hold array\u2019s contents. The size of the memory buffer in bytes can be computed as array.buffer_info()[1] * array.itemsize. This is occasionally useful when working with low-level (and inherently unsafe) I/O interfaces that require memory addresses, such as certain ioctl() operations. The returned numbers are valid as long as the array exists and no length-changing operations are applied to it.", 
        "name": "array.array.buffer_info", 
        "params": [], 
        "path": "python/library/array#array.array.buffer_info", 
        "syntax": "array.buffer_info()", 
        "type": "Data Types"
    }, 
    "bytearray": {
        "descr": "Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as most methods that the bytes type has, see Bytes and Bytearray Operations.", 
        "name": "bytearray", 
        "params": [], 
        "path": "python/library/functions#bytearray", 
        "syntax": "bytearray([source[, encoding[, errors]]])", 
        "type": "Built-in Functions"
    }, 
    "bytearray.decode": {
        "descr": "Return a string decoded from the given bytes. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace' and any other name registered via codecs.register_error(), see section Codec Base Classes. For a list of possible encodings, see section Standard Encodings.", 
        "name": "bytearray.decode", 
        "params": [], 
        "path": "python/library/stdtypes#bytearray.decode", 
        "syntax": "bytearray.decode(encoding=\"utf-8\", errors=\"strict\")", 
        "type": "Built-in Types"
    }, 
    "bytearray.fromhex": {
        "descr": "This bytes class method returns a bytes or bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, spaces are ignored.", 
        "name": "bytearray.fromhex", 
        "params": [], 
        "path": "python/library/stdtypes#bytearray.fromhex", 
        "syntax": "classmethod bytearray.fromhex(string)", 
        "type": "Built-in Types"
    }, 
    "bytearray.translate": {
        "descr": "Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument delete are removed, and the remaining bytes have been mapped through the given translation table, which must be a bytes object of length 256.", 
        "name": "bytearray.translate", 
        "params": [], 
        "path": "python/library/stdtypes#bytearray.translate", 
        "syntax": "bytearray.translate(table[, delete])", 
        "type": "Built-in Types"
    }, 
    "bytes": {
        "descr": "Return a new \u201cbytes\u201d object, which is an immutable sequence of integers in the range 0 <= x < 256. bytes is an immutable version of bytearray \u2013 it has the same non-mutating methods and the same indexing and slicing behavior.", 
        "name": "bytes", 
        "params": [], 
        "path": "python/library/functions#bytes", 
        "syntax": "bytes([source[, encoding[, errors]]])", 
        "type": "Built-in Functions"
    }, 
    "bytes.decode": {
        "descr": "Return a string decoded from the given bytes. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace' and any other name registered via codecs.register_error(), see section Codec Base Classes. For a list of possible encodings, see section Standard Encodings.", 
        "name": "bytes.decode", 
        "params": [], 
        "path": "python/library/stdtypes#bytes.decode", 
        "syntax": "bytes.decode(encoding=\"utf-8\", errors=\"strict\")", 
        "type": "Built-in Types"
    }, 
    "bytes.fromhex": {
        "descr": "This bytes class method returns a bytes or bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, spaces are ignored.", 
        "name": "bytes.fromhex", 
        "params": [], 
        "path": "python/library/stdtypes#bytes.fromhex", 
        "syntax": "classmethod bytes.fromhex(string)", 
        "type": "Built-in Types"
    }, 
    "bytes.translate": {
        "descr": "Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument delete are removed, and the remaining bytes have been mapped through the given translation table, which must be a bytes object of length 256.", 
        "name": "bytes.translate", 
        "params": [], 
        "path": "python/library/stdtypes#bytes.translate", 
        "syntax": "bytes.translate(table[, delete])", 
        "type": "Built-in Types"
    }, 
    "byteswap": {
        "descr": "\u201cByteswap\u201d all items of the array. This is only supported for values which are 1, 2, 4, or 8 bytes in size; for other types of values, RuntimeError is raised. It is useful when reading data from a file written on a machine with a different byte order.", 
        "name": "array.array.byteswap", 
        "params": [], 
        "path": "python/library/array#array.array.byteswap", 
        "syntax": "array.byteswap()", 
        "type": "Data Types"
    }, 
    "bz2.BZ2Compressor": {
        "descr": "Create a new compressor object. This object may be used to compress data incrementally. For one-shot compression, use the compress() function instead.", 
        "name": "bz2.BZ2Compressor", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Compressor", 
        "syntax": "class bz2.BZ2Compressor(compresslevel=9)", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2Compressor.compress": {
        "descr": "Provide data to the compressor object. Returns a chunk of compressed data if possible, or an empty byte string otherwise.", 
        "name": "bz2.BZ2Compressor.compress", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Compressor.compress", 
        "syntax": "compress(data)", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2Compressor.flush": {
        "descr": "Finish the compression process. Returns the compressed data left in internal buffers.", 
        "name": "bz2.BZ2Compressor.flush", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Compressor.flush", 
        "syntax": "flush()", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2Decompressor": {
        "descr": "Create a new decompressor object. This object may be used to decompress data incrementally. For one-shot compression, use the decompress() function instead.", 
        "name": "bz2.BZ2Decompressor", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Decompressor", 
        "syntax": "class bz2.BZ2Decompressor", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2Decompressor.decompress": {
        "descr": "Provide data to the decompressor object. Returns a chunk of decompressed data if possible, or an empty byte string otherwise.", 
        "name": "bz2.BZ2Decompressor.decompress", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Decompressor.decompress", 
        "syntax": "decompress(data)", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2Decompressor.eof": {
        "descr": "True if the end-of-stream marker has been reached.", 
        "name": "bz2.BZ2Decompressor.eof", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Decompressor.eof", 
        "syntax": "eof", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2Decompressor.unused_data": {
        "descr": "Data found after the end of the compressed stream.", 
        "name": "bz2.BZ2Decompressor.unused_data", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2Decompressor.unused_data", 
        "syntax": "unused_data", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2File": {
        "descr": "Open a bzip2-compressed file in binary mode.", 
        "name": "bz2.BZ2File", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2File", 
        "syntax": "class bz2.BZ2File(filename, mode='r', buffering=None, compresslevel=9)", 
        "type": "Data Compression"
    }, 
    "bz2.BZ2File.peek": {
        "descr": "Return buffered data without advancing the file position. At least one byte of data will be returned (unless at EOF). The exact number of bytes returned is unspecified.", 
        "name": "bz2.BZ2File.peek", 
        "params": [], 
        "path": "python/library/bz2#bz2.BZ2File.peek", 
        "syntax": "peek([n])", 
        "type": "Data Compression"
    }, 
    "bz2.compress": {
        "descr": "Compress data.", 
        "name": "bz2.compress", 
        "params": [], 
        "path": "python/library/bz2#bz2.compress", 
        "syntax": "bz2.compress(data, compresslevel=9)", 
        "type": "Data Compression"
    }, 
    "bz2.decompress": {
        "descr": "Decompress data.", 
        "name": "bz2.decompress", 
        "params": [], 
        "path": "python/library/bz2#bz2.decompress", 
        "syntax": "bz2.decompress(data)", 
        "type": "Data Compression"
    }, 
    "bz2.open": {
        "descr": "Open a bzip2-compressed file in binary or text mode, returning a file object.", 
        "name": "bz2.open", 
        "params": [], 
        "path": "python/library/bz2#bz2.open", 
        "syntax": "bz2.open(filename, mode='r', compresslevel=9, encoding=None, errors=None, newline=None)", 
        "type": "Data Compression"
    }, 
    "calendar.Calendar": {
        "descr": "Creates a Calendar object. firstweekday is an integer specifying the first day of the week. 0 is Monday (the default), 6 is Sunday.", 
        "name": "calendar.Calendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar", 
        "syntax": "class calendar.Calendar(firstweekday=0)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.itermonthdates": {
        "descr": "Return an iterator for the month month (1-12) in the year year. This iterator will return all days (as datetime.date objects) for the month and all days before the start of the month or after the end of the month that are required to get a complete week.", 
        "name": "calendar.Calendar.itermonthdates", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.itermonthdates", 
        "syntax": "itermonthdates(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.itermonthdays": {
        "descr": "Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will simply be day numbers.", 
        "name": "calendar.Calendar.itermonthdays", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.itermonthdays", 
        "syntax": "itermonthdays(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.itermonthdays2": {
        "descr": "Return an iterator for the month month in the year year similar to itermonthdates(). Days returned will be tuples consisting of a day number and a week day number.", 
        "name": "calendar.Calendar.itermonthdays2", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.itermonthdays2", 
        "syntax": "itermonthdays2(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.iterweekdays": {
        "descr": "Return an iterator for the week day numbers that will be used for one week. The first value from the iterator will be the same as the value of the firstweekday property.", 
        "name": "calendar.Calendar.iterweekdays", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.iterweekdays", 
        "syntax": "iterweekdays()", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.monthdatescalendar": {
        "descr": "Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven datetime.date objects.", 
        "name": "calendar.Calendar.monthdatescalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.monthdatescalendar", 
        "syntax": "monthdatescalendar(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.monthdays2calendar": {
        "descr": "Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven tuples of day numbers and weekday numbers.", 
        "name": "calendar.Calendar.monthdays2calendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.monthdays2calendar", 
        "syntax": "monthdays2calendar(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.monthdayscalendar": {
        "descr": "Return a list of the weeks in the month month of the year as full weeks. Weeks are lists of seven day numbers.", 
        "name": "calendar.Calendar.monthdayscalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.monthdayscalendar", 
        "syntax": "monthdayscalendar(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.yeardatescalendar": {
        "descr": "Return the data for the specified year ready for formatting. The return value is a list of month rows. Each month row contains up to width months (defaulting to 3). Each month contains between 4 and 6 weeks and each week contains 1\u20137 days. Days are datetime.date objects.", 
        "name": "calendar.Calendar.yeardatescalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.yeardatescalendar", 
        "syntax": "yeardatescalendar(year, width=3)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.yeardays2calendar": {
        "descr": "Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are tuples of day numbers and weekday numbers. Day numbers outside this month are zero.", 
        "name": "calendar.Calendar.yeardays2calendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.yeardays2calendar", 
        "syntax": "yeardays2calendar(year, width=3)", 
        "type": "Data Types"
    }, 
    "calendar.Calendar.yeardayscalendar": {
        "descr": "Return the data for the specified year ready for formatting (similar to yeardatescalendar()). Entries in the week lists are day numbers. Day numbers outside this month are zero.", 
        "name": "calendar.Calendar.yeardayscalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.Calendar.yeardayscalendar", 
        "syntax": "yeardayscalendar(year, width=3)", 
        "type": "Data Types"
    }, 
    "calendar.HTMLCalendar": {
        "descr": "This class can be used to generate HTML calendars.", 
        "name": "calendar.HTMLCalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.HTMLCalendar", 
        "syntax": "class calendar.HTMLCalendar(firstweekday=0)", 
        "type": "Data Types"
    }, 
    "calendar.HTMLCalendar.formatmonth": {
        "descr": "Return a month\u2019s calendar as an HTML table. If withyear is true the year will be included in the header, otherwise just the month name will be used.", 
        "name": "calendar.HTMLCalendar.formatmonth", 
        "params": [], 
        "path": "python/library/calendar#calendar.HTMLCalendar.formatmonth", 
        "syntax": "formatmonth(theyear, themonth, withyear=True)", 
        "type": "Data Types"
    }, 
    "calendar.HTMLCalendar.formatyear": {
        "descr": "Return a year\u2019s calendar as an HTML table. width (defaulting to 3) specifies the number of months per row.", 
        "name": "calendar.HTMLCalendar.formatyear", 
        "params": [], 
        "path": "python/library/calendar#calendar.HTMLCalendar.formatyear", 
        "syntax": "formatyear(theyear, width=3)", 
        "type": "Data Types"
    }, 
    "calendar.HTMLCalendar.formatyearpage": {
        "descr": "Return a year\u2019s calendar as a complete HTML page. width (defaulting to 3) specifies the number of months per row. css is the name for the cascading style sheet to be used. None can be passed if no style sheet should be used. encoding specifies the encoding to be used for the output (defaulting to the system default encoding).", 
        "name": "calendar.HTMLCalendar.formatyearpage", 
        "params": [], 
        "path": "python/library/calendar#calendar.HTMLCalendar.formatyearpage", 
        "syntax": "formatyearpage(theyear, width=3, css='calendar.css', encoding=None)", 
        "type": "Data Types"
    }, 
    "calendar.LocaleHTMLCalendar": {
        "descr": "This subclass of HTMLCalendar can be passed a locale name in the constructor and will return month and weekday names in the specified locale. If this locale includes an encoding all strings containing month and weekday names will be returned as unicode.", 
        "name": "calendar.LocaleHTMLCalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.LocaleHTMLCalendar", 
        "syntax": "class calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)", 
        "type": "Data Types"
    }, 
    "calendar.LocaleTextCalendar": {
        "descr": "This subclass of TextCalendar can be passed a locale name in the constructor and will return month and weekday names in the specified locale. If this locale includes an encoding all strings containing month and weekday names will be returned as unicode.", 
        "name": "calendar.LocaleTextCalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.LocaleTextCalendar", 
        "syntax": "class calendar.LocaleTextCalendar(firstweekday=0, locale=None)", 
        "type": "Data Types"
    }, 
    "calendar.TextCalendar": {
        "descr": "This class can be used to generate plain text calendars.", 
        "name": "calendar.TextCalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.TextCalendar", 
        "syntax": "class calendar.TextCalendar(firstweekday=0)", 
        "type": "Data Types"
    }, 
    "calendar.TextCalendar.formatmonth": {
        "descr": "Return a month\u2019s calendar in a multi-line string. If w is provided, it specifies the width of the date columns, which are centered. If l is given, it specifies the number of lines that each week will use. Depends on the first weekday as specified in the constructor or set by the setfirstweekday() method.", 
        "name": "calendar.TextCalendar.formatmonth", 
        "params": [], 
        "path": "python/library/calendar#calendar.TextCalendar.formatmonth", 
        "syntax": "formatmonth(theyear, themonth, w=0, l=0)", 
        "type": "Data Types"
    }, 
    "calendar.TextCalendar.formatyear": {
        "descr": "Return a m-column calendar for an entire year as a multi-line string. Optional parameters w, l, and c are for date column width, lines per week, and number of spaces between month columns, respectively. Depends on the first weekday as specified in the constructor or set by the setfirstweekday() method. The earliest year for which a calendar can be generated is platform-dependent.", 
        "name": "calendar.TextCalendar.formatyear", 
        "params": [], 
        "path": "python/library/calendar#calendar.TextCalendar.formatyear", 
        "syntax": "formatyear(theyear, w=2, l=1, c=6, m=3)", 
        "type": "Data Types"
    }, 
    "calendar.TextCalendar.prmonth": {
        "descr": "Print a month\u2019s calendar as returned by formatmonth().", 
        "name": "calendar.TextCalendar.prmonth", 
        "params": [], 
        "path": "python/library/calendar#calendar.TextCalendar.prmonth", 
        "syntax": "prmonth(theyear, themonth, w=0, l=0)", 
        "type": "Data Types"
    }, 
    "calendar.TextCalendar.pryear": {
        "descr": "Print the calendar for an entire year as returned by formatyear().", 
        "name": "calendar.TextCalendar.pryear", 
        "params": [], 
        "path": "python/library/calendar#calendar.TextCalendar.pryear", 
        "syntax": "pryear(theyear, w=2, l=1, c=6, m=3)", 
        "type": "Data Types"
    }, 
    "calendar.calendar": {
        "descr": "Returns a 3-column calendar for an entire year as a multi-line string using the formatyear() of the TextCalendar class.", 
        "name": "calendar.calendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.calendar", 
        "syntax": "calendar.calendar(year, w=2, l=1, c=6, m=3)", 
        "type": "Data Types"
    }, 
    "calendar.day_abbr": {
        "descr": "An array that represents the abbreviated days of the week in the current locale.", 
        "name": "calendar.day_abbr", 
        "params": [], 
        "path": "python/library/calendar#calendar.day_abbr", 
        "syntax": "calendar.day_abbr", 
        "type": "Data Types"
    }, 
    "calendar.day_name": {
        "descr": "An array that represents the days of the week in the current locale.", 
        "name": "calendar.day_name", 
        "params": [], 
        "path": "python/library/calendar#calendar.day_name", 
        "syntax": "calendar.day_name", 
        "type": "Data Types"
    }, 
    "calendar.firstweekday": {
        "descr": "Returns the current setting for the weekday to start each week.", 
        "name": "calendar.firstweekday", 
        "params": [], 
        "path": "python/library/calendar#calendar.firstweekday", 
        "syntax": "calendar.firstweekday()", 
        "type": "Data Types"
    }, 
    "calendar.isleap": {
        "descr": "Returns True if year is a leap year, otherwise False.", 
        "name": "calendar.isleap", 
        "params": [], 
        "path": "python/library/calendar#calendar.isleap", 
        "syntax": "calendar.isleap(year)", 
        "type": "Data Types"
    }, 
    "calendar.leapdays": {
        "descr": "Returns the number of leap years in the range from y1 to y2 (exclusive), where y1 and y2 are years.", 
        "name": "calendar.leapdays", 
        "params": [], 
        "path": "python/library/calendar#calendar.leapdays", 
        "syntax": "calendar.leapdays(y1, y2)", 
        "type": "Data Types"
    }, 
    "calendar.month": {
        "descr": "Returns a month\u2019s calendar in a multi-line string using the formatmonth() of the TextCalendar class.", 
        "name": "calendar.month", 
        "params": [], 
        "path": "python/library/calendar#calendar.month", 
        "syntax": "calendar.month(theyear, themonth, w=0, l=0)", 
        "type": "Data Types"
    }, 
    "calendar.month_abbr": {
        "descr": "An array that represents the abbreviated months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and month_abbr[0] is the empty string.", 
        "name": "calendar.month_abbr", 
        "params": [], 
        "path": "python/library/calendar#calendar.month_abbr", 
        "syntax": "calendar.month_abbr", 
        "type": "Data Types"
    }, 
    "calendar.month_name": {
        "descr": "An array that represents the months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and month_name[0] is the empty string.", 
        "name": "calendar.month_name", 
        "params": [], 
        "path": "python/library/calendar#calendar.month_name", 
        "syntax": "calendar.month_name", 
        "type": "Data Types"
    }, 
    "calendar.monthcalendar": {
        "descr": "Returns a matrix representing a month\u2019s calendar. Each row represents a week; days outside of the month a represented by zeros. Each week begins with Monday unless set by setfirstweekday().", 
        "name": "calendar.monthcalendar", 
        "params": [], 
        "path": "python/library/calendar#calendar.monthcalendar", 
        "syntax": "calendar.monthcalendar(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.monthrange": {
        "descr": "Returns weekday of first day of the month and number of days in month, for the specified year and month.", 
        "name": "calendar.monthrange", 
        "params": [], 
        "path": "python/library/calendar#calendar.monthrange", 
        "syntax": "calendar.monthrange(year, month)", 
        "type": "Data Types"
    }, 
    "calendar.prcal": {
        "descr": "Prints the calendar for an entire year as returned by calendar().", 
        "name": "calendar.prcal", 
        "params": [], 
        "path": "python/library/calendar#calendar.prcal", 
        "syntax": "calendar.prcal(year, w=0, l=0, c=6, m=3)", 
        "type": "Data Types"
    }, 
    "calendar.prmonth": {
        "descr": "Prints a month\u2019s calendar as returned by month().", 
        "name": "calendar.prmonth", 
        "params": [], 
        "path": "python/library/calendar#calendar.prmonth", 
        "syntax": "calendar.prmonth(theyear, themonth, w=0, l=0)", 
        "type": "Data Types"
    }, 
    "calendar.setfirstweekday": {
        "descr": "Sets the weekday (0 is Monday, 6 is Sunday) to start each week. The values MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY are provided for convenience. For example, to set the first weekday to Sunday:", 
        "name": "calendar.setfirstweekday", 
        "params": [], 
        "path": "python/library/calendar#calendar.setfirstweekday", 
        "syntax": "calendar.setfirstweekday(weekday)", 
        "type": "Data Types"
    }, 
    "calendar.timegm": {
        "descr": "An unrelated but handy function that takes a time tuple such as returned by the gmtime() function in the time module, and returns the corresponding Unix timestamp value, assuming an epoch of 1970, and the POSIX encoding. In fact, time.gmtime() and timegm() are each others\u2019 inverse.", 
        "name": "calendar.timegm", 
        "params": [], 
        "path": "python/library/calendar#calendar.timegm", 
        "syntax": "calendar.timegm(tuple)", 
        "type": "Data Types"
    }, 
    "calendar.weekday": {
        "descr": "Returns the day of the week (0 is Monday) for year (1970\u2013...), month (1\u201312), day (1\u201331).", 
        "name": "calendar.weekday", 
        "params": [], 
        "path": "python/library/calendar#calendar.weekday", 
        "syntax": "calendar.weekday(year, month, day)", 
        "type": "Data Types"
    }, 
    "calendar.weekheader": {
        "descr": "Return a header containing abbreviated weekday names. n specifies the width in characters for one weekday.", 
        "name": "calendar.weekheader", 
        "params": [], 
        "path": "python/library/calendar#calendar.weekheader", 
        "syntax": "calendar.weekheader(n)", 
        "type": "Data Types"
    }, 
    "callable": {
        "descr": "Return True if the object argument appears callable, False if not. If this returns true, it is still possible that a call fails, but if it is false, calling object will never succeed. Note that classes are callable (calling a class returns a new instance); instances are callable if their class has a __call__() method.", 
        "name": "callable", 
        "params": [], 
        "path": "python/library/functions#callable", 
        "syntax": "callable(object)", 
        "type": "Built-in Functions"
    }, 
    "capitalize": {
        "descr": "Return a copy of the string with its first character capitalized and the rest lowercased.", 
        "name": "str.capitalize", 
        "params": [], 
        "path": "python/library/stdtypes#str.capitalize", 
        "syntax": "str.capitalize()", 
        "type": "Built-in Types"
    }, 
    "casefold": {
        "descr": "Return a casefolded copy of the string. Casefolded strings may be used for caseless matching.", 
        "name": "str.casefold", 
        "params": [], 
        "path": "python/library/stdtypes#str.casefold", 
        "syntax": "str.casefold()", 
        "type": "Built-in Types"
    }, 
    "center": {
        "descr": "Return centered in a string of length width. Padding is done using the specified fillchar (default is a space).", 
        "name": "str.center", 
        "params": [], 
        "path": "python/library/stdtypes#str.center", 
        "syntax": "str.center(width[, fillchar])", 
        "type": "Built-in Types"
    }, 
    "cgi.FieldStorage.getfirst": {
        "descr": "This method always returns only one value associated with form field name. The method returns only the first value in case that more values were posted under such name. Please note that the order in which the values are received may vary from browser to browser and should not be counted on. [1] If no such form field or value exists then the method returns the value specified by the optional parameter default. This parameter defaults to None if not specified.", 
        "name": "cgi.FieldStorage.getfirst", 
        "params": [], 
        "path": "python/library/cgi#cgi.FieldStorage.getfirst", 
        "syntax": "FieldStorage.getfirst(name, default=None)", 
        "type": "Internet"
    }, 
    "cgi.FieldStorage.getlist": {
        "descr": "This method always returns a list of values associated with form field name. The method returns an empty list if no such form field or value exists for name. It returns a list consisting of one item if only one such value exists.", 
        "name": "cgi.FieldStorage.getlist", 
        "params": [], 
        "path": "python/library/cgi#cgi.FieldStorage.getlist", 
        "syntax": "FieldStorage.getlist(name)", 
        "type": "Internet"
    }, 
    "cgi.escape": {
        "descr": "Convert the characters '&', '<' and '>' in string s to HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. If the optional flag quote is true, the quotation mark character (\") is also translated; this helps for inclusion in an HTML attribute value delimited by double quotes, as in <a href=\"...\">. Note that single quotes are never translated.", 
        "name": "cgi.escape", 
        "params": [], 
        "path": "python/library/cgi#cgi.escape", 
        "syntax": "cgi.escape(s, quote=False)", 
        "type": "Internet"
    }, 
    "cgi.parse": {
        "descr": "Parse a query in the environment or from a file (the file defaults to sys.stdin). The keep_blank_values and strict_parsing parameters are passed to urllib.parse.parse_qs() unchanged.", 
        "name": "cgi.parse", 
        "params": [], 
        "path": "python/library/cgi#cgi.parse", 
        "syntax": "cgi.parse(fp=None, environ=os.environ, keep_blank_values=False, strict_parsing=False)", 
        "type": "Internet"
    }, 
    "cgi.parse_header": {
        "descr": "Parse a MIME header (such as Content-Type) into a main value and a dictionary of parameters.", 
        "name": "cgi.parse_header", 
        "params": [], 
        "path": "python/library/cgi#cgi.parse_header", 
        "syntax": "cgi.parse_header(string)", 
        "type": "Internet"
    }, 
    "cgi.parse_multipart": {
        "descr": "Parse input of type multipart/form-data (for file uploads). Arguments are fp for the input file and pdict for a dictionary containing other parameters in the Content-Type header.", 
        "name": "cgi.parse_multipart", 
        "params": [], 
        "path": "python/library/cgi#cgi.parse_multipart", 
        "syntax": "cgi.parse_multipart(fp, pdict)", 
        "type": "Internet"
    }, 
    "cgi.parse_qs": {
        "descr": "This function is deprecated in this module. Use urllib.parse.parse_qs() instead. It is maintained here only for backward compatibility.", 
        "name": "cgi.parse_qs", 
        "params": [], 
        "path": "python/library/cgi#cgi.parse_qs", 
        "syntax": "cgi.parse_qs(qs, keep_blank_values=False, strict_parsing=False)", 
        "type": "Internet"
    }, 
    "cgi.parse_qsl": {
        "descr": "This function is deprecated in this module. Use urllib.parse.parse_qs() instead. It is maintained here only for backward compatibility.", 
        "name": "cgi.parse_qsl", 
        "params": [], 
        "path": "python/library/cgi#cgi.parse_qsl", 
        "syntax": "cgi.parse_qsl(qs, keep_blank_values=False, strict_parsing=False)", 
        "type": "Internet"
    }, 
    "cgi.print_directory": {
        "descr": "Format the current directory in HTML.", 
        "name": "cgi.print_directory", 
        "params": [], 
        "path": "python/library/cgi#cgi.print_directory", 
        "syntax": "cgi.print_directory()", 
        "type": "Internet"
    }, 
    "cgi.print_environ": {
        "descr": "Format the shell environment in HTML.", 
        "name": "cgi.print_environ", 
        "params": [], 
        "path": "python/library/cgi#cgi.print_environ", 
        "syntax": "cgi.print_environ()", 
        "type": "Internet"
    }, 
    "cgi.print_environ_usage": {
        "descr": "Print a list of useful (used by CGI) environment variables in HTML.", 
        "name": "cgi.print_environ_usage", 
        "params": [], 
        "path": "python/library/cgi#cgi.print_environ_usage", 
        "syntax": "cgi.print_environ_usage()", 
        "type": "Internet"
    }, 
    "cgi.print_form": {
        "descr": "Format a form in HTML.", 
        "name": "cgi.print_form", 
        "params": [], 
        "path": "python/library/cgi#cgi.print_form", 
        "syntax": "cgi.print_form(form)", 
        "type": "Internet"
    }, 
    "cgi.test": {
        "descr": "Robust test CGI script, usable as main program. Writes minimal HTTP headers and formats all information provided to the script in HTML form.", 
        "name": "cgi.test", 
        "params": [], 
        "path": "python/library/cgi#cgi.test", 
        "syntax": "cgi.test()", 
        "type": "Internet"
    }, 
    "cgitb.enable": {
        "descr": "The optional argument display defaults to 1 and can be set to 0 to suppress sending the traceback to the browser. If the argument logdir is present, the traceback reports are written to files. The value of logdir should be a directory where these files will be placed. The optional argument context is the number of lines of context to display around the current line of source code in the traceback; this defaults to 5. If the optional argument format is \"html\", the output is formatted as HTML. Any other value forces plain text output. The default value is \"html\".", 
        "name": "cgitb.enable", 
        "params": [], 
        "path": "python/library/cgitb#cgitb.enable", 
        "syntax": "cgitb.enable(display=1, logdir=None, context=5, format=\"html\")", 
        "type": "Internet"
    }, 
    "cgitb.handler": {
        "descr": "This function handles an exception using the default settings (that is, show a report in the browser, but don\u2019t log to a file). This can be used when you\u2019ve caught an exception and want to report it using cgitb. The optional info argument should be a 3-tuple containing an exception type, exception value, and traceback object, exactly like the tuple returned by sys.exc_info(). If the info argument is not supplied, the current exception is obtained from sys.exc_info().", 
        "name": "cgitb.handler", 
        "params": [], 
        "path": "python/library/cgitb#cgitb.handler", 
        "syntax": "cgitb.handler(info=None)", 
        "type": "Internet"
    }, 
    "chr": {
        "descr": "Return the string representing a character whose Unicode codepoint is the integer i. For example, chr(97) returns the string 'a'. This is the inverse of ord(). The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16). ValueError will be raised if i is outside that range.", 
        "name": "chr", 
        "params": [], 
        "path": "python/library/functions#chr", 
        "syntax": "chr(i)", 
        "type": "Built-in Functions"
    }, 
    "chunk.Chunk": {
        "descr": "Class which represents a chunk. The file argument is expected to be a file-like object. An instance of this class is specifically allowed. The only method that is needed is read(). If the methods seek() and tell() are present and don\u2019t raise an exception, they are also used. If these methods are present and raise an exception, they are expected to not have altered the object. If the optional argument align is true, chunks are assumed to be aligned on 2-byte boundaries. If align is false, no alignment is assumed. The default value is true. If the optional argument bigendian is false, the chunk size is assumed to be in little-endian order. This is needed for WAVE audio files. The default value is true. If the optional argument inclheader is true, the size given in the chunk header includes the size of the header. The default value is false.", 
        "name": "chunk.Chunk", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk", 
        "syntax": "class chunk.Chunk(file, align=True, bigendian=True, inclheader=False)", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.close": {
        "descr": "Close and skip to the end of the chunk. This does not close the underlying file.", 
        "name": "chunk.Chunk.close", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.close", 
        "syntax": "close()", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.getname": {
        "descr": "Returns the name (ID) of the chunk. This is the first 4 bytes of the chunk.", 
        "name": "chunk.Chunk.getname", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.getname", 
        "syntax": "getname()", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.getsize": {
        "descr": "Returns the size of the chunk.", 
        "name": "chunk.Chunk.getsize", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.getsize", 
        "syntax": "getsize()", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.isatty": {
        "descr": "Returns False.", 
        "name": "chunk.Chunk.isatty", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.isatty", 
        "syntax": "isatty()", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.read": {
        "descr": "Read at most size bytes from the chunk (less if the read hits the end of the chunk before obtaining size bytes). If the size argument is negative or omitted, read all data until the end of the chunk. An empty bytes object is returned when the end of the chunk is encountered immediately.", 
        "name": "chunk.Chunk.read", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.read", 
        "syntax": "read(size=-1)", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.seek": {
        "descr": "Set the chunk\u2019s current position. The whence argument is optional and defaults to 0 (absolute file positioning); other values are 1 (seek relative to the current position) and 2 (seek relative to the file\u2019s end). There is no return value. If the underlying file does not allow seek, only forward seeks are allowed.", 
        "name": "chunk.Chunk.seek", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.seek", 
        "syntax": "seek(pos, whence=0)", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.skip": {
        "descr": "Skip to the end of the chunk. All further calls to read() for the chunk will return b''. If you are not interested in the contents of the chunk, this method should be called so that the file points to the start of the next chunk.", 
        "name": "chunk.Chunk.skip", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.skip", 
        "syntax": "skip()", 
        "type": "Multimedia"
    }, 
    "chunk.Chunk.tell": {
        "descr": "Return the current position into the chunk.", 
        "name": "chunk.Chunk.tell", 
        "params": [], 
        "path": "python/library/chunk#chunk.Chunk.tell", 
        "syntax": "tell()", 
        "type": "Multimedia"
    }, 
    "class.__bases__": {
        "descr": "The tuple of base classes of a class object.", 
        "name": "class.__bases__", 
        "params": [], 
        "path": "python/library/stdtypes#class.__bases__", 
        "syntax": "class.__bases__", 
        "type": "Built-in Types"
    }, 
    "class.__mro__": {
        "descr": "This attribute is a tuple of classes that are considered when looking for base classes during method resolution.", 
        "name": "class.__mro__", 
        "params": [], 
        "path": "python/library/stdtypes#class.__mro__", 
        "syntax": "class.__mro__", 
        "type": "Built-in Types"
    }, 
    "class.__name__": {
        "descr": "The name of the class or type.", 
        "name": "class.__name__", 
        "params": [], 
        "path": "python/library/stdtypes#class.__name__", 
        "syntax": "class.__name__", 
        "type": "Built-in Types"
    }, 
    "class.__qualname__": {
        "descr": "The qualified name of the class or type.", 
        "name": "class.__qualname__", 
        "params": [], 
        "path": "python/library/stdtypes#class.__qualname__", 
        "syntax": "class.__qualname__", 
        "type": "Built-in Types"
    }, 
    "class.__subclasses__": {
        "descr": "Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. Example:", 
        "name": "class.__subclasses__", 
        "params": [], 
        "path": "python/library/stdtypes#class.__subclasses__", 
        "syntax": "class.__subclasses__()", 
        "type": "Built-in Types"
    }, 
    "class.mro": {
        "descr": "This method can be overridden by a metaclass to customize the method resolution order for its instances. It is called at class instantiation, and its result is stored in __mro__.", 
        "name": "class.mro", 
        "params": [], 
        "path": "python/library/stdtypes#class.mro", 
        "syntax": "class.mro()", 
        "type": "Built-in Types"
    }, 
    "classmethod": {
        "descr": "Return a class method for function.", 
        "name": "classmethod", 
        "params": [], 
        "path": "python/library/functions#classmethod", 
        "syntax": "classmethod(function)", 
        "type": "Built-in Functions"
    }, 
    "clear": {
        "descr": "Remove all items from the dictionary.", 
        "name": "dict.clear", 
        "params": [], 
        "path": "python/library/stdtypes#dict.clear", 
        "syntax": "clear()", 
        "type": "Built-in Types"
    }, 
    "cmath.acos": {
        "descr": "Return the arc cosine of x. There are two branch cuts: One extends right from 1 along the real axis to \u221e, continuous from below. The other extends left from -1 along the real axis to -\u221e, continuous from above.", 
        "name": "cmath.acos", 
        "params": [], 
        "path": "python/library/cmath#cmath.acos", 
        "syntax": "cmath.acos(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.acosh": {
        "descr": "Return the hyperbolic arc cosine of x. There is one branch cut, extending left from 1 along the real axis to -\u221e, continuous from above.", 
        "name": "cmath.acosh", 
        "params": [], 
        "path": "python/library/cmath#cmath.acosh", 
        "syntax": "cmath.acosh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.asin": {
        "descr": "Return the arc sine of x. This has the same branch cuts as acos().", 
        "name": "cmath.asin", 
        "params": [], 
        "path": "python/library/cmath#cmath.asin", 
        "syntax": "cmath.asin(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.asinh": {
        "descr": "Return the hyperbolic arc sine of x. There are two branch cuts: One extends from 1j along the imaginary axis to \u221ej, continuous from the right. The other extends from -1j along the imaginary axis to -\u221ej, continuous from the left.", 
        "name": "cmath.asinh", 
        "params": [], 
        "path": "python/library/cmath#cmath.asinh", 
        "syntax": "cmath.asinh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.atan": {
        "descr": "Return the arc tangent of x. There are two branch cuts: One extends from 1j along the imaginary axis to \u221ej, continuous from the right. The other extends from -1j along the imaginary axis to -\u221ej, continuous from the left.", 
        "name": "cmath.atan", 
        "params": [], 
        "path": "python/library/cmath#cmath.atan", 
        "syntax": "cmath.atan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.atanh": {
        "descr": "Return the hyperbolic arc tangent of x. There are two branch cuts: One extends from 1 along the real axis to \u221e, continuous from below. The other extends from -1 along the real axis to -\u221e, continuous from above.", 
        "name": "cmath.atanh", 
        "params": [], 
        "path": "python/library/cmath#cmath.atanh", 
        "syntax": "cmath.atanh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.cos": {
        "descr": "Return the cosine of x.", 
        "name": "cmath.cos", 
        "params": [], 
        "path": "python/library/cmath#cmath.cos", 
        "syntax": "cmath.cos(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.cosh": {
        "descr": "Return the hyperbolic cosine of x.", 
        "name": "cmath.cosh", 
        "params": [], 
        "path": "python/library/cmath#cmath.cosh", 
        "syntax": "cmath.cosh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.e": {
        "descr": "The mathematical constant e, as a float.", 
        "name": "cmath.e", 
        "params": [], 
        "path": "python/library/cmath#cmath.e", 
        "syntax": "cmath.e", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.exp": {
        "descr": "Return the exponential value e**x.", 
        "name": "cmath.exp", 
        "params": [], 
        "path": "python/library/cmath#cmath.exp", 
        "syntax": "cmath.exp(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.isfinite": {
        "descr": "Return True if both the real and imaginary parts of x are finite, and False otherwise.", 
        "name": "cmath.isfinite", 
        "params": [], 
        "path": "python/library/cmath#cmath.isfinite", 
        "syntax": "cmath.isfinite(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.isinf": {
        "descr": "Return True if either the real or the imaginary part of x is an infinity, and False otherwise.", 
        "name": "cmath.isinf", 
        "params": [], 
        "path": "python/library/cmath#cmath.isinf", 
        "syntax": "cmath.isinf(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.isnan": {
        "descr": "Return True if either the real or the imaginary part of x is a NaN, and False otherwise.", 
        "name": "cmath.isnan", 
        "params": [], 
        "path": "python/library/cmath#cmath.isnan", 
        "syntax": "cmath.isnan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.log": {
        "descr": "Return the base-10 logarithm of x. This has the same branch cut as log().", 
        "name": "cmath.log", 
        "params": [], 
        "path": "python/library/cmath#cmath.log", 
        "syntax": "cmath.log10(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.log10": {
        "descr": "Return the base-10 logarithm of x. This has the same branch cut as log().", 
        "name": "cmath.log10", 
        "params": [], 
        "path": "python/library/cmath#cmath.log10", 
        "syntax": "cmath.log10(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.phase": {
        "descr": "Return the phase of x (also known as the argument of x), as a float. phase(x) is equivalent to math.atan2(x.imag, x.real). The result lies in the range [-\u03c0, \u03c0], and the branch cut for this operation lies along the negative real axis, continuous from above. On systems with support for signed zeros (which includes most systems in current use), this means that the sign of the result is the same as the sign of x.imag, even when x.imag is zero:", 
        "name": "cmath.phase", 
        "params": [], 
        "path": "python/library/cmath#cmath.phase", 
        "syntax": "cmath.phase(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.pi": {
        "descr": "The mathematical constant \u03c0, as a float.", 
        "name": "cmath.pi", 
        "params": [], 
        "path": "python/library/cmath#cmath.pi", 
        "syntax": "cmath.pi", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.polar": {
        "descr": "Return the representation of x in polar coordinates. Returns a pair (r, phi) where r is the modulus of x and phi is the phase of x. polar(x) is equivalent to (abs(x), phase(x)).", 
        "name": "cmath.polar", 
        "params": [], 
        "path": "python/library/cmath#cmath.polar", 
        "syntax": "cmath.polar(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.rect": {
        "descr": "Return the complex number x with polar coordinates r and phi. Equivalent to r * (math.cos(phi) + math.sin(phi)*1j).", 
        "name": "cmath.rect", 
        "params": [], 
        "path": "python/library/cmath#cmath.rect", 
        "syntax": "cmath.rect(r, phi)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.sin": {
        "descr": "Return the sine of x.", 
        "name": "cmath.sin", 
        "params": [], 
        "path": "python/library/cmath#cmath.sin", 
        "syntax": "cmath.sin(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.sinh": {
        "descr": "Return the hyperbolic sine of x.", 
        "name": "cmath.sinh", 
        "params": [], 
        "path": "python/library/cmath#cmath.sinh", 
        "syntax": "cmath.sinh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.sqrt": {
        "descr": "Return the square root of x. This has the same branch cut as log().", 
        "name": "cmath.sqrt", 
        "params": [], 
        "path": "python/library/cmath#cmath.sqrt", 
        "syntax": "cmath.sqrt(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.tan": {
        "descr": "Return the tangent of x.", 
        "name": "cmath.tan", 
        "params": [], 
        "path": "python/library/cmath#cmath.tan", 
        "syntax": "cmath.tan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmath.tanh": {
        "descr": "Return the hyperbolic tangent of x.", 
        "name": "cmath.tanh", 
        "params": [], 
        "path": "python/library/cmath#cmath.tanh", 
        "syntax": "cmath.tanh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "cmd.Cmd": {
        "descr": "A Cmd instance or subclass instance is a line-oriented interpreter framework. There is no good reason to instantiate Cmd itself; rather, it\u2019s useful as a superclass of an interpreter class you define yourself in order to inherit Cmd\u2018s methods and encapsulate action methods.", 
        "name": "cmd.Cmd", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd", 
        "syntax": "class cmd.Cmd(completekey='tab', stdin=None, stdout=None)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.cmdloop": {
        "descr": "Repeatedly issue a prompt, accept input, parse an initial prefix off the received input, and dispatch to action methods, passing them the remainder of the line as argument.", 
        "name": "cmd.Cmd.cmdloop", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.cmdloop", 
        "syntax": "Cmd.cmdloop(intro=None)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.completedefault": {
        "descr": "Method called to complete an input line when no command-specific complete_*() method is available. By default, it returns an empty list.", 
        "name": "cmd.Cmd.completedefault", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.completedefault", 
        "syntax": "Cmd.completedefault(text, line, begidx, endidx)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.default": {
        "descr": "Method called on an input line when the command prefix is not recognized. If this method is not overridden, it prints an error message and returns.", 
        "name": "cmd.Cmd.default", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.default", 
        "syntax": "Cmd.default(line)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.doc_header": {
        "descr": "The header to issue if the help output has a section for documented commands.", 
        "name": "cmd.Cmd.doc_header", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.doc_header", 
        "syntax": "Cmd.doc_header", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.emptyline": {
        "descr": "Method called when an empty line is entered in response to the prompt. If this method is not overridden, it repeats the last nonempty command entered.", 
        "name": "cmd.Cmd.emptyline", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.emptyline", 
        "syntax": "Cmd.emptyline()", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.identchars": {
        "descr": "The string of characters accepted for the command prefix.", 
        "name": "cmd.Cmd.identchars", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.identchars", 
        "syntax": "Cmd.identchars", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.intro": {
        "descr": "A string to issue as an intro or banner. May be overridden by giving the cmdloop() method an argument.", 
        "name": "cmd.Cmd.intro", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.intro", 
        "syntax": "Cmd.intro", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.lastcmd": {
        "descr": "The last nonempty command prefix seen.", 
        "name": "cmd.Cmd.lastcmd", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.lastcmd", 
        "syntax": "Cmd.lastcmd", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.misc_header": {
        "descr": "The header to issue if the help output has a section for miscellaneous help topics (that is, there are help_*() methods without corresponding do_*() methods).", 
        "name": "cmd.Cmd.misc_header", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.misc_header", 
        "syntax": "Cmd.misc_header", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.onecmd": {
        "descr": "Interpret the argument as though it had been typed in response to the prompt. This may be overridden, but should not normally need to be; see the precmd() and postcmd() methods for useful execution hooks. The return value is a flag indicating whether interpretation of commands by the interpreter should stop. If there is a do_*() method for the command str, the return value of that method is returned, otherwise the return value from the default() method is returned.", 
        "name": "cmd.Cmd.onecmd", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.onecmd", 
        "syntax": "Cmd.onecmd(str)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.postcmd": {
        "descr": "Hook method executed just after a command dispatch is finished. This method is a stub in Cmd; it exists to be overridden by subclasses. line is the command line which was executed, and stop is a flag which indicates whether execution will be terminated after the call to postcmd(); this will be the return value of the onecmd() method. The return value of this method will be used as the new value for the internal flag which corresponds to stop; returning false will cause interpretation to continue.", 
        "name": "cmd.Cmd.postcmd", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.postcmd", 
        "syntax": "Cmd.postcmd(stop, line)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.postloop": {
        "descr": "Hook method executed once when cmdloop() is about to return. This method is a stub in Cmd; it exists to be overridden by subclasses.", 
        "name": "cmd.Cmd.postloop", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.postloop", 
        "syntax": "Cmd.postloop()", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.precmd": {
        "descr": "Hook method executed just before the command line line is interpreted, but after the input prompt is generated and issued. This method is a stub in Cmd; it exists to be overridden by subclasses. The return value is used as the command which will be executed by the onecmd() method; the precmd() implementation may re-write the command or simply return line unchanged.", 
        "name": "cmd.Cmd.precmd", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.precmd", 
        "syntax": "Cmd.precmd(line)", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.preloop": {
        "descr": "Hook method executed once when cmdloop() is called. This method is a stub in Cmd; it exists to be overridden by subclasses.", 
        "name": "cmd.Cmd.preloop", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.preloop", 
        "syntax": "Cmd.preloop()", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.prompt": {
        "descr": "The prompt issued to solicit input.", 
        "name": "cmd.Cmd.prompt", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.prompt", 
        "syntax": "Cmd.prompt", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.ruler": {
        "descr": "The character used to draw separator lines under the help-message headers. If empty, no ruler line is drawn. It defaults to '='.", 
        "name": "cmd.Cmd.ruler", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.ruler", 
        "syntax": "Cmd.ruler", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.undoc_header": {
        "descr": "The header to issue if the help output has a section for undocumented commands (that is, there are do_*() methods without corresponding help_*() methods).", 
        "name": "cmd.Cmd.undoc_header", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.undoc_header", 
        "syntax": "Cmd.undoc_header", 
        "type": "Frameworks"
    }, 
    "cmd.Cmd.use_rawinput": {
        "descr": "A flag, defaulting to true. If true, cmdloop() uses input() to display a prompt and read the next command; if false, sys.stdout.write() and sys.stdin.readline() are used. (This means that by importing readline, on systems that support it, the interpreter will automatically support Emacs-like line editing and command-history keystrokes.)", 
        "name": "cmd.Cmd.use_rawinput", 
        "params": [], 
        "path": "python/library/cmd#cmd.Cmd.use_rawinput", 
        "syntax": "Cmd.use_rawinput", 
        "type": "Frameworks"
    }, 
    "code.InteractiveConsole": {
        "descr": "Closely emulate the behavior of the interactive Python interpreter. This class builds on InteractiveInterpreter and adds prompting using the familiar sys.ps1 and sys.ps2, and input buffering.", 
        "name": "code.InteractiveConsole", 
        "params": [], 
        "path": "python/library/code#code.InteractiveConsole", 
        "syntax": "class code.InteractiveConsole(locals=None, filename=\"<console>\")", 
        "type": "Interpreters"
    }, 
    "code.InteractiveConsole.interact": {
        "descr": "Closely emulate the interactive Python console. The optional banner argument specify the banner to print before the first interaction; by default it prints a banner similar to the one printed by the standard Python interpreter, followed by the class name of the console object in parentheses (so as not to confuse this with the real interpreter \u2013 since it\u2019s so close!).", 
        "name": "code.InteractiveConsole.interact", 
        "params": [], 
        "path": "python/library/code#code.InteractiveConsole.interact", 
        "syntax": "InteractiveConsole.interact(banner=None)", 
        "type": "Interpreters"
    }, 
    "code.InteractiveConsole.push": {
        "descr": "Push a line of source text to the interpreter. The line should not have a trailing newline; it may have internal newlines. The line is appended to a buffer and the interpreter\u2019s runsource() method is called with the concatenated contents of the buffer as source. If this indicates that the command was executed or invalid, the buffer is reset; otherwise, the command is incomplete, and the buffer is left as it was after the line was appended. The return value is True if more input is required, False if the line was dealt with in some way (this is the same as runsource()).", 
        "name": "code.InteractiveConsole.push", 
        "params": [], 
        "path": "python/library/code#code.InteractiveConsole.push", 
        "syntax": "InteractiveConsole.push(line)", 
        "type": "Interpreters"
    }, 
    "code.InteractiveConsole.raw_input": {
        "descr": "Write a prompt and read a line. The returned line does not include the trailing newline. When the user enters the EOF key sequence, EOFError is raised. The base implementation reads from sys.stdin; a subclass may replace this with a different implementation.", 
        "name": "code.InteractiveConsole.raw_input", 
        "params": [], 
        "path": "python/library/code#code.InteractiveConsole.raw_input", 
        "syntax": "InteractiveConsole.raw_input(prompt=\"\")", 
        "type": "Interpreters"
    }, 
    "code.InteractiveConsole.resetbuffer": {
        "descr": "Remove any unhandled source text from the input buffer.", 
        "name": "code.InteractiveConsole.resetbuffer", 
        "params": [], 
        "path": "python/library/code#code.InteractiveConsole.resetbuffer", 
        "syntax": "InteractiveConsole.resetbuffer()", 
        "type": "Interpreters"
    }, 
    "code.InteractiveInterpreter": {
        "descr": "This class deals with parsing and interpreter state (the user\u2019s namespace); it does not deal with input buffering or prompting or input file naming (the filename is always passed in explicitly). The optional locals argument specifies the dictionary in which code will be executed; it defaults to a newly created dictionary with key '__name__' set to '__console__' and key '__doc__' set to None.", 
        "name": "code.InteractiveInterpreter", 
        "params": [], 
        "path": "python/library/code#code.InteractiveInterpreter", 
        "syntax": "class code.InteractiveInterpreter(locals=None)", 
        "type": "Interpreters"
    }, 
    "code.InteractiveInterpreter.runcode": {
        "descr": "Execute a code object. When an exception occurs, showtraceback() is called to display a traceback. All exceptions are caught except SystemExit, which is allowed to propagate.", 
        "name": "code.InteractiveInterpreter.runcode", 
        "params": [], 
        "path": "python/library/code#code.InteractiveInterpreter.runcode", 
        "syntax": "InteractiveInterpreter.runcode(code)", 
        "type": "Interpreters"
    }, 
    "code.InteractiveInterpreter.runsource": {
        "descr": "Compile and run some source in the interpreter. Arguments are the same as for compile_command(); the default for filename is '<input>', and for symbol is 'single'. One several things can happen:", 
        "name": "code.InteractiveInterpreter.runsource", 
        "params": [], 
        "path": "python/library/code#code.InteractiveInterpreter.runsource", 
        "syntax": "InteractiveInterpreter.runsource(source, filename=\"<input>\", symbol=\"single\")", 
        "type": "Interpreters"
    }, 
    "code.InteractiveInterpreter.showsyntaxerror": {
        "descr": "Display the syntax error that just occurred. This does not display a stack trace because there isn\u2019t one for syntax errors. If filename is given, it is stuffed into the exception instead of the default filename provided by Python\u2019s parser, because it always uses '<string>' when reading from a string. The output is written by the write() method.", 
        "name": "code.InteractiveInterpreter.showsyntaxerror", 
        "params": [], 
        "path": "python/library/code#code.InteractiveInterpreter.showsyntaxerror", 
        "syntax": "InteractiveInterpreter.showsyntaxerror(filename=None)", 
        "type": "Interpreters"
    }, 
    "code.InteractiveInterpreter.showtraceback": {
        "descr": "Display the exception that just occurred. We remove the first stack item because it is within the interpreter object implementation. The output is written by the write() method.", 
        "name": "code.InteractiveInterpreter.showtraceback", 
        "params": [], 
        "path": "python/library/code#code.InteractiveInterpreter.showtraceback", 
        "syntax": "InteractiveInterpreter.showtraceback()", 
        "type": "Interpreters"
    }, 
    "code.InteractiveInterpreter.write": {
        "descr": "Write a string to the standard error stream (sys.stderr). Derived classes should override this to provide the appropriate output handling as needed.", 
        "name": "code.InteractiveInterpreter.write", 
        "params": [], 
        "path": "python/library/code#code.InteractiveInterpreter.write", 
        "syntax": "InteractiveInterpreter.write(data)", 
        "type": "Interpreters"
    }, 
    "code.compile_command": {
        "descr": "This function is useful for programs that want to emulate Python\u2019s interpreter main loop (a.k.a. the read-eval-print loop). The tricky part is to determine when the user has entered an incomplete command that can be completed by entering more text (as opposed to a complete command or a syntax error). This function almost always makes the same decision as the real interpreter main loop.", 
        "name": "code.compile_command", 
        "params": [], 
        "path": "python/library/code#code.compile_command", 
        "syntax": "code.compile_command(source, filename=\"<input>\", symbol=\"single\")", 
        "type": "Interpreters"
    }, 
    "code.interact": {
        "descr": "Convenience function to run a read-eval-print loop. This creates a new instance of InteractiveConsole and sets readfunc to be used as the InteractiveConsole.raw_input() method, if provided. If local is provided, it is passed to the InteractiveConsole constructor for use as the default namespace for the interpreter loop. The interact() method of the instance is then run with banner passed as the banner to use, if provided. The console object is discarded after use.", 
        "name": "code.interact", 
        "params": [], 
        "path": "python/library/code#code.interact", 
        "syntax": "code.interact(banner=None, readfunc=None, local=None)", 
        "type": "Interpreters"
    }, 
    "codecs.Codec.decode": {
        "descr": "Decodes the object input and returns a tuple (output object, length consumed). Decoding converts a bytes object encoded using a particular character set encoding to a string object.", 
        "name": "codecs.Codec.decode", 
        "params": [], 
        "path": "python/library/codecs#codecs.Codec.decode", 
        "syntax": "Codec.decode(input[, errors])", 
        "type": "Binary Data"
    }, 
    "codecs.Codec.encode": {
        "descr": "Encodes the object input and returns a tuple (output object, length consumed). Encoding converts a string object to a bytes object using a particular character set encoding (e.g., cp1252 or iso-8859-1).", 
        "name": "codecs.Codec.encode", 
        "params": [], 
        "path": "python/library/codecs#codecs.Codec.encode", 
        "syntax": "Codec.encode(input[, errors])", 
        "type": "Binary Data"
    }, 
    "codecs.EncodedFile": {
        "descr": "Return a wrapped version of file which provides transparent encoding translation.", 
        "name": "codecs.EncodedFile", 
        "params": [], 
        "path": "python/library/codecs#codecs.EncodedFile", 
        "syntax": "codecs.EncodedFile(file, data_encoding, file_encoding=None, errors='strict')", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalDecoder": {
        "descr": "Constructor for an IncrementalDecoder instance.", 
        "name": "codecs.IncrementalDecoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalDecoder", 
        "syntax": "class codecs.IncrementalDecoder([errors])", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalDecoder.decode": {
        "descr": "Decodes object (taking the current state of the decoder into account) and returns the resulting decoded object. If this is the last call to decode() final must be true (the default is false). If final is true the decoder must decode the input completely and must flush all buffers. If this isn\u2019t possible (e.g. because of incomplete byte sequences at the end of the input) it must initiate error handling just like in the stateless case (which might raise an exception).", 
        "name": "codecs.IncrementalDecoder.decode", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalDecoder.decode", 
        "syntax": "decode(object[, final])", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalDecoder.getstate": {
        "descr": "Return the current state of the decoder. This must be a tuple with two items, the first must be the buffer containing the still undecoded input. The second must be an integer and can be additional state info. (The implementation should make sure that 0 is the most common additional state info.) If this additional state info is 0 it must be possible to set the decoder to the state which has no input buffered and 0 as the additional state info, so that feeding the previously buffered input to the decoder returns it to the previous state without producing any output. (Additional state info that is more complicated than integers can be converted into an integer by marshaling/pickling the info and encoding the bytes of the resulting string into an integer.)", 
        "name": "codecs.IncrementalDecoder.getstate", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalDecoder.getstate", 
        "syntax": "getstate()", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalDecoder.reset": {
        "descr": "Reset the decoder to the initial state.", 
        "name": "codecs.IncrementalDecoder.reset", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalDecoder.reset", 
        "syntax": "reset()", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalDecoder.setstate": {
        "descr": "Set the state of the encoder to state. state must be a decoder state returned by getstate().", 
        "name": "codecs.IncrementalDecoder.setstate", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalDecoder.setstate", 
        "syntax": "setstate(state)", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalEncoder": {
        "descr": "Constructor for an IncrementalEncoder instance.", 
        "name": "codecs.IncrementalEncoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalEncoder", 
        "syntax": "class codecs.IncrementalEncoder([errors])", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalEncoder.encode": {
        "descr": "Encodes object (taking the current state of the encoder into account) and returns the resulting encoded object. If this is the last call to encode() final must be true (the default is false).", 
        "name": "codecs.IncrementalEncoder.encode", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalEncoder.encode", 
        "syntax": "encode(object[, final])", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalEncoder.getstate": {
        "descr": "Return the current state of the encoder which must be an integer. The implementation should make sure that 0 is the most common state. (States that are more complicated than integers can be converted into an integer by marshaling/pickling the state and encoding the bytes of the resulting string into an integer).", 
        "name": "codecs.IncrementalEncoder.getstate", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalEncoder.getstate", 
        "syntax": "IncrementalEncoder.getstate()", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalEncoder.reset": {
        "descr": "Reset the encoder to the initial state. The output is discarded: call .encode('', final=True) to reset the encoder and to get the output.", 
        "name": "codecs.IncrementalEncoder.reset", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalEncoder.reset", 
        "syntax": "reset()", 
        "type": "Binary Data"
    }, 
    "codecs.IncrementalEncoder.setstate": {
        "descr": "Set the state of the encoder to state. state must be an encoder state returned by getstate().", 
        "name": "codecs.IncrementalEncoder.setstate", 
        "params": [], 
        "path": "python/library/codecs#codecs.IncrementalEncoder.setstate", 
        "syntax": "IncrementalEncoder.setstate(state)", 
        "type": "Binary Data"
    }, 
    "codecs.StreamReader": {
        "descr": "Constructor for a StreamReader instance.", 
        "name": "codecs.StreamReader", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamReader", 
        "syntax": "class codecs.StreamReader(stream[, errors])", 
        "type": "Binary Data"
    }, 
    "codecs.StreamReader.read": {
        "descr": "Decodes data from the stream and returns the resulting object.", 
        "name": "codecs.StreamReader.read", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamReader.read", 
        "syntax": "read([size[, chars[, firstline]]])", 
        "type": "Binary Data"
    }, 
    "codecs.StreamReader.readline": {
        "descr": "Read one line from the input stream and return the decoded data.", 
        "name": "codecs.StreamReader.readline", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamReader.readline", 
        "syntax": "readline([size[, keepends]])", 
        "type": "Binary Data"
    }, 
    "codecs.StreamReader.readlines": {
        "descr": "Read all lines available on the input stream and return them as a list of lines.", 
        "name": "codecs.StreamReader.readlines", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamReader.readlines", 
        "syntax": "readlines([sizehint[, keepends]])", 
        "type": "Binary Data"
    }, 
    "codecs.StreamReader.reset": {
        "descr": "Resets the codec buffers used for keeping state.", 
        "name": "codecs.StreamReader.reset", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamReader.reset", 
        "syntax": "reset()", 
        "type": "Binary Data"
    }, 
    "codecs.StreamReaderWriter": {
        "descr": "Creates a StreamReaderWriter instance. stream must be a file-like object. Reader and Writer must be factory functions or classes providing the StreamReader and StreamWriter interface resp. Error handling is done in the same way as defined for the stream readers and writers.", 
        "name": "codecs.StreamReaderWriter", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamReaderWriter", 
        "syntax": "class codecs.StreamReaderWriter(stream, Reader, Writer, errors)", 
        "type": "Binary Data"
    }, 
    "codecs.StreamRecoder": {
        "descr": "Creates a StreamRecoder instance which implements a two-way conversion: encode and decode work on the frontend (the input to read() and output of write()) while Reader and Writer work on the backend (reading and writing to the stream).", 
        "name": "codecs.StreamRecoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamRecoder", 
        "syntax": "class codecs.StreamRecoder(stream, encode, decode, Reader, Writer, errors)", 
        "type": "Binary Data"
    }, 
    "codecs.StreamWriter": {
        "descr": "Constructor for a StreamWriter instance.", 
        "name": "codecs.StreamWriter", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamWriter", 
        "syntax": "class codecs.StreamWriter(stream[, errors])", 
        "type": "Binary Data"
    }, 
    "codecs.StreamWriter.reset": {
        "descr": "Flushes and resets the codec buffers used for keeping state.", 
        "name": "codecs.StreamWriter.reset", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamWriter.reset", 
        "syntax": "reset()", 
        "type": "Binary Data"
    }, 
    "codecs.StreamWriter.write": {
        "descr": "Writes the object\u2019s contents encoded to the stream.", 
        "name": "codecs.StreamWriter.write", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamWriter.write", 
        "syntax": "write(object)", 
        "type": "Binary Data"
    }, 
    "codecs.StreamWriter.writelines": {
        "descr": "Writes the concatenated list of strings to the stream (possibly by reusing the write() method).", 
        "name": "codecs.StreamWriter.writelines", 
        "params": [], 
        "path": "python/library/codecs#codecs.StreamWriter.writelines", 
        "syntax": "writelines(list)", 
        "type": "Binary Data"
    }, 
    "codecs.backslashreplace_errors": {
        "descr": "Implements the backslashreplace error handling (for encoding only): the unencodable character is replaced by a backslashed escape sequence.", 
        "name": "codecs.backslashreplace_errors", 
        "params": [], 
        "path": "python/library/codecs#codecs.backslashreplace_errors", 
        "syntax": "codecs.backslashreplace_errors(exception)", 
        "type": "Binary Data"
    }, 
    "codecs.decode": {
        "descr": "Decodes obj using the codec registered for encoding.", 
        "name": "codecs.decode", 
        "params": [], 
        "path": "python/library/codecs#codecs.decode", 
        "syntax": "codecs.decode(obj, encoding='utf-8', errors='strict')", 
        "type": "Binary Data"
    }, 
    "codecs.encode": {
        "descr": "Encodes obj using the codec registered for encoding.", 
        "name": "codecs.encode", 
        "params": [], 
        "path": "python/library/codecs#codecs.encode", 
        "syntax": "codecs.encode(obj, encoding='utf-8', errors='strict')", 
        "type": "Binary Data"
    }, 
    "codecs.getdecoder": {
        "descr": "Look up the codec for the given encoding and return its decoder function.", 
        "name": "codecs.getdecoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.getdecoder", 
        "syntax": "codecs.getdecoder(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.getencoder": {
        "descr": "Look up the codec for the given encoding and return its encoder function.", 
        "name": "codecs.getencoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.getencoder", 
        "syntax": "codecs.getencoder(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.getincrementaldecoder": {
        "descr": "Look up the codec for the given encoding and return its incremental decoder class or factory function.", 
        "name": "codecs.getincrementaldecoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.getincrementaldecoder", 
        "syntax": "codecs.getincrementaldecoder(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.getincrementalencoder": {
        "descr": "Look up the codec for the given encoding and return its incremental encoder class or factory function.", 
        "name": "codecs.getincrementalencoder", 
        "params": [], 
        "path": "python/library/codecs#codecs.getincrementalencoder", 
        "syntax": "codecs.getincrementalencoder(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.getreader": {
        "descr": "Look up the codec for the given encoding and return its StreamReader class or factory function.", 
        "name": "codecs.getreader", 
        "params": [], 
        "path": "python/library/codecs#codecs.getreader", 
        "syntax": "codecs.getreader(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.getwriter": {
        "descr": "Look up the codec for the given encoding and return its StreamWriter class or factory function.", 
        "name": "codecs.getwriter", 
        "params": [], 
        "path": "python/library/codecs#codecs.getwriter", 
        "syntax": "codecs.getwriter(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.ignore_errors": {
        "descr": "Implements the ignore error handling: malformed data is ignored and encoding or decoding is continued without further notice.", 
        "name": "codecs.ignore_errors", 
        "params": [], 
        "path": "python/library/codecs#codecs.ignore_errors", 
        "syntax": "codecs.ignore_errors(exception)", 
        "type": "Binary Data"
    }, 
    "codecs.iterdecode": {
        "descr": "Uses an incremental decoder to iteratively decode the input provided by iterator. This function is a generator. errors (as well as any other keyword argument) is passed through to the incremental decoder.", 
        "name": "codecs.iterdecode", 
        "params": [], 
        "path": "python/library/codecs#codecs.iterdecode", 
        "syntax": "codecs.iterdecode(iterator, encoding, errors='strict', **kwargs)", 
        "type": "Binary Data"
    }, 
    "codecs.iterencode": {
        "descr": "Uses an incremental encoder to iteratively encode the input provided by iterator. This function is a generator. errors (as well as any other keyword argument) is passed through to the incremental encoder.", 
        "name": "codecs.iterencode", 
        "params": [], 
        "path": "python/library/codecs#codecs.iterencode", 
        "syntax": "codecs.iterencode(iterator, encoding, errors='strict', **kwargs)", 
        "type": "Binary Data"
    }, 
    "codecs.lookup": {
        "descr": "Looks up the codec info in the Python codec registry and returns a CodecInfo object as defined above.", 
        "name": "codecs.lookup", 
        "params": [], 
        "path": "python/library/codecs#codecs.lookup", 
        "syntax": "codecs.lookup(encoding)", 
        "type": "Binary Data"
    }, 
    "codecs.lookup_error": {
        "descr": "Return the error handler previously registered under the name name.", 
        "name": "codecs.lookup_error", 
        "params": [], 
        "path": "python/library/codecs#codecs.lookup_error", 
        "syntax": "codecs.lookup_error(name)", 
        "type": "Binary Data"
    }, 
    "codecs.open": {
        "descr": "Open an encoded file using the given mode and return a wrapped version providing transparent encoding/decoding. The default file mode is 'r' meaning to open the file in read mode.", 
        "name": "codecs.open", 
        "params": [], 
        "path": "python/library/codecs#codecs.open", 
        "syntax": "codecs.open(filename, mode[, encoding[, errors[, buffering]]])", 
        "type": "Binary Data"
    }, 
    "codecs.register": {
        "descr": "Register a codec search function. Search functions are expected to take one argument, the encoding name in all lower case letters, and return a CodecInfo object having the following attributes:", 
        "name": "codecs.register", 
        "params": [], 
        "path": "python/library/codecs#codecs.register", 
        "syntax": "codecs.register(search_function)", 
        "type": "Binary Data"
    }, 
    "codecs.register_error": {
        "descr": "Register the error handling function error_handler under the name name. error_handler will be called during encoding and decoding in case of an error, when name is specified as the errors parameter.", 
        "name": "codecs.register_error", 
        "params": [], 
        "path": "python/library/codecs#codecs.register_error", 
        "syntax": "codecs.register_error(name, error_handler)", 
        "type": "Binary Data"
    }, 
    "codecs.replace_errors": {
        "descr": "Implements the replace error handling: malformed data is replaced with a suitable replacement character such as '?' in bytestrings and '\\ufffd' in Unicode strings.", 
        "name": "codecs.replace_errors", 
        "params": [], 
        "path": "python/library/codecs#codecs.replace_errors", 
        "syntax": "codecs.replace_errors(exception)", 
        "type": "Binary Data"
    }, 
    "codecs.strict_errors": {
        "descr": "Implements the strict error handling: each encoding or decoding error raises a UnicodeError.", 
        "name": "codecs.strict_errors", 
        "params": [], 
        "path": "python/library/codecs#codecs.strict_errors", 
        "syntax": "codecs.strict_errors(exception)", 
        "type": "Binary Data"
    }, 
    "codecs.xmlcharrefreplace_errors": {
        "descr": "Implements the xmlcharrefreplace error handling (for encoding only): the unencodable character is replaced by an appropriate XML character reference.", 
        "name": "codecs.xmlcharrefreplace_errors", 
        "params": [], 
        "path": "python/library/codecs#codecs.xmlcharrefreplace_errors", 
        "syntax": "codecs.xmlcharrefreplace_errors(exception)", 
        "type": "Binary Data"
    }, 
    "codeop.CommandCompiler": {
        "descr": "Instances of this class have __call__() methods identical in signature to compile_command(); the difference is that if the instance compiles program text containing a __future__ statement, the instance \u2018remembers\u2019 and compiles all subsequent program texts with the statement in force.", 
        "name": "codeop.CommandCompiler", 
        "params": [], 
        "path": "python/library/codeop#codeop.CommandCompiler", 
        "syntax": "class codeop.CommandCompiler", 
        "type": "Interpreters"
    }, 
    "codeop.Compile": {
        "descr": "Instances of this class have __call__() methods identical in signature to the built-in function compile(), but with the difference that if the instance compiles program text containing a __future__ statement, the instance \u2018remembers\u2019 and compiles all subsequent program texts with the statement in force.", 
        "name": "codeop.Compile", 
        "params": [], 
        "path": "python/library/codeop#codeop.Compile", 
        "syntax": "class codeop.Compile", 
        "type": "Interpreters"
    }, 
    "codeop.compile_command": {
        "descr": "Tries to compile source, which should be a string of Python code and return a code object if source is valid Python code. In that case, the filename attribute of the code object will be filename, which defaults to '<input>'. Returns None if source is not valid Python code, but is a prefix of valid Python code.", 
        "name": "codeop.compile_command", 
        "params": [], 
        "path": "python/library/codeop#codeop.compile_command", 
        "syntax": "codeop.compile_command(source, filename=\"<input>\", symbol=\"single\")", 
        "type": "Interpreters"
    }, 
    "collections.ChainMap": {
        "descr": "A ChainMap groups multiple dicts or other mappings together to create a single, updateable view. If no maps are specified, a single empty dictionary is provided so that a new chain always has at least one mapping.", 
        "name": "collections.ChainMap", 
        "params": [], 
        "path": "python/library/collections#collections.ChainMap", 
        "syntax": "class collections.ChainMap(*maps)", 
        "type": "Data Types"
    }, 
    "collections.ChainMap.maps": {
        "descr": "A user updateable list of mappings. The list is ordered from first-searched to last-searched. It is the only stored state and can be modified to change which mappings are searched. The list should always contain at least one mapping.", 
        "name": "collections.ChainMap.maps", 
        "params": [], 
        "path": "python/library/collections#collections.ChainMap.maps", 
        "syntax": "maps", 
        "type": "Data Types"
    }, 
    "collections.ChainMap.new_child": {
        "descr": "Returns a new ChainMap containing a new dict followed by all of the maps in the current instance. A call to d.new_child() is equivalent to: ChainMap({}, *d.maps). This method is used for creating subcontexts that can be updated without altering values in any of the parent mappings.", 
        "name": "collections.ChainMap.new_child", 
        "params": [], 
        "path": "python/library/collections#collections.ChainMap.new_child", 
        "syntax": "new_child()", 
        "type": "Data Types"
    }, 
    "collections.ChainMap.parents": {
        "descr": "Property returning a new ChainMap containing all of the maps in the current instance except the first one. This is useful for skipping the first map in the search. Use cases are similar to those for the nonlocal keyword used in nested scopes. The use cases also parallel those for the built-in super() function. A reference to d.parents is equivalent to: ChainMap(*d.maps[1:]).", 
        "name": "collections.ChainMap.parents", 
        "params": [], 
        "path": "python/library/collections#collections.ChainMap.parents", 
        "syntax": "parents", 
        "type": "Data Types"
    }, 
    "collections.Counter": {
        "descr": "A Counter is a dict subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages.", 
        "name": "collections.Counter", 
        "params": [], 
        "path": "python/library/collections#collections.Counter", 
        "syntax": "class collections.Counter([iterable-or-mapping])", 
        "type": "Data Types"
    }, 
    "collections.Counter.elements": {
        "descr": "Return an iterator over elements repeating each as many times as its count. Elements are returned in arbitrary order. If an element\u2019s count is less than one, elements() will ignore it.", 
        "name": "collections.Counter.elements", 
        "params": [], 
        "path": "python/library/collections#collections.Counter.elements", 
        "syntax": "elements()", 
        "type": "Data Types"
    }, 
    "collections.Counter.fromkeys": {
        "descr": "This class method is not implemented for Counter objects.", 
        "name": "collections.Counter.fromkeys", 
        "params": [], 
        "path": "python/library/collections#collections.Counter.fromkeys", 
        "syntax": "fromkeys(iterable)", 
        "type": "Data Types"
    }, 
    "collections.Counter.most_common": {
        "descr": "Return a list of the n most common elements and their counts from the most common to the least. If n is not specified, most_common() returns all elements in the counter. Elements with equal counts are ordered arbitrarily:", 
        "name": "collections.Counter.most_common", 
        "params": [], 
        "path": "python/library/collections#collections.Counter.most_common", 
        "syntax": "most_common([n])", 
        "type": "Data Types"
    }, 
    "collections.Counter.subtract": {
        "descr": "Elements are subtracted from an iterable or from another mapping (or counter). Like dict.update() but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative.", 
        "name": "collections.Counter.subtract", 
        "params": [], 
        "path": "python/library/collections#collections.Counter.subtract", 
        "syntax": "subtract([iterable-or-mapping])", 
        "type": "Data Types"
    }, 
    "collections.Counter.update": {
        "descr": "Elements are counted from an iterable or added-in from another mapping (or counter). Like dict.update() but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of (key, value) pairs.", 
        "name": "collections.Counter.update", 
        "params": [], 
        "path": "python/library/collections#collections.Counter.update", 
        "syntax": "update([iterable-or-mapping])", 
        "type": "Data Types"
    }, 
    "collections.OrderedDict": {
        "descr": "Return an instance of a dict subclass, supporting the usual dict methods. An OrderedDict is a dict that remembers the order that keys were first inserted. If a new entry overwrites an existing entry, the original insertion position is left unchanged. Deleting an entry and reinserting it will move it to the end.", 
        "name": "collections.OrderedDict", 
        "params": [], 
        "path": "python/library/collections#collections.OrderedDict", 
        "syntax": "class collections.OrderedDict([items])", 
        "type": "Data Types"
    }, 
    "collections.OrderedDict.move_to_end": {
        "descr": "Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises KeyError if the key does not exist:", 
        "name": "collections.OrderedDict.move_to_end", 
        "params": [], 
        "path": "python/library/collections#collections.OrderedDict.move_to_end", 
        "syntax": "move_to_end(key, last=True)", 
        "type": "Data Types"
    }, 
    "collections.OrderedDict.popitem": {
        "descr": "The popitem() method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in LIFO order if last is true or FIFO order if false.", 
        "name": "collections.OrderedDict.popitem", 
        "params": [], 
        "path": "python/library/collections#collections.OrderedDict.popitem", 
        "syntax": "popitem(last=True)", 
        "type": "Data Types"
    }, 
    "collections.UserDict": {
        "descr": "Class that simulates a dictionary. The instance\u2019s contents are kept in a regular dictionary, which is accessible via the data attribute of UserDict instances. If initialdata is provided, data is initialized with its contents; note that a reference to initialdata will not be kept, allowing it be used for other purposes.", 
        "name": "collections.UserDict", 
        "params": [], 
        "path": "python/library/collections#collections.UserDict", 
        "syntax": "class collections.UserDict([initialdata])", 
        "type": "Data Types"
    }, 
    "collections.UserDict.data": {
        "descr": "A real dictionary used to store the contents of the UserDict class.", 
        "name": "collections.UserDict.data", 
        "params": [], 
        "path": "python/library/collections#collections.UserDict.data", 
        "syntax": "data", 
        "type": "Data Types"
    }, 
    "collections.UserList": {
        "descr": "Class that simulates a list. The instance\u2019s contents are kept in a regular list, which is accessible via the data attribute of UserList instances. The instance\u2019s contents are initially set to a copy of list, defaulting to the empty list []. list can be any iterable, for example a real Python list or a UserList object.", 
        "name": "collections.UserList", 
        "params": [], 
        "path": "python/library/collections#collections.UserList", 
        "syntax": "class collections.UserList([list])", 
        "type": "Data Types"
    }, 
    "collections.UserList.data": {
        "descr": "A real list object used to store the contents of the UserList class.", 
        "name": "collections.UserList.data", 
        "params": [], 
        "path": "python/library/collections#collections.UserList.data", 
        "syntax": "data", 
        "type": "Data Types"
    }, 
    "collections.UserString": {
        "descr": "Class that simulates a string or a Unicode string object. The instance\u2019s content is kept in a regular string object, which is accessible via the data attribute of UserString instances. The instance\u2019s contents are initially set to a copy of sequence. The sequence can be an instance of bytes, str, UserString (or a subclass) or an arbitrary sequence which can be converted into a string using the built-in str() function.", 
        "name": "collections.UserString", 
        "params": [], 
        "path": "python/library/collections#collections.UserString", 
        "syntax": "class collections.UserString([sequence])", 
        "type": "Data Types"
    }, 
    "collections.abc.Callable": {
        "descr": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", 
        "name": "collections.abc.Callable", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Callable", 
        "syntax": "class collections.abc.Callable", 
        "type": "Data Types"
    }, 
    "collections.abc.Container": {
        "descr": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", 
        "name": "collections.abc.Container", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Container", 
        "syntax": "class collections.abc.Container", 
        "type": "Data Types"
    }, 
    "collections.abc.Hashable": {
        "descr": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", 
        "name": "collections.abc.Hashable", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Hashable", 
        "syntax": "class collections.abc.Hashable", 
        "type": "Data Types"
    }, 
    "collections.abc.ItemsView": {
        "descr": "ABCs for mapping, items, keys, and values views.", 
        "name": "collections.abc.ItemsView", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.ItemsView", 
        "syntax": "class collections.abc.ItemsView", 
        "type": "Data Types"
    }, 
    "collections.abc.Iterable": {
        "descr": "ABC for classes that provide the __iter__() method. See also the definition of iterable.", 
        "name": "collections.abc.Iterable", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Iterable", 
        "syntax": "class collections.abc.Iterable", 
        "type": "Data Types"
    }, 
    "collections.abc.Iterator": {
        "descr": "ABC for classes that provide the __iter__() and __next__() methods. See also the definition of iterator.", 
        "name": "collections.abc.Iterator", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Iterator", 
        "syntax": "class collections.abc.Iterator", 
        "type": "Data Types"
    }, 
    "collections.abc.KeysView": {
        "descr": "ABCs for mapping, items, keys, and values views.", 
        "name": "collections.abc.KeysView", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.KeysView", 
        "syntax": "class collections.abc.KeysView", 
        "type": "Data Types"
    }, 
    "collections.abc.Mapping": {
        "descr": "ABCs for read-only and mutable mappings.", 
        "name": "collections.abc.Mapping", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Mapping", 
        "syntax": "class collections.abc.Mapping", 
        "type": "Data Types"
    }, 
    "collections.abc.MappingView": {
        "descr": "ABCs for mapping, items, keys, and values views.", 
        "name": "collections.abc.MappingView", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.MappingView", 
        "syntax": "class collections.abc.MappingView", 
        "type": "Data Types"
    }, 
    "collections.abc.MutableMapping": {
        "descr": "ABCs for read-only and mutable mappings.", 
        "name": "collections.abc.MutableMapping", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.MutableMapping", 
        "syntax": "class collections.abc.MutableMapping", 
        "type": "Data Types"
    }, 
    "collections.abc.MutableSequence": {
        "descr": "ABCs for read-only and mutable sequences.", 
        "name": "collections.abc.MutableSequence", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.MutableSequence", 
        "syntax": "class collections.abc.MutableSequence", 
        "type": "Data Types"
    }, 
    "collections.abc.MutableSet": {
        "descr": "ABCs for read-only and mutable sets.", 
        "name": "collections.abc.MutableSet", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.MutableSet", 
        "syntax": "class collections.abc.MutableSet", 
        "type": "Data Types"
    }, 
    "collections.abc.Sequence": {
        "descr": "ABCs for read-only and mutable sequences.", 
        "name": "collections.abc.Sequence", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Sequence", 
        "syntax": "class collections.abc.Sequence", 
        "type": "Data Types"
    }, 
    "collections.abc.Set": {
        "descr": "ABCs for read-only and mutable sets.", 
        "name": "collections.abc.Set", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Set", 
        "syntax": "class collections.abc.Set", 
        "type": "Data Types"
    }, 
    "collections.abc.Sized": {
        "descr": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", 
        "name": "collections.abc.Sized", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.Sized", 
        "syntax": "class collections.abc.Sized", 
        "type": "Data Types"
    }, 
    "collections.abc.ValuesView": {
        "descr": "ABCs for mapping, items, keys, and values views.", 
        "name": "collections.abc.ValuesView", 
        "params": [], 
        "path": "python/library/collections.abc#collections.abc.ValuesView", 
        "syntax": "class collections.abc.ValuesView", 
        "type": "Data Types"
    }, 
    "collections.defaultdict": {
        "descr": "Returns a new dictionary-like object. defaultdict is a subclass of the built-in dict class. It overrides one method and adds one writable instance variable. The remaining functionality is the same as for the dict class and is not documented here.", 
        "name": "collections.defaultdict", 
        "params": [], 
        "path": "python/library/collections#collections.defaultdict", 
        "syntax": "class collections.defaultdict([default_factory[, ...]])", 
        "type": "Data Types"
    }, 
    "collections.defaultdict.__missing__": {
        "descr": "If the default_factory attribute is None, this raises a KeyError exception with the key as argument.", 
        "name": "collections.defaultdict.__missing__", 
        "params": [], 
        "path": "python/library/collections#collections.defaultdict.__missing__", 
        "syntax": "__missing__(key)", 
        "type": "Data Types"
    }, 
    "collections.defaultdict.default_factory": {
        "descr": "This attribute is used by the __missing__() method; it is initialized from the first argument to the constructor, if present, or to None, if absent.", 
        "name": "collections.defaultdict.default_factory", 
        "params": [], 
        "path": "python/library/collections#collections.defaultdict.default_factory", 
        "syntax": "default_factory", 
        "type": "Data Types"
    }, 
    "collections.deque": {
        "descr": "Returns a new deque object initialized left-to-right (using append()) with data from iterable. If iterable is not specified, the new deque is empty.", 
        "name": "collections.deque", 
        "params": [], 
        "path": "python/library/collections#collections.deque", 
        "syntax": "class collections.deque([iterable[, maxlen]])", 
        "type": "Data Types"
    }, 
    "collections.deque.append": {
        "descr": "Add x to the right side of the deque.", 
        "name": "collections.deque.append", 
        "params": [], 
        "path": "python/library/collections#collections.deque.append", 
        "syntax": "append(x)", 
        "type": "Data Types"
    }, 
    "collections.deque.appendleft": {
        "descr": "Add x to the left side of the deque.", 
        "name": "collections.deque.appendleft", 
        "params": [], 
        "path": "python/library/collections#collections.deque.appendleft", 
        "syntax": "appendleft(x)", 
        "type": "Data Types"
    }, 
    "collections.deque.clear": {
        "descr": "Remove all elements from the deque leaving it with length 0.", 
        "name": "collections.deque.clear", 
        "params": [], 
        "path": "python/library/collections#collections.deque.clear", 
        "syntax": "clear()", 
        "type": "Data Types"
    }, 
    "collections.deque.count": {
        "descr": "Count the number of deque elements equal to x.", 
        "name": "collections.deque.count", 
        "params": [], 
        "path": "python/library/collections#collections.deque.count", 
        "syntax": "count(x)", 
        "type": "Data Types"
    }, 
    "collections.deque.extend": {
        "descr": "Extend the right side of the deque by appending elements from the iterable argument.", 
        "name": "collections.deque.extend", 
        "params": [], 
        "path": "python/library/collections#collections.deque.extend", 
        "syntax": "extend(iterable)", 
        "type": "Data Types"
    }, 
    "collections.deque.extendleft": {
        "descr": "Extend the left side of the deque by appending elements from iterable. Note, the series of left appends results in reversing the order of elements in the iterable argument.", 
        "name": "collections.deque.extendleft", 
        "params": [], 
        "path": "python/library/collections#collections.deque.extendleft", 
        "syntax": "extendleft(iterable)", 
        "type": "Data Types"
    }, 
    "collections.deque.maxlen": {
        "descr": "Maximum size of a deque or None if unbounded.", 
        "name": "collections.deque.maxlen", 
        "params": [], 
        "path": "python/library/collections#collections.deque.maxlen", 
        "syntax": "maxlen", 
        "type": "Data Types"
    }, 
    "collections.deque.pop": {
        "descr": "Remove and return an element from the right side of the deque. If no elements are present, raises an IndexError.", 
        "name": "collections.deque.pop", 
        "params": [], 
        "path": "python/library/collections#collections.deque.pop", 
        "syntax": "pop()", 
        "type": "Data Types"
    }, 
    "collections.deque.popleft": {
        "descr": "Remove and return an element from the left side of the deque. If no elements are present, raises an IndexError.", 
        "name": "collections.deque.popleft", 
        "params": [], 
        "path": "python/library/collections#collections.deque.popleft", 
        "syntax": "popleft()", 
        "type": "Data Types"
    }, 
    "collections.deque.remove": {
        "descr": "Removed the first occurrence of value. If not found, raises a ValueError.", 
        "name": "collections.deque.remove", 
        "params": [], 
        "path": "python/library/collections#collections.deque.remove", 
        "syntax": "remove(value)", 
        "type": "Data Types"
    }, 
    "collections.deque.reverse": {
        "descr": "Reverse the elements of the deque in-place and then return None.", 
        "name": "collections.deque.reverse", 
        "params": [], 
        "path": "python/library/collections#collections.deque.reverse", 
        "syntax": "reverse()", 
        "type": "Data Types"
    }, 
    "collections.deque.rotate": {
        "descr": "Rotate the deque n steps to the right. If n is negative, rotate to the left. Rotating one step to the right is equivalent to: d.appendleft(d.pop()).", 
        "name": "collections.deque.rotate", 
        "params": [], 
        "path": "python/library/collections#collections.deque.rotate", 
        "syntax": "rotate(n)", 
        "type": "Data Types"
    }, 
    "collections.namedtuple": {
        "descr": "Returns a new tuple subclass named typename. The new subclass is used to create tuple-like objects that have fields accessible by attribute lookup as well as being indexable and iterable. Instances of the subclass also have a helpful docstring (with typename and field_names) and a helpful __repr__() method which lists the tuple contents in a name=value format.", 
        "name": "collections.namedtuple", 
        "params": [], 
        "path": "python/library/collections#collections.namedtuple", 
        "syntax": "collections.namedtuple(typename, field_names, verbose=False, rename=False)", 
        "type": "Data Types"
    }, 
    "collections.somenamedtuple._asdict": {
        "descr": "Return a new OrderedDict which maps field names to their corresponding values. Note, this method is no longer needed now that the same effect can be achieved by using the built-in vars() function:", 
        "name": "collections.somenamedtuple._asdict", 
        "params": [], 
        "path": "python/library/collections#collections.somenamedtuple._asdict", 
        "syntax": "somenamedtuple._asdict()", 
        "type": "Data Types"
    }, 
    "collections.somenamedtuple._fields": {
        "descr": "Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples.", 
        "name": "collections.somenamedtuple._fields", 
        "params": [], 
        "path": "python/library/collections#collections.somenamedtuple._fields", 
        "syntax": "somenamedtuple._fields", 
        "type": "Data Types"
    }, 
    "collections.somenamedtuple._make": {
        "descr": "Class method that makes a new instance from an existing sequence or iterable.", 
        "name": "collections.somenamedtuple._make", 
        "params": [], 
        "path": "python/library/collections#collections.somenamedtuple._make", 
        "syntax": "classmethod somenamedtuple._make(iterable)", 
        "type": "Data Types"
    }, 
    "collections.somenamedtuple._replace": {
        "descr": "Return a new instance of the named tuple replacing specified fields with new values:", 
        "name": "collections.somenamedtuple._replace", 
        "params": [], 
        "path": "python/library/collections#collections.somenamedtuple._replace", 
        "syntax": "somenamedtuple._replace(kwargs)", 
        "type": "Data Types"
    }, 
    "collections.somenamedtuple._source": {
        "descr": "A string with the pure Python source code used to create the named tuple class. The source makes the named tuple self-documenting. It can be printed, executed using exec(), or saved to a file and imported.", 
        "name": "collections.somenamedtuple._source", 
        "params": [], 
        "path": "python/library/collections#collections.somenamedtuple._source", 
        "syntax": "somenamedtuple._source", 
        "type": "Data Types"
    }, 
    "colorsys.hls_to_rgb": {
        "descr": "Convert the color from HLS coordinates to RGB coordinates.", 
        "name": "colorsys.hls_to_rgb", 
        "params": [], 
        "path": "python/library/colorsys#colorsys.hls_to_rgb", 
        "syntax": "colorsys.hls_to_rgb(h, l, s)", 
        "type": "Multimedia"
    }, 
    "colorsys.hsv_to_rgb": {
        "descr": "Convert the color from HSV coordinates to RGB coordinates.", 
        "name": "colorsys.hsv_to_rgb", 
        "params": [], 
        "path": "python/library/colorsys#colorsys.hsv_to_rgb", 
        "syntax": "colorsys.hsv_to_rgb(h, s, v)", 
        "type": "Multimedia"
    }, 
    "colorsys.rgb_to_hls": {
        "descr": "Convert the color from RGB coordinates to HLS coordinates.", 
        "name": "colorsys.rgb_to_hls", 
        "params": [], 
        "path": "python/library/colorsys#colorsys.rgb_to_hls", 
        "syntax": "colorsys.rgb_to_hls(r, g, b)", 
        "type": "Multimedia"
    }, 
    "colorsys.rgb_to_hsv": {
        "descr": "Convert the color from RGB coordinates to HSV coordinates.", 
        "name": "colorsys.rgb_to_hsv", 
        "params": [], 
        "path": "python/library/colorsys#colorsys.rgb_to_hsv", 
        "syntax": "colorsys.rgb_to_hsv(r, g, b)", 
        "type": "Multimedia"
    }, 
    "colorsys.rgb_to_yiq": {
        "descr": "Convert the color from RGB coordinates to YIQ coordinates.", 
        "name": "colorsys.rgb_to_yiq", 
        "params": [], 
        "path": "python/library/colorsys#colorsys.rgb_to_yiq", 
        "syntax": "colorsys.rgb_to_yiq(r, g, b)", 
        "type": "Multimedia"
    }, 
    "colorsys.yiq_to_rgb": {
        "descr": "Convert the color from YIQ coordinates to RGB coordinates.", 
        "name": "colorsys.yiq_to_rgb", 
        "params": [], 
        "path": "python/library/colorsys#colorsys.yiq_to_rgb", 
        "syntax": "colorsys.yiq_to_rgb(y, i, q)", 
        "type": "Multimedia"
    }, 
    "compile": {
        "descr": "Compile the source into a code or AST object. Code objects can be executed by exec() or eval(). source can either be a normal string, a byte string, or an AST object. Refer to the ast module documentation for information on how to work with AST objects.", 
        "name": "compile", 
        "params": [], 
        "path": "python/library/functions#compile", 
        "syntax": "compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)", 
        "type": "Built-in Functions"
    }, 
    "complex": {
        "descr": "Create a complex number with the value real + imag*j or convert a string or number to a complex number. If the first parameter is a string, it will be interpreted as a complex number and the function must be called without a second parameter. The second parameter can never be a string. Each argument may be any numeric type (including complex). If imag is omitted, it defaults to zero and the function serves as a numeric conversion function like int() and float(). If both arguments are omitted, returns 0j.", 
        "name": "complex", 
        "params": [], 
        "path": "python/library/functions#complex", 
        "syntax": "complex([real[, imag]])", 
        "type": "Built-in Functions"
    }, 
    "concurrent.futures.BrokenProcessPool": {
        "descr": "Derived from RuntimeError, this exception class is raised when one of the workers of a ProcessPoolExecutor has terminated in a non-clean fashion (for example, if it was killed from the outside).", 
        "name": "concurrent.futures.BrokenProcessPool", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.BrokenProcessPool", 
        "syntax": "exception concurrent.futures.BrokenProcessPool", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Executor": {
        "descr": "An abstract class that provides methods to execute calls asynchronously. It should not be used directly, but through its concrete subclasses.", 
        "name": "concurrent.futures.Executor", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Executor", 
        "syntax": "class concurrent.futures.Executor", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Executor.map": {
        "descr": "Equivalent to map(func, *iterables) except func is executed asynchronously and several calls to func may be made concurrently. The returned iterator raises a TimeoutError if __next__() is called and the result isn\u2019t available after timeout seconds from the original call to Executor.map(). timeout can be an int or a float. If timeout is not specified or None, there is no limit to the wait time. If a call raises an exception, then that exception will be raised when its value is retrieved from the iterator.", 
        "name": "concurrent.futures.Executor.map", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Executor.map", 
        "syntax": "map(func, *iterables, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Executor.shutdown": {
        "descr": "Signal the executor that it should free any resources that it is using when the currently pending futures are done executing. Calls to Executor.submit() and Executor.map() made after shutdown will raise RuntimeError.", 
        "name": "concurrent.futures.Executor.shutdown", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Executor.shutdown", 
        "syntax": "shutdown(wait=True)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Executor.submit": {
        "descr": "Schedules the callable, fn, to be executed as fn(*args **kwargs) and returns a Future object representing the execution of the callable.", 
        "name": "concurrent.futures.Executor.submit", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Executor.submit", 
        "syntax": "submit(fn, *args, **kwargs)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future": {
        "descr": "Encapsulates the asynchronous execution of a callable. Future instances are created by Executor.submit() and should not be created directly except for testing.", 
        "name": "concurrent.futures.Future", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future", 
        "syntax": "class concurrent.futures.Future", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.add_done_callback": {
        "descr": "Attaches the callable fn to the future. fn will be called, with the future as its only argument, when the future is cancelled or finishes running.", 
        "name": "concurrent.futures.Future.add_done_callback", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.add_done_callback", 
        "syntax": "add_done_callback(fn)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.cancel": {
        "descr": "Attempt to cancel the call. If the call is currently being executed and cannot be cancelled then the method will return False, otherwise the call will be cancelled and the method will return True.", 
        "name": "concurrent.futures.Future.cancel", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.cancel", 
        "syntax": "cancel()", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.cancelled": {
        "descr": "Return True if the call was successfully cancelled.", 
        "name": "concurrent.futures.Future.cancelled", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.cancelled", 
        "syntax": "cancelled()", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.done": {
        "descr": "Return True if the call was successfully cancelled or finished running.", 
        "name": "concurrent.futures.Future.done", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.done", 
        "syntax": "done()", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.exception": {
        "descr": "Return the exception raised by the call. If the call hasn\u2019t yet completed then this method will wait up to timeout seconds. If the call hasn\u2019t completed in timeout seconds, then a TimeoutError will be raised. timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.", 
        "name": "concurrent.futures.Future.exception", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.exception", 
        "syntax": "exception(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.result": {
        "descr": "Return the value returned by the call. If the call hasn\u2019t yet completed then this method will wait up to timeout seconds. If the call hasn\u2019t completed in timeout seconds, then a TimeoutError will be raised. timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.", 
        "name": "concurrent.futures.Future.result", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.result", 
        "syntax": "result(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.running": {
        "descr": "Return True if the call is currently being executed and cannot be cancelled.", 
        "name": "concurrent.futures.Future.running", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.running", 
        "syntax": "running()", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.set_exception": {
        "descr": "Sets the result of the work associated with the Future to the Exception exception.", 
        "name": "concurrent.futures.Future.set_exception", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.set_exception", 
        "syntax": "set_exception(exception)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.set_result": {
        "descr": "Sets the result of the work associated with the Future to result.", 
        "name": "concurrent.futures.Future.set_result", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.set_result", 
        "syntax": "set_result(result)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.Future.set_running_or_notify_cancel": {
        "descr": "This method should only be called by Executor implementations before executing the work associated with the Future and by unit tests.", 
        "name": "concurrent.futures.Future.set_running_or_notify_cancel", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.Future.set_running_or_notify_cancel", 
        "syntax": "set_running_or_notify_cancel()", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.ProcessPoolExecutor": {
        "descr": "An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers is None or not given, it will default to the number of processors on the machine.", 
        "name": "concurrent.futures.ProcessPoolExecutor", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.ProcessPoolExecutor", 
        "syntax": "class concurrent.futures.ProcessPoolExecutor(max_workers=None)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.ThreadPoolExecutor": {
        "descr": "An Executor subclass that uses a pool of at most max_workers threads to execute calls asynchronously.", 
        "name": "concurrent.futures.ThreadPoolExecutor", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.ThreadPoolExecutor", 
        "syntax": "class concurrent.futures.ThreadPoolExecutor(max_workers)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.as_completed": {
        "descr": "Returns an iterator over the Future instances (possibly created by different Executor instances) given by fs that yields futures as they complete (finished or were cancelled). Any futures given by fs that are duplicated will be returned once. Any futures that completed before as_completed() is called will be yielded first. The returned iterator raises a TimeoutError if __next__() is called and the result isn\u2019t available after timeout seconds from the original call to as_completed(). timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.", 
        "name": "concurrent.futures.as_completed", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.as_completed", 
        "syntax": "concurrent.futures.as_completed(fs, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "concurrent.futures.wait": {
        "descr": "Wait for the Future instances (possibly created by different Executor instances) given by fs to complete. Returns a named 2-tuple of sets. The first set, named done, contains the futures that completed (finished or were cancelled) before the wait completed. The second set, named not_done, contains uncompleted futures.", 
        "name": "concurrent.futures.wait", 
        "params": [], 
        "path": "python/library/concurrent.futures#concurrent.futures.wait", 
        "syntax": "concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)", 
        "type": "Concurrent Execution"
    }, 
    "configparser.BOOLEAN_STATES": {
        "descr": "By default when using getboolean(), config parsers consider the following values True: '1', 'yes', 'true', 'on' and the following values False: '0', 'no', 'false', 'off'. You can override this by specifying a custom dictionary of strings and their Boolean outcomes. For example:", 
        "name": "configparser.BOOLEAN_STATES", 
        "params": [], 
        "path": "python/library/configparser#configparser.BOOLEAN_STATES", 
        "syntax": "configparser.BOOLEAN_STATES", 
        "type": "File Formats"
    }, 
    "configparser.BasicInterpolation": {
        "descr": "The default implementation used by ConfigParser. It enables values to contain format strings which refer to other values in the same section, or values in the special default section [1]. Additional default values can be provided on initialization.", 
        "name": "configparser.BasicInterpolation", 
        "params": [], 
        "path": "python/library/configparser#configparser.BasicInterpolation", 
        "syntax": "class configparser.BasicInterpolation", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser": {
        "descr": "The main configuration parser. When defaults is given, it is initialized into the dictionary of intrinsic defaults. When dict_type is given, it will be used to create the dictionary objects for the list of sections, for the options within a section, and for the default values.", 
        "name": "configparser.ConfigParser", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser", 
        "syntax": "class configparser.ConfigParser(defaults=None, dict_type=collections.OrderedDict, allow_no_value=False, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT, interpolation=BasicInterpolation())", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.add_section": {
        "descr": "Add a section named section to the instance. If a section by the given name already exists, DuplicateSectionError is raised. If the default section name is passed, ValueError is raised. The name of the section must be a string; if not, TypeError is raised.", 
        "name": "configparser.ConfigParser.add_section", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.add_section", 
        "syntax": "add_section(section)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.defaults": {
        "descr": "Return a dictionary containing the instance-wide defaults.", 
        "name": "configparser.ConfigParser.defaults", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.defaults", 
        "syntax": "defaults()", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.get": {
        "descr": "Get an option value for the named section. If vars is provided, it must be a dictionary. The option is looked up in vars (if provided), section, and in DEFAULTSECT in that order. If the key is not found and fallback is provided, it is used as a fallback value. None can be provided as a fallback value.", 
        "name": "configparser.ConfigParser.get", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.get", 
        "syntax": "get(section, option, *, raw=False, vars=None[, fallback])", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.getboolean": {
        "descr": "A convenience method which coerces the option in the specified section to a Boolean value. Note that the accepted values for the option are '1', 'yes', 'true', and 'on', which cause this method to return True, and '0', 'no', 'false', and 'off', which cause it to return False. These string values are checked in a case-insensitive manner. Any other value will cause it to raise ValueError. See get() for explanation of raw, vars and fallback.", 
        "name": "configparser.ConfigParser.getboolean", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.getboolean", 
        "syntax": "getboolean(section, option, *, raw=False, vars=None[, fallback])", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.getfloat": {
        "descr": "A convenience method which coerces the option in the specified section to a floating point number. See get() for explanation of raw, vars and fallback.", 
        "name": "configparser.ConfigParser.getfloat", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.getfloat", 
        "syntax": "getfloat(section, option, *, raw=False, vars=None[, fallback])", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.getint": {
        "descr": "A convenience method which coerces the option in the specified section to an integer. See get() for explanation of raw, vars and fallback.", 
        "name": "configparser.ConfigParser.getint", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.getint", 
        "syntax": "getint(section, option, *, raw=False, vars=None[, fallback])", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.has_option": {
        "descr": "If the given section exists, and contains the given option, return True; otherwise return False. If the specified section is None or an empty string, DEFAULT is assumed.", 
        "name": "configparser.ConfigParser.has_option", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.has_option", 
        "syntax": "has_option(section, option)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.has_section": {
        "descr": "Indicates whether the named section is present in the configuration. The default section is not acknowledged.", 
        "name": "configparser.ConfigParser.has_section", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.has_section", 
        "syntax": "has_section(section)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.items": {
        "descr": "When section is not given, return a list of section_name, section_proxy pairs, including DEFAULTSECT.", 
        "name": "configparser.ConfigParser.items", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.items", 
        "syntax": "items(raw=False, vars=None)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.options": {
        "descr": "Return a list of options available in the specified section.", 
        "name": "configparser.ConfigParser.options", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.options", 
        "syntax": "options(section)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.optionxform": {
        "descr": "Transforms the option name option as found in an input file or as passed in by client code to the form that should be used in the internal structures. The default implementation returns a lower-case version of option; subclasses may override this or client code can set an attribute of this name on instances to affect this behavior.", 
        "name": "configparser.ConfigParser.optionxform", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.optionxform", 
        "syntax": "optionxform(option)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.read": {
        "descr": "Attempt to read and parse a list of filenames, returning a list of filenames which were successfully parsed. If filenames is a string, it is treated as a single filename. If a file named in filenames cannot be opened, that file will be ignored. This is designed so that you can specify a list of potential configuration file locations (for example, the current directory, the user\u2019s home directory, and some system-wide directory), and all existing configuration files in the list will be read. If none of the named files exist, the ConfigParser instance will contain an empty dataset. An application which requires initial values to be loaded from a file should load the required file or files using read_file() before calling read() for any optional files:", 
        "name": "configparser.ConfigParser.read", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.read", 
        "syntax": "read(filenames, encoding=None)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.read_dict": {
        "descr": "Load configuration from any object that provides a dict-like items() method. Keys are section names, values are dictionaries with keys and values that should be present in the section. If the used dictionary type preserves order, sections and their keys will be added in order. Values are automatically converted to strings.", 
        "name": "configparser.ConfigParser.read_dict", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.read_dict", 
        "syntax": "read_dict(dictionary, source='<dict>')", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.read_file": {
        "descr": "Read and parse configuration data from f which must be an iterable yielding Unicode strings (for example files opened in text mode).", 
        "name": "configparser.ConfigParser.read_file", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.read_file", 
        "syntax": "read_file(f, source=None)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.read_string": {
        "descr": "Parse configuration data from a string.", 
        "name": "configparser.ConfigParser.read_string", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.read_string", 
        "syntax": "read_string(string, source='<string>')", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.readfp": {
        "descr": "Deprecated since version 3.2: Use read_file() instead.", 
        "name": "configparser.ConfigParser.readfp", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.readfp", 
        "syntax": "readfp(fp, filename=None)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.remove_option": {
        "descr": "Remove the specified option from the specified section. If the section does not exist, raise NoSectionError. If the option existed to be removed, return True; otherwise return False.", 
        "name": "configparser.ConfigParser.remove_option", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.remove_option", 
        "syntax": "remove_option(section, option)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.remove_section": {
        "descr": "Remove the specified section from the configuration. If the section in fact existed, return True. Otherwise return False.", 
        "name": "configparser.ConfigParser.remove_section", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.remove_section", 
        "syntax": "remove_section(section)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.sections": {
        "descr": "Return a list of the sections available; the default section is not included in the list.", 
        "name": "configparser.ConfigParser.sections", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.sections", 
        "syntax": "sections()", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.set": {
        "descr": "If the given section exists, set the given option to the specified value; otherwise raise NoSectionError. option and value must be strings; if not, TypeError is raised.", 
        "name": "configparser.ConfigParser.set", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.set", 
        "syntax": "set(section, option, value)", 
        "type": "File Formats"
    }, 
    "configparser.ConfigParser.write": {
        "descr": "Write a representation of the configuration to the specified file object, which must be opened in text mode (accepting strings). This representation can be parsed by a future read() call. If space_around_delimiters is true, delimiters between keys and values are surrounded by spaces.", 
        "name": "configparser.ConfigParser.write", 
        "params": [], 
        "path": "python/library/configparser#configparser.ConfigParser.write", 
        "syntax": "write(fileobject, space_around_delimiters=True)", 
        "type": "File Formats"
    }, 
    "configparser.DuplicateOptionError": {
        "descr": "Exception raised by strict parsers if a single option appears twice during reading from a single file, string or dictionary. This catches misspellings and case sensitivity-related errors, e.g. a dictionary may have two keys representing the same case-insensitive configuration key.", 
        "name": "configparser.DuplicateOptionError", 
        "params": [], 
        "path": "python/library/configparser#configparser.DuplicateOptionError", 
        "syntax": "exception configparser.DuplicateOptionError", 
        "type": "File Formats"
    }, 
    "configparser.DuplicateSectionError": {
        "descr": "Exception raised if add_section() is called with the name of a section that is already present or in strict parsers when a section if found more than once in a single input file, string or dictionary.", 
        "name": "configparser.DuplicateSectionError", 
        "params": [], 
        "path": "python/library/configparser#configparser.DuplicateSectionError", 
        "syntax": "exception configparser.DuplicateSectionError", 
        "type": "File Formats"
    }, 
    "configparser.Error": {
        "descr": "Base class for all other configparser exceptions.", 
        "name": "configparser.Error", 
        "params": [], 
        "path": "python/library/configparser#configparser.Error", 
        "syntax": "exception configparser.Error", 
        "type": "File Formats"
    }, 
    "configparser.ExtendedInterpolation": {
        "descr": "An alternative handler for interpolation which implements a more advanced syntax, used for instance in zc.buildout. Extended interpolation is using ${section:option} to denote a value from a foreign section. Interpolation can span multiple levels. For convenience, if the section: part is omitted, interpolation defaults to the current section (and possibly the default values from the special section).", 
        "name": "configparser.ExtendedInterpolation", 
        "params": [], 
        "path": "python/library/configparser#configparser.ExtendedInterpolation", 
        "syntax": "class configparser.ExtendedInterpolation", 
        "type": "File Formats"
    }, 
    "configparser.InterpolationDepthError": {
        "descr": "Exception raised when string interpolation cannot be completed because the number of iterations exceeds MAX_INTERPOLATION_DEPTH. Subclass of InterpolationError.", 
        "name": "configparser.InterpolationDepthError", 
        "params": [], 
        "path": "python/library/configparser#configparser.InterpolationDepthError", 
        "syntax": "exception configparser.InterpolationDepthError", 
        "type": "File Formats"
    }, 
    "configparser.InterpolationError": {
        "descr": "Base class for exceptions raised when problems occur performing string interpolation.", 
        "name": "configparser.InterpolationError", 
        "params": [], 
        "path": "python/library/configparser#configparser.InterpolationError", 
        "syntax": "exception configparser.InterpolationError", 
        "type": "File Formats"
    }, 
    "configparser.InterpolationMissingOptionError": {
        "descr": "Exception raised when an option referenced from a value does not exist. Subclass of InterpolationError.", 
        "name": "configparser.InterpolationMissingOptionError", 
        "params": [], 
        "path": "python/library/configparser#configparser.InterpolationMissingOptionError", 
        "syntax": "exception configparser.InterpolationMissingOptionError", 
        "type": "File Formats"
    }, 
    "configparser.InterpolationSyntaxError": {
        "descr": "Exception raised when the source text into which substitutions are made does not conform to the required syntax. Subclass of InterpolationError.", 
        "name": "configparser.InterpolationSyntaxError", 
        "params": [], 
        "path": "python/library/configparser#configparser.InterpolationSyntaxError", 
        "syntax": "exception configparser.InterpolationSyntaxError", 
        "type": "File Formats"
    }, 
    "configparser.MissingSectionHeaderError": {
        "descr": "Exception raised when attempting to parse a file which has no section headers.", 
        "name": "configparser.MissingSectionHeaderError", 
        "params": [], 
        "path": "python/library/configparser#configparser.MissingSectionHeaderError", 
        "syntax": "exception configparser.MissingSectionHeaderError", 
        "type": "File Formats"
    }, 
    "configparser.NoOptionError": {
        "descr": "Exception raised when a specified option is not found in the specified section.", 
        "name": "configparser.NoOptionError", 
        "params": [], 
        "path": "python/library/configparser#configparser.NoOptionError", 
        "syntax": "exception configparser.NoOptionError", 
        "type": "File Formats"
    }, 
    "configparser.NoSectionError": {
        "descr": "Exception raised when a specified section is not found.", 
        "name": "configparser.NoSectionError", 
        "params": [], 
        "path": "python/library/configparser#configparser.NoSectionError", 
        "syntax": "exception configparser.NoSectionError", 
        "type": "File Formats"
    }, 
    "configparser.ParsingError": {
        "descr": "Exception raised when errors occur attempting to parse a file.", 
        "name": "configparser.ParsingError", 
        "params": [], 
        "path": "python/library/configparser#configparser.ParsingError", 
        "syntax": "exception configparser.ParsingError", 
        "type": "File Formats"
    }, 
    "configparser.RawConfigParser": {
        "descr": "Legacy variant of the ConfigParser with interpolation disabled by default and unsafe add_section and set methods.", 
        "name": "configparser.RawConfigParser", 
        "params": [], 
        "path": "python/library/configparser#configparser.RawConfigParser", 
        "syntax": "class configparser.RawConfigParser(defaults=None, dict_type=collections.OrderedDict, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT[, interpolation])", 
        "type": "File Formats"
    }, 
    "configparser.RawConfigParser.add_section": {
        "descr": "Add a section named section to the instance. If a section by the given name already exists, DuplicateSectionError is raised. If the default section name is passed, ValueError is raised.", 
        "name": "configparser.RawConfigParser.add_section", 
        "params": [], 
        "path": "python/library/configparser#configparser.RawConfigParser.add_section", 
        "syntax": "add_section(section)", 
        "type": "File Formats"
    }, 
    "configparser.RawConfigParser.set": {
        "descr": "If the given section exists, set the given option to the specified value; otherwise raise NoSectionError. While it is possible to use RawConfigParser (or ConfigParser with raw parameters set to true) for internal storage of non-string values, full functionality (including interpolation and output to files) can only be achieved using string values.", 
        "name": "configparser.RawConfigParser.set", 
        "params": [], 
        "path": "python/library/configparser#configparser.RawConfigParser.set", 
        "syntax": "set(section, option, value)", 
        "type": "File Formats"
    }, 
    "configparser.SECTCRE": {
        "descr": "A compiled regular expression used to parse section headers. The default matches [section] to the name \"section\". Whitespace is considered part of the section name, thus [ larch ] will be read as a section of name \" larch \". Override this attribute if that\u2019s unsuitable. For example:", 
        "name": "configparser.SECTCRE", 
        "params": [], 
        "path": "python/library/configparser#configparser.SECTCRE", 
        "syntax": "configparser.SECTCRE", 
        "type": "File Formats"
    }, 
    "configparser.optionxform": {
        "descr": "This method transforms option names on every read, get, or set operation. The default converts the name to lowercase. This also means that when a configuration file gets written, all keys will be lowercase. Override this method if that\u2019s unsuitable. For example:", 
        "name": "configparser.optionxform", 
        "params": [], 
        "path": "python/library/configparser#configparser.optionxform", 
        "syntax": "configparser.optionxform(option)", 
        "type": "File Formats"
    }, 
    "container.__iter__": {
        "descr": "Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example of an object supporting multiple forms of iteration would be a tree structure which supports both breadth-first and depth-first traversal.) This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API.", 
        "name": "container.__iter__", 
        "params": [], 
        "path": "python/library/stdtypes#container.__iter__", 
        "syntax": "container.__iter__()", 
        "type": "Built-in Types"
    }, 
    "contextlib.ContextDecorator": {
        "descr": "A base class that enables a context manager to also be used as a decorator.", 
        "name": "contextlib.ContextDecorator", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ContextDecorator", 
        "syntax": "class contextlib.ContextDecorator", 
        "type": "Runtime"
    }, 
    "contextlib.ExitStack": {
        "descr": "A context manager that is designed to make it easy to programmatically combine other context managers and cleanup functions, especially those that are optional or otherwise driven by input data.", 
        "name": "contextlib.ExitStack", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ExitStack", 
        "syntax": "class contextlib.ExitStack", 
        "type": "Runtime"
    }, 
    "contextlib.ExitStack.callback": {
        "descr": "Accepts an arbitrary callback function and arguments and adds it to the callback stack.", 
        "name": "contextlib.ExitStack.callback", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ExitStack.callback", 
        "syntax": "callback(callback, *args, **kwds)", 
        "type": "Runtime"
    }, 
    "contextlib.ExitStack.close": {
        "descr": "Immediately unwinds the callback stack, invoking callbacks in the reverse order of registration. For any context managers and exit callbacks registered, the arguments passed in will indicate that no exception occurred.", 
        "name": "contextlib.ExitStack.close", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ExitStack.close", 
        "syntax": "close()", 
        "type": "Runtime"
    }, 
    "contextlib.ExitStack.enter_context": {
        "descr": "Enters a new context manager and adds its __exit__() method to the callback stack. The return value is the result of the context manager\u2019s own __enter__() method.", 
        "name": "contextlib.ExitStack.enter_context", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ExitStack.enter_context", 
        "syntax": "enter_context(cm)", 
        "type": "Runtime"
    }, 
    "contextlib.ExitStack.pop_all": {
        "descr": "Transfers the callback stack to a fresh ExitStack instance and returns it. No callbacks are invoked by this operation - instead, they will now be invoked when the new stack is closed (either explicitly or implicitly at the end of a with statement).", 
        "name": "contextlib.ExitStack.pop_all", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ExitStack.pop_all", 
        "syntax": "pop_all()", 
        "type": "Runtime"
    }, 
    "contextlib.ExitStack.push": {
        "descr": "Adds a context manager\u2019s __exit__() method to the callback stack.", 
        "name": "contextlib.ExitStack.push", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.ExitStack.push", 
        "syntax": "push(exit)", 
        "type": "Runtime"
    }, 
    "contextlib.closing": {
        "descr": "Return a context manager that closes thing upon completion of the block. This is basically equivalent to:", 
        "name": "contextlib.closing", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.closing", 
        "syntax": "contextlib.closing(thing)", 
        "type": "Runtime"
    }, 
    "contextlib.contextmanager": {
        "descr": "This function is a decorator that can be used to define a factory function for with statement context managers, without needing to create a class or separate __enter__() and __exit__() methods.", 
        "name": "contextlib.contextmanager", 
        "params": [], 
        "path": "python/library/contextlib#contextlib.contextmanager", 
        "syntax": "@contextlib.contextmanager", 
        "type": "Runtime"
    }, 
    "contextmanager.__enter__": {
        "descr": "Enter the runtime context and return either this object or another object related to the runtime context. The value returned by this method is bound to the identifier in the as clause of with statements using this context manager.", 
        "name": "contextmanager.__enter__", 
        "params": [], 
        "path": "python/library/stdtypes#contextmanager.__enter__", 
        "syntax": "contextmanager.__enter__()", 
        "type": "Built-in Types"
    }, 
    "contextmanager.__exit__": {
        "descr": "Exit the runtime context and return a Boolean flag indicating if any exception that occurred should be suppressed. If an exception occurred while executing the body of the with statement, the arguments contain the exception type, value and traceback information. Otherwise, all three arguments are None.", 
        "name": "contextmanager.__exit__", 
        "params": [], 
        "path": "python/library/stdtypes#contextmanager.__exit__", 
        "syntax": "contextmanager.__exit__(exc_type, exc_val, exc_tb)", 
        "type": "Built-in Types"
    }, 
    "copy": {
        "descr": "Return a shallow copy of the dictionary.", 
        "name": "dict.copy", 
        "params": [], 
        "path": "python/library/stdtypes#dict.copy", 
        "syntax": "copy()", 
        "type": "Built-in Types"
    }, 
    "copy.copy": {
        "descr": "Return a shallow copy of x.", 
        "name": "copy.copy", 
        "params": [], 
        "path": "python/library/copy#copy.copy", 
        "syntax": "copy.copy(x)", 
        "type": "Data Types"
    }, 
    "copy.deepcopy": {
        "descr": "Return a deep copy of x.", 
        "name": "copy.deepcopy", 
        "params": [], 
        "path": "python/library/copy#copy.deepcopy", 
        "syntax": "copy.deepcopy(x)", 
        "type": "Data Types"
    }, 
    "copy.error": {
        "descr": "Raised for module specific errors.", 
        "name": "copy.error", 
        "params": [], 
        "path": "python/library/copy#copy.error", 
        "syntax": "exception copy.error", 
        "type": "Data Types"
    }, 
    "copyreg.constructor": {
        "descr": "Declares object to be a valid constructor. If object is not callable (and hence not valid as a constructor), raises TypeError.", 
        "name": "copyreg.constructor", 
        "params": [], 
        "path": "python/library/copyreg#copyreg.constructor", 
        "syntax": "copyreg.constructor(object)", 
        "type": "Data Persistence"
    }, 
    "copyreg.pickle": {
        "descr": "Declares that function should be used as a \u201creduction\u201d function for objects of type type. function should return either a string or a tuple containing two or three elements.", 
        "name": "copyreg.pickle", 
        "params": [], 
        "path": "python/library/copyreg#copyreg.pickle", 
        "syntax": "copyreg.pickle(type, function, constructor=None)", 
        "type": "Data Persistence"
    }, 
    "copyright": {
        "descr": "Objects that when printed, print a message like \u201cType license() to see the full license text\u201d, and when called, display the corresponding text in a pager-like fashion (one screen at a time).", 
        "name": "copyright", 
        "params": [], 
        "path": "python/library/constants#copyright", 
        "syntax": "copyright", 
        "type": "Built-in Constants"
    }, 
    "count": {
        "descr": "Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", 
        "name": "str.count", 
        "params": [], 
        "path": "python/library/stdtypes#str.count", 
        "syntax": "str.count(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "credits": {
        "descr": "Objects that when printed, print a message like \u201cType license() to see the full license text\u201d, and when called, display the corresponding text in a pager-like fashion (one screen at a time).", 
        "name": "credits", 
        "params": [], 
        "path": "python/library/constants#credits", 
        "syntax": "credits", 
        "type": "Built-in Constants"
    }, 
    "crypt.crypt": {
        "descr": "word will usually be a user\u2019s password as typed at a prompt or in a graphical interface. The optional salt is either a string as returned from mksalt(), one of the crypt.METHOD_* values (though not all may be available on all platforms), or a full encrypted password including salt, as returned by this function. If salt is not provided, the strongest method will be used (as returned by methods().", 
        "name": "crypt.crypt", 
        "params": [], 
        "path": "python/library/crypt#crypt.crypt", 
        "syntax": "crypt.crypt(word, salt=None)", 
        "type": "Unix"
    }, 
    "crypt.methods": {
        "descr": "A list of available password hashing algorithms, as crypt.METHOD_* objects. This list is sorted from strongest to weakest, and is guaranteed to have at least crypt.METHOD_CRYPT.", 
        "name": "crypt.methods", 
        "params": [], 
        "path": "python/library/crypt#crypt.methods", 
        "syntax": "crypt.methods", 
        "type": "Unix"
    }, 
    "crypt.mksalt": {
        "descr": "Return a randomly generated salt of the specified method. If no method is given, the strongest method available as returned by methods() is used.", 
        "name": "crypt.mksalt", 
        "params": [], 
        "path": "python/library/crypt#crypt.mksalt", 
        "syntax": "crypt.mksalt(method=None)", 
        "type": "Unix"
    }, 
    "csv.Dialect": {
        "descr": "The Dialect class is a container class relied on primarily for its attributes, which are used to define the parameters for a specific reader or writer instance.", 
        "name": "csv.Dialect", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect", 
        "syntax": "class csv.Dialect", 
        "type": "File Formats"
    }, 
    "csv.Dialect.delimiter": {
        "descr": "A one-character string used to separate fields. It defaults to ','.", 
        "name": "csv.Dialect.delimiter", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.delimiter", 
        "syntax": "Dialect.delimiter", 
        "type": "File Formats"
    }, 
    "csv.Dialect.doublequote": {
        "descr": "Controls how instances of quotechar appearing inside a field should be themselves be quoted. When True, the character is doubled. When False, the escapechar is used as a prefix to the quotechar. It defaults to True.", 
        "name": "csv.Dialect.doublequote", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.doublequote", 
        "syntax": "Dialect.doublequote", 
        "type": "File Formats"
    }, 
    "csv.Dialect.escapechar": {
        "descr": "A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if doublequote is False. On reading, the escapechar removes any special meaning from the following character. It defaults to None, which disables escaping.", 
        "name": "csv.Dialect.escapechar", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.escapechar", 
        "syntax": "Dialect.escapechar", 
        "type": "File Formats"
    }, 
    "csv.Dialect.lineterminator": {
        "descr": "The string used to terminate lines produced by the writer. It defaults to '\\r\\n'.", 
        "name": "csv.Dialect.lineterminator", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.lineterminator", 
        "syntax": "Dialect.lineterminator", 
        "type": "File Formats"
    }, 
    "csv.Dialect.quotechar": {
        "descr": "A one-character string used to quote fields containing special characters, such as the delimiter or quotechar, or which contain new-line characters. It defaults to '\"'.", 
        "name": "csv.Dialect.quotechar", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.quotechar", 
        "syntax": "Dialect.quotechar", 
        "type": "File Formats"
    }, 
    "csv.Dialect.quoting": {
        "descr": "Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the QUOTE_* constants (see section Module Contents) and defaults to QUOTE_MINIMAL.", 
        "name": "csv.Dialect.quoting", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.quoting", 
        "syntax": "Dialect.quoting", 
        "type": "File Formats"
    }, 
    "csv.Dialect.skipinitialspace": {
        "descr": "When True, whitespace immediately following the delimiter is ignored. The default is False.", 
        "name": "csv.Dialect.skipinitialspace", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.skipinitialspace", 
        "syntax": "Dialect.skipinitialspace", 
        "type": "File Formats"
    }, 
    "csv.Dialect.strict": {
        "descr": "When True, raise exception Error on bad CSV input. The default is False.", 
        "name": "csv.Dialect.strict", 
        "params": [], 
        "path": "python/library/csv#csv.Dialect.strict", 
        "syntax": "Dialect.strict", 
        "type": "File Formats"
    }, 
    "csv.DictReader": {
        "descr": "Create an object which operates like a regular reader but maps the information read into a dict whose keys are given by the optional fieldnames parameter. If the fieldnames parameter is omitted, the values in the first row of the csvfile will be used as the fieldnames. If the row read has more fields than the fieldnames sequence, the remaining data is added as a sequence keyed by the value of restkey. If the row read has fewer fields than the fieldnames sequence, the remaining keys take the value of the optional restval parameter. Any other optional or keyword arguments are passed to the underlying reader instance.", 
        "name": "csv.DictReader", 
        "params": [], 
        "path": "python/library/csv#csv.DictReader", 
        "syntax": "class csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)", 
        "type": "File Formats"
    }, 
    "csv.DictWriter": {
        "descr": "Create an object which operates like a regular writer but maps dictionaries onto output rows. The fieldnames parameter identifies the order in which values in the dictionary passed to the writerow() method are written to the csvfile. The optional restval parameter specifies the value to be written if the dictionary is missing a key in fieldnames. If the dictionary passed to the writerow() method contains a key not found in fieldnames, the optional extrasaction parameter indicates what action to take. If it is set to 'raise' a ValueError is raised. If it is set to 'ignore', extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying writer instance.", 
        "name": "csv.DictWriter", 
        "params": [], 
        "path": "python/library/csv#csv.DictWriter", 
        "syntax": "class csv.DictWriter(csvfile, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)", 
        "type": "File Formats"
    }, 
    "csv.DictWriter.writeheader": {
        "descr": "Write a row with the field names (as specified in the constructor).", 
        "name": "csv.DictWriter.writeheader", 
        "params": [], 
        "path": "python/library/csv#csv.DictWriter.writeheader", 
        "syntax": "DictWriter.writeheader()", 
        "type": "File Formats"
    }, 
    "csv.Error": {
        "descr": "Raised by any of the functions when an error is detected.", 
        "name": "csv.Error", 
        "params": [], 
        "path": "python/library/csv#csv.Error", 
        "syntax": "exception csv.Error", 
        "type": "File Formats"
    }, 
    "csv.Sniffer": {
        "descr": "The Sniffer class is used to deduce the format of a CSV file.", 
        "name": "csv.Sniffer", 
        "params": [], 
        "path": "python/library/csv#csv.Sniffer", 
        "syntax": "class csv.Sniffer", 
        "type": "File Formats"
    }, 
    "csv.Sniffer.has_header": {
        "descr": "Analyze the sample text (presumed to be in CSV format) and return True if the first row appears to be a series of column headers.", 
        "name": "csv.Sniffer.has_header", 
        "params": [], 
        "path": "python/library/csv#csv.Sniffer.has_header", 
        "syntax": "has_header(sample)", 
        "type": "File Formats"
    }, 
    "csv.Sniffer.sniff": {
        "descr": "Analyze the given sample and return a Dialect subclass reflecting the parameters found. If the optional delimiters parameter is given, it is interpreted as a string containing possible valid delimiter characters.", 
        "name": "csv.Sniffer.sniff", 
        "params": [], 
        "path": "python/library/csv#csv.Sniffer.sniff", 
        "syntax": "sniff(sample, delimiters=None)", 
        "type": "File Formats"
    }, 
    "csv.csvreader.__next__": {
        "descr": "Return the next row of the reader\u2019s iterable object as a list, parsed according to the current dialect. Usually you should call this as next(reader).", 
        "name": "csv.csvreader.__next__", 
        "params": [], 
        "path": "python/library/csv#csv.csvreader.__next__", 
        "syntax": "csvreader.__next__()", 
        "type": "File Formats"
    }, 
    "csv.csvreader.dialect": {
        "descr": "A read-only description of the dialect in use by the parser.", 
        "name": "csv.csvreader.dialect", 
        "params": [], 
        "path": "python/library/csv#csv.csvreader.dialect", 
        "syntax": "csvreader.dialect", 
        "type": "File Formats"
    }, 
    "csv.csvreader.fieldnames": {
        "descr": "If not passed as a parameter when creating the object, this attribute is initialized upon first access or when the first record is read from the file.", 
        "name": "csv.csvreader.fieldnames", 
        "params": [], 
        "path": "python/library/csv#csv.csvreader.fieldnames", 
        "syntax": "csvreader.fieldnames", 
        "type": "File Formats"
    }, 
    "csv.csvreader.line_num": {
        "descr": "The number of lines read from the source iterator. This is not the same as the number of records returned, as records can span multiple lines.", 
        "name": "csv.csvreader.line_num", 
        "params": [], 
        "path": "python/library/csv#csv.csvreader.line_num", 
        "syntax": "csvreader.line_num", 
        "type": "File Formats"
    }, 
    "csv.csvwriter.dialect": {
        "descr": "A read-only description of the dialect in use by the writer.", 
        "name": "csv.csvwriter.dialect", 
        "params": [], 
        "path": "python/library/csv#csv.csvwriter.dialect", 
        "syntax": "csvwriter.dialect", 
        "type": "File Formats"
    }, 
    "csv.csvwriter.writerow": {
        "descr": "Write the row parameter to the writer\u2019s file object, formatted according to the current dialect.", 
        "name": "csv.csvwriter.writerow", 
        "params": [], 
        "path": "python/library/csv#csv.csvwriter.writerow", 
        "syntax": "csvwriter.writerow(row)", 
        "type": "File Formats"
    }, 
    "csv.csvwriter.writerows": {
        "descr": "Write all the rows parameters (a list of row objects as described above) to the writer\u2019s file object, formatted according to the current dialect.", 
        "name": "csv.csvwriter.writerows", 
        "params": [], 
        "path": "python/library/csv#csv.csvwriter.writerows", 
        "syntax": "csvwriter.writerows(rows)", 
        "type": "File Formats"
    }, 
    "csv.excel": {
        "descr": "The excel class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name 'excel'.", 
        "name": "csv.excel", 
        "params": [], 
        "path": "python/library/csv#csv.excel", 
        "syntax": "class csv.excel", 
        "type": "File Formats"
    }, 
    "csv.excel_tab": {
        "descr": "The excel_tab class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name 'excel-tab'.", 
        "name": "csv.excel_tab", 
        "params": [], 
        "path": "python/library/csv#csv.excel_tab", 
        "syntax": "class csv.excel_tab", 
        "type": "File Formats"
    }, 
    "csv.field_size_limit": {
        "descr": "Returns the current maximum field size allowed by the parser. If new_limit is given, this becomes the new limit.", 
        "name": "csv.field_size_limit", 
        "params": [], 
        "path": "python/library/csv#csv.field_size_limit", 
        "syntax": "csv.field_size_limit([new_limit])", 
        "type": "File Formats"
    }, 
    "csv.get_dialect": {
        "descr": "Return the dialect associated with name. An Error is raised if name is not a registered dialect name. This function returns an immutable Dialect.", 
        "name": "csv.get_dialect", 
        "params": [], 
        "path": "python/library/csv#csv.get_dialect", 
        "syntax": "csv.get_dialect(name)", 
        "type": "File Formats"
    }, 
    "csv.list_dialects": {
        "descr": "Return the names of all registered dialects.", 
        "name": "csv.list_dialects", 
        "params": [], 
        "path": "python/library/csv#csv.list_dialects", 
        "syntax": "csv.list_dialects()", 
        "type": "File Formats"
    }, 
    "csv.reader": {
        "descr": "Return a reader object which will iterate over lines in the given csvfile. csvfile can be any object which supports the iterator protocol and returns a string each time its __next__() method is called \u2014 file objects and list objects are both suitable. If csvfile is a file object, it should be opened with newline=''. [1] An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the Dialect class or one of the strings returned by the list_dialects() function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters.", 
        "name": "csv.reader", 
        "params": [], 
        "path": "python/library/csv#csv.reader", 
        "syntax": "csv.reader(csvfile, dialect='excel', **fmtparams)", 
        "type": "File Formats"
    }, 
    "csv.register_dialect": {
        "descr": "Associate dialect with name. name must be a string. The dialect can be specified either by passing a sub-class of Dialect, or by fmtparams keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters.", 
        "name": "csv.register_dialect", 
        "params": [], 
        "path": "python/library/csv#csv.register_dialect", 
        "syntax": "csv.register_dialect(name[, dialect], **fmtparams)", 
        "type": "File Formats"
    }, 
    "csv.unix_dialect": {
        "descr": "The unix_dialect class defines the usual properties of a CSV file generated on UNIX systems, i.e. using '\\n' as line terminator and quoting all fields. It is registered with the dialect name 'unix'.", 
        "name": "csv.unix_dialect", 
        "params": [], 
        "path": "python/library/csv#csv.unix_dialect", 
        "syntax": "class csv.unix_dialect", 
        "type": "File Formats"
    }, 
    "csv.unregister_dialect": {
        "descr": "Delete the dialect associated with name from the dialect registry. An Error is raised if name is not a registered dialect name.", 
        "name": "csv.unregister_dialect", 
        "params": [], 
        "path": "python/library/csv#csv.unregister_dialect", 
        "syntax": "csv.unregister_dialect(name)", 
        "type": "File Formats"
    }, 
    "csv.writer": {
        "descr": "Return a writer object responsible for converting the user\u2019s data into delimited strings on the given file-like object. csvfile can be any object with a write() method. If csvfile is a file object, it should be opened with newline='' [1]. An optional dialect parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the Dialect class or one of the strings returned by the list_dialects() function. The other optional fmtparams keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section Dialects and Formatting Parameters. To make it as easy as possible to interface with modules which implement the DB API, the value None is written as the empty string. While this isn\u2019t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a cursor.fetch* call. All other non-string data are stringified with str() before being written.", 
        "name": "csv.writer", 
        "params": [], 
        "path": "python/library/csv#csv.writer", 
        "syntax": "csv.writer(csvfile, dialect='excel', **fmtparams)", 
        "type": "File Formats"
    }, 
    "ctypes.ArgumentError": {
        "descr": "This exception is raised when a foreign function call cannot convert one of the passed arguments.", 
        "name": "ctypes.ArgumentError", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.ArgumentError", 
        "syntax": "exception ctypes.ArgumentError", 
        "type": "Operating System"
    }, 
    "ctypes.BigEndianStructure": {
        "descr": "Abstract base class for structures in big endian byte order.", 
        "name": "ctypes.BigEndianStructure", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.BigEndianStructure", 
        "syntax": "class ctypes.BigEndianStructure(*args, **kw)", 
        "type": "Operating System"
    }, 
    "ctypes.CDLL": {
        "descr": "Instances of this class represent loaded shared libraries. Functions in these libraries use the standard C calling convention, and are assumed to return int.", 
        "name": "ctypes.CDLL", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.CDLL", 
        "syntax": "class ctypes.CDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False)", 
        "type": "Operating System"
    }, 
    "ctypes.CFUNCTYPE": {
        "descr": "The returned function prototype creates functions that use the standard C calling convention. The function will release the GIL during the call. If use_errno is set to True, the ctypes private copy of the system errno variable is exchanged with the real errno value before and after the call; use_last_error does the same for the Windows error code.", 
        "name": "ctypes.CFUNCTYPE", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.CFUNCTYPE", 
        "syntax": "ctypes.CFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)", 
        "type": "Operating System"
    }, 
    "ctypes.DllCanUnloadNow": {
        "descr": "Windows only: This function is a hook which allows to implement in-process COM servers with ctypes. It is called from the DllCanUnloadNow function that the _ctypes extension dll exports.", 
        "name": "ctypes.DllCanUnloadNow", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.DllCanUnloadNow", 
        "syntax": "ctypes.DllCanUnloadNow()", 
        "type": "Operating System"
    }, 
    "ctypes.DllGetClassObject": {
        "descr": "Windows only: This function is a hook which allows to implement in-process COM servers with ctypes. It is called from the DllGetClassObject function that the _ctypes extension dll exports.", 
        "name": "ctypes.DllGetClassObject", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.DllGetClassObject", 
        "syntax": "ctypes.DllGetClassObject()", 
        "type": "Operating System"
    }, 
    "ctypes.FormatError": {
        "descr": "Windows only: Returns a textual description of the error code code. If no error code is specified, the last error code is used by calling the Windows api function GetLastError.", 
        "name": "ctypes.FormatError", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.FormatError", 
        "syntax": "ctypes.FormatError([code])", 
        "type": "Operating System"
    }, 
    "ctypes.GetLastError": {
        "descr": "Windows only: Returns the last error code set by Windows in the calling thread. This function calls the Windows GetLastError() function directly, it does not return the ctypes-private copy of the error code.", 
        "name": "ctypes.GetLastError", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.GetLastError", 
        "syntax": "ctypes.GetLastError()", 
        "type": "Operating System"
    }, 
    "ctypes.HRESULT": {
        "descr": "Windows only: Represents a HRESULT value, which contains success or error information for a function or method call.", 
        "name": "ctypes.HRESULT", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.HRESULT", 
        "syntax": "class ctypes.HRESULT", 
        "type": "Operating System"
    }, 
    "ctypes.LibraryLoader": {
        "descr": "Class which loads shared libraries. dlltype should be one of the CDLL, PyDLL, WinDLL, or OleDLL types.", 
        "name": "ctypes.LibraryLoader", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.LibraryLoader", 
        "syntax": "class ctypes.LibraryLoader(dlltype)", 
        "type": "Operating System"
    }, 
    "ctypes.LibraryLoader.LoadLibrary": {
        "descr": "Load a shared library into the process and return it. This method always returns a new instance of the library.", 
        "name": "ctypes.LibraryLoader.LoadLibrary", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.LibraryLoader.LoadLibrary", 
        "syntax": "LoadLibrary(name)", 
        "type": "Operating System"
    }, 
    "ctypes.LittleEndianStructure": {
        "descr": "Abstract base class for structures in little endian byte order.", 
        "name": "ctypes.LittleEndianStructure", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.LittleEndianStructure", 
        "syntax": "class ctypes.LittleEndianStructure(*args, **kw)", 
        "type": "Operating System"
    }, 
    "ctypes.OleDLL": {
        "descr": "Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the stdcall calling convention, and are assumed to return the windows specific HRESULT code. HRESULT values contain information specifying whether the function call failed or succeeded, together with additional error code. If the return value signals a failure, an OSError is automatically raised.", 
        "name": "ctypes.OleDLL", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.OleDLL", 
        "syntax": "class ctypes.OleDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False)", 
        "type": "Operating System"
    }, 
    "ctypes.POINTER": {
        "descr": "This factory function creates and returns a new ctypes pointer type. Pointer types are cached an reused internally, so calling this function repeatedly is cheap. type must be a ctypes type.", 
        "name": "ctypes.POINTER", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.POINTER", 
        "syntax": "ctypes.POINTER(type)", 
        "type": "Operating System"
    }, 
    "ctypes.PYFUNCTYPE": {
        "descr": "The returned function prototype creates functions that use the Python calling convention. The function will not release the GIL during the call.", 
        "name": "ctypes.PYFUNCTYPE", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.PYFUNCTYPE", 
        "syntax": "ctypes.PYFUNCTYPE(restype, *argtypes)", 
        "type": "Operating System"
    }, 
    "ctypes.PyDLL": {
        "descr": "Instances of this class behave like CDLL instances, except that the Python GIL is not released during the function call, and after the function execution the Python error flag is checked. If the error flag is set, a Python exception is raised.", 
        "name": "ctypes.PyDLL", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.PyDLL", 
        "syntax": "class ctypes.PyDLL(name, mode=DEFAULT_MODE, handle=None)", 
        "type": "Operating System"
    }, 
    "ctypes.PyDLL._handle": {
        "descr": "The system handle used to access the library.", 
        "name": "ctypes.PyDLL._handle", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.PyDLL._handle", 
        "syntax": "PyDLL._handle", 
        "type": "Operating System"
    }, 
    "ctypes.PyDLL._name": {
        "descr": "The name of the library passed in the constructor.", 
        "name": "ctypes.PyDLL._name", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.PyDLL._name", 
        "syntax": "PyDLL._name", 
        "type": "Operating System"
    }, 
    "ctypes.Structure": {
        "descr": "Abstract base class for structures in native byte order.", 
        "name": "ctypes.Structure", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.Structure", 
        "syntax": "class ctypes.Structure(*args, **kw)", 
        "type": "Operating System"
    }, 
    "ctypes.Structure._anonymous_": {
        "descr": "An optional sequence that lists the names of unnamed (anonymous) fields. _anonymous_ must be already defined when _fields_ is assigned, otherwise it will have no effect.", 
        "name": "ctypes.Structure._anonymous_", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.Structure._anonymous_", 
        "syntax": "_anonymous_", 
        "type": "Operating System"
    }, 
    "ctypes.Structure._fields_": {
        "descr": "A sequence defining the structure fields. The items must be 2-tuples or 3-tuples. The first item is the name of the field, the second item specifies the type of the field; it can be any ctypes data type.", 
        "name": "ctypes.Structure._fields_", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.Structure._fields_", 
        "syntax": "_fields_", 
        "type": "Operating System"
    }, 
    "ctypes.Structure._pack_": {
        "descr": "An optional small integer that allows to override the alignment of structure fields in the instance. _pack_ must already be defined when _fields_ is assigned, otherwise it will have no effect.", 
        "name": "ctypes.Structure._pack_", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.Structure._pack_", 
        "syntax": "_pack_", 
        "type": "Operating System"
    }, 
    "ctypes.Union": {
        "descr": "Abstract base class for unions in native byte order.", 
        "name": "ctypes.Union", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.Union", 
        "syntax": "class ctypes.Union(*args, **kw)", 
        "type": "Operating System"
    }, 
    "ctypes.WINFUNCTYPE": {
        "descr": "Windows only: The returned function prototype creates functions that use the stdcall calling convention, except on Windows CE where WINFUNCTYPE() is the same as CFUNCTYPE(). The function will release the GIL during the call. use_errno and use_last_error have the same meaning as above.", 
        "name": "ctypes.WINFUNCTYPE", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.WINFUNCTYPE", 
        "syntax": "ctypes.WINFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)", 
        "type": "Operating System"
    }, 
    "ctypes.WinDLL": {
        "descr": "Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the stdcall calling convention, and are assumed to return int by default.", 
        "name": "ctypes.WinDLL", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.WinDLL", 
        "syntax": "class ctypes.WinDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False)", 
        "type": "Operating System"
    }, 
    "ctypes.WinError": {
        "descr": "Windows only: this function is probably the worst-named thing in ctypes. It creates an instance of OSError. If code is not specified, GetLastError is called to determine the error code. If descr is not specified, FormatError() is called to get a textual description of the error.", 
        "name": "ctypes.WinError", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.WinError", 
        "syntax": "ctypes.WinError(code=None, descr=None)", 
        "type": "Operating System"
    }, 
    "ctypes._CData": {
        "descr": "This non-public class is the common base class of all ctypes data types. Among other things, all ctypes type instances contain a memory block that hold C compatible data; the address of the memory block is returned by the addressof() helper function. Another instance variable is exposed as _objects; this contains other Python objects that need to be kept alive in case the memory block contains pointers.", 
        "name": "ctypes._CData", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData", 
        "syntax": "class ctypes._CData", 
        "type": "Operating System"
    }, 
    "ctypes._CData._b_base_": {
        "descr": "Sometimes ctypes data instances do not own the memory block they contain, instead they share part of the memory block of a base object. The _b_base_ read-only member is the root ctypes object that owns the memory block.", 
        "name": "ctypes._CData._b_base_", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData._b_base_", 
        "syntax": "_b_base_", 
        "type": "Operating System"
    }, 
    "ctypes._CData._b_needsfree_": {
        "descr": "This read-only variable is true when the ctypes data instance has allocated the memory block itself, false otherwise.", 
        "name": "ctypes._CData._b_needsfree_", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData._b_needsfree_", 
        "syntax": "_b_needsfree_", 
        "type": "Operating System"
    }, 
    "ctypes._CData._objects": {
        "descr": "This member is either None or a dictionary containing Python objects that need to be kept alive so that the memory block contents is kept valid. This object is only exposed for debugging; never modify the contents of this dictionary.", 
        "name": "ctypes._CData._objects", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData._objects", 
        "syntax": "_objects", 
        "type": "Operating System"
    }, 
    "ctypes._CData.from_address": {
        "descr": "This method returns a ctypes type instance using the memory specified by address which must be an integer.", 
        "name": "ctypes._CData.from_address", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData.from_address", 
        "syntax": "from_address(address)", 
        "type": "Operating System"
    }, 
    "ctypes._CData.from_buffer": {
        "descr": "This method returns a ctypes instance that shares the buffer of the source object. The source object must support the writeable buffer interface. The optional offset parameter specifies an offset into the source buffer in bytes; the default is zero. If the source buffer is not large enough a ValueError is raised.", 
        "name": "ctypes._CData.from_buffer", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData.from_buffer", 
        "syntax": "from_buffer(source[, offset])", 
        "type": "Operating System"
    }, 
    "ctypes._CData.from_buffer_copy": {
        "descr": "This method creates a ctypes instance, copying the buffer from the source object buffer which must be readable. The optional offset parameter specifies an offset into the source buffer in bytes; the default is zero. If the source buffer is not large enough a ValueError is raised.", 
        "name": "ctypes._CData.from_buffer_copy", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData.from_buffer_copy", 
        "syntax": "from_buffer_copy(source[, offset])", 
        "type": "Operating System"
    }, 
    "ctypes._CData.from_param": {
        "descr": "This method adapts obj to a ctypes type. It is called with the actual object used in a foreign function call when the type is present in the foreign function\u2019s argtypes tuple; it must return an object that can be used as a function call parameter.", 
        "name": "ctypes._CData.from_param", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData.from_param", 
        "syntax": "from_param(obj)", 
        "type": "Operating System"
    }, 
    "ctypes._CData.in_dll": {
        "descr": "This method returns a ctypes type instance exported by a shared library. name is the name of the symbol that exports the data, library is the loaded shared library.", 
        "name": "ctypes._CData.in_dll", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._CData.in_dll", 
        "syntax": "in_dll(library, name)", 
        "type": "Operating System"
    }, 
    "ctypes._FuncPtr": {
        "descr": "Base class for C callable foreign functions.", 
        "name": "ctypes._FuncPtr", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._FuncPtr", 
        "syntax": "class ctypes._FuncPtr", 
        "type": "Operating System"
    }, 
    "ctypes._FuncPtr.argtypes": {
        "descr": "Assign a tuple of ctypes types to specify the argument types that the function accepts. Functions using the stdcall calling convention can only be called with the same number of arguments as the length of this tuple; functions using the C calling convention accept additional, unspecified arguments as well.", 
        "name": "ctypes._FuncPtr.argtypes", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._FuncPtr.argtypes", 
        "syntax": "argtypes", 
        "type": "Operating System"
    }, 
    "ctypes._FuncPtr.errcheck": {
        "descr": "Assign a Python function or another callable to this attribute. The callable will be called with three or more arguments:", 
        "name": "ctypes._FuncPtr.errcheck", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._FuncPtr.errcheck", 
        "syntax": "errcheck", 
        "type": "Operating System"
    }, 
    "ctypes._FuncPtr.restype": {
        "descr": "Assign a ctypes type to specify the result type of the foreign function. Use None for void, a function not returning anything.", 
        "name": "ctypes._FuncPtr.restype", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._FuncPtr.restype", 
        "syntax": "restype", 
        "type": "Operating System"
    }, 
    "ctypes._SimpleCData": {
        "descr": "This non-public class is the base class of all fundamental ctypes data types. It is mentioned here because it contains the common attributes of the fundamental ctypes data types. _SimpleCData is a subclass of _CData, so it inherits their methods and attributes. ctypes data types that are not and do not contain pointers can now be pickled.", 
        "name": "ctypes._SimpleCData", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._SimpleCData", 
        "syntax": "class ctypes._SimpleCData", 
        "type": "Operating System"
    }, 
    "ctypes._SimpleCData.value": {
        "descr": "This attribute contains the actual value of the instance. For integer and pointer types, it is an integer, for character types, it is a single character bytes object or string, for character pointer types it is a Python bytes object or string.", 
        "name": "ctypes._SimpleCData.value", 
        "params": [], 
        "path": "python/library/ctypes#ctypes._SimpleCData.value", 
        "syntax": "value", 
        "type": "Operating System"
    }, 
    "ctypes.addressof": {
        "descr": "Returns the address of the memory buffer as integer. obj must be an instance of a ctypes type.", 
        "name": "ctypes.addressof", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.addressof", 
        "syntax": "ctypes.addressof(obj)", 
        "type": "Operating System"
    }, 
    "ctypes.alignment": {
        "descr": "Returns the alignment requirements of a ctypes type. obj_or_type must be a ctypes type or instance.", 
        "name": "ctypes.alignment", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.alignment", 
        "syntax": "ctypes.alignment(obj_or_type)", 
        "type": "Operating System"
    }, 
    "ctypes.byref": {
        "descr": "Returns a light-weight pointer to obj, which must be an instance of a ctypes type. offset defaults to zero, and must be an integer that will be added to the internal pointer value.", 
        "name": "ctypes.byref", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.byref", 
        "syntax": "ctypes.byref(obj[, offset])", 
        "type": "Operating System"
    }, 
    "ctypes.c_bool": {
        "descr": "Represent the C bool datatype (more accurately, _Bool from C99). Its value can be True or False, and the constructor accepts any object that has a truth value.", 
        "name": "ctypes.c_bool", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_bool", 
        "syntax": "class ctypes.c_bool", 
        "type": "Operating System"
    }, 
    "ctypes.c_byte": {
        "descr": "Represents the C signed char datatype, and interprets the value as small integer. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_byte", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_byte", 
        "syntax": "class ctypes.c_byte", 
        "type": "Operating System"
    }, 
    "ctypes.c_char": {
        "descr": "Represents the C char datatype, and interprets the value as a single character. The constructor accepts an optional string initializer, the length of the string must be exactly one character.", 
        "name": "ctypes.c_char", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_char", 
        "syntax": "class ctypes.c_char", 
        "type": "Operating System"
    }, 
    "ctypes.c_char_p": {
        "descr": "Represents the C char * datatype when it points to a zero-terminated string. For a general character pointer that may also point to binary data, POINTER(c_char) must be used. The constructor accepts an integer address, or a bytes object.", 
        "name": "ctypes.c_char_p", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_char_p", 
        "syntax": "class ctypes.c_char_p", 
        "type": "Operating System"
    }, 
    "ctypes.c_double": {
        "descr": "Represents the C double datatype. The constructor accepts an optional float initializer.", 
        "name": "ctypes.c_double", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_double", 
        "syntax": "class ctypes.c_double", 
        "type": "Operating System"
    }, 
    "ctypes.c_float": {
        "descr": "Represents the C float datatype. The constructor accepts an optional float initializer.", 
        "name": "ctypes.c_float", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_float", 
        "syntax": "class ctypes.c_float", 
        "type": "Operating System"
    }, 
    "ctypes.c_int": {
        "descr": "Represents the C 64-bit signed int datatype. Usually an alias for c_longlong.", 
        "name": "ctypes.c_int", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_int", 
        "syntax": "class ctypes.c_int64", 
        "type": "Operating System"
    }, 
    "ctypes.c_int16": {
        "descr": "Represents the C 16-bit signed int datatype. Usually an alias for c_short.", 
        "name": "ctypes.c_int16", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_int16", 
        "syntax": "class ctypes.c_int16", 
        "type": "Operating System"
    }, 
    "ctypes.c_int32": {
        "descr": "Represents the C 32-bit signed int datatype. Usually an alias for c_int.", 
        "name": "ctypes.c_int32", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_int32", 
        "syntax": "class ctypes.c_int32", 
        "type": "Operating System"
    }, 
    "ctypes.c_int64": {
        "descr": "Represents the C 64-bit signed int datatype. Usually an alias for c_longlong.", 
        "name": "ctypes.c_int64", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_int64", 
        "syntax": "class ctypes.c_int64", 
        "type": "Operating System"
    }, 
    "ctypes.c_int8": {
        "descr": "Represents the C 8-bit signed int datatype. Usually an alias for c_byte.", 
        "name": "ctypes.c_int8", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_int8", 
        "syntax": "class ctypes.c_int8", 
        "type": "Operating System"
    }, 
    "ctypes.c_long": {
        "descr": "Represents the C signed long datatype. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_long", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_long", 
        "syntax": "class ctypes.c_long", 
        "type": "Operating System"
    }, 
    "ctypes.c_longdouble": {
        "descr": "Represents the C long double datatype. The constructor accepts an optional float initializer. On platforms where sizeof(long double) == sizeof(double) it is an alias to c_double.", 
        "name": "ctypes.c_longdouble", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_longdouble", 
        "syntax": "class ctypes.c_longdouble", 
        "type": "Operating System"
    }, 
    "ctypes.c_longlong": {
        "descr": "Represents the C signed long long datatype. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_longlong", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_longlong", 
        "syntax": "class ctypes.c_longlong", 
        "type": "Operating System"
    }, 
    "ctypes.c_short": {
        "descr": "Represents the C signed short datatype. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_short", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_short", 
        "syntax": "class ctypes.c_short", 
        "type": "Operating System"
    }, 
    "ctypes.c_size_t": {
        "descr": "Represents the C size_t datatype.", 
        "name": "ctypes.c_size_t", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_size_t", 
        "syntax": "class ctypes.c_size_t", 
        "type": "Operating System"
    }, 
    "ctypes.c_ssize_t": {
        "descr": "Represents the C ssize_t datatype.", 
        "name": "ctypes.c_ssize_t", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_ssize_t", 
        "syntax": "class ctypes.c_ssize_t", 
        "type": "Operating System"
    }, 
    "ctypes.c_ubyte": {
        "descr": "Represents the C unsigned char datatype, it interprets the value as small integer. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_ubyte", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_ubyte", 
        "syntax": "class ctypes.c_ubyte", 
        "type": "Operating System"
    }, 
    "ctypes.c_uint": {
        "descr": "Represents the C 64-bit unsigned int datatype. Usually an alias for c_ulonglong.", 
        "name": "ctypes.c_uint", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_uint", 
        "syntax": "class ctypes.c_uint64", 
        "type": "Operating System"
    }, 
    "ctypes.c_uint16": {
        "descr": "Represents the C 16-bit unsigned int datatype. Usually an alias for c_ushort.", 
        "name": "ctypes.c_uint16", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_uint16", 
        "syntax": "class ctypes.c_uint16", 
        "type": "Operating System"
    }, 
    "ctypes.c_uint32": {
        "descr": "Represents the C 32-bit unsigned int datatype. Usually an alias for c_uint.", 
        "name": "ctypes.c_uint32", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_uint32", 
        "syntax": "class ctypes.c_uint32", 
        "type": "Operating System"
    }, 
    "ctypes.c_uint64": {
        "descr": "Represents the C 64-bit unsigned int datatype. Usually an alias for c_ulonglong.", 
        "name": "ctypes.c_uint64", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_uint64", 
        "syntax": "class ctypes.c_uint64", 
        "type": "Operating System"
    }, 
    "ctypes.c_uint8": {
        "descr": "Represents the C 8-bit unsigned int datatype. Usually an alias for c_ubyte.", 
        "name": "ctypes.c_uint8", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_uint8", 
        "syntax": "class ctypes.c_uint8", 
        "type": "Operating System"
    }, 
    "ctypes.c_ulong": {
        "descr": "Represents the C unsigned long datatype. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_ulong", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_ulong", 
        "syntax": "class ctypes.c_ulong", 
        "type": "Operating System"
    }, 
    "ctypes.c_ulonglong": {
        "descr": "Represents the C unsigned long long datatype. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_ulonglong", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_ulonglong", 
        "syntax": "class ctypes.c_ulonglong", 
        "type": "Operating System"
    }, 
    "ctypes.c_ushort": {
        "descr": "Represents the C unsigned short datatype. The constructor accepts an optional integer initializer; no overflow checking is done.", 
        "name": "ctypes.c_ushort", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_ushort", 
        "syntax": "class ctypes.c_ushort", 
        "type": "Operating System"
    }, 
    "ctypes.c_void_p": {
        "descr": "Represents the C void * type. The value is represented as integer. The constructor accepts an optional integer initializer.", 
        "name": "ctypes.c_void_p", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_void_p", 
        "syntax": "class ctypes.c_void_p", 
        "type": "Operating System"
    }, 
    "ctypes.c_wchar": {
        "descr": "Represents the C wchar_t datatype, and interprets the value as a single character unicode string. The constructor accepts an optional string initializer, the length of the string must be exactly one character.", 
        "name": "ctypes.c_wchar", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_wchar", 
        "syntax": "class ctypes.c_wchar", 
        "type": "Operating System"
    }, 
    "ctypes.c_wchar_p": {
        "descr": "Represents the C wchar_t * datatype, which must be a pointer to a zero-terminated wide character string. The constructor accepts an integer address, or a string.", 
        "name": "ctypes.c_wchar_p", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.c_wchar_p", 
        "syntax": "class ctypes.c_wchar_p", 
        "type": "Operating System"
    }, 
    "ctypes.cast": {
        "descr": "This function is similar to the cast operator in C. It returns a new instance of type which points to the same memory block as obj. type must be a pointer type, and obj must be an object that can be interpreted as a pointer.", 
        "name": "ctypes.cast", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.cast", 
        "syntax": "ctypes.cast(obj, type)", 
        "type": "Operating System"
    }, 
    "ctypes.create_string_buffer": {
        "descr": "This function creates a mutable character buffer. The returned object is a ctypes array of c_char.", 
        "name": "ctypes.create_string_buffer", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.create_string_buffer", 
        "syntax": "ctypes.create_string_buffer(init_or_size, size=None)", 
        "type": "Operating System"
    }, 
    "ctypes.create_unicode_buffer": {
        "descr": "This function creates a mutable unicode character buffer. The returned object is a ctypes array of c_wchar.", 
        "name": "ctypes.create_unicode_buffer", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.create_unicode_buffer", 
        "syntax": "ctypes.create_unicode_buffer(init_or_size, size=None)", 
        "type": "Operating System"
    }, 
    "ctypes.get_errno": {
        "descr": "Returns the current value of the ctypes-private copy of the system errno variable in the calling thread.", 
        "name": "ctypes.get_errno", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.get_errno", 
        "syntax": "ctypes.get_errno()", 
        "type": "Operating System"
    }, 
    "ctypes.get_last_error": {
        "descr": "Windows only: returns the current value of the ctypes-private copy of the system LastError variable in the calling thread.", 
        "name": "ctypes.get_last_error", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.get_last_error", 
        "syntax": "ctypes.get_last_error()", 
        "type": "Operating System"
    }, 
    "ctypes.memmove": {
        "descr": "Same as the standard C memmove library function: copies count bytes from src to dst. dst and src must be integers or ctypes instances that can be converted to pointers.", 
        "name": "ctypes.memmove", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.memmove", 
        "syntax": "ctypes.memmove(dst, src, count)", 
        "type": "Operating System"
    }, 
    "ctypes.memset": {
        "descr": "Same as the standard C memset library function: fills the memory block at address dst with count bytes of value c. dst must be an integer specifying an address, or a ctypes instance.", 
        "name": "ctypes.memset", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.memset", 
        "syntax": "ctypes.memset(dst, c, count)", 
        "type": "Operating System"
    }, 
    "ctypes.pointer": {
        "descr": "This function creates a new pointer instance, pointing to obj. The returned object is of the type POINTER(type(obj)).", 
        "name": "ctypes.pointer", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.pointer", 
        "syntax": "ctypes.pointer(obj)", 
        "type": "Operating System"
    }, 
    "ctypes.py_object": {
        "descr": "Represents the C PyObject * datatype. Calling this without an argument creates a NULL PyObject * pointer.", 
        "name": "ctypes.py_object", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.py_object", 
        "syntax": "class ctypes.py_object", 
        "type": "Operating System"
    }, 
    "ctypes.resize": {
        "descr": "This function resizes the internal memory buffer of obj, which must be an instance of a ctypes type. It is not possible to make the buffer smaller than the native size of the objects type, as given by sizeof(type(obj)), but it is possible to enlarge the buffer.", 
        "name": "ctypes.resize", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.resize", 
        "syntax": "ctypes.resize(obj, size)", 
        "type": "Operating System"
    }, 
    "ctypes.set_errno": {
        "descr": "Set the current value of the ctypes-private copy of the system errno variable in the calling thread to value and return the previous value.", 
        "name": "ctypes.set_errno", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.set_errno", 
        "syntax": "ctypes.set_errno(value)", 
        "type": "Operating System"
    }, 
    "ctypes.set_last_error": {
        "descr": "Windows only: set the current value of the ctypes-private copy of the system LastError variable in the calling thread to value and return the previous value.", 
        "name": "ctypes.set_last_error", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.set_last_error", 
        "syntax": "ctypes.set_last_error(value)", 
        "type": "Operating System"
    }, 
    "ctypes.sizeof": {
        "descr": "Returns the size in bytes of a ctypes type or instance memory buffer. Does the same as the C sizeof operator.", 
        "name": "ctypes.sizeof", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.sizeof", 
        "syntax": "ctypes.sizeof(obj_or_type)", 
        "type": "Operating System"
    }, 
    "ctypes.string_at": {
        "descr": "This function returns the C string starting at memory address address as a bytes object. If size is specified, it is used as size, otherwise the string is assumed to be zero-terminated.", 
        "name": "ctypes.string_at", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.string_at", 
        "syntax": "ctypes.string_at(address, size=-1)", 
        "type": "Operating System"
    }, 
    "ctypes.util.find_library": {
        "descr": "Try to find a library and return a pathname. name is the library name without any prefix like lib, suffix like .so, .dylib or version number (this is the form used for the posix linker option -l). If no library can be found, returns None.", 
        "name": "ctypes.util.find_library", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.util.find_library", 
        "syntax": "ctypes.util.find_library(name)", 
        "type": "Operating System"
    }, 
    "ctypes.util.find_msvcrt": {
        "descr": "Windows only: return the filename of the VC runtype library used by Python, and by the extension modules. If the name of the library cannot be determined, None is returned.", 
        "name": "ctypes.util.find_msvcrt", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.util.find_msvcrt", 
        "syntax": "ctypes.util.find_msvcrt()", 
        "type": "Operating System"
    }, 
    "ctypes.wstring_at": {
        "descr": "This function returns the wide character string starting at memory address address as a string. If size is specified, it is used as the number of characters of the string, otherwise the string is assumed to be zero-terminated.", 
        "name": "ctypes.wstring_at", 
        "params": [], 
        "path": "python/library/ctypes#ctypes.wstring_at", 
        "syntax": "ctypes.wstring_at(address, size=-1)", 
        "type": "Operating System"
    }, 
    "curses.ascii.alt": {
        "descr": "Return the 8-bit character corresponding to the given ASCII character (the character bit value is bitwise-ored with 0x80).", 
        "name": "curses.ascii.alt", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.alt", 
        "syntax": "curses.ascii.alt(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.ascii": {
        "descr": "Return the ASCII value corresponding to the low 7 bits of c.", 
        "name": "curses.ascii.ascii", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.ascii", 
        "syntax": "curses.ascii.ascii(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.controlnames": {
        "descr": "A 33-element string array that contains the ASCII mnemonics for the thirty-two ASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the mnemonic SP for the space character.", 
        "name": "curses.ascii.controlnames", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.controlnames", 
        "syntax": "curses.ascii.controlnames", 
        "type": "Operating System"
    }, 
    "curses.ascii.ctrl": {
        "descr": "Return the control character corresponding to the given character (the character bit value is bitwise-anded with 0x1f).", 
        "name": "curses.ascii.ctrl", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.ctrl", 
        "syntax": "curses.ascii.ctrl(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isalnum": {
        "descr": "Checks for an ASCII alphanumeric character; it is equivalent to isalpha(c) or isdigit(c).", 
        "name": "curses.ascii.isalnum", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isalnum", 
        "syntax": "curses.ascii.isalnum(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isalpha": {
        "descr": "Checks for an ASCII alphabetic character; it is equivalent to isupper(c) or islower(c).", 
        "name": "curses.ascii.isalpha", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isalpha", 
        "syntax": "curses.ascii.isalpha(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isascii": {
        "descr": "Checks for a character value that fits in the 7-bit ASCII set.", 
        "name": "curses.ascii.isascii", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isascii", 
        "syntax": "curses.ascii.isascii(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isblank": {
        "descr": "Checks for an ASCII whitespace character.", 
        "name": "curses.ascii.isblank", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isblank", 
        "syntax": "curses.ascii.isblank(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.iscntrl": {
        "descr": "Checks for an ASCII control character (in the range 0x00 to 0x1f).", 
        "name": "curses.ascii.iscntrl", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.iscntrl", 
        "syntax": "curses.ascii.iscntrl(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isctrl": {
        "descr": "Checks for an ASCII control character (ordinal values 0 to 31).", 
        "name": "curses.ascii.isctrl", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isctrl", 
        "syntax": "curses.ascii.isctrl(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isdigit": {
        "descr": "Checks for an ASCII decimal digit, '0' through '9'. This is equivalent to c in string.digits.", 
        "name": "curses.ascii.isdigit", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isdigit", 
        "syntax": "curses.ascii.isdigit(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isgraph": {
        "descr": "Checks for ASCII any printable character except space.", 
        "name": "curses.ascii.isgraph", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isgraph", 
        "syntax": "curses.ascii.isgraph(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.islower": {
        "descr": "Checks for an ASCII lower-case character.", 
        "name": "curses.ascii.islower", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.islower", 
        "syntax": "curses.ascii.islower(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.ismeta": {
        "descr": "Checks for a non-ASCII character (ordinal values 0x80 and above).", 
        "name": "curses.ascii.ismeta", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.ismeta", 
        "syntax": "curses.ascii.ismeta(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isprint": {
        "descr": "Checks for any ASCII printable character including space.", 
        "name": "curses.ascii.isprint", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isprint", 
        "syntax": "curses.ascii.isprint(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.ispunct": {
        "descr": "Checks for any printable ASCII character which is not a space or an alphanumeric character.", 
        "name": "curses.ascii.ispunct", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.ispunct", 
        "syntax": "curses.ascii.ispunct(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isspace": {
        "descr": "Checks for ASCII white-space characters; space, line feed, carriage return, form feed, horizontal tab, vertical tab.", 
        "name": "curses.ascii.isspace", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isspace", 
        "syntax": "curses.ascii.isspace(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isupper": {
        "descr": "Checks for an ASCII uppercase letter.", 
        "name": "curses.ascii.isupper", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isupper", 
        "syntax": "curses.ascii.isupper(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.isxdigit": {
        "descr": "Checks for an ASCII hexadecimal digit. This is equivalent to c in string.hexdigits.", 
        "name": "curses.ascii.isxdigit", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.isxdigit", 
        "syntax": "curses.ascii.isxdigit(c)", 
        "type": "Operating System"
    }, 
    "curses.ascii.unctrl": {
        "descr": "Return a string representation of the ASCII character c. If c is printable, this string is the character itself. If the character is a control character (0x00-0x1f) the string consists of a caret ('^') followed by the corresponding uppercase letter. If the character is an ASCII delete (0x7f) the string is '^?'. If the character has its meta bit (0x80) set, the meta bit is stripped, the preceding rules applied, and '!' prepended to the result.", 
        "name": "curses.ascii.unctrl", 
        "params": [], 
        "path": "python/library/curses.ascii#curses.ascii.unctrl", 
        "syntax": "curses.ascii.unctrl(c)", 
        "type": "Operating System"
    }, 
    "curses.baudrate": {
        "descr": "Return the output speed of the terminal in bits per second. On software terminal emulators it will have a fixed high value. Included for historical reasons; in former times, it was used to write output loops for time delays and occasionally to change interfaces depending on the line speed.", 
        "name": "curses.baudrate", 
        "params": [], 
        "path": "python/library/curses#curses.baudrate", 
        "syntax": "curses.baudrate()", 
        "type": "Operating System"
    }, 
    "curses.beep": {
        "descr": "Emit a short attention sound.", 
        "name": "curses.beep", 
        "params": [], 
        "path": "python/library/curses#curses.beep", 
        "syntax": "curses.beep()", 
        "type": "Operating System"
    }, 
    "curses.can_change_color": {
        "descr": "Return True or False, depending on whether the programmer can change the colors displayed by the terminal.", 
        "name": "curses.can_change_color", 
        "params": [], 
        "path": "python/library/curses#curses.can_change_color", 
        "syntax": "curses.can_change_color()", 
        "type": "Operating System"
    }, 
    "curses.cbreak": {
        "descr": "Enter cbreak mode. In cbreak mode (sometimes called \u201crare\u201d mode) normal tty line buffering is turned off and characters are available to be read one by one. However, unlike raw mode, special characters (interrupt, quit, suspend, and flow control) retain their effects on the tty driver and calling program. Calling first raw() then cbreak() leaves the terminal in cbreak mode.", 
        "name": "curses.cbreak", 
        "params": [], 
        "path": "python/library/curses#curses.cbreak", 
        "syntax": "curses.cbreak()", 
        "type": "Operating System"
    }, 
    "curses.color_content": {
        "descr": "Return the intensity of the red, green, and blue (RGB) components in the color color_number, which must be between 0 and COLORS. A 3-tuple is returned, containing the R,G,B values for the given color, which will be between 0 (no component) and 1000 (maximum amount of component).", 
        "name": "curses.color_content", 
        "params": [], 
        "path": "python/library/curses#curses.color_content", 
        "syntax": "curses.color_content(color_number)", 
        "type": "Operating System"
    }, 
    "curses.color_pair": {
        "descr": "Return the attribute value for displaying text in the specified color. This attribute value can be combined with A_STANDOUT, A_REVERSE, and the other A_* attributes. pair_number() is the counterpart to this function.", 
        "name": "curses.color_pair", 
        "params": [], 
        "path": "python/library/curses#curses.color_pair", 
        "syntax": "curses.color_pair(color_number)", 
        "type": "Operating System"
    }, 
    "curses.curs_set": {
        "descr": "Set the cursor state. visibility can be set to 0, 1, or 2, for invisible, normal, or very visible. If the terminal supports the visibility requested, the previous cursor state is returned; otherwise, an exception is raised. On many terminals, the \u201cvisible\u201d mode is an underline cursor and the \u201cvery visible\u201d mode is a block cursor.", 
        "name": "curses.curs_set", 
        "params": [], 
        "path": "python/library/curses#curses.curs_set", 
        "syntax": "curses.curs_set(visibility)", 
        "type": "Operating System"
    }, 
    "curses.def_prog_mode": {
        "descr": "Save the current terminal mode as the \u201cprogram\u201d mode, the mode when the running program is using curses. (Its counterpart is the \u201cshell\u201d mode, for when the program is not in curses.) Subsequent calls to reset_prog_mode() will restore this mode.", 
        "name": "curses.def_prog_mode", 
        "params": [], 
        "path": "python/library/curses#curses.def_prog_mode", 
        "syntax": "curses.def_prog_mode()", 
        "type": "Operating System"
    }, 
    "curses.def_shell_mode": {
        "descr": "Save the current terminal mode as the \u201cshell\u201d mode, the mode when the running program is not using curses. (Its counterpart is the \u201cprogram\u201d mode, when the program is using curses capabilities.) Subsequent calls to reset_shell_mode() will restore this mode.", 
        "name": "curses.def_shell_mode", 
        "params": [], 
        "path": "python/library/curses#curses.def_shell_mode", 
        "syntax": "curses.def_shell_mode()", 
        "type": "Operating System"
    }, 
    "curses.delay_output": {
        "descr": "Insert an ms millisecond pause in output.", 
        "name": "curses.delay_output", 
        "params": [], 
        "path": "python/library/curses#curses.delay_output", 
        "syntax": "curses.delay_output(ms)", 
        "type": "Operating System"
    }, 
    "curses.doupdate": {
        "descr": "Update the physical screen. The curses library keeps two data structures, one representing the current physical screen contents and a virtual screen representing the desired next state. The doupdate() ground updates the physical screen to match the virtual screen.", 
        "name": "curses.doupdate", 
        "params": [], 
        "path": "python/library/curses#curses.doupdate", 
        "syntax": "curses.doupdate()", 
        "type": "Operating System"
    }, 
    "curses.echo": {
        "descr": "Enter echo mode. In echo mode, each character input is echoed to the screen as it is entered.", 
        "name": "curses.echo", 
        "params": [], 
        "path": "python/library/curses#curses.echo", 
        "syntax": "curses.echo()", 
        "type": "Operating System"
    }, 
    "curses.endwin": {
        "descr": "De-initialize the library, and return terminal to normal status.", 
        "name": "curses.endwin", 
        "params": [], 
        "path": "python/library/curses#curses.endwin", 
        "syntax": "curses.endwin()", 
        "type": "Operating System"
    }, 
    "curses.erasechar": {
        "descr": "Return the user\u2019s current erase character. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself.", 
        "name": "curses.erasechar", 
        "params": [], 
        "path": "python/library/curses#curses.erasechar", 
        "syntax": "curses.erasechar()", 
        "type": "Operating System"
    }, 
    "curses.error": {
        "descr": "Exception raised when a curses library function returns an error.", 
        "name": "curses.error", 
        "params": [], 
        "path": "python/library/curses#curses.error", 
        "syntax": "exception curses.error", 
        "type": "Operating System"
    }, 
    "curses.filter": {
        "descr": "The filter() routine, if used, must be called before initscr() is called. The effect is that, during those calls, LINES is set to 1; the capabilities clear, cup, cud, cud1, cuu1, cuu, vpa are disabled; and the home string is set to the value of cr. The effect is that the cursor is confined to the current line, and so are screen updates. This may be used for enabling character-at-a-time line editing without touching the rest of the screen.", 
        "name": "curses.filter", 
        "params": [], 
        "path": "python/library/curses#curses.filter", 
        "syntax": "curses.filter()", 
        "type": "Operating System"
    }, 
    "curses.flash": {
        "descr": "Flash the screen. That is, change it to reverse-video and then change it back in a short interval. Some people prefer such as \u2018visible bell\u2019 to the audible attention signal produced by beep().", 
        "name": "curses.flash", 
        "params": [], 
        "path": "python/library/curses#curses.flash", 
        "syntax": "curses.flash()", 
        "type": "Operating System"
    }, 
    "curses.flushinp": {
        "descr": "Flush all input buffers. This throws away any typeahead that has been typed by the user and has not yet been processed by the program.", 
        "name": "curses.flushinp", 
        "params": [], 
        "path": "python/library/curses#curses.flushinp", 
        "syntax": "curses.flushinp()", 
        "type": "Operating System"
    }, 
    "curses.getmouse": {
        "descr": "After getch() returns KEY_MOUSE to signal a mouse event, this method should be call to retrieve the queued mouse event, represented as a 5-tuple (id, x, y, z, bstate). id is an ID value used to distinguish multiple devices, and x, y, z are the event\u2019s coordinates. (z is currently unused.) bstate is an integer value whose bits will be set to indicate the type of event, and will be the bitwise OR of one or more of the following constants, where n is the button number from 1 to 4: BUTTONn_PRESSED, BUTTONn_RELEASED, BUTTONn_CLICKED, BUTTONn_DOUBLE_CLICKED, BUTTONn_TRIPLE_CLICKED, BUTTON_SHIFT, BUTTON_CTRL, BUTTON_ALT.", 
        "name": "curses.getmouse", 
        "params": [], 
        "path": "python/library/curses#curses.getmouse", 
        "syntax": "curses.getmouse()", 
        "type": "Operating System"
    }, 
    "curses.getsyx": {
        "descr": "Return the current coordinates of the virtual screen cursor in y and x. If leaveok is currently true, then -1,-1 is returned.", 
        "name": "curses.getsyx", 
        "params": [], 
        "path": "python/library/curses#curses.getsyx", 
        "syntax": "curses.getsyx()", 
        "type": "Operating System"
    }, 
    "curses.getwin": {
        "descr": "Read window related data stored in the file by an earlier putwin() call. The routine then creates and initializes a new window using that data, returning the new window object.", 
        "name": "curses.getwin", 
        "params": [], 
        "path": "python/library/curses#curses.getwin", 
        "syntax": "curses.getwin(file)", 
        "type": "Operating System"
    }, 
    "curses.halfdelay": {
        "descr": "Used for half-delay mode, which is similar to cbreak mode in that characters typed by the user are immediately available to the program. However, after blocking for tenths tenths of seconds, an exception is raised if nothing has been typed. The value of tenths must be a number between 1 and 255. Use nocbreak() to leave half-delay mode.", 
        "name": "curses.halfdelay", 
        "params": [], 
        "path": "python/library/curses#curses.halfdelay", 
        "syntax": "curses.halfdelay(tenths)", 
        "type": "Operating System"
    }, 
    "curses.has_colors": {
        "descr": "Return True if the terminal can display colors; otherwise, return False.", 
        "name": "curses.has_colors", 
        "params": [], 
        "path": "python/library/curses#curses.has_colors", 
        "syntax": "curses.has_colors()", 
        "type": "Operating System"
    }, 
    "curses.has_ic": {
        "descr": "Return True if the terminal has insert- and delete-character capabilities. This function is included for historical reasons only, as all modern software terminal emulators have such capabilities.", 
        "name": "curses.has_ic", 
        "params": [], 
        "path": "python/library/curses#curses.has_ic", 
        "syntax": "curses.has_ic()", 
        "type": "Operating System"
    }, 
    "curses.has_il": {
        "descr": "Return True if the terminal has insert- and delete-line capabilities, or can simulate them using scrolling regions. This function is included for historical reasons only, as all modern software terminal emulators have such capabilities.", 
        "name": "curses.has_il", 
        "params": [], 
        "path": "python/library/curses#curses.has_il", 
        "syntax": "curses.has_il()", 
        "type": "Operating System"
    }, 
    "curses.has_key": {
        "descr": "Take a key value ch, and return True if the current terminal type recognizes a key with that value.", 
        "name": "curses.has_key", 
        "params": [], 
        "path": "python/library/curses#curses.has_key", 
        "syntax": "curses.has_key(ch)", 
        "type": "Operating System"
    }, 
    "curses.init_color": {
        "descr": "Change the definition of a color, taking the number of the color to be changed followed by three RGB values (for the amounts of red, green, and blue components). The value of color_number must be between 0 and COLORS. Each of r, g, b, must be a value between 0 and 1000. When init_color() is used, all occurrences of that color on the screen immediately change to the new definition. This function is a no-op on most terminals; it is active only if can_change_color() returns 1.", 
        "name": "curses.init_color", 
        "params": [], 
        "path": "python/library/curses#curses.init_color", 
        "syntax": "curses.init_color(color_number, r, g, b)", 
        "type": "Operating System"
    }, 
    "curses.init_pair": {
        "descr": "Change the definition of a color-pair. It takes three arguments: the number of the color-pair to be changed, the foreground color number, and the background color number. The value of pair_number must be between 1 and COLOR_PAIRS - 1 (the 0 color pair is wired to white on black and cannot be changed). The value of fg and bg arguments must be between 0 and COLORS. If the color-pair was previously initialized, the screen is refreshed and all occurrences of that color-pair are changed to the new definition.", 
        "name": "curses.init_pair", 
        "params": [], 
        "path": "python/library/curses#curses.init_pair", 
        "syntax": "curses.init_pair(pair_number, fg, bg)", 
        "type": "Operating System"
    }, 
    "curses.initscr": {
        "descr": "Initialize the library. Return a WindowObject which represents the whole screen.", 
        "name": "curses.initscr", 
        "params": [], 
        "path": "python/library/curses#curses.initscr", 
        "syntax": "curses.initscr()", 
        "type": "Operating System"
    }, 
    "curses.is_term_resized": {
        "descr": "Return True if resize_term() would modify the window structure, False otherwise.", 
        "name": "curses.is_term_resized", 
        "params": [], 
        "path": "python/library/curses#curses.is_term_resized", 
        "syntax": "curses.is_term_resized(nlines, ncols)", 
        "type": "Operating System"
    }, 
    "curses.isendwin": {
        "descr": "Return True if endwin() has been called (that is, the curses library has been deinitialized).", 
        "name": "curses.isendwin", 
        "params": [], 
        "path": "python/library/curses#curses.isendwin", 
        "syntax": "curses.isendwin()", 
        "type": "Operating System"
    }, 
    "curses.keyname": {
        "descr": "Return the name of the key numbered k. The name of a key generating printable ASCII character is the key\u2019s character. The name of a control-key combination is a two-character string consisting of a caret followed by the corresponding printable ASCII character. The name of an alt-key combination (128-255) is a string consisting of the prefix \u2018M-\u2018 followed by the name of the corresponding ASCII character.", 
        "name": "curses.keyname", 
        "params": [], 
        "path": "python/library/curses#curses.keyname", 
        "syntax": "curses.keyname(k)", 
        "type": "Operating System"
    }, 
    "curses.killchar": {
        "descr": "Return the user\u2019s current line kill character. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself.", 
        "name": "curses.killchar", 
        "params": [], 
        "path": "python/library/curses#curses.killchar", 
        "syntax": "curses.killchar()", 
        "type": "Operating System"
    }, 
    "curses.longname": {
        "descr": "Return a string containing the terminfo long name field describing the current terminal. The maximum length of a verbose description is 128 characters. It is defined only after the call to initscr().", 
        "name": "curses.longname", 
        "params": [], 
        "path": "python/library/curses#curses.longname", 
        "syntax": "curses.longname()", 
        "type": "Operating System"
    }, 
    "curses.meta": {
        "descr": "If yes is 1, allow 8-bit characters to be input. If yes is 0, allow only 7-bit chars.", 
        "name": "curses.meta", 
        "params": [], 
        "path": "python/library/curses#curses.meta", 
        "syntax": "curses.meta(yes)", 
        "type": "Operating System"
    }, 
    "curses.mouseinterval": {
        "descr": "Set the maximum time in milliseconds that can elapse between press and release events in order for them to be recognized as a click, and return the previous interval value. The default value is 200 msec, or one fifth of a second.", 
        "name": "curses.mouseinterval", 
        "params": [], 
        "path": "python/library/curses#curses.mouseinterval", 
        "syntax": "curses.mouseinterval(interval)", 
        "type": "Operating System"
    }, 
    "curses.mousemask": {
        "descr": "Set the mouse events to be reported, and return a tuple (availmask, oldmask). availmask indicates which of the specified mouse events can be reported; on complete failure it returns 0. oldmask is the previous value of the given window\u2019s mouse event mask. If this function is never called, no mouse events are ever reported.", 
        "name": "curses.mousemask", 
        "params": [], 
        "path": "python/library/curses#curses.mousemask", 
        "syntax": "curses.mousemask(mousemask)", 
        "type": "Operating System"
    }, 
    "curses.napms": {
        "descr": "Sleep for ms milliseconds.", 
        "name": "curses.napms", 
        "params": [], 
        "path": "python/library/curses#curses.napms", 
        "syntax": "curses.napms(ms)", 
        "type": "Operating System"
    }, 
    "curses.newpad": {
        "descr": "Create and return a pointer to a new pad data structure with the given number of lines and columns. A pad is returned as a window object.", 
        "name": "curses.newpad", 
        "params": [], 
        "path": "python/library/curses#curses.newpad", 
        "syntax": "curses.newpad(nlines, ncols)", 
        "type": "Operating System"
    }, 
    "curses.newwin": {
        "descr": "Return a new window, whose left-upper corner is at (begin_y, begin_x), and whose height/width is nlines/ncols.", 
        "name": "curses.newwin", 
        "params": [], 
        "path": "python/library/curses#curses.newwin", 
        "syntax": "curses.newwin(nlines, ncols)", 
        "type": "Operating System"
    }, 
    "curses.nl": {
        "descr": "Enter newline mode. This mode translates the return key into newline on input, and translates newline into return and line-feed on output. Newline mode is initially on.", 
        "name": "curses.nl", 
        "params": [], 
        "path": "python/library/curses#curses.nl", 
        "syntax": "curses.nl()", 
        "type": "Operating System"
    }, 
    "curses.nocbreak": {
        "descr": "Leave cbreak mode. Return to normal \u201ccooked\u201d mode with line buffering.", 
        "name": "curses.nocbreak", 
        "params": [], 
        "path": "python/library/curses#curses.nocbreak", 
        "syntax": "curses.nocbreak()", 
        "type": "Operating System"
    }, 
    "curses.noecho": {
        "descr": "Leave echo mode. Echoing of input characters is turned off.", 
        "name": "curses.noecho", 
        "params": [], 
        "path": "python/library/curses#curses.noecho", 
        "syntax": "curses.noecho()", 
        "type": "Operating System"
    }, 
    "curses.nonl": {
        "descr": "Leave newline mode. Disable translation of return into newline on input, and disable low-level translation of newline into newline/return on output (but this does not change the behavior of addch('\\n'), which always does the equivalent of return and line feed on the virtual screen). With translation off, curses can sometimes speed up vertical motion a little; also, it will be able to detect the return key on input.", 
        "name": "curses.nonl", 
        "params": [], 
        "path": "python/library/curses#curses.nonl", 
        "syntax": "curses.nonl()", 
        "type": "Operating System"
    }, 
    "curses.noqiflush": {
        "descr": "When the noqiflush() routine is used, normal flush of input and output queues associated with the INTR, QUIT and SUSP characters will not be done. You may want to call noqiflush() in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits.", 
        "name": "curses.noqiflush", 
        "params": [], 
        "path": "python/library/curses#curses.noqiflush", 
        "syntax": "curses.noqiflush()", 
        "type": "Operating System"
    }, 
    "curses.noraw": {
        "descr": "Leave raw mode. Return to normal \u201ccooked\u201d mode with line buffering.", 
        "name": "curses.noraw", 
        "params": [], 
        "path": "python/library/curses#curses.noraw", 
        "syntax": "curses.noraw()", 
        "type": "Operating System"
    }, 
    "curses.pair_content": {
        "descr": "Return a tuple (fg, bg) containing the colors for the requested color pair. The value of pair_number must be between 1 and COLOR_PAIRS - 1.", 
        "name": "curses.pair_content", 
        "params": [], 
        "path": "python/library/curses#curses.pair_content", 
        "syntax": "curses.pair_content(pair_number)", 
        "type": "Operating System"
    }, 
    "curses.pair_number": {
        "descr": "Return the number of the color-pair set by the attribute value attr. color_pair() is the counterpart to this function.", 
        "name": "curses.pair_number", 
        "params": [], 
        "path": "python/library/curses#curses.pair_number", 
        "syntax": "curses.pair_number(attr)", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.above": {
        "descr": "Returns the panel above the current panel.", 
        "name": "curses.panel.Panel.above", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.above", 
        "syntax": "Panel.above()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.below": {
        "descr": "Returns the panel below the current panel.", 
        "name": "curses.panel.Panel.below", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.below", 
        "syntax": "Panel.below()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.bottom": {
        "descr": "Push the panel to the bottom of the stack.", 
        "name": "curses.panel.Panel.bottom", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.bottom", 
        "syntax": "Panel.bottom()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.hidden": {
        "descr": "Returns true if the panel is hidden (not visible), false otherwise.", 
        "name": "curses.panel.Panel.hidden", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.hidden", 
        "syntax": "Panel.hidden()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.hide": {
        "descr": "Hide the panel. This does not delete the object, it just makes the window on screen invisible.", 
        "name": "curses.panel.Panel.hide", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.hide", 
        "syntax": "Panel.hide()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.move": {
        "descr": "Move the panel to the screen coordinates (y, x).", 
        "name": "curses.panel.Panel.move", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.move", 
        "syntax": "Panel.move(y, x)", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.replace": {
        "descr": "Change the window associated with the panel to the window win.", 
        "name": "curses.panel.Panel.replace", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.replace", 
        "syntax": "Panel.replace(win)", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.set_userptr": {
        "descr": "Set the panel\u2019s user pointer to obj. This is used to associate an arbitrary piece of data with the panel, and can be any Python object.", 
        "name": "curses.panel.Panel.set_userptr", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.set_userptr", 
        "syntax": "Panel.set_userptr(obj)", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.show": {
        "descr": "Display the panel (which might have been hidden).", 
        "name": "curses.panel.Panel.show", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.show", 
        "syntax": "Panel.show()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.top": {
        "descr": "Push panel to the top of the stack.", 
        "name": "curses.panel.Panel.top", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.top", 
        "syntax": "Panel.top()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.userptr": {
        "descr": "Returns the user pointer for the panel. This might be any Python object.", 
        "name": "curses.panel.Panel.userptr", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.userptr", 
        "syntax": "Panel.userptr()", 
        "type": "Operating System"
    }, 
    "curses.panel.Panel.window": {
        "descr": "Returns the window object associated with the panel.", 
        "name": "curses.panel.Panel.window", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.Panel.window", 
        "syntax": "Panel.window()", 
        "type": "Operating System"
    }, 
    "curses.panel.bottom_panel": {
        "descr": "Returns the bottom panel in the panel stack.", 
        "name": "curses.panel.bottom_panel", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.bottom_panel", 
        "syntax": "curses.panel.bottom_panel()", 
        "type": "Operating System"
    }, 
    "curses.panel.new_panel": {
        "descr": "Returns a panel object, associating it with the given window win. Be aware that you need to keep the returned panel object referenced explicitly. If you don\u2019t, the panel object is garbage collected and removed from the panel stack.", 
        "name": "curses.panel.new_panel", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.new_panel", 
        "syntax": "curses.panel.new_panel(win)", 
        "type": "Operating System"
    }, 
    "curses.panel.top_panel": {
        "descr": "Returns the top panel in the panel stack.", 
        "name": "curses.panel.top_panel", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.top_panel", 
        "syntax": "curses.panel.top_panel()", 
        "type": "Operating System"
    }, 
    "curses.panel.update_panels": {
        "descr": "Updates the virtual screen after changes in the panel stack. This does not call curses.doupdate(), so you\u2019ll have to do this yourself.", 
        "name": "curses.panel.update_panels", 
        "params": [], 
        "path": "python/library/curses.panel#curses.panel.update_panels", 
        "syntax": "curses.panel.update_panels()", 
        "type": "Operating System"
    }, 
    "curses.putp": {
        "descr": "Equivalent to tputs(str, 1, putchar); emit the value of a specified terminfo capability for the current terminal. Note that the output of putp() always goes to standard output.", 
        "name": "curses.putp", 
        "params": [], 
        "path": "python/library/curses#curses.putp", 
        "syntax": "curses.putp(string)", 
        "type": "Operating System"
    }, 
    "curses.qiflush": {
        "descr": "If flag is False, the effect is the same as calling noqiflush(). If flag is True, or no argument is provided, the queues will be flushed when these control characters are read.", 
        "name": "curses.qiflush", 
        "params": [], 
        "path": "python/library/curses#curses.qiflush", 
        "syntax": "curses.qiflush([flag])", 
        "type": "Operating System"
    }, 
    "curses.raw": {
        "descr": "Enter raw mode. In raw mode, normal line buffering and processing of interrupt, quit, suspend, and flow control keys are turned off; characters are presented to curses input functions one by one.", 
        "name": "curses.raw", 
        "params": [], 
        "path": "python/library/curses#curses.raw", 
        "syntax": "curses.raw()", 
        "type": "Operating System"
    }, 
    "curses.reset_prog_mode": {
        "descr": "Restore the terminal to \u201cprogram\u201d mode, as previously saved by def_prog_mode().", 
        "name": "curses.reset_prog_mode", 
        "params": [], 
        "path": "python/library/curses#curses.reset_prog_mode", 
        "syntax": "curses.reset_prog_mode()", 
        "type": "Operating System"
    }, 
    "curses.reset_shell_mode": {
        "descr": "Restore the terminal to \u201cshell\u201d mode, as previously saved by def_shell_mode().", 
        "name": "curses.reset_shell_mode", 
        "params": [], 
        "path": "python/library/curses#curses.reset_shell_mode", 
        "syntax": "curses.reset_shell_mode()", 
        "type": "Operating System"
    }, 
    "curses.resetty": {
        "descr": "Restore the state of the terminal modes to what it was at the last call to savetty().", 
        "name": "curses.resetty", 
        "params": [], 
        "path": "python/library/curses#curses.resetty", 
        "syntax": "curses.resetty()", 
        "type": "Operating System"
    }, 
    "curses.resize_term": {
        "descr": "Backend function used by resizeterm(), performing most of the work; when resizing the windows, resize_term() blank-fills the areas that are extended. The calling application should fill in these areas with appropriate data. The resize_term() function attempts to resize all windows. However, due to the calling convention of pads, it is not possible to resize these without additional interaction with the application.", 
        "name": "curses.resize_term", 
        "params": [], 
        "path": "python/library/curses#curses.resize_term", 
        "syntax": "curses.resize_term(nlines, ncols)", 
        "type": "Operating System"
    }, 
    "curses.resizeterm": {
        "descr": "Resize the standard and current windows to the specified dimensions, and adjusts other bookkeeping data used by the curses library that record the window dimensions (in particular the SIGWINCH handler).", 
        "name": "curses.resizeterm", 
        "params": [], 
        "path": "python/library/curses#curses.resizeterm", 
        "syntax": "curses.resizeterm(nlines, ncols)", 
        "type": "Operating System"
    }, 
    "curses.savetty": {
        "descr": "Save the current state of the terminal modes in a buffer, usable by resetty().", 
        "name": "curses.savetty", 
        "params": [], 
        "path": "python/library/curses#curses.savetty", 
        "syntax": "curses.savetty()", 
        "type": "Operating System"
    }, 
    "curses.setsyx": {
        "descr": "Set the virtual screen cursor to y, x. If y and x are both -1, then leaveok is set.", 
        "name": "curses.setsyx", 
        "params": [], 
        "path": "python/library/curses#curses.setsyx", 
        "syntax": "curses.setsyx(y, x)", 
        "type": "Operating System"
    }, 
    "curses.setupterm": {
        "descr": "Initialize the terminal. termstr is a string giving the terminal name; if omitted, the value of the TERM environment variable will be used. fd is the file descriptor to which any initialization sequences will be sent; if not supplied, the file descriptor for sys.stdout will be used.", 
        "name": "curses.setupterm", 
        "params": [], 
        "path": "python/library/curses#curses.setupterm", 
        "syntax": "curses.setupterm([termstr, fd])", 
        "type": "Operating System"
    }, 
    "curses.start_color": {
        "descr": "Must be called if the programmer wants to use colors, and before any other color manipulation routine is called. It is good practice to call this routine right after initscr().", 
        "name": "curses.start_color", 
        "params": [], 
        "path": "python/library/curses#curses.start_color", 
        "syntax": "curses.start_color()", 
        "type": "Operating System"
    }, 
    "curses.termattrs": {
        "descr": "Return a logical OR of all video attributes supported by the terminal. This information is useful when a curses program needs complete control over the appearance of the screen.", 
        "name": "curses.termattrs", 
        "params": [], 
        "path": "python/library/curses#curses.termattrs", 
        "syntax": "curses.termattrs()", 
        "type": "Operating System"
    }, 
    "curses.termname": {
        "descr": "Return the value of the environment variable TERM, truncated to 14 characters.", 
        "name": "curses.termname", 
        "params": [], 
        "path": "python/library/curses#curses.termname", 
        "syntax": "curses.termname()", 
        "type": "Operating System"
    }, 
    "curses.tigetflag": {
        "descr": "Return the value of the Boolean capability corresponding to the terminfo capability name capname. The value -1 is returned if capname is not a Boolean capability, or 0 if it is canceled or absent from the terminal description.", 
        "name": "curses.tigetflag", 
        "params": [], 
        "path": "python/library/curses#curses.tigetflag", 
        "syntax": "curses.tigetflag(capname)", 
        "type": "Operating System"
    }, 
    "curses.tigetnum": {
        "descr": "Return the value of the numeric capability corresponding to the terminfo capability name capname. The value -2 is returned if capname is not a numeric capability, or -1 if it is canceled or absent from the terminal description.", 
        "name": "curses.tigetnum", 
        "params": [], 
        "path": "python/library/curses#curses.tigetnum", 
        "syntax": "curses.tigetnum(capname)", 
        "type": "Operating System"
    }, 
    "curses.tigetstr": {
        "descr": "Return the value of the string capability corresponding to the terminfo capability name capname. None is returned if capname is not a string capability, or is canceled or absent from the terminal description.", 
        "name": "curses.tigetstr", 
        "params": [], 
        "path": "python/library/curses#curses.tigetstr", 
        "syntax": "curses.tigetstr(capname)", 
        "type": "Operating System"
    }, 
    "curses.tparm": {
        "descr": "Instantiate the string str with the supplied parameters, where str should be a parameterized string obtained from the terminfo database. E.g. tparm(tigetstr(\"cup\"), 5, 3) could result in b'\\033[6;4H', the exact result depending on terminal type.", 
        "name": "curses.tparm", 
        "params": [], 
        "path": "python/library/curses#curses.tparm", 
        "syntax": "curses.tparm(str[, ...])", 
        "type": "Operating System"
    }, 
    "curses.typeahead": {
        "descr": "Specify that the file descriptor fd be used for typeahead checking. If fd is -1, then no typeahead checking is done.", 
        "name": "curses.typeahead", 
        "params": [], 
        "path": "python/library/curses#curses.typeahead", 
        "syntax": "curses.typeahead(fd)", 
        "type": "Operating System"
    }, 
    "curses.unctrl": {
        "descr": "Return a string which is a printable representation of the character ch. Control characters are displayed as a caret followed by the character, for example as ^C. Printing characters are left as they are.", 
        "name": "curses.unctrl", 
        "params": [], 
        "path": "python/library/curses#curses.unctrl", 
        "syntax": "curses.unctrl(ch)", 
        "type": "Operating System"
    }, 
    "curses.unget_wch": {
        "descr": "Push ch so the next get_wch() will return it.", 
        "name": "curses.unget_wch", 
        "params": [], 
        "path": "python/library/curses#curses.unget_wch", 
        "syntax": "curses.unget_wch(ch)", 
        "type": "Operating System"
    }, 
    "curses.ungetch": {
        "descr": "Push ch so the next getch() will return it.", 
        "name": "curses.ungetch", 
        "params": [], 
        "path": "python/library/curses#curses.ungetch", 
        "syntax": "curses.ungetch(ch)", 
        "type": "Operating System"
    }, 
    "curses.ungetmouse": {
        "descr": "Push a KEY_MOUSE event onto the input queue, associating the given state data with it.", 
        "name": "curses.ungetmouse", 
        "params": [], 
        "path": "python/library/curses#curses.ungetmouse", 
        "syntax": "curses.ungetmouse(id, x, y, z, bstate)", 
        "type": "Operating System"
    }, 
    "curses.use_default_colors": {
        "descr": "Allow use of default values for colors on terminals supporting this feature. Use this to support transparency in your application. The default color is assigned to the color number -1. After calling this function, init_pair(x, curses.COLOR_RED, -1) initializes, for instance, color pair x to a red foreground color on the default background.", 
        "name": "curses.use_default_colors", 
        "params": [], 
        "path": "python/library/curses#curses.use_default_colors", 
        "syntax": "curses.use_default_colors()", 
        "type": "Operating System"
    }, 
    "curses.use_env": {
        "descr": "If used, this function should be called before initscr() or newterm are called. When flag is False, the values of lines and columns specified in the terminfo database will be used, even if environment variables LINES and COLUMNS (used by default) are set, or if curses is running in a window (in which case default behavior would be to use the window size if LINES and COLUMNS are not set).", 
        "name": "curses.use_env", 
        "params": [], 
        "path": "python/library/curses#curses.use_env", 
        "syntax": "curses.use_env(flag)", 
        "type": "Operating System"
    }, 
    "curses.version": {
        "descr": "A string representing the current version of the module. Also available as __version__.", 
        "name": "curses.version", 
        "params": [], 
        "path": "python/library/curses#curses.version", 
        "syntax": "curses.version", 
        "type": "Operating System"
    }, 
    "curses.window.addch": {
        "descr": "Paint character ch at (y, x) with attributes attr, overwriting any character previously painter at that location. By default, the character position and attributes are the current settings for the window object.", 
        "name": "curses.window.addch", 
        "params": [], 
        "path": "python/library/curses#curses.window.addch", 
        "syntax": "window.addch(ch[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.addnstr": {
        "descr": "Paint at most n characters of the string str at (y, x) with attributes attr, overwriting anything previously on the display.", 
        "name": "curses.window.addnstr", 
        "params": [], 
        "path": "python/library/curses#curses.window.addnstr", 
        "syntax": "window.addnstr(str, n[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.addstr": {
        "descr": "Paint the string str at (y, x) with attributes attr, overwriting anything previously on the display.", 
        "name": "curses.window.addstr", 
        "params": [], 
        "path": "python/library/curses#curses.window.addstr", 
        "syntax": "window.addstr(str[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.attroff": {
        "descr": "Remove attribute attr from the \u201cbackground\u201d set applied to all writes to the current window.", 
        "name": "curses.window.attroff", 
        "params": [], 
        "path": "python/library/curses#curses.window.attroff", 
        "syntax": "window.attroff(attr)", 
        "type": "Operating System"
    }, 
    "curses.window.attron": {
        "descr": "Add attribute attr from the \u201cbackground\u201d set applied to all writes to the current window.", 
        "name": "curses.window.attron", 
        "params": [], 
        "path": "python/library/curses#curses.window.attron", 
        "syntax": "window.attron(attr)", 
        "type": "Operating System"
    }, 
    "curses.window.attrset": {
        "descr": "Set the \u201cbackground\u201d set of attributes to attr. This set is initially 0 (no attributes).", 
        "name": "curses.window.attrset", 
        "params": [], 
        "path": "python/library/curses#curses.window.attrset", 
        "syntax": "window.attrset(attr)", 
        "type": "Operating System"
    }, 
    "curses.window.bkgd": {
        "descr": "Set the background property of the window to the character ch, with attributes attr. The change is then applied to every character position in that window:", 
        "name": "curses.window.bkgd", 
        "params": [], 
        "path": "python/library/curses#curses.window.bkgd", 
        "syntax": "window.bkgd(ch[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.bkgdset": {
        "descr": "Set the window\u2019s background. A window\u2019s background consists of a character and any combination of attributes. The attribute part of the background is combined (OR\u2019ed) with all non-blank characters that are written into the window. Both the character and attribute parts of the background are combined with the blank characters. The background becomes a property of the character and moves with the character through any scrolling and insert/delete line/character operations.", 
        "name": "curses.window.bkgdset", 
        "params": [], 
        "path": "python/library/curses#curses.window.bkgdset", 
        "syntax": "window.bkgdset(ch[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.border": {
        "descr": "Draw a border around the edges of the window. Each parameter specifies the character to use for a specific part of the border; see the table below for more details. The characters can be specified as integers or as one-character strings.", 
        "name": "curses.window.border", 
        "params": [], 
        "path": "python/library/curses#curses.window.border", 
        "syntax": "window.border([ls[, rs[, ts[, bs[, tl[, tr[, bl[, br]]]]]]]])", 
        "type": "Operating System"
    }, 
    "curses.window.box": {
        "descr": "Similar to border(), but both ls and rs are vertch and both ts and bs are horch. The default corner characters are always used by this function.", 
        "name": "curses.window.box", 
        "params": [], 
        "path": "python/library/curses#curses.window.box", 
        "syntax": "window.box([vertch, horch])", 
        "type": "Operating System"
    }, 
    "curses.window.chgat": {
        "descr": "Set the attributes of num characters at the current cursor position, or at position (y, x) if supplied. If no value of num is given or num = -1, the attribute will be set on all the characters to the end of the line. This function does not move the cursor. The changed line will be touched using the touchline() method so that the contents will be redisplayed by the next window refresh.", 
        "name": "curses.window.chgat", 
        "params": [], 
        "path": "python/library/curses#curses.window.chgat", 
        "syntax": "window.chgat(attr)", 
        "type": "Operating System"
    }, 
    "curses.window.clear": {
        "descr": "Like erase(), but also cause the whole window to be repainted upon next call to refresh().", 
        "name": "curses.window.clear", 
        "params": [], 
        "path": "python/library/curses#curses.window.clear", 
        "syntax": "window.clear()", 
        "type": "Operating System"
    }, 
    "curses.window.clearok": {
        "descr": "If yes is 1, the next call to refresh() will clear the window completely.", 
        "name": "curses.window.clearok", 
        "params": [], 
        "path": "python/library/curses#curses.window.clearok", 
        "syntax": "window.clearok(yes)", 
        "type": "Operating System"
    }, 
    "curses.window.clrtobot": {
        "descr": "Erase from cursor to the end of the window: all lines below the cursor are deleted, and then the equivalent of clrtoeol() is performed.", 
        "name": "curses.window.clrtobot", 
        "params": [], 
        "path": "python/library/curses#curses.window.clrtobot", 
        "syntax": "window.clrtobot()", 
        "type": "Operating System"
    }, 
    "curses.window.clrtoeol": {
        "descr": "Erase from cursor to the end of the line.", 
        "name": "curses.window.clrtoeol", 
        "params": [], 
        "path": "python/library/curses#curses.window.clrtoeol", 
        "syntax": "window.clrtoeol()", 
        "type": "Operating System"
    }, 
    "curses.window.cursyncup": {
        "descr": "Update the current cursor position of all the ancestors of the window to reflect the current cursor position of the window.", 
        "name": "curses.window.cursyncup", 
        "params": [], 
        "path": "python/library/curses#curses.window.cursyncup", 
        "syntax": "window.cursyncup()", 
        "type": "Operating System"
    }, 
    "curses.window.delch": {
        "descr": "Delete any character at (y, x).", 
        "name": "curses.window.delch", 
        "params": [], 
        "path": "python/library/curses#curses.window.delch", 
        "syntax": "window.delch([y, x])", 
        "type": "Operating System"
    }, 
    "curses.window.deleteln": {
        "descr": "Delete the line under the cursor. All following lines are moved up by one line.", 
        "name": "curses.window.deleteln", 
        "params": [], 
        "path": "python/library/curses#curses.window.deleteln", 
        "syntax": "window.deleteln()", 
        "type": "Operating System"
    }, 
    "curses.window.derwin": {
        "descr": "An abbreviation for \u201cderive window\u201d, derwin() is the same as calling subwin(), except that begin_y and begin_x are relative to the origin of the window, rather than relative to the entire screen. Return a window object for the derived window.", 
        "name": "curses.window.derwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.derwin", 
        "syntax": "window.derwin(begin_y, begin_x)", 
        "type": "Operating System"
    }, 
    "curses.window.echochar": {
        "descr": "Add character ch with attribute attr, and immediately call refresh() on the window.", 
        "name": "curses.window.echochar", 
        "params": [], 
        "path": "python/library/curses#curses.window.echochar", 
        "syntax": "window.echochar(ch[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.enclose": {
        "descr": "Test whether the given pair of screen-relative character-cell coordinates are enclosed by the given window, returning True or False. It is useful for determining what subset of the screen windows enclose the location of a mouse event.", 
        "name": "curses.window.enclose", 
        "params": [], 
        "path": "python/library/curses#curses.window.enclose", 
        "syntax": "window.enclose(y, x)", 
        "type": "Operating System"
    }, 
    "curses.window.encoding": {
        "descr": "Encoding used to encode method arguments (Unicode strings and characters). The encoding attribute is inherited from the parent window when a subwindow is created, for example with window.subwin(). By default, the locale encoding is used (see locale.getpreferredencoding()).", 
        "name": "curses.window.encoding", 
        "params": [], 
        "path": "python/library/curses#curses.window.encoding", 
        "syntax": "window.encoding", 
        "type": "Operating System"
    }, 
    "curses.window.erase": {
        "descr": "Clear the window.", 
        "name": "curses.window.erase", 
        "params": [], 
        "path": "python/library/curses#curses.window.erase", 
        "syntax": "window.erase()", 
        "type": "Operating System"
    }, 
    "curses.window.get_wch": {
        "descr": "Get a wide character. Return a character for most keys, or an integer for function keys, keypad keys, and other special keys.", 
        "name": "curses.window.get_wch", 
        "params": [], 
        "path": "python/library/curses#curses.window.get_wch", 
        "syntax": "window.get_wch([y, x])", 
        "type": "Operating System"
    }, 
    "curses.window.getbegyx": {
        "descr": "Return a tuple (y, x) of co-ordinates of upper-left corner.", 
        "name": "curses.window.getbegyx", 
        "params": [], 
        "path": "python/library/curses#curses.window.getbegyx", 
        "syntax": "window.getbegyx()", 
        "type": "Operating System"
    }, 
    "curses.window.getbkgd": {
        "descr": "Return the given window\u2019s current background character/attribute pair.", 
        "name": "curses.window.getbkgd", 
        "params": [], 
        "path": "python/library/curses#curses.window.getbkgd", 
        "syntax": "window.getbkgd()", 
        "type": "Operating System"
    }, 
    "curses.window.getch": {
        "descr": "Get a character. Note that the integer returned does not have to be in ASCII range: function keys, keypad keys and so on return numbers higher than 256. In no-delay mode, -1 is returned if there is no input, else getch() waits until a key is pressed.", 
        "name": "curses.window.getch", 
        "params": [], 
        "path": "python/library/curses#curses.window.getch", 
        "syntax": "window.getch([y, x])", 
        "type": "Operating System"
    }, 
    "curses.window.getkey": {
        "descr": "Get a character, returning a string instead of an integer, as getch() does. Function keys, keypad keys and other special keys return a multibyte string containing the key name. In no-delay mode, an exception is raised if there is no input.", 
        "name": "curses.window.getkey", 
        "params": [], 
        "path": "python/library/curses#curses.window.getkey", 
        "syntax": "window.getkey([y, x])", 
        "type": "Operating System"
    }, 
    "curses.window.getmaxyx": {
        "descr": "Return a tuple (y, x) of the height and width of the window.", 
        "name": "curses.window.getmaxyx", 
        "params": [], 
        "path": "python/library/curses#curses.window.getmaxyx", 
        "syntax": "window.getmaxyx()", 
        "type": "Operating System"
    }, 
    "curses.window.getparyx": {
        "descr": "Return the beginning coordinates of this window relative to its parent window into two integer variables y and x. Return -1, -1 if this window has no parent.", 
        "name": "curses.window.getparyx", 
        "params": [], 
        "path": "python/library/curses#curses.window.getparyx", 
        "syntax": "window.getparyx()", 
        "type": "Operating System"
    }, 
    "curses.window.getstr": {
        "descr": "Read a string from the user, with primitive line editing capacity.", 
        "name": "curses.window.getstr", 
        "params": [], 
        "path": "python/library/curses#curses.window.getstr", 
        "syntax": "window.getstr([y, x])", 
        "type": "Operating System"
    }, 
    "curses.window.getyx": {
        "descr": "Return a tuple (y, x) of current cursor position relative to the window\u2019s upper-left corner.", 
        "name": "curses.window.getyx", 
        "params": [], 
        "path": "python/library/curses#curses.window.getyx", 
        "syntax": "window.getyx()", 
        "type": "Operating System"
    }, 
    "curses.window.hline": {
        "descr": "Display a horizontal line starting at (y, x) with length n consisting of the character ch.", 
        "name": "curses.window.hline", 
        "params": [], 
        "path": "python/library/curses#curses.window.hline", 
        "syntax": "window.hline(ch, n)", 
        "type": "Operating System"
    }, 
    "curses.window.idcok": {
        "descr": "If flag is False, curses no longer considers using the hardware insert/delete character feature of the terminal; if flag is True, use of character insertion and deletion is enabled. When curses is first initialized, use of character insert/delete is enabled by default.", 
        "name": "curses.window.idcok", 
        "params": [], 
        "path": "python/library/curses#curses.window.idcok", 
        "syntax": "window.idcok(flag)", 
        "type": "Operating System"
    }, 
    "curses.window.idlok": {
        "descr": "If called with yes equal to 1, curses will try and use hardware line editing facilities. Otherwise, line insertion/deletion are disabled.", 
        "name": "curses.window.idlok", 
        "params": [], 
        "path": "python/library/curses#curses.window.idlok", 
        "syntax": "window.idlok(yes)", 
        "type": "Operating System"
    }, 
    "curses.window.immedok": {
        "descr": "If flag is True, any change in the window image automatically causes the window to be refreshed; you no longer have to call refresh() yourself. However, it may degrade performance considerably, due to repeated calls to wrefresh. This option is disabled by default.", 
        "name": "curses.window.immedok", 
        "params": [], 
        "path": "python/library/curses#curses.window.immedok", 
        "syntax": "window.immedok(flag)", 
        "type": "Operating System"
    }, 
    "curses.window.inch": {
        "descr": "Return the character at the given position in the window. The bottom 8 bits are the character proper, and upper bits are the attributes.", 
        "name": "curses.window.inch", 
        "params": [], 
        "path": "python/library/curses#curses.window.inch", 
        "syntax": "window.inch([y, x])", 
        "type": "Operating System"
    }, 
    "curses.window.insch": {
        "descr": "Paint character ch at (y, x) with attributes attr, moving the line from position x right by one character.", 
        "name": "curses.window.insch", 
        "params": [], 
        "path": "python/library/curses#curses.window.insch", 
        "syntax": "window.insch(ch[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.insdelln": {
        "descr": "Insert nlines lines into the specified window above the current line. The nlines bottom lines are lost. For negative nlines, delete nlines lines starting with the one under the cursor, and move the remaining lines up. The bottom nlines lines are cleared. The current cursor position remains the same.", 
        "name": "curses.window.insdelln", 
        "params": [], 
        "path": "python/library/curses#curses.window.insdelln", 
        "syntax": "window.insdelln(nlines)", 
        "type": "Operating System"
    }, 
    "curses.window.insertln": {
        "descr": "Insert a blank line under the cursor. All following lines are moved down by one line.", 
        "name": "curses.window.insertln", 
        "params": [], 
        "path": "python/library/curses#curses.window.insertln", 
        "syntax": "window.insertln()", 
        "type": "Operating System"
    }, 
    "curses.window.insnstr": {
        "descr": "Insert a character string (as many characters as will fit on the line) before the character under the cursor, up to n characters. If n is zero or negative, the entire string is inserted. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to y, x, if specified).", 
        "name": "curses.window.insnstr", 
        "params": [], 
        "path": "python/library/curses#curses.window.insnstr", 
        "syntax": "window.insnstr(str, n[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.insstr": {
        "descr": "Insert a character string (as many characters as will fit on the line) before the character under the cursor. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to y, x, if specified).", 
        "name": "curses.window.insstr", 
        "params": [], 
        "path": "python/library/curses#curses.window.insstr", 
        "syntax": "window.insstr(str[, attr])", 
        "type": "Operating System"
    }, 
    "curses.window.instr": {
        "descr": "Return a string of characters, extracted from the window starting at the current cursor position, or at y, x if specified. Attributes are stripped from the characters. If n is specified, instr() returns a string at most n characters long (exclusive of the trailing NUL).", 
        "name": "curses.window.instr", 
        "params": [], 
        "path": "python/library/curses#curses.window.instr", 
        "syntax": "window.instr([n])", 
        "type": "Operating System"
    }, 
    "curses.window.is_linetouched": {
        "descr": "Return True if the specified line was modified since the last call to refresh(); otherwise return False. Raise a curses.error exception if line is not valid for the given window.", 
        "name": "curses.window.is_linetouched", 
        "params": [], 
        "path": "python/library/curses#curses.window.is_linetouched", 
        "syntax": "window.is_linetouched(line)", 
        "type": "Operating System"
    }, 
    "curses.window.is_wintouched": {
        "descr": "Return True if the specified window was modified since the last call to refresh(); otherwise return False.", 
        "name": "curses.window.is_wintouched", 
        "params": [], 
        "path": "python/library/curses#curses.window.is_wintouched", 
        "syntax": "window.is_wintouched()", 
        "type": "Operating System"
    }, 
    "curses.window.keypad": {
        "descr": "If yes is 1, escape sequences generated by some keys (keypad, function keys) will be interpreted by curses. If yes is 0, escape sequences will be left as is in the input stream.", 
        "name": "curses.window.keypad", 
        "params": [], 
        "path": "python/library/curses#curses.window.keypad", 
        "syntax": "window.keypad(yes)", 
        "type": "Operating System"
    }, 
    "curses.window.leaveok": {
        "descr": "If yes is 1, cursor is left where it is on update, instead of being at \u201ccursor position.\u201d This reduces cursor movement where possible. If possible the cursor will be made invisible.", 
        "name": "curses.window.leaveok", 
        "params": [], 
        "path": "python/library/curses#curses.window.leaveok", 
        "syntax": "window.leaveok(yes)", 
        "type": "Operating System"
    }, 
    "curses.window.move": {
        "descr": "Move cursor to (new_y, new_x).", 
        "name": "curses.window.move", 
        "params": [], 
        "path": "python/library/curses#curses.window.move", 
        "syntax": "window.move(new_y, new_x)", 
        "type": "Operating System"
    }, 
    "curses.window.mvderwin": {
        "descr": "Move the window inside its parent window. The screen-relative parameters of the window are not changed. This routine is used to display different parts of the parent window at the same physical position on the screen.", 
        "name": "curses.window.mvderwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.mvderwin", 
        "syntax": "window.mvderwin(y, x)", 
        "type": "Operating System"
    }, 
    "curses.window.mvwin": {
        "descr": "Move the window so its upper-left corner is at (new_y, new_x).", 
        "name": "curses.window.mvwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.mvwin", 
        "syntax": "window.mvwin(new_y, new_x)", 
        "type": "Operating System"
    }, 
    "curses.window.nodelay": {
        "descr": "If yes is 1, getch() will be non-blocking.", 
        "name": "curses.window.nodelay", 
        "params": [], 
        "path": "python/library/curses#curses.window.nodelay", 
        "syntax": "window.nodelay(yes)", 
        "type": "Operating System"
    }, 
    "curses.window.notimeout": {
        "descr": "If yes is 1, escape sequences will not be timed out.", 
        "name": "curses.window.notimeout", 
        "params": [], 
        "path": "python/library/curses#curses.window.notimeout", 
        "syntax": "window.notimeout(yes)", 
        "type": "Operating System"
    }, 
    "curses.window.noutrefresh": {
        "descr": "Mark for refresh but wait. This function updates the data structure representing the desired state of the window, but does not force an update of the physical screen. To accomplish that, call doupdate().", 
        "name": "curses.window.noutrefresh", 
        "params": [], 
        "path": "python/library/curses#curses.window.noutrefresh", 
        "syntax": "window.noutrefresh()", 
        "type": "Operating System"
    }, 
    "curses.window.overlay": {
        "descr": "Overlay the window on top of destwin. The windows need not be the same size, only the overlapping region is copied. This copy is non-destructive, which means that the current background character does not overwrite the old contents of destwin.", 
        "name": "curses.window.overlay", 
        "params": [], 
        "path": "python/library/curses#curses.window.overlay", 
        "syntax": "window.overlay(destwin[, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])", 
        "type": "Operating System"
    }, 
    "curses.window.overwrite": {
        "descr": "Overwrite the window on top of destwin. The windows need not be the same size, in which case only the overlapping region is copied. This copy is destructive, which means that the current background character overwrites the old contents of destwin.", 
        "name": "curses.window.overwrite", 
        "params": [], 
        "path": "python/library/curses#curses.window.overwrite", 
        "syntax": "window.overwrite(destwin[, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])", 
        "type": "Operating System"
    }, 
    "curses.window.putwin": {
        "descr": "Write all data associated with the window into the provided file object. This information can be later retrieved using the getwin() function.", 
        "name": "curses.window.putwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.putwin", 
        "syntax": "window.putwin(file)", 
        "type": "Operating System"
    }, 
    "curses.window.redrawln": {
        "descr": "Indicate that the num screen lines, starting at line beg, are corrupted and should be completely redrawn on the next refresh() call.", 
        "name": "curses.window.redrawln", 
        "params": [], 
        "path": "python/library/curses#curses.window.redrawln", 
        "syntax": "window.redrawln(beg, num)", 
        "type": "Operating System"
    }, 
    "curses.window.redrawwin": {
        "descr": "Touch the entire window, causing it to be completely redrawn on the next refresh() call.", 
        "name": "curses.window.redrawwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.redrawwin", 
        "syntax": "window.redrawwin()", 
        "type": "Operating System"
    }, 
    "curses.window.refresh": {
        "descr": "Update the display immediately (sync actual screen with previous drawing/deleting methods).", 
        "name": "curses.window.refresh", 
        "params": [], 
        "path": "python/library/curses#curses.window.refresh", 
        "syntax": "window.refresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])", 
        "type": "Operating System"
    }, 
    "curses.window.resize": {
        "descr": "Reallocate storage for a curses window to adjust its dimensions to the specified values. If either dimension is larger than the current values, the window\u2019s data is filled with blanks that have the current background rendition (as set by bkgdset()) merged into them.", 
        "name": "curses.window.resize", 
        "params": [], 
        "path": "python/library/curses#curses.window.resize", 
        "syntax": "window.resize(nlines, ncols)", 
        "type": "Operating System"
    }, 
    "curses.window.scroll": {
        "descr": "Scroll the screen or scrolling region upward by lines lines.", 
        "name": "curses.window.scroll", 
        "params": [], 
        "path": "python/library/curses#curses.window.scroll", 
        "syntax": "window.scroll([lines=1])", 
        "type": "Operating System"
    }, 
    "curses.window.scrollok": {
        "descr": "Control what happens when the cursor of a window is moved off the edge of the window or scrolling region, either as a result of a newline action on the bottom line, or typing the last character of the last line. If flag is false, the cursor is left on the bottom line. If flag is true, the window is scrolled up one line. Note that in order to get the physical scrolling effect on the terminal, it is also necessary to call idlok().", 
        "name": "curses.window.scrollok", 
        "params": [], 
        "path": "python/library/curses#curses.window.scrollok", 
        "syntax": "window.scrollok(flag)", 
        "type": "Operating System"
    }, 
    "curses.window.setscrreg": {
        "descr": "Set the scrolling region from line top to line bottom. All scrolling actions will take place in this region.", 
        "name": "curses.window.setscrreg", 
        "params": [], 
        "path": "python/library/curses#curses.window.setscrreg", 
        "syntax": "window.setscrreg(top, bottom)", 
        "type": "Operating System"
    }, 
    "curses.window.standend": {
        "descr": "Turn off the standout attribute. On some terminals this has the side effect of turning off all attributes.", 
        "name": "curses.window.standend", 
        "params": [], 
        "path": "python/library/curses#curses.window.standend", 
        "syntax": "window.standend()", 
        "type": "Operating System"
    }, 
    "curses.window.standout": {
        "descr": "Turn on attribute A_STANDOUT.", 
        "name": "curses.window.standout", 
        "params": [], 
        "path": "python/library/curses#curses.window.standout", 
        "syntax": "window.standout()", 
        "type": "Operating System"
    }, 
    "curses.window.subpad": {
        "descr": "Return a sub-window, whose upper-left corner is at (begin_y, begin_x), and whose width/height is ncols/nlines.", 
        "name": "curses.window.subpad", 
        "params": [], 
        "path": "python/library/curses#curses.window.subpad", 
        "syntax": "window.subpad(begin_y, begin_x)", 
        "type": "Operating System"
    }, 
    "curses.window.subwin": {
        "descr": "Return a sub-window, whose upper-left corner is at (begin_y, begin_x), and whose width/height is ncols/nlines.", 
        "name": "curses.window.subwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.subwin", 
        "syntax": "window.subwin(begin_y, begin_x)", 
        "type": "Operating System"
    }, 
    "curses.window.syncdown": {
        "descr": "Touch each location in the window that has been touched in any of its ancestor windows. This routine is called by refresh(), so it should almost never be necessary to call it manually.", 
        "name": "curses.window.syncdown", 
        "params": [], 
        "path": "python/library/curses#curses.window.syncdown", 
        "syntax": "window.syncdown()", 
        "type": "Operating System"
    }, 
    "curses.window.syncok": {
        "descr": "If called with flag set to True, then syncup() is called automatically whenever there is a change in the window.", 
        "name": "curses.window.syncok", 
        "params": [], 
        "path": "python/library/curses#curses.window.syncok", 
        "syntax": "window.syncok(flag)", 
        "type": "Operating System"
    }, 
    "curses.window.syncup": {
        "descr": "Touch all locations in ancestors of the window that have been changed in the window.", 
        "name": "curses.window.syncup", 
        "params": [], 
        "path": "python/library/curses#curses.window.syncup", 
        "syntax": "window.syncup()", 
        "type": "Operating System"
    }, 
    "curses.window.timeout": {
        "descr": "Set blocking or non-blocking read behavior for the window. If delay is negative, blocking read is used (which will wait indefinitely for input). If delay is zero, then non-blocking read is used, and -1 will be returned by getch() if no input is waiting. If delay is positive, then getch() will block for delay milliseconds, and return -1 if there is still no input at the end of that time.", 
        "name": "curses.window.timeout", 
        "params": [], 
        "path": "python/library/curses#curses.window.timeout", 
        "syntax": "window.timeout(delay)", 
        "type": "Operating System"
    }, 
    "curses.window.touchline": {
        "descr": "Pretend count lines have been changed, starting with line start. If changed is supplied, it specifies whether the affected lines are marked as having been changed (changed=1) or unchanged (changed=0).", 
        "name": "curses.window.touchline", 
        "params": [], 
        "path": "python/library/curses#curses.window.touchline", 
        "syntax": "window.touchline(start, count[, changed])", 
        "type": "Operating System"
    }, 
    "curses.window.touchwin": {
        "descr": "Pretend the whole window has been changed, for purposes of drawing optimizations.", 
        "name": "curses.window.touchwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.touchwin", 
        "syntax": "window.touchwin()", 
        "type": "Operating System"
    }, 
    "curses.window.untouchwin": {
        "descr": "Mark all lines in the window as unchanged since the last call to refresh().", 
        "name": "curses.window.untouchwin", 
        "params": [], 
        "path": "python/library/curses#curses.window.untouchwin", 
        "syntax": "window.untouchwin()", 
        "type": "Operating System"
    }, 
    "curses.window.vline": {
        "descr": "Display a vertical line starting at (y, x) with length n consisting of the character ch.", 
        "name": "curses.window.vline", 
        "params": [], 
        "path": "python/library/curses#curses.window.vline", 
        "syntax": "window.vline(ch, n)", 
        "type": "Operating System"
    }, 
    "curses.wrapper": {
        "descr": "Initialize curses and call another callable object, func, which should be the rest of your curses-using application. If the application raises an exception, this function will restore the terminal to a sane state before re-raising the exception and generating a traceback. The callable object func is then passed the main window \u2018stdscr\u2019 as its first argument, followed by any other arguments passed to wrapper(). Before calling func, wrapper() turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.", 
        "name": "curses.wrapper", 
        "params": [], 
        "path": "python/library/curses#curses.wrapper", 
        "syntax": "curses.wrapper(func, ...)", 
        "type": "Operating System"
    }, 
    "datetime.date": {
        "descr": "All arguments are required. Arguments may be integers, in the following ranges:", 
        "name": "datetime.date", 
        "params": [], 
        "path": "python/library/datetime#datetime.date", 
        "syntax": "class datetime.date(year, month, day)", 
        "type": "Data Types"
    }, 
    "datetime.date.__format__": {
        "descr": "Same as date.strftime(). This makes it possible to specify format string for a date object when using str.format(). For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.date.__format__", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.__format__", 
        "syntax": "date.__format__(format)", 
        "type": "Data Types"
    }, 
    "datetime.date.__str__": {
        "descr": "For a date d, str(d) is equivalent to d.isoformat().", 
        "name": "datetime.date.__str__", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.__str__", 
        "syntax": "date.__str__()", 
        "type": "Data Types"
    }, 
    "datetime.date.ctime": {
        "descr": "Return a string representing the date, for example date(2002, 12, 4).ctime() == 'Wed Dec 4 00:00:00 2002'. d.ctime() is equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which date.ctime() does not invoke) conforms to the C standard.", 
        "name": "datetime.date.ctime", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.ctime", 
        "syntax": "date.ctime()", 
        "type": "Data Types"
    }, 
    "datetime.date.day": {
        "descr": "Between 1 and the number of days in the given month of the given year.", 
        "name": "datetime.date.day", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.day", 
        "syntax": "date.day", 
        "type": "Data Types"
    }, 
    "datetime.date.fromordinal": {
        "descr": "Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 <= ordinal <= date.max.toordinal(). For any date d, date.fromordinal(d.toordinal()) == d.", 
        "name": "datetime.date.fromordinal", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.fromordinal", 
        "syntax": "classmethod date.fromordinal(ordinal)", 
        "type": "Data Types"
    }, 
    "datetime.date.fromtimestamp": {
        "descr": "Return the local date corresponding to the POSIX timestamp, such as is returned by time.time(). This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C localtime() function, and OSError on localtime() failure. It\u2019s common for this to be restricted to years from 1970 through 2038. Note that on non-POSIX systems that include leap seconds in their notion of a timestamp, leap seconds are ignored by fromtimestamp().", 
        "name": "datetime.date.fromtimestamp", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.fromtimestamp", 
        "syntax": "classmethod date.fromtimestamp(timestamp)", 
        "type": "Data Types"
    }, 
    "datetime.date.isocalendar": {
        "descr": "Return a 3-tuple, (ISO year, ISO week number, ISO weekday).", 
        "name": "datetime.date.isocalendar", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.isocalendar", 
        "syntax": "date.isocalendar()", 
        "type": "Data Types"
    }, 
    "datetime.date.isoformat": {
        "descr": "Return a string representing the date in ISO 8601 format, \u2018YYYY-MM-DD\u2019. For example, date(2002, 12, 4).isoformat() == '2002-12-04'.", 
        "name": "datetime.date.isoformat", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.isoformat", 
        "syntax": "date.isoformat()", 
        "type": "Data Types"
    }, 
    "datetime.date.isoweekday": {
        "descr": "Return the day of the week as an integer, where Monday is 1 and Sunday is 7. For example, date(2002, 12, 4).isoweekday() == 3, a Wednesday. See also weekday(), isocalendar().", 
        "name": "datetime.date.isoweekday", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.isoweekday", 
        "syntax": "date.isoweekday()", 
        "type": "Data Types"
    }, 
    "datetime.date.max": {
        "descr": "The latest representable date, date(MAXYEAR, 12, 31).", 
        "name": "datetime.date.max", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.max", 
        "syntax": "date.max", 
        "type": "Data Types"
    }, 
    "datetime.date.min": {
        "descr": "The earliest representable date, date(MINYEAR, 1, 1).", 
        "name": "datetime.date.min", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.min", 
        "syntax": "date.min", 
        "type": "Data Types"
    }, 
    "datetime.date.month": {
        "descr": "Between 1 and 12 inclusive.", 
        "name": "datetime.date.month", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.month", 
        "syntax": "date.month", 
        "type": "Data Types"
    }, 
    "datetime.date.replace": {
        "descr": "Return a date with the same value, except for those parameters given new values by whichever keyword arguments are specified. For example, if d == date(2002, 12, 31), then d.replace(day=26) == date(2002, 12, 26).", 
        "name": "datetime.date.replace", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.replace", 
        "syntax": "date.replace(year, month, day)", 
        "type": "Data Types"
    }, 
    "datetime.date.resolution": {
        "descr": "The smallest possible difference between non-equal date objects, timedelta(days=1).", 
        "name": "datetime.date.resolution", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.resolution", 
        "syntax": "date.resolution", 
        "type": "Data Types"
    }, 
    "datetime.date.strftime": {
        "descr": "Return a string representing the date, controlled by an explicit format string. Format codes referring to hours, minutes or seconds will see 0 values. For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.date.strftime", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.strftime", 
        "syntax": "date.strftime(format)", 
        "type": "Data Types"
    }, 
    "datetime.date.timetuple": {
        "descr": "Return a time.struct_time such as returned by time.localtime(). The hours, minutes and seconds are 0, and the DST flag is -1. d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1)), where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st.", 
        "name": "datetime.date.timetuple", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.timetuple", 
        "syntax": "date.timetuple()", 
        "type": "Data Types"
    }, 
    "datetime.date.today": {
        "descr": "Return the current local date. This is equivalent to date.fromtimestamp(time.time()).", 
        "name": "datetime.date.today", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.today", 
        "syntax": "classmethod date.today()", 
        "type": "Data Types"
    }, 
    "datetime.date.toordinal": {
        "descr": "Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1. For any date object d, date.fromordinal(d.toordinal()) == d.", 
        "name": "datetime.date.toordinal", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.toordinal", 
        "syntax": "date.toordinal()", 
        "type": "Data Types"
    }, 
    "datetime.date.weekday": {
        "descr": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6. For example, date(2002, 12, 4).weekday() == 2, a Wednesday. See also isoweekday().", 
        "name": "datetime.date.weekday", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.weekday", 
        "syntax": "date.weekday()", 
        "type": "Data Types"
    }, 
    "datetime.date.year": {
        "descr": "Between MINYEAR and MAXYEAR inclusive.", 
        "name": "datetime.date.year", 
        "params": [], 
        "path": "python/library/datetime#datetime.date.year", 
        "syntax": "date.year", 
        "type": "Data Types"
    }, 
    "datetime.datetime": {
        "descr": "The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be integers, in the following ranges:", 
        "name": "datetime.datetime", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime", 
        "syntax": "class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.__format__": {
        "descr": "Same as datetime.strftime(). This makes it possible to specify format string for a datetime object when using str.format(). For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.datetime.__format__", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.__format__", 
        "syntax": "datetime.__format__(format)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.__str__": {
        "descr": "For a datetime instance d, str(d) is equivalent to d.isoformat(' ').", 
        "name": "datetime.datetime.__str__", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.__str__", 
        "syntax": "datetime.__str__()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.astimezone": {
        "descr": "Return a datetime object with new tzinfo attribute tz, adjusting the date and time data so the result is the same UTC time as self, but in tz\u2018s local time.", 
        "name": "datetime.datetime.astimezone", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.astimezone", 
        "syntax": "datetime.astimezone(tz=None)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.combine": {
        "descr": "Return a new datetime object whose date components are equal to the given date object\u2019s, and whose time components and tzinfo attributes are equal to the given time object\u2019s. For any datetime object d, d == datetime.combine(d.date(), d.timetz()). If date is a datetime object, its time components and tzinfo attributes are ignored.", 
        "name": "datetime.datetime.combine", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.combine", 
        "syntax": "classmethod datetime.combine(date, time)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.ctime": {
        "descr": "Return a string representing the date and time, for example datetime(2002, 12, 4, 20, 30, 40).ctime() == 'Wed Dec 4 20:30:40 2002'. d.ctime() is equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which datetime.ctime() does not invoke) conforms to the C standard.", 
        "name": "datetime.datetime.ctime", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.ctime", 
        "syntax": "datetime.ctime()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.date": {
        "descr": "Return date object with same year, month and day.", 
        "name": "datetime.datetime.date", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.date", 
        "syntax": "datetime.date()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.day": {
        "descr": "Between 1 and the number of days in the given month of the given year.", 
        "name": "datetime.datetime.day", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.day", 
        "syntax": "datetime.day", 
        "type": "Data Types"
    }, 
    "datetime.datetime.dst": {
        "descr": "If tzinfo is None, returns None, else returns self.tzinfo.dst(self), and raises an exception if the latter doesn\u2019t return None, or a timedelta object representing a whole number of minutes with magnitude less than one day.", 
        "name": "datetime.datetime.dst", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.dst", 
        "syntax": "datetime.dst()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.fromordinal": {
        "descr": "Return the datetime corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 <= ordinal <= datetime.max.toordinal(). The hour, minute, second and microsecond of the result are all 0, and tzinfo is None.", 
        "name": "datetime.datetime.fromordinal", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.fromordinal", 
        "syntax": "classmethod datetime.fromordinal(ordinal)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.fromtimestamp": {
        "descr": "Return the local date and time corresponding to the POSIX timestamp, such as is returned by time.time(). If optional argument tz is None or not specified, the timestamp is converted to the platform\u2019s local date and time, and the returned datetime object is naive.", 
        "name": "datetime.datetime.fromtimestamp", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.fromtimestamp", 
        "syntax": "classmethod datetime.fromtimestamp(timestamp, tz=None)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.hour": {
        "descr": "In range(24).", 
        "name": "datetime.datetime.hour", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.hour", 
        "syntax": "datetime.hour", 
        "type": "Data Types"
    }, 
    "datetime.datetime.isocalendar": {
        "descr": "Return a 3-tuple, (ISO year, ISO week number, ISO weekday). The same as self.date().isocalendar().", 
        "name": "datetime.datetime.isocalendar", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.isocalendar", 
        "syntax": "datetime.isocalendar()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.isoformat": {
        "descr": "Return a string representing the date and time in ISO 8601 format, YYYY-MM-DDTHH:MM:SS.mmmmmm or, if microsecond is 0, YYYY-MM-DDTHH:MM:SS", 
        "name": "datetime.datetime.isoformat", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.isoformat", 
        "syntax": "datetime.isoformat(sep='T')", 
        "type": "Data Types"
    }, 
    "datetime.datetime.isoweekday": {
        "descr": "Return the day of the week as an integer, where Monday is 1 and Sunday is 7. The same as self.date().isoweekday(). See also weekday(), isocalendar().", 
        "name": "datetime.datetime.isoweekday", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.isoweekday", 
        "syntax": "datetime.isoweekday()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.max": {
        "descr": "The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).", 
        "name": "datetime.datetime.max", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.max", 
        "syntax": "datetime.max", 
        "type": "Data Types"
    }, 
    "datetime.datetime.microsecond": {
        "descr": "In range(1000000).", 
        "name": "datetime.datetime.microsecond", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.microsecond", 
        "syntax": "datetime.microsecond", 
        "type": "Data Types"
    }, 
    "datetime.datetime.min": {
        "descr": "The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).", 
        "name": "datetime.datetime.min", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.min", 
        "syntax": "datetime.min", 
        "type": "Data Types"
    }, 
    "datetime.datetime.minute": {
        "descr": "In range(60).", 
        "name": "datetime.datetime.minute", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.minute", 
        "syntax": "datetime.minute", 
        "type": "Data Types"
    }, 
    "datetime.datetime.month": {
        "descr": "Between 1 and 12 inclusive.", 
        "name": "datetime.datetime.month", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.month", 
        "syntax": "datetime.month", 
        "type": "Data Types"
    }, 
    "datetime.datetime.now": {
        "descr": "Return the current local date and time. If optional argument tz is None or not specified, this is like today(), but, if possible, supplies more precision than can be gotten from going through a time.time() timestamp (for example, this may be possible on platforms supplying the C gettimeofday() function).", 
        "name": "datetime.datetime.now", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.now", 
        "syntax": "classmethod datetime.now(tz=None)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.replace": {
        "descr": "Return a datetime with the same attributes, except for those attributes given new values by whichever keyword arguments are specified. Note that tzinfo=None can be specified to create a naive datetime from an aware datetime with no conversion of date and time data.", 
        "name": "datetime.datetime.replace", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.replace", 
        "syntax": "datetime.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])", 
        "type": "Data Types"
    }, 
    "datetime.datetime.resolution": {
        "descr": "The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).", 
        "name": "datetime.datetime.resolution", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.resolution", 
        "syntax": "datetime.resolution", 
        "type": "Data Types"
    }, 
    "datetime.datetime.second": {
        "descr": "In range(60).", 
        "name": "datetime.datetime.second", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.second", 
        "syntax": "datetime.second", 
        "type": "Data Types"
    }, 
    "datetime.datetime.strftime": {
        "descr": "Return a string representing the date and time, controlled by an explicit format string. For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.datetime.strftime", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.strftime", 
        "syntax": "datetime.strftime(format)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.strptime": {
        "descr": "Return a datetime corresponding to date_string, parsed according to format. This is equivalent to datetime(*(time.strptime(date_string, format)[0:6])). ValueError is raised if the date_string and format can\u2019t be parsed by time.strptime() or if it returns a value which isn\u2019t a time tuple. For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.datetime.strptime", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.strptime", 
        "syntax": "classmethod datetime.strptime(date_string, format)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.time": {
        "descr": "Return time object with same hour, minute, second and microsecond. tzinfo is None. See also method timetz().", 
        "name": "datetime.datetime.time", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.time", 
        "syntax": "datetime.time()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.timestamp": {
        "descr": "Return POSIX timestamp corresponding to the datetime instance. The return value is a float similar to that returned by time.time().", 
        "name": "datetime.datetime.timestamp", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.timestamp", 
        "syntax": "datetime.timestamp()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.timetuple": {
        "descr": "Return a time.struct_time such as returned by time.localtime(). d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday, dst)), where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. The tm_isdst flag of the result is set according to the dst() method: tzinfo is None or dst() returns None, tm_isdst is set to -1; else if dst() returns a non-zero value, tm_isdst is set to 1; else tm_isdst is set to 0.", 
        "name": "datetime.datetime.timetuple", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.timetuple", 
        "syntax": "datetime.timetuple()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.timetz": {
        "descr": "Return time object with same hour, minute, second, microsecond, and tzinfo attributes. See also method time().", 
        "name": "datetime.datetime.timetz", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.timetz", 
        "syntax": "datetime.timetz()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.today": {
        "descr": "Return the current local datetime, with tzinfo None. This is equivalent to datetime.fromtimestamp(time.time()). See also now(), fromtimestamp().", 
        "name": "datetime.datetime.today", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.today", 
        "syntax": "classmethod datetime.today()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.toordinal": {
        "descr": "Return the proleptic Gregorian ordinal of the date. The same as self.date().toordinal().", 
        "name": "datetime.datetime.toordinal", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.toordinal", 
        "syntax": "datetime.toordinal()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.tzinfo": {
        "descr": "The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.", 
        "name": "datetime.datetime.tzinfo", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.tzinfo", 
        "syntax": "datetime.tzinfo", 
        "type": "Data Types"
    }, 
    "datetime.datetime.tzname": {
        "descr": "If tzinfo is None, returns None, else returns self.tzinfo.tzname(self), raises an exception if the latter doesn\u2019t return None or a string object,", 
        "name": "datetime.datetime.tzname", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.tzname", 
        "syntax": "datetime.tzname()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.utcfromtimestamp": {
        "descr": "Return the UTC datetime corresponding to the POSIX timestamp, with tzinfo None. This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C gmtime() function, and OSError on gmtime() failure. It\u2019s common for this to be restricted to years in 1970 through 2038. See also fromtimestamp().", 
        "name": "datetime.datetime.utcfromtimestamp", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.utcfromtimestamp", 
        "syntax": "classmethod datetime.utcfromtimestamp(timestamp)", 
        "type": "Data Types"
    }, 
    "datetime.datetime.utcnow": {
        "descr": "Return the current UTC date and time, with tzinfo None. This is like now(), but returns the current UTC date and time, as a naive datetime object. An aware current UTC datetime can be obtained by calling datetime.now(timezone.utc). See also now().", 
        "name": "datetime.datetime.utcnow", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.utcnow", 
        "syntax": "classmethod datetime.utcnow()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.utcoffset": {
        "descr": "If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(self), and raises an exception if the latter doesn\u2019t return None, or a timedelta object representing a whole number of minutes with magnitude less than one day.", 
        "name": "datetime.datetime.utcoffset", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.utcoffset", 
        "syntax": "datetime.utcoffset()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.utctimetuple": {
        "descr": "If datetime instance d is naive, this is the same as d.timetuple() except that tm_isdst is forced to 0 regardless of what d.dst() returns. DST is never in effect for a UTC time.", 
        "name": "datetime.datetime.utctimetuple", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.utctimetuple", 
        "syntax": "datetime.utctimetuple()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.weekday": {
        "descr": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6. The same as self.date().weekday(). See also isoweekday().", 
        "name": "datetime.datetime.weekday", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.weekday", 
        "syntax": "datetime.weekday()", 
        "type": "Data Types"
    }, 
    "datetime.datetime.year": {
        "descr": "Between MINYEAR and MAXYEAR inclusive.", 
        "name": "datetime.datetime.year", 
        "params": [], 
        "path": "python/library/datetime#datetime.datetime.year", 
        "syntax": "datetime.year", 
        "type": "Data Types"
    }, 
    "datetime.time": {
        "descr": "All arguments are optional. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments may be integers, in the following ranges:", 
        "name": "datetime.time", 
        "params": [], 
        "path": "python/library/datetime#datetime.time", 
        "syntax": "class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)", 
        "type": "Data Types"
    }, 
    "datetime.time.__format__": {
        "descr": "Same as time.strftime(). This makes it possible to specify format string for a time object when using str.format(). For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.time.__format__", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.__format__", 
        "syntax": "time.__format__(format)", 
        "type": "Data Types"
    }, 
    "datetime.time.__str__": {
        "descr": "For a time t, str(t) is equivalent to t.isoformat().", 
        "name": "datetime.time.__str__", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.__str__", 
        "syntax": "time.__str__()", 
        "type": "Data Types"
    }, 
    "datetime.time.dst": {
        "descr": "If tzinfo is None, returns None, else returns self.tzinfo.dst(None), and raises an exception if the latter doesn\u2019t return None, or a timedelta object representing a whole number of minutes with magnitude less than one day.", 
        "name": "datetime.time.dst", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.dst", 
        "syntax": "time.dst()", 
        "type": "Data Types"
    }, 
    "datetime.time.hour": {
        "descr": "In range(24).", 
        "name": "datetime.time.hour", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.hour", 
        "syntax": "time.hour", 
        "type": "Data Types"
    }, 
    "datetime.time.isoformat": {
        "descr": "Return a string representing the time in ISO 8601 format, HH:MM:SS.mmmmmm or, if self.microsecond is 0, HH:MM:SS If utcoffset() does not return None, a 6-character string is appended, giving the UTC offset in (signed) hours and minutes: HH:MM:SS.mmmmmm+HH:MM or, if self.microsecond is 0, HH:MM:SS+HH:MM", 
        "name": "datetime.time.isoformat", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.isoformat", 
        "syntax": "time.isoformat()", 
        "type": "Data Types"
    }, 
    "datetime.time.max": {
        "descr": "The latest representable time, time(23, 59, 59, 999999).", 
        "name": "datetime.time.max", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.max", 
        "syntax": "time.max", 
        "type": "Data Types"
    }, 
    "datetime.time.microsecond": {
        "descr": "In range(1000000).", 
        "name": "datetime.time.microsecond", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.microsecond", 
        "syntax": "time.microsecond", 
        "type": "Data Types"
    }, 
    "datetime.time.min": {
        "descr": "The earliest representable time, time(0, 0, 0, 0).", 
        "name": "datetime.time.min", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.min", 
        "syntax": "time.min", 
        "type": "Data Types"
    }, 
    "datetime.time.minute": {
        "descr": "In range(60).", 
        "name": "datetime.time.minute", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.minute", 
        "syntax": "time.minute", 
        "type": "Data Types"
    }, 
    "datetime.time.replace": {
        "descr": "Return a time with the same value, except for those attributes given new values by whichever keyword arguments are specified. Note that tzinfo=None can be specified to create a naive time from an aware time, without conversion of the time data.", 
        "name": "datetime.time.replace", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.replace", 
        "syntax": "time.replace([hour[, minute[, second[, microsecond[, tzinfo]]]]])", 
        "type": "Data Types"
    }, 
    "datetime.time.resolution": {
        "descr": "The smallest possible difference between non-equal time objects, timedelta(microseconds=1), although note that arithmetic on time objects is not supported.", 
        "name": "datetime.time.resolution", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.resolution", 
        "syntax": "time.resolution", 
        "type": "Data Types"
    }, 
    "datetime.time.second": {
        "descr": "In range(60).", 
        "name": "datetime.time.second", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.second", 
        "syntax": "time.second", 
        "type": "Data Types"
    }, 
    "datetime.time.strftime": {
        "descr": "Return a string representing the time, controlled by an explicit format string. For a complete list of formatting directives, see strftime() and strptime() Behavior.", 
        "name": "datetime.time.strftime", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.strftime", 
        "syntax": "time.strftime(format)", 
        "type": "Data Types"
    }, 
    "datetime.time.tzinfo": {
        "descr": "The object passed as the tzinfo argument to the time constructor, or None if none was passed.", 
        "name": "datetime.time.tzinfo", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.tzinfo", 
        "syntax": "time.tzinfo", 
        "type": "Data Types"
    }, 
    "datetime.time.tzname": {
        "descr": "If tzinfo is None, returns None, else returns self.tzinfo.tzname(None), or raises an exception if the latter doesn\u2019t return None or a string object.", 
        "name": "datetime.time.tzname", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.tzname", 
        "syntax": "time.tzname()", 
        "type": "Data Types"
    }, 
    "datetime.time.utcoffset": {
        "descr": "If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(None), and raises an exception if the latter doesn\u2019t return None or a timedelta object representing a whole number of minutes with magnitude less than one day.", 
        "name": "datetime.time.utcoffset", 
        "params": [], 
        "path": "python/library/datetime#datetime.time.utcoffset", 
        "syntax": "time.utcoffset()", 
        "type": "Data Types"
    }, 
    "datetime.timedelta": {
        "descr": "All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative.", 
        "name": "datetime.timedelta", 
        "params": [], 
        "path": "python/library/datetime#datetime.timedelta", 
        "syntax": "class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)", 
        "type": "Data Types"
    }, 
    "datetime.timedelta.max": {
        "descr": "The most positive timedelta object, timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999).", 
        "name": "datetime.timedelta.max", 
        "params": [], 
        "path": "python/library/datetime#datetime.timedelta.max", 
        "syntax": "timedelta.max", 
        "type": "Data Types"
    }, 
    "datetime.timedelta.min": {
        "descr": "The most negative timedelta object, timedelta(-999999999).", 
        "name": "datetime.timedelta.min", 
        "params": [], 
        "path": "python/library/datetime#datetime.timedelta.min", 
        "syntax": "timedelta.min", 
        "type": "Data Types"
    }, 
    "datetime.timedelta.resolution": {
        "descr": "The smallest possible difference between non-equal timedelta objects, timedelta(microseconds=1).", 
        "name": "datetime.timedelta.resolution", 
        "params": [], 
        "path": "python/library/datetime#datetime.timedelta.resolution", 
        "syntax": "timedelta.resolution", 
        "type": "Data Types"
    }, 
    "datetime.timedelta.total_seconds": {
        "descr": "Return the total number of seconds contained in the duration. Equivalent to td / timedelta(seconds=1).", 
        "name": "datetime.timedelta.total_seconds", 
        "params": [], 
        "path": "python/library/datetime#datetime.timedelta.total_seconds", 
        "syntax": "timedelta.total_seconds()", 
        "type": "Data Types"
    }, 
    "datetime.timezone": {
        "descr": "A class that implements the tzinfo abstract base class as a fixed offset from the UTC.", 
        "name": "datetime.timezone", 
        "params": [], 
        "path": "python/library/datetime#datetime.timezone", 
        "syntax": "class datetime.timezone", 
        "type": "Data Types"
    }, 
    "datetime.timezone.dst": {
        "descr": "Always returns None.", 
        "name": "datetime.timezone.dst", 
        "params": [], 
        "path": "python/library/datetime#datetime.timezone.dst", 
        "syntax": "timezone.dst(dt)", 
        "type": "Data Types"
    }, 
    "datetime.timezone.fromutc": {
        "descr": "Return dt + offset. The dt argument must be an aware datetime instance, with tzinfo set to self.", 
        "name": "datetime.timezone.fromutc", 
        "params": [], 
        "path": "python/library/datetime#datetime.timezone.fromutc", 
        "syntax": "timezone.fromutc(dt)", 
        "type": "Data Types"
    }, 
    "datetime.timezone.tzname": {
        "descr": "Return the fixed value specified when the timezone instance is constructed or a string \u2018UTCsHH:MM\u2019, where s is the sign of offset, HH and MM are two digits of offset.hours and offset.minutes respectively.", 
        "name": "datetime.timezone.tzname", 
        "params": [], 
        "path": "python/library/datetime#datetime.timezone.tzname", 
        "syntax": "timezone.tzname(dt)", 
        "type": "Data Types"
    }, 
    "datetime.timezone.utc": {
        "descr": "The UTC timezone, timezone(timedelta(0)).", 
        "name": "datetime.timezone.utc", 
        "params": [], 
        "path": "python/library/datetime#datetime.timezone.utc", 
        "syntax": "timezone.utc", 
        "type": "Data Types"
    }, 
    "datetime.timezone.utcoffset": {
        "descr": "Return the fixed value specified when the timezone instance is constructed. The dt argument is ignored. The return value is a timedelta instance equal to the difference between the local time and UTC.", 
        "name": "datetime.timezone.utcoffset", 
        "params": [], 
        "path": "python/library/datetime#datetime.timezone.utcoffset", 
        "syntax": "timezone.utcoffset(dt)", 
        "type": "Data Types"
    }, 
    "datetime.tzinfo": {
        "descr": "An abstract base class for time zone information objects. These are used by the datetime and time classes to provide a customizable notion of time adjustment (for example, to account for time zone and/or daylight saving time).", 
        "name": "datetime.tzinfo", 
        "params": [], 
        "path": "python/library/datetime#datetime.tzinfo", 
        "syntax": "class datetime.tzinfo", 
        "type": "Data Types"
    }, 
    "datetime.tzinfo.dst": {
        "descr": "Return the daylight saving time (DST) adjustment, in minutes east of UTC, or None if DST information isn\u2019t known. Return timedelta(0) if DST is not in effect. If DST is in effect, return the offset as a timedelta object (see utcoffset() for details). Note that DST offset, if applicable, has already been added to the UTC offset returned by utcoffset(), so there\u2019s no need to consult dst() unless you\u2019re interested in obtaining DST info separately. For example, datetime.timetuple() calls its tzinfo attribute\u2019s dst() method to determine how the tm_isdst flag should be set, and tzinfo.fromutc() calls dst() to account for DST changes when crossing time zones.", 
        "name": "datetime.tzinfo.dst", 
        "params": [], 
        "path": "python/library/datetime#datetime.tzinfo.dst", 
        "syntax": "tzinfo.dst(dt)", 
        "type": "Data Types"
    }, 
    "datetime.tzinfo.fromutc": {
        "descr": "This is called from the default datetime.astimezone() implementation. When called from that, dt.tzinfo is self, and dt\u2018s date and time data are to be viewed as expressing a UTC time. The purpose of fromutc() is to adjust the date and time data, returning an equivalent datetime in self\u2018s local time.", 
        "name": "datetime.tzinfo.fromutc", 
        "params": [], 
        "path": "python/library/datetime#datetime.tzinfo.fromutc", 
        "syntax": "tzinfo.fromutc(dt)", 
        "type": "Data Types"
    }, 
    "datetime.tzinfo.tzname": {
        "descr": "Return the time zone name corresponding to the datetime object dt, as a string. Nothing about string names is defined by the datetime module, and there\u2019s no requirement that it mean anything in particular. For example, \u201cGMT\u201d, \u201cUTC\u201d, \u201c-500\u201d, \u201c-5:00\u201d, \u201cEDT\u201d, \u201cUS/Eastern\u201d, \u201cAmerica/New York\u201d are all valid replies. Return None if a string name isn\u2019t known. Note that this is a method rather than a fixed string primarily because some tzinfo subclasses will wish to return different names depending on the specific value of dt passed, especially if the tzinfo class is accounting for daylight time.", 
        "name": "datetime.tzinfo.tzname", 
        "params": [], 
        "path": "python/library/datetime#datetime.tzinfo.tzname", 
        "syntax": "tzinfo.tzname(dt)", 
        "type": "Data Types"
    }, 
    "datetime.tzinfo.utcoffset": {
        "descr": "Return offset of local time from UTC, in minutes east of UTC. If local time is west of UTC, this should be negative. Note that this is intended to be the total offset from UTC; for example, if a tzinfo object represents both time zone and DST adjustments, utcoffset() should return their sum. If the UTC offset isn\u2019t known, return None. Else the value returned must be a timedelta object specifying a whole number of minutes in the range -1439 to 1439 inclusive (1440 = 24*60; the magnitude of the offset must be less than one day). Most implementations of utcoffset() will probably look like one of these two:", 
        "name": "datetime.tzinfo.utcoffset", 
        "params": [], 
        "path": "python/library/datetime#datetime.tzinfo.utcoffset", 
        "syntax": "tzinfo.utcoffset(dt)", 
        "type": "Data Types"
    }, 
    "dbm.dumb.dumbdbm.sync": {
        "descr": "Synchronize the on-disk directory and data files. This method is called by the Shelve.sync() method.", 
        "name": "dbm.dumb.dumbdbm.sync", 
        "params": [], 
        "path": "python/library/dbm#dbm.dumb.dumbdbm.sync", 
        "syntax": "dumbdbm.sync()", 
        "type": "Data Persistence"
    }, 
    "dbm.dumb.error": {
        "descr": "Raised on dbm.dumb-specific errors, such as I/O errors. KeyError is raised for general mapping errors like specifying an incorrect key.", 
        "name": "dbm.dumb.error", 
        "params": [], 
        "path": "python/library/dbm#dbm.dumb.error", 
        "syntax": "exception dbm.dumb.error", 
        "type": "Data Persistence"
    }, 
    "dbm.dumb.open": {
        "descr": "Open a dumbdbm database and return a dumbdbm object. The filename argument is the basename of the database file (without any specific extensions). When a dumbdbm database is created, files with .dat and .dir extensions are created.", 
        "name": "dbm.dumb.open", 
        "params": [], 
        "path": "python/library/dbm#dbm.dumb.open", 
        "syntax": "dbm.dumb.open(filename[, flag[, mode]])", 
        "type": "Data Persistence"
    }, 
    "dbm.error": {
        "descr": "A tuple containing the exceptions that can be raised by each of the supported modules, with a unique exception also named dbm.error as the first item \u2014 the latter is used when dbm.error is raised.", 
        "name": "dbm.error", 
        "params": [], 
        "path": "python/library/dbm#dbm.error", 
        "syntax": "exception dbm.error", 
        "type": "Data Persistence"
    }, 
    "dbm.gnu.error": {
        "descr": "Raised on dbm.gnu-specific errors, such as I/O errors. KeyError is raised for general mapping errors like specifying an incorrect key.", 
        "name": "dbm.gnu.error", 
        "params": [], 
        "path": "python/library/dbm#dbm.gnu.error", 
        "syntax": "exception dbm.gnu.error", 
        "type": "Data Persistence"
    }, 
    "dbm.gnu.gdbm.firstkey": {
        "descr": "It\u2019s possible to loop over every key in the database using this method and the nextkey() method. The traversal is ordered by gdbm\u2018s internal hash values, and won\u2019t be sorted by the key values. This method returns the starting key.", 
        "name": "dbm.gnu.gdbm.firstkey", 
        "params": [], 
        "path": "python/library/dbm#dbm.gnu.gdbm.firstkey", 
        "syntax": "gdbm.firstkey()", 
        "type": "Data Persistence"
    }, 
    "dbm.gnu.gdbm.nextkey": {
        "descr": "Returns the key that follows key in the traversal. The following code prints every key in the database db, without having to create a list in memory that contains them all:", 
        "name": "dbm.gnu.gdbm.nextkey", 
        "params": [], 
        "path": "python/library/dbm#dbm.gnu.gdbm.nextkey", 
        "syntax": "gdbm.nextkey(key)", 
        "type": "Data Persistence"
    }, 
    "dbm.gnu.gdbm.reorganize": {
        "descr": "If you have carried out a lot of deletions and would like to shrink the space used by the gdbm file, this routine will reorganize the database. gdbm objects will not shorten the length of a database file except by using this reorganization; otherwise, deleted file space will be kept and reused as new (key, value) pairs are added.", 
        "name": "dbm.gnu.gdbm.reorganize", 
        "params": [], 
        "path": "python/library/dbm#dbm.gnu.gdbm.reorganize", 
        "syntax": "gdbm.reorganize()", 
        "type": "Data Persistence"
    }, 
    "dbm.gnu.gdbm.sync": {
        "descr": "When the database has been opened in fast mode, this method forces any unwritten data to be written to the disk.", 
        "name": "dbm.gnu.gdbm.sync", 
        "params": [], 
        "path": "python/library/dbm#dbm.gnu.gdbm.sync", 
        "syntax": "gdbm.sync()", 
        "type": "Data Persistence"
    }, 
    "dbm.gnu.open": {
        "descr": "Open a gdbm database and return a gdbm object. The filename argument is the name of the database file.", 
        "name": "dbm.gnu.open", 
        "params": [], 
        "path": "python/library/dbm#dbm.gnu.open", 
        "syntax": "dbm.gnu.open(filename[, flag[, mode]])", 
        "type": "Data Persistence"
    }, 
    "dbm.ndbm.error": {
        "descr": "Raised on dbm.ndbm-specific errors, such as I/O errors. KeyError is raised for general mapping errors like specifying an incorrect key.", 
        "name": "dbm.ndbm.error", 
        "params": [], 
        "path": "python/library/dbm#dbm.ndbm.error", 
        "syntax": "exception dbm.ndbm.error", 
        "type": "Data Persistence"
    }, 
    "dbm.ndbm.library": {
        "descr": "Name of the ndbm implementation library used.", 
        "name": "dbm.ndbm.library", 
        "params": [], 
        "path": "python/library/dbm#dbm.ndbm.library", 
        "syntax": "dbm.ndbm.library", 
        "type": "Data Persistence"
    }, 
    "dbm.ndbm.open": {
        "descr": "Open a dbm database and return a dbm object. The filename argument is the name of the database file (without the .dir or .pag extensions).", 
        "name": "dbm.ndbm.open", 
        "params": [], 
        "path": "python/library/dbm#dbm.ndbm.open", 
        "syntax": "dbm.ndbm.open(filename[, flag[, mode]])", 
        "type": "Data Persistence"
    }, 
    "dbm.open": {
        "descr": "Open the database file file and return a corresponding object.", 
        "name": "dbm.open", 
        "params": [], 
        "path": "python/library/dbm#dbm.open", 
        "syntax": "dbm.open(file, flag='r', mode=0o666)", 
        "type": "Data Persistence"
    }, 
    "dbm.whichdb": {
        "descr": "This function attempts to guess which of the several simple database modules available \u2014 dbm.gnu, dbm.ndbm or dbm.dumb \u2014 should be used to open a given file.", 
        "name": "dbm.whichdb", 
        "params": [], 
        "path": "python/library/dbm#dbm.whichdb", 
        "syntax": "dbm.whichdb(filename)", 
        "type": "Data Persistence"
    }, 
    "decimal.BasicContext": {
        "descr": "This is a standard context defined by the General Decimal Arithmetic Specification. Precision is set to nine. Rounding is set to ROUND_HALF_UP. All flags are cleared. All traps are enabled (treated as exceptions) except Inexact, Rounded, and Subnormal.", 
        "name": "decimal.BasicContext", 
        "params": [], 
        "path": "python/library/decimal#decimal.BasicContext", 
        "syntax": "class decimal.BasicContext", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Clamped": {
        "descr": "Altered an exponent to fit representation constraints.", 
        "name": "decimal.Clamped", 
        "params": [], 
        "path": "python/library/decimal#decimal.Clamped", 
        "syntax": "class decimal.Clamped", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context": {
        "descr": "Creates a new context. If a field is not specified or is None, the default values are copied from the DefaultContext. If the flags field is not specified or is None, all flags are cleared.", 
        "name": "decimal.Context", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context", 
        "syntax": "class decimal.Context(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.Etiny": {
        "descr": "Returns a value equal to Emin - prec + 1 which is the minimum exponent value for subnormal results. When underflow occurs, the exponent is set to Etiny.", 
        "name": "decimal.Context.Etiny", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.Etiny", 
        "syntax": "Etiny()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.Etop": {
        "descr": "Returns a value equal to Emax - prec + 1.", 
        "name": "decimal.Context.Etop", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.Etop", 
        "syntax": "Etop()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.abs": {
        "descr": "Returns the absolute value of x.", 
        "name": "decimal.Context.abs", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.abs", 
        "syntax": "abs(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.add": {
        "descr": "Return the sum of x and y.", 
        "name": "decimal.Context.add", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.add", 
        "syntax": "add(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.canonical": {
        "descr": "Returns the same Decimal object x.", 
        "name": "decimal.Context.canonical", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.canonical", 
        "syntax": "canonical(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.clear_flags": {
        "descr": "Resets all of the flags to 0.", 
        "name": "decimal.Context.clear_flags", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.clear_flags", 
        "syntax": "clear_flags()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.clear_traps": {
        "descr": "Resets all of the traps to 0.", 
        "name": "decimal.Context.clear_traps", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.clear_traps", 
        "syntax": "clear_traps()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.compare": {
        "descr": "Compares x and y numerically.", 
        "name": "decimal.Context.compare", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.compare", 
        "syntax": "compare(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.compare_signal": {
        "descr": "Compares the values of the two operands numerically.", 
        "name": "decimal.Context.compare_signal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.compare_signal", 
        "syntax": "compare_signal(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.compare_total": {
        "descr": "Compares two operands using their abstract representation.", 
        "name": "decimal.Context.compare_total", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.compare_total", 
        "syntax": "compare_total(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.compare_total_mag": {
        "descr": "Compares two operands using their abstract representation, ignoring sign.", 
        "name": "decimal.Context.compare_total_mag", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.compare_total_mag", 
        "syntax": "compare_total_mag(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.copy": {
        "descr": "Return a duplicate of the context.", 
        "name": "decimal.Context.copy", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.copy", 
        "syntax": "copy()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.copy_abs": {
        "descr": "Returns a copy of x with the sign set to 0.", 
        "name": "decimal.Context.copy_abs", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.copy_abs", 
        "syntax": "copy_abs(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.copy_decimal": {
        "descr": "Return a copy of the Decimal instance num.", 
        "name": "decimal.Context.copy_decimal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.copy_decimal", 
        "syntax": "copy_decimal(num)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.copy_negate": {
        "descr": "Returns a copy of x with the sign inverted.", 
        "name": "decimal.Context.copy_negate", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.copy_negate", 
        "syntax": "copy_negate(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.copy_sign": {
        "descr": "Copies the sign from y to x.", 
        "name": "decimal.Context.copy_sign", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.copy_sign", 
        "syntax": "copy_sign(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.create_decimal": {
        "descr": "Creates a new Decimal instance from num but using self as context. Unlike the Decimal constructor, the context precision, rounding method, flags, and traps are applied to the conversion.", 
        "name": "decimal.Context.create_decimal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.create_decimal", 
        "syntax": "create_decimal(num)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.create_decimal_from_float": {
        "descr": "Creates a new Decimal instance from a float f but rounding using self as the context. Unlike the Decimal.from_float() class method, the context precision, rounding method, flags, and traps are applied to the conversion.", 
        "name": "decimal.Context.create_decimal_from_float", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.create_decimal_from_float", 
        "syntax": "create_decimal_from_float(f)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.divide": {
        "descr": "Return x divided by y.", 
        "name": "decimal.Context.divide", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.divide", 
        "syntax": "divide(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.divide_int": {
        "descr": "Return x divided by y, truncated to an integer.", 
        "name": "decimal.Context.divide_int", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.divide_int", 
        "syntax": "divide_int(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.divmod": {
        "descr": "Divides two numbers and returns the integer part of the result.", 
        "name": "decimal.Context.divmod", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.divmod", 
        "syntax": "divmod(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.exp": {
        "descr": "Returns e ** x.", 
        "name": "decimal.Context.exp", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.exp", 
        "syntax": "exp(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.fma": {
        "descr": "Returns x multiplied by y, plus z.", 
        "name": "decimal.Context.fma", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.fma", 
        "syntax": "fma(x, y, z)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_canonical": {
        "descr": "Returns True if x is canonical; otherwise returns False.", 
        "name": "decimal.Context.is_canonical", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_canonical", 
        "syntax": "is_canonical(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_finite": {
        "descr": "Returns True if x is finite; otherwise returns False.", 
        "name": "decimal.Context.is_finite", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_finite", 
        "syntax": "is_finite(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_infinite": {
        "descr": "Returns True if x is infinite; otherwise returns False.", 
        "name": "decimal.Context.is_infinite", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_infinite", 
        "syntax": "is_infinite(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_nan": {
        "descr": "Returns True if x is a qNaN or sNaN; otherwise returns False.", 
        "name": "decimal.Context.is_nan", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_nan", 
        "syntax": "is_nan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_normal": {
        "descr": "Returns True if x is a normal number; otherwise returns False.", 
        "name": "decimal.Context.is_normal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_normal", 
        "syntax": "is_normal(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_qnan": {
        "descr": "Returns True if x is a quiet NaN; otherwise returns False.", 
        "name": "decimal.Context.is_qnan", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_qnan", 
        "syntax": "is_qnan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_signed": {
        "descr": "Returns True if x is negative; otherwise returns False.", 
        "name": "decimal.Context.is_signed", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_signed", 
        "syntax": "is_signed(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_snan": {
        "descr": "Returns True if x is a signaling NaN; otherwise returns False.", 
        "name": "decimal.Context.is_snan", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_snan", 
        "syntax": "is_snan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_subnormal": {
        "descr": "Returns True if x is subnormal; otherwise returns False.", 
        "name": "decimal.Context.is_subnormal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_subnormal", 
        "syntax": "is_subnormal(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.is_zero": {
        "descr": "Returns True if x is a zero; otherwise returns False.", 
        "name": "decimal.Context.is_zero", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.is_zero", 
        "syntax": "is_zero(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.ln": {
        "descr": "Returns the natural (base e) logarithm of x.", 
        "name": "decimal.Context.ln", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.ln", 
        "syntax": "ln(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.log10": {
        "descr": "Returns the base 10 logarithm of x.", 
        "name": "decimal.Context.log10", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.log10", 
        "syntax": "log10(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.logb": {
        "descr": "Returns the exponent of the magnitude of the operand\u2019s MSD.", 
        "name": "decimal.Context.logb", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.logb", 
        "syntax": "logb(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.logical_and": {
        "descr": "Applies the logical operation and between each operand\u2019s digits.", 
        "name": "decimal.Context.logical_and", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.logical_and", 
        "syntax": "logical_and(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.logical_invert": {
        "descr": "Invert all the digits in x.", 
        "name": "decimal.Context.logical_invert", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.logical_invert", 
        "syntax": "logical_invert(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.logical_or": {
        "descr": "Applies the logical operation or between each operand\u2019s digits.", 
        "name": "decimal.Context.logical_or", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.logical_or", 
        "syntax": "logical_or(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.logical_xor": {
        "descr": "Applies the logical operation xor between each operand\u2019s digits.", 
        "name": "decimal.Context.logical_xor", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.logical_xor", 
        "syntax": "logical_xor(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.max": {
        "descr": "Compares two values numerically and returns the maximum.", 
        "name": "decimal.Context.max", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.max", 
        "syntax": "max(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.max_mag": {
        "descr": "Compares the values numerically with their sign ignored.", 
        "name": "decimal.Context.max_mag", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.max_mag", 
        "syntax": "max_mag(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.min": {
        "descr": "Compares two values numerically and returns the minimum.", 
        "name": "decimal.Context.min", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.min", 
        "syntax": "min(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.min_mag": {
        "descr": "Compares the values numerically with their sign ignored.", 
        "name": "decimal.Context.min_mag", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.min_mag", 
        "syntax": "min_mag(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.minus": {
        "descr": "Minus corresponds to the unary prefix minus operator in Python.", 
        "name": "decimal.Context.minus", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.minus", 
        "syntax": "minus(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.multiply": {
        "descr": "Return the product of x and y.", 
        "name": "decimal.Context.multiply", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.multiply", 
        "syntax": "multiply(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.next_minus": {
        "descr": "Returns the largest representable number smaller than x.", 
        "name": "decimal.Context.next_minus", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.next_minus", 
        "syntax": "next_minus(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.next_plus": {
        "descr": "Returns the smallest representable number larger than x.", 
        "name": "decimal.Context.next_plus", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.next_plus", 
        "syntax": "next_plus(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.next_toward": {
        "descr": "Returns the number closest to x, in direction towards y.", 
        "name": "decimal.Context.next_toward", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.next_toward", 
        "syntax": "next_toward(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.normalize": {
        "descr": "Reduces x to its simplest form.", 
        "name": "decimal.Context.normalize", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.normalize", 
        "syntax": "normalize(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.number_class": {
        "descr": "Returns an indication of the class of x.", 
        "name": "decimal.Context.number_class", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.number_class", 
        "syntax": "number_class(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.plus": {
        "descr": "Plus corresponds to the unary prefix plus operator in Python. This operation applies the context precision and rounding, so it is not an identity operation.", 
        "name": "decimal.Context.plus", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.plus", 
        "syntax": "plus(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.power": {
        "descr": "Return x to the power of y, reduced modulo modulo if given.", 
        "name": "decimal.Context.power", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.power", 
        "syntax": "power(x, y, modulo=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.quantize": {
        "descr": "Returns a value equal to x (rounded), having the exponent of y.", 
        "name": "decimal.Context.quantize", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.quantize", 
        "syntax": "quantize(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.radix": {
        "descr": "Just returns 10, as this is Decimal, :)", 
        "name": "decimal.Context.radix", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.radix", 
        "syntax": "radix()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.remainder": {
        "descr": "Returns the remainder from integer division.", 
        "name": "decimal.Context.remainder", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.remainder", 
        "syntax": "remainder(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.remainder_near": {
        "descr": "Returns x - y * n, where n is the integer nearest the exact value of x / y (if the result is 0 then its sign will be the sign of x).", 
        "name": "decimal.Context.remainder_near", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.remainder_near", 
        "syntax": "remainder_near(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.rotate": {
        "descr": "Returns a rotated copy of x, y times.", 
        "name": "decimal.Context.rotate", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.rotate", 
        "syntax": "rotate(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.same_quantum": {
        "descr": "Returns True if the two operands have the same exponent.", 
        "name": "decimal.Context.same_quantum", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.same_quantum", 
        "syntax": "same_quantum(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.scaleb": {
        "descr": "Returns the first operand after adding the second value its exp.", 
        "name": "decimal.Context.scaleb", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.scaleb", 
        "syntax": "scaleb(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.shift": {
        "descr": "Returns a shifted copy of x, y times.", 
        "name": "decimal.Context.shift", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.shift", 
        "syntax": "shift(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.sqrt": {
        "descr": "Square root of a non-negative number to context precision.", 
        "name": "decimal.Context.sqrt", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.sqrt", 
        "syntax": "sqrt(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.subtract": {
        "descr": "Return the difference between x and y.", 
        "name": "decimal.Context.subtract", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.subtract", 
        "syntax": "subtract(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.to_eng_string": {
        "descr": "Converts a number to a string, using scientific notation.", 
        "name": "decimal.Context.to_eng_string", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.to_eng_string", 
        "syntax": "to_eng_string(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.to_integral_exact": {
        "descr": "Rounds to an integer.", 
        "name": "decimal.Context.to_integral_exact", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.to_integral_exact", 
        "syntax": "to_integral_exact(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Context.to_sci_string": {
        "descr": "Converts a number to a string using scientific notation.", 
        "name": "decimal.Context.to_sci_string", 
        "params": [], 
        "path": "python/library/decimal#decimal.Context.to_sci_string", 
        "syntax": "to_sci_string(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal": {
        "descr": "Construct a new Decimal object based from value.", 
        "name": "decimal.Decimal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal", 
        "syntax": "class decimal.Decimal(value=\"0\", context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.adjusted": {
        "descr": "Return the adjusted exponent after shifting out the coefficient\u2019s rightmost digits until only the lead digit remains: Decimal('321e+5').adjusted() returns seven. Used for determining the position of the most significant digit with respect to the decimal point.", 
        "name": "decimal.Decimal.adjusted", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.adjusted", 
        "syntax": "adjusted()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.as_tuple": {
        "descr": "Return a named tuple representation of the number: DecimalTuple(sign, digits, exponent).", 
        "name": "decimal.Decimal.as_tuple", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.as_tuple", 
        "syntax": "as_tuple()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.canonical": {
        "descr": "Return the canonical encoding of the argument. Currently, the encoding of a Decimal instance is always canonical, so this operation returns its argument unchanged.", 
        "name": "decimal.Decimal.canonical", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.canonical", 
        "syntax": "canonical()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.compare": {
        "descr": "Compare the values of two Decimal instances. compare() returns a Decimal instance, and if either operand is a NaN then the result is a NaN:", 
        "name": "decimal.Decimal.compare", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.compare", 
        "syntax": "compare(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.compare_signal": {
        "descr": "This operation is identical to the compare() method, except that all NaNs signal. That is, if neither operand is a signaling NaN then any quiet NaN operand is treated as though it were a signaling NaN.", 
        "name": "decimal.Decimal.compare_signal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.compare_signal", 
        "syntax": "compare_signal(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.compare_total": {
        "descr": "Compare two operands using their abstract representation rather than their numerical value. Similar to the compare() method, but the result gives a total ordering on Decimal instances. Two Decimal instances with the same numeric value but different representations compare unequal in this ordering:", 
        "name": "decimal.Decimal.compare_total", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.compare_total", 
        "syntax": "compare_total(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.compare_total_mag": {
        "descr": "Compare two operands using their abstract representation rather than their value as in compare_total(), but ignoring the sign of each operand. x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()).", 
        "name": "decimal.Decimal.compare_total_mag", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.compare_total_mag", 
        "syntax": "compare_total_mag(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.conjugate": {
        "descr": "Just returns self, this method is only to comply with the Decimal Specification.", 
        "name": "decimal.Decimal.conjugate", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.conjugate", 
        "syntax": "conjugate()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.copy_abs": {
        "descr": "Return the absolute value of the argument. This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed.", 
        "name": "decimal.Decimal.copy_abs", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.copy_abs", 
        "syntax": "copy_abs()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.copy_negate": {
        "descr": "Return the negation of the argument. This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed.", 
        "name": "decimal.Decimal.copy_negate", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.copy_negate", 
        "syntax": "copy_negate()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.copy_sign": {
        "descr": "Return a copy of the first operand with the sign set to be the same as the sign of the second operand. For example:", 
        "name": "decimal.Decimal.copy_sign", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.copy_sign", 
        "syntax": "copy_sign(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.exp": {
        "descr": "Return the value of the (natural) exponential function e**x at the given number. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode.", 
        "name": "decimal.Decimal.exp", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.exp", 
        "syntax": "exp(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.fma": {
        "descr": "Fused multiply-add. Return self*other+third with no rounding of the intermediate product self*other.", 
        "name": "decimal.Decimal.fma", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.fma", 
        "syntax": "fma(other, third, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.from_float": {
        "descr": "Classmethod that converts a float to a decimal number, exactly.", 
        "name": "decimal.Decimal.from_float", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.from_float", 
        "syntax": "from_float(f)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_canonical": {
        "descr": "Return True if the argument is canonical and False otherwise. Currently, a Decimal instance is always canonical, so this operation always returns True.", 
        "name": "decimal.Decimal.is_canonical", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_canonical", 
        "syntax": "is_canonical()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_finite": {
        "descr": "Return True if the argument is a finite number, and False if the argument is an infinity or a NaN.", 
        "name": "decimal.Decimal.is_finite", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_finite", 
        "syntax": "is_finite()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_infinite": {
        "descr": "Return True if the argument is either positive or negative infinity and False otherwise.", 
        "name": "decimal.Decimal.is_infinite", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_infinite", 
        "syntax": "is_infinite()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_nan": {
        "descr": "Return True if the argument is a (quiet or signaling) NaN and False otherwise.", 
        "name": "decimal.Decimal.is_nan", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_nan", 
        "syntax": "is_nan()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_normal": {
        "descr": "Return True if the argument is a normal finite number. Return False if the argument is zero, subnormal, infinite or a NaN.", 
        "name": "decimal.Decimal.is_normal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_normal", 
        "syntax": "is_normal(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_qnan": {
        "descr": "Return True if the argument is a quiet NaN, and False otherwise.", 
        "name": "decimal.Decimal.is_qnan", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_qnan", 
        "syntax": "is_qnan()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_signed": {
        "descr": "Return True if the argument has a negative sign and False otherwise. Note that zeros and NaNs can both carry signs.", 
        "name": "decimal.Decimal.is_signed", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_signed", 
        "syntax": "is_signed()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_snan": {
        "descr": "Return True if the argument is a signaling NaN and False otherwise.", 
        "name": "decimal.Decimal.is_snan", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_snan", 
        "syntax": "is_snan()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_subnormal": {
        "descr": "Return True if the argument is subnormal, and False otherwise.", 
        "name": "decimal.Decimal.is_subnormal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_subnormal", 
        "syntax": "is_subnormal(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.is_zero": {
        "descr": "Return True if the argument is a (positive or negative) zero and False otherwise.", 
        "name": "decimal.Decimal.is_zero", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.is_zero", 
        "syntax": "is_zero()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.ln": {
        "descr": "Return the natural (base e) logarithm of the operand. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode.", 
        "name": "decimal.Decimal.ln", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.ln", 
        "syntax": "ln(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.log10": {
        "descr": "Return the base ten logarithm of the operand. The result is correctly rounded using the ROUND_HALF_EVEN rounding mode.", 
        "name": "decimal.Decimal.log10", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.log10", 
        "syntax": "log10(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.logb": {
        "descr": "For a nonzero number, return the adjusted exponent of its operand as a Decimal instance. If the operand is a zero then Decimal('-Infinity') is returned and the DivisionByZero flag is raised. If the operand is an infinity then Decimal('Infinity') is returned.", 
        "name": "decimal.Decimal.logb", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.logb", 
        "syntax": "logb(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.logical_and": {
        "descr": "logical_and() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise and of the two operands.", 
        "name": "decimal.Decimal.logical_and", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.logical_and", 
        "syntax": "logical_and(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.logical_invert": {
        "descr": "logical_invert() is a logical operation. The result is the digit-wise inversion of the operand.", 
        "name": "decimal.Decimal.logical_invert", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.logical_invert", 
        "syntax": "logical_invert(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.logical_or": {
        "descr": "logical_or() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise or of the two operands.", 
        "name": "decimal.Decimal.logical_or", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.logical_or", 
        "syntax": "logical_or(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.logical_xor": {
        "descr": "logical_xor() is a logical operation which takes two logical operands (see Logical operands). The result is the digit-wise exclusive or of the two operands.", 
        "name": "decimal.Decimal.logical_xor", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.logical_xor", 
        "syntax": "logical_xor(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.max": {
        "descr": "Like max(self, other) except that the context rounding rule is applied before returning and that NaN values are either signaled or ignored (depending on the context and whether they are signaling or quiet).", 
        "name": "decimal.Decimal.max", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.max", 
        "syntax": "max(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.max_mag": {
        "descr": "Similar to the max() method, but the comparison is done using the absolute values of the operands.", 
        "name": "decimal.Decimal.max_mag", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.max_mag", 
        "syntax": "max_mag(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.min": {
        "descr": "Like min(self, other) except that the context rounding rule is applied before returning and that NaN values are either signaled or ignored (depending on the context and whether they are signaling or quiet).", 
        "name": "decimal.Decimal.min", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.min", 
        "syntax": "min(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.min_mag": {
        "descr": "Similar to the min() method, but the comparison is done using the absolute values of the operands.", 
        "name": "decimal.Decimal.min_mag", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.min_mag", 
        "syntax": "min_mag(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.next_minus": {
        "descr": "Return the largest number representable in the given context (or in the current thread\u2019s context if no context is given) that is smaller than the given operand.", 
        "name": "decimal.Decimal.next_minus", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.next_minus", 
        "syntax": "next_minus(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.next_plus": {
        "descr": "Return the smallest number representable in the given context (or in the current thread\u2019s context if no context is given) that is larger than the given operand.", 
        "name": "decimal.Decimal.next_plus", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.next_plus", 
        "syntax": "next_plus(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.next_toward": {
        "descr": "If the two operands are unequal, return the number closest to the first operand in the direction of the second operand. If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand.", 
        "name": "decimal.Decimal.next_toward", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.next_toward", 
        "syntax": "next_toward(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.normalize": {
        "descr": "Normalize the number by stripping the rightmost trailing zeros and converting any result equal to Decimal('0') to Decimal('0e0'). Used for producing canonical values for attributes of an equivalence class. For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize to the equivalent value Decimal('32.1').", 
        "name": "decimal.Decimal.normalize", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.normalize", 
        "syntax": "normalize(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.number_class": {
        "descr": "Return a string describing the class of the operand. The returned value is one of the following ten strings.", 
        "name": "decimal.Decimal.number_class", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.number_class", 
        "syntax": "number_class(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.quantize": {
        "descr": "Return a value equal to the first operand after rounding and having the exponent of the second operand.", 
        "name": "decimal.Decimal.quantize", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.quantize", 
        "syntax": "quantize(exp, rounding=None, context=None, watchexp=True)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.radix": {
        "descr": "Return Decimal(10), the radix (base) in which the Decimal class does all its arithmetic. Included for compatibility with the specification.", 
        "name": "decimal.Decimal.radix", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.radix", 
        "syntax": "radix()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.remainder_near": {
        "descr": "Return the remainder from dividing self by other. This differs from self % other in that the sign of the remainder is chosen so as to minimize its absolute value. More precisely, the return value is self - n * other where n is the integer nearest to the exact value of self / other, and if two integers are equally near then the even one is chosen.", 
        "name": "decimal.Decimal.remainder_near", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.remainder_near", 
        "syntax": "remainder_near(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.rotate": {
        "descr": "Return the result of rotating the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to rotate. If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary. The sign and exponent of the first operand are unchanged.", 
        "name": "decimal.Decimal.rotate", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.rotate", 
        "syntax": "rotate(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.same_quantum": {
        "descr": "Test whether self and other have the same exponent or whether both are NaN.", 
        "name": "decimal.Decimal.same_quantum", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.same_quantum", 
        "syntax": "same_quantum(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.scaleb": {
        "descr": "Return the first operand with exponent adjusted by the second. Equivalently, return the first operand multiplied by 10**other. The second operand must be an integer.", 
        "name": "decimal.Decimal.scaleb", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.scaleb", 
        "syntax": "scaleb(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.shift": {
        "descr": "Return the result of shifting the digits of the first operand by an amount specified by the second operand. The second operand must be an integer in the range -precision through precision. The absolute value of the second operand gives the number of places to shift. If the second operand is positive then the shift is to the left; otherwise the shift is to the right. Digits shifted into the coefficient are zeros. The sign and exponent of the first operand are unchanged.", 
        "name": "decimal.Decimal.shift", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.shift", 
        "syntax": "shift(other, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.sqrt": {
        "descr": "Return the square root of the argument to full precision.", 
        "name": "decimal.Decimal.sqrt", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.sqrt", 
        "syntax": "sqrt(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.to_eng_string": {
        "descr": "Convert to an engineering-type string.", 
        "name": "decimal.Decimal.to_eng_string", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.to_eng_string", 
        "syntax": "to_eng_string(context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.to_integral": {
        "descr": "Identical to the to_integral_value() method. The to_integral name has been kept for compatibility with older versions.", 
        "name": "decimal.Decimal.to_integral", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.to_integral", 
        "syntax": "to_integral(rounding=None, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.to_integral_exact": {
        "descr": "Round to the nearest integer, signaling Inexact or Rounded as appropriate if rounding occurs. The rounding mode is determined by the rounding parameter if given, else by the given context. If neither parameter is given then the rounding mode of the current context is used.", 
        "name": "decimal.Decimal.to_integral_exact", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.to_integral_exact", 
        "syntax": "to_integral_exact(rounding=None, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Decimal.to_integral_value": {
        "descr": "Round to the nearest integer without signaling Inexact or Rounded. If given, applies rounding; otherwise, uses the rounding method in either the supplied context or the current context.", 
        "name": "decimal.Decimal.to_integral_value", 
        "params": [], 
        "path": "python/library/decimal#decimal.Decimal.to_integral_value", 
        "syntax": "to_integral_value(rounding=None, context=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.DecimalException": {
        "descr": "Base class for other signals and a subclass of ArithmeticError.", 
        "name": "decimal.DecimalException", 
        "params": [], 
        "path": "python/library/decimal#decimal.DecimalException", 
        "syntax": "class decimal.DecimalException", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.DefaultContext": {
        "descr": "This context is used by the Context constructor as a prototype for new contexts. Changing a field (such a precision) has the effect of changing the default for new contexts created by the Context constructor.", 
        "name": "decimal.DefaultContext", 
        "params": [], 
        "path": "python/library/decimal#decimal.DefaultContext", 
        "syntax": "class decimal.DefaultContext", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.DivisionByZero": {
        "descr": "Signals the division of a non-infinite number by zero.", 
        "name": "decimal.DivisionByZero", 
        "params": [], 
        "path": "python/library/decimal#decimal.DivisionByZero", 
        "syntax": "class decimal.DivisionByZero", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.ExtendedContext": {
        "descr": "This is a standard context defined by the General Decimal Arithmetic Specification. Precision is set to nine. Rounding is set to ROUND_HALF_EVEN. All flags are cleared. No traps are enabled (so that exceptions are not raised during computations).", 
        "name": "decimal.ExtendedContext", 
        "params": [], 
        "path": "python/library/decimal#decimal.ExtendedContext", 
        "syntax": "class decimal.ExtendedContext", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.FloatOperation": {
        "descr": "Enable stricter semantics for mixing floats and Decimals.", 
        "name": "decimal.FloatOperation", 
        "params": [], 
        "path": "python/library/decimal#decimal.FloatOperation", 
        "syntax": "class decimal.FloatOperation", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Inexact": {
        "descr": "Indicates that rounding occurred and the result is not exact.", 
        "name": "decimal.Inexact", 
        "params": [], 
        "path": "python/library/decimal#decimal.Inexact", 
        "syntax": "class decimal.Inexact", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.InvalidOperation": {
        "descr": "An invalid operation was performed.", 
        "name": "decimal.InvalidOperation", 
        "params": [], 
        "path": "python/library/decimal#decimal.InvalidOperation", 
        "syntax": "class decimal.InvalidOperation", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Overflow": {
        "descr": "Numerical overflow.", 
        "name": "decimal.Overflow", 
        "params": [], 
        "path": "python/library/decimal#decimal.Overflow", 
        "syntax": "class decimal.Overflow", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Rounded": {
        "descr": "Rounding occurred though possibly no information was lost.", 
        "name": "decimal.Rounded", 
        "params": [], 
        "path": "python/library/decimal#decimal.Rounded", 
        "syntax": "class decimal.Rounded", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Subnormal": {
        "descr": "Exponent was lower than Emin prior to rounding.", 
        "name": "decimal.Subnormal", 
        "params": [], 
        "path": "python/library/decimal#decimal.Subnormal", 
        "syntax": "class decimal.Subnormal", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.Underflow": {
        "descr": "Numerical underflow with result rounded to zero.", 
        "name": "decimal.Underflow", 
        "params": [], 
        "path": "python/library/decimal#decimal.Underflow", 
        "syntax": "class decimal.Underflow", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.getcontext": {
        "descr": "Return the current context for the active thread.", 
        "name": "decimal.getcontext", 
        "params": [], 
        "path": "python/library/decimal#decimal.getcontext", 
        "syntax": "decimal.getcontext()", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.localcontext": {
        "descr": "Return a context manager that will set the current context for the active thread to a copy of ctx on entry to the with-statement and restore the previous context when exiting the with-statement. If no context is specified, a copy of the current context is used.", 
        "name": "decimal.localcontext", 
        "params": [], 
        "path": "python/library/decimal#decimal.localcontext", 
        "syntax": "decimal.localcontext(ctx=None)", 
        "type": "Numeric & Mathematical"
    }, 
    "decimal.setcontext": {
        "descr": "Set the current context for the active thread to c.", 
        "name": "decimal.setcontext", 
        "params": [], 
        "path": "python/library/decimal#decimal.setcontext", 
        "syntax": "decimal.setcontext(c)", 
        "type": "Numeric & Mathematical"
    }, 
    "decode": {
        "descr": "Return a string decoded from the given bytes. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace' and any other name registered via codecs.register_error(), see section Codec Base Classes. For a list of possible encodings, see section Standard Encodings.", 
        "name": "bytes.decode", 
        "params": [], 
        "path": "python/library/stdtypes#bytes.decode", 
        "syntax": "bytes.decode(encoding=\"utf-8\", errors=\"strict\")", 
        "type": "Built-in Types"
    }, 
    "delattr": {
        "descr": "This is a relative of setattr(). The arguments are an object and a string. The string must be the name of one of the object\u2019s attributes. The function deletes the named attribute, provided the object allows it. For example, delattr(x, 'foobar') is equivalent to del x.foobar.", 
        "name": "delattr", 
        "params": [], 
        "path": "python/library/functions#delattr", 
        "syntax": "delattr(object, name)", 
        "type": "Built-in Functions"
    }, 
    "dict": {
        "descr": "Create a new dictionary. The dict object is the dictionary class. See dict and Mapping Types \u2014 dict for documentation about this class.", 
        "name": "dict", 
        "params": [], 
        "path": "python/library/functions#dict", 
        "syntax": "dict(**kwarg)", 
        "type": "Built-in Functions"
    }, 
    "dict.clear": {
        "descr": "Remove all items from the dictionary.", 
        "name": "dict.clear", 
        "params": [], 
        "path": "python/library/stdtypes#dict.clear", 
        "syntax": "clear()", 
        "type": "Built-in Types"
    }, 
    "dict.copy": {
        "descr": "Return a shallow copy of the dictionary.", 
        "name": "dict.copy", 
        "params": [], 
        "path": "python/library/stdtypes#dict.copy", 
        "syntax": "copy()", 
        "type": "Built-in Types"
    }, 
    "dict.fromkeys": {
        "descr": "Create a new dictionary with keys from seq and values set to value.", 
        "name": "dict.fromkeys", 
        "params": [], 
        "path": "python/library/stdtypes#dict.fromkeys", 
        "syntax": "classmethod fromkeys(seq[, value])", 
        "type": "Built-in Types"
    }, 
    "dict.get": {
        "descr": "Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError.", 
        "name": "dict.get", 
        "params": [], 
        "path": "python/library/stdtypes#dict.get", 
        "syntax": "get(key[, default])", 
        "type": "Built-in Types"
    }, 
    "dict.items": {
        "descr": "Return a new view of the dictionary\u2019s items ((key, value) pairs). See the documentation of view objects.", 
        "name": "dict.items", 
        "params": [], 
        "path": "python/library/stdtypes#dict.items", 
        "syntax": "items()", 
        "type": "Built-in Types"
    }, 
    "dict.keys": {
        "descr": "Return a new view of the dictionary\u2019s keys. See the documentation of view objects.", 
        "name": "dict.keys", 
        "params": [], 
        "path": "python/library/stdtypes#dict.keys", 
        "syntax": "keys()", 
        "type": "Built-in Types"
    }, 
    "dict.pop": {
        "descr": "If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised.", 
        "name": "dict.pop", 
        "params": [], 
        "path": "python/library/stdtypes#dict.pop", 
        "syntax": "pop(key[, default])", 
        "type": "Built-in Types"
    }, 
    "dict.popitem": {
        "descr": "Remove and return an arbitrary (key, value) pair from the dictionary.", 
        "name": "dict.popitem", 
        "params": [], 
        "path": "python/library/stdtypes#dict.popitem", 
        "syntax": "popitem()", 
        "type": "Built-in Types"
    }, 
    "dict.setdefault": {
        "descr": "If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None.", 
        "name": "dict.setdefault", 
        "params": [], 
        "path": "python/library/stdtypes#dict.setdefault", 
        "syntax": "setdefault(key[, default])", 
        "type": "Built-in Types"
    }, 
    "dict.update": {
        "descr": "Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None.", 
        "name": "dict.update", 
        "params": [], 
        "path": "python/library/stdtypes#dict.update", 
        "syntax": "update([other])", 
        "type": "Built-in Types"
    }, 
    "dict.values": {
        "descr": "Return a new view of the dictionary\u2019s values. See the documentation of view objects.", 
        "name": "dict.values", 
        "params": [], 
        "path": "python/library/stdtypes#dict.values", 
        "syntax": "values()", 
        "type": "Built-in Types"
    }, 
    "difflib.Differ": {
        "descr": "This is a class for comparing sequences of lines of text, and producing human-readable differences or deltas. Differ uses SequenceMatcher both to compare sequences of lines, and to compare sequences of characters within similar (near-matching) lines.", 
        "name": "difflib.Differ", 
        "params": [], 
        "path": "python/library/difflib#difflib.Differ", 
        "syntax": "class difflib.Differ", 
        "type": "Text Processing"
    }, 
    "difflib.Differ.compare": {
        "descr": "Compare two sequences of lines, and generate the delta (a sequence of lines).", 
        "name": "difflib.Differ.compare", 
        "params": [], 
        "path": "python/library/difflib#difflib.Differ.compare", 
        "syntax": "compare(a, b)", 
        "type": "Text Processing"
    }, 
    "difflib.HtmlDiff": {
        "descr": "This class can be used to create an HTML table (or a complete HTML file containing the table) showing a side by side, line by line comparison of text with inter-line and intra-line change highlights. The table can be generated in either full or contextual difference mode.", 
        "name": "difflib.HtmlDiff", 
        "params": [], 
        "path": "python/library/difflib#difflib.HtmlDiff", 
        "syntax": "class difflib.HtmlDiff", 
        "type": "Text Processing"
    }, 
    "difflib.HtmlDiff.__init__": {
        "descr": "Initializes instance of HtmlDiff.", 
        "name": "difflib.HtmlDiff.__init__", 
        "params": [], 
        "path": "python/library/difflib#difflib.HtmlDiff.__init__", 
        "syntax": "__init__(tabsize=8, wrapcolumn=None, linejunk=None, charjunk=IS_CHARACTER_JUNK)", 
        "type": "Text Processing"
    }, 
    "difflib.HtmlDiff.make_file": {
        "descr": "Compares fromlines and tolines (lists of strings) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted.", 
        "name": "difflib.HtmlDiff.make_file", 
        "params": [], 
        "path": "python/library/difflib#difflib.HtmlDiff.make_file", 
        "syntax": "make_file(fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5)", 
        "type": "Text Processing"
    }, 
    "difflib.HtmlDiff.make_table": {
        "descr": "Compares fromlines and tolines (lists of strings) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted.", 
        "name": "difflib.HtmlDiff.make_table", 
        "params": [], 
        "path": "python/library/difflib#difflib.HtmlDiff.make_table", 
        "syntax": "make_table(fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5)", 
        "type": "Text Processing"
    }, 
    "difflib.IS_CHARACTER_JUNK": {
        "descr": "Return true for ignorable characters. The character ch is ignorable if ch is a space or tab, otherwise it is not ignorable. Used as a default for parameter charjunk in ndiff().", 
        "name": "difflib.IS_CHARACTER_JUNK", 
        "params": [], 
        "path": "python/library/difflib#difflib.IS_CHARACTER_JUNK", 
        "syntax": "difflib.IS_CHARACTER_JUNK(ch)", 
        "type": "Text Processing"
    }, 
    "difflib.IS_LINE_JUNK": {
        "descr": "Return true for ignorable lines. The line line is ignorable if line is blank or contains a single '#', otherwise it is not ignorable. Used as a default for parameter linejunk in ndiff() in older versions.", 
        "name": "difflib.IS_LINE_JUNK", 
        "params": [], 
        "path": "python/library/difflib#difflib.IS_LINE_JUNK", 
        "syntax": "difflib.IS_LINE_JUNK(line)", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher": {
        "descr": "This is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980\u2019s by Ratcliff and Obershelp under the hyperbolic name \u201cgestalt pattern matching.\u201d The idea is to find the longest contiguous matching subsequence that contains no \u201cjunk\u201d elements (the Ratcliff and Obershelp algorithm doesn\u2019t address junk). The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that \u201clook right\u201d to people.", 
        "name": "difflib.SequenceMatcher", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher", 
        "syntax": "class difflib.SequenceMatcher", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.find_longest_match": {
        "descr": "Find longest matching block in a[alo:ahi] and b[blo:bhi].", 
        "name": "difflib.SequenceMatcher.find_longest_match", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.find_longest_match", 
        "syntax": "find_longest_match(alo, ahi, blo, bhi)", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.get_grouped_opcodes": {
        "descr": "Return a generator of groups with up to n lines of context.", 
        "name": "difflib.SequenceMatcher.get_grouped_opcodes", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.get_grouped_opcodes", 
        "syntax": "get_grouped_opcodes(n=3)", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.get_matching_blocks": {
        "descr": "Return list of triples describing matching subsequences. Each triple is of the form (i, j, n), and means that a[i:i+n] == b[j:j+n]. The triples are monotonically increasing in i and j.", 
        "name": "difflib.SequenceMatcher.get_matching_blocks", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.get_matching_blocks", 
        "syntax": "get_matching_blocks()", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.get_opcodes": {
        "descr": "Return list of 5-tuples describing how to turn a into b. Each tuple is of the form (tag, i1, i2, j1, j2). The first tuple has i1 == j1 == 0, and remaining tuples have i1 equal to the i2 from the preceding tuple, and, likewise, j1 equal to the previous j2.", 
        "name": "difflib.SequenceMatcher.get_opcodes", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.get_opcodes", 
        "syntax": "get_opcodes()", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.quick_ratio": {
        "descr": "Return an upper bound on ratio() relatively quickly.", 
        "name": "difflib.SequenceMatcher.quick_ratio", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.quick_ratio", 
        "syntax": "quick_ratio()", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.ratio": {
        "descr": "Return a measure of the sequences\u2019 similarity as a float in the range [0, 1].", 
        "name": "difflib.SequenceMatcher.ratio", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.ratio", 
        "syntax": "ratio()", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.real_quick_ratio": {
        "descr": "Return an upper bound on ratio() very quickly.", 
        "name": "difflib.SequenceMatcher.real_quick_ratio", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.real_quick_ratio", 
        "syntax": "real_quick_ratio()", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.set_seq1": {
        "descr": "Set the first sequence to be compared. The second sequence to be compared is not changed.", 
        "name": "difflib.SequenceMatcher.set_seq1", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.set_seq1", 
        "syntax": "set_seq1(a)", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.set_seq2": {
        "descr": "Set the second sequence to be compared. The first sequence to be compared is not changed.", 
        "name": "difflib.SequenceMatcher.set_seq2", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.set_seq2", 
        "syntax": "set_seq2(b)", 
        "type": "Text Processing"
    }, 
    "difflib.SequenceMatcher.set_seqs": {
        "descr": "Set the two sequences to be compared.", 
        "name": "difflib.SequenceMatcher.set_seqs", 
        "params": [], 
        "path": "python/library/difflib#difflib.SequenceMatcher.set_seqs", 
        "syntax": "set_seqs(a, b)", 
        "type": "Text Processing"
    }, 
    "difflib.context_diff": {
        "descr": "Compare a and b (lists of strings); return a delta (a generator generating the delta lines) in context diff format.", 
        "name": "difflib.context_diff", 
        "params": [], 
        "path": "python/library/difflib#difflib.context_diff", 
        "syntax": "difflib.context_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')", 
        "type": "Text Processing"
    }, 
    "difflib.get_close_matches": {
        "descr": "Return a list of the best \u201cgood enough\u201d matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings).", 
        "name": "difflib.get_close_matches", 
        "params": [], 
        "path": "python/library/difflib#difflib.get_close_matches", 
        "syntax": "difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6)", 
        "type": "Text Processing"
    }, 
    "difflib.ndiff": {
        "descr": "Compare a and b (lists of strings); return a Differ-style delta (a generator generating the delta lines).", 
        "name": "difflib.ndiff", 
        "params": [], 
        "path": "python/library/difflib#difflib.ndiff", 
        "syntax": "difflib.ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK)", 
        "type": "Text Processing"
    }, 
    "difflib.restore": {
        "descr": "Return one of the two sequences that generated a delta.", 
        "name": "difflib.restore", 
        "params": [], 
        "path": "python/library/difflib#difflib.restore", 
        "syntax": "difflib.restore(sequence, which)", 
        "type": "Text Processing"
    }, 
    "difflib.unified_diff": {
        "descr": "Compare a and b (lists of strings); return a delta (a generator generating the delta lines) in unified diff format.", 
        "name": "difflib.unified_diff", 
        "params": [], 
        "path": "python/library/difflib#difflib.unified_diff", 
        "syntax": "difflib.unified_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')", 
        "type": "Text Processing"
    }, 
    "dir": {
        "descr": "Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.", 
        "name": "dir", 
        "params": [], 
        "path": "python/library/functions#dir", 
        "syntax": "dir([object])", 
        "type": "Built-in Functions"
    }, 
    "divmod": {
        "descr": "Take two (non complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using integer division. With mixed operand types, the rules for binary arithmetic operators apply. For integers, the result is the same as (a // b, a % b). For floating point numbers the result is (q, a % b), where q is usually math.floor(a / b) but may be 1 less than that. In any case q * b + a % b is very close to a, if a % b is non-zero it has the same sign as b, and 0 <= abs(a % b) < abs(b).", 
        "name": "divmod", 
        "params": [], 
        "path": "python/library/functions#divmod", 
        "syntax": "divmod(a, b)", 
        "type": "Built-in Functions"
    }, 
    "doctest.DebugRunner": {
        "descr": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered. If an unexpected exception occurs, an UnexpectedException exception is raised, containing the test, the example, and the original exception. If the output doesn\u2019t match, then a DocTestFailure exception is raised, containing the test, the example, and the actual output.", 
        "name": "doctest.DebugRunner", 
        "params": [], 
        "path": "python/library/doctest#doctest.DebugRunner", 
        "syntax": "class doctest.DebugRunner(checker=None, verbose=None, optionflags=0)", 
        "type": "Development Tools"
    }, 
    "doctest.DocFileSuite": {
        "descr": "Convert doctest tests from one or more text files to a unittest.TestSuite.", 
        "name": "doctest.DocFileSuite", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocFileSuite", 
        "syntax": "doctest.DocFileSuite(*paths, module_relative=True, package=None, setUp=None, tearDown=None, globs=None, optionflags=0, parser=DocTestParser(), encoding=None)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest": {
        "descr": "A collection of doctest examples that should be run in a single namespace. The constructor arguments are used to initialize the attributes of the same names.", 
        "name": "doctest.DocTest", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest", 
        "syntax": "class doctest.DocTest(examples, globs, name, filename, lineno, docstring)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest.docstring": {
        "descr": "The string that the test was extracted from, or \u2018None\u2019 if the string is unavailable, or if the test was not extracted from a string.", 
        "name": "doctest.DocTest.docstring", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest.docstring", 
        "syntax": "docstring", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest.examples": {
        "descr": "A list of Example objects encoding the individual interactive Python examples that should be run by this test.", 
        "name": "doctest.DocTest.examples", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest.examples", 
        "syntax": "examples", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest.filename": {
        "descr": "The name of the file that this DocTest was extracted from; or None if the filename is unknown, or if the DocTest was not extracted from a file.", 
        "name": "doctest.DocTest.filename", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest.filename", 
        "syntax": "filename", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest.globs": {
        "descr": "The namespace (aka globals) that the examples should be run in. This is a dictionary mapping names to values. Any changes to the namespace made by the examples (such as binding new variables) will be reflected in globs after the test is run.", 
        "name": "doctest.DocTest.globs", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest.globs", 
        "syntax": "globs", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest.lineno": {
        "descr": "The line number within filename where this DocTest begins, or None if the line number is unavailable. This line number is zero-based with respect to the beginning of the file.", 
        "name": "doctest.DocTest.lineno", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest.lineno", 
        "syntax": "lineno", 
        "type": "Development Tools"
    }, 
    "doctest.DocTest.name": {
        "descr": "A string name identifying the DocTest. Typically, this is the name of the object or file that the test was extracted from.", 
        "name": "doctest.DocTest.name", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTest.name", 
        "syntax": "name", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestFailure": {
        "descr": "An exception raised by DocTestRunner to signal that a doctest example\u2019s actual output did not match its expected output. The constructor arguments are used to initialize the attributes of the same names.", 
        "name": "doctest.DocTestFailure", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestFailure", 
        "syntax": "exception doctest.DocTestFailure(test, example, got)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestFailure.example": {
        "descr": "The Example that failed.", 
        "name": "doctest.DocTestFailure.example", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestFailure.example", 
        "syntax": "DocTestFailure.example", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestFailure.got": {
        "descr": "The example\u2019s actual output.", 
        "name": "doctest.DocTestFailure.got", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestFailure.got", 
        "syntax": "DocTestFailure.got", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestFailure.test": {
        "descr": "The DocTest object that was being run when the example failed.", 
        "name": "doctest.DocTestFailure.test", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestFailure.test", 
        "syntax": "DocTestFailure.test", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestFinder": {
        "descr": "A processing class used to extract the DocTests that are relevant to a given object, from its docstring and the docstrings of its contained objects. DocTests can currently be extracted from the following object types: modules, functions, classes, methods, staticmethods, classmethods, and properties.", 
        "name": "doctest.DocTestFinder", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestFinder", 
        "syntax": "class doctest.DocTestFinder(verbose=False, parser=DocTestParser(), recurse=True, exclude_empty=True)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestFinder.find": {
        "descr": "Return a list of the DocTests that are defined by obj\u2018s docstring, or by any of its contained objects\u2019 docstrings.", 
        "name": "doctest.DocTestFinder.find", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestFinder.find", 
        "syntax": "find(obj[, name][, module][, globs][, extraglobs])", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestParser": {
        "descr": "A processing class used to extract interactive examples from a string, and use them to create a DocTest object.", 
        "name": "doctest.DocTestParser", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestParser", 
        "syntax": "class doctest.DocTestParser", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestParser.get_doctest": {
        "descr": "Extract all doctest examples from the given string, and collect them into a DocTest object.", 
        "name": "doctest.DocTestParser.get_doctest", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestParser.get_doctest", 
        "syntax": "get_doctest(string, globs, name, filename, lineno)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestParser.get_examples": {
        "descr": "Extract all doctest examples from the given string, and return them as a list of Example objects. Line numbers are 0-based. The optional argument name is a name identifying this string, and is only used for error messages.", 
        "name": "doctest.DocTestParser.get_examples", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestParser.get_examples", 
        "syntax": "get_examples(string, name='<string>')", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestParser.parse": {
        "descr": "Divide the given string into examples and intervening text, and return them as a list of alternating Examples and strings. Line numbers for the Examples are 0-based. The optional argument name is a name identifying this string, and is only used for error messages.", 
        "name": "doctest.DocTestParser.parse", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestParser.parse", 
        "syntax": "parse(string, name='<string>')", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner": {
        "descr": "A processing class used to execute and verify the interactive examples in a DocTest.", 
        "name": "doctest.DocTestRunner", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner", 
        "syntax": "class doctest.DocTestRunner(checker=None, verbose=None, optionflags=0)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner.report_failure": {
        "descr": "Report that the given example failed. This method is provided to allow subclasses of DocTestRunner to customize their output; it should not be called directly.", 
        "name": "doctest.DocTestRunner.report_failure", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner.report_failure", 
        "syntax": "report_failure(out, test, example, got)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner.report_start": {
        "descr": "Report that the test runner is about to process the given example. This method is provided to allow subclasses of DocTestRunner to customize their output; it should not be called directly.", 
        "name": "doctest.DocTestRunner.report_start", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner.report_start", 
        "syntax": "report_start(out, test, example)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner.report_success": {
        "descr": "Report that the given example ran successfully. This method is provided to allow subclasses of DocTestRunner to customize their output; it should not be called directly.", 
        "name": "doctest.DocTestRunner.report_success", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner.report_success", 
        "syntax": "report_success(out, test, example, got)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner.report_unexpected_exception": {
        "descr": "Report that the given example raised an unexpected exception. This method is provided to allow subclasses of DocTestRunner to customize their output; it should not be called directly.", 
        "name": "doctest.DocTestRunner.report_unexpected_exception", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner.report_unexpected_exception", 
        "syntax": "report_unexpected_exception(out, test, example, exc_info)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner.run": {
        "descr": "Run the examples in test (a DocTest object), and display the results using the writer function out.", 
        "name": "doctest.DocTestRunner.run", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner.run", 
        "syntax": "run(test, compileflags=None, out=None, clear_globs=True)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestRunner.summarize": {
        "descr": "Print a summary of all the test cases that have been run by this DocTestRunner, and return a named tuple TestResults(failed, attempted).", 
        "name": "doctest.DocTestRunner.summarize", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestRunner.summarize", 
        "syntax": "summarize(verbose=None)", 
        "type": "Development Tools"
    }, 
    "doctest.DocTestSuite": {
        "descr": "Convert doctest tests for a module to a unittest.TestSuite.", 
        "name": "doctest.DocTestSuite", 
        "params": [], 
        "path": "python/library/doctest#doctest.DocTestSuite", 
        "syntax": "doctest.DocTestSuite(module=None, globs=None, extraglobs=None, test_finder=None, setUp=None, tearDown=None, checker=None)", 
        "type": "Development Tools"
    }, 
    "doctest.Example": {
        "descr": "A single interactive example, consisting of a Python statement and its expected output. The constructor arguments are used to initialize the attributes of the same names.", 
        "name": "doctest.Example", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example", 
        "syntax": "class doctest.Example(source, want, exc_msg=None, lineno=0, indent=0, options=None)", 
        "type": "Development Tools"
    }, 
    "doctest.Example.exc_msg": {
        "descr": "The exception message generated by the example, if the example is expected to generate an exception; or None if it is not expected to generate an exception. This exception message is compared against the return value of traceback.format_exception_only(). exc_msg ends with a newline unless it\u2019s None. The constructor adds a newline if needed.", 
        "name": "doctest.Example.exc_msg", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example.exc_msg", 
        "syntax": "exc_msg", 
        "type": "Development Tools"
    }, 
    "doctest.Example.indent": {
        "descr": "The example\u2019s indentation in the containing string, i.e., the number of space characters that precede the example\u2019s first prompt.", 
        "name": "doctest.Example.indent", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example.indent", 
        "syntax": "indent", 
        "type": "Development Tools"
    }, 
    "doctest.Example.lineno": {
        "descr": "The line number within the string containing this example where the example begins. This line number is zero-based with respect to the beginning of the containing string.", 
        "name": "doctest.Example.lineno", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example.lineno", 
        "syntax": "lineno", 
        "type": "Development Tools"
    }, 
    "doctest.Example.options": {
        "descr": "A dictionary mapping from option flags to True or False, which is used to override default options for this example. Any option flags not contained in this dictionary are left at their default value (as specified by the DocTestRunner\u2018s optionflags). By default, no options are set.", 
        "name": "doctest.Example.options", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example.options", 
        "syntax": "options", 
        "type": "Development Tools"
    }, 
    "doctest.Example.source": {
        "descr": "A string containing the example\u2019s source code. This source code consists of a single Python statement, and always ends with a newline; the constructor adds a newline when necessary.", 
        "name": "doctest.Example.source", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example.source", 
        "syntax": "source", 
        "type": "Development Tools"
    }, 
    "doctest.Example.want": {
        "descr": "The expected output from running the example\u2019s source code (either from stdout, or a traceback in case of exception). want ends with a newline unless no output is expected, in which case it\u2019s an empty string. The constructor adds a newline when necessary.", 
        "name": "doctest.Example.want", 
        "params": [], 
        "path": "python/library/doctest#doctest.Example.want", 
        "syntax": "want", 
        "type": "Development Tools"
    }, 
    "doctest.OutputChecker": {
        "descr": "A class used to check the whether the actual output from a doctest example matches the expected output. OutputChecker defines two methods: check_output(), which compares a given pair of outputs, and returns true if they match; and output_difference(), which returns a string describing the differences between two outputs.", 
        "name": "doctest.OutputChecker", 
        "params": [], 
        "path": "python/library/doctest#doctest.OutputChecker", 
        "syntax": "class doctest.OutputChecker", 
        "type": "Development Tools"
    }, 
    "doctest.OutputChecker.check_output": {
        "descr": "Return True iff the actual output from an example (got) matches the expected output (want). These strings are always considered to match if they are identical; but depending on what option flags the test runner is using, several non-exact match types are also possible. See section Option Flags for more information about option flags.", 
        "name": "doctest.OutputChecker.check_output", 
        "params": [], 
        "path": "python/library/doctest#doctest.OutputChecker.check_output", 
        "syntax": "check_output(want, got, optionflags)", 
        "type": "Development Tools"
    }, 
    "doctest.OutputChecker.output_difference": {
        "descr": "Return a string describing the differences between the expected output for a given example (example) and the actual output (got). optionflags is the set of option flags used to compare want and got.", 
        "name": "doctest.OutputChecker.output_difference", 
        "params": [], 
        "path": "python/library/doctest#doctest.OutputChecker.output_difference", 
        "syntax": "output_difference(example, got, optionflags)", 
        "type": "Development Tools"
    }, 
    "doctest.UnexpectedException": {
        "descr": "An exception raised by DocTestRunner to signal that a doctest example raised an unexpected exception. The constructor arguments are used to initialize the attributes of the same names.", 
        "name": "doctest.UnexpectedException", 
        "params": [], 
        "path": "python/library/doctest#doctest.UnexpectedException", 
        "syntax": "exception doctest.UnexpectedException(test, example, exc_info)", 
        "type": "Development Tools"
    }, 
    "doctest.UnexpectedException.example": {
        "descr": "The Example that failed.", 
        "name": "doctest.UnexpectedException.example", 
        "params": [], 
        "path": "python/library/doctest#doctest.UnexpectedException.example", 
        "syntax": "UnexpectedException.example", 
        "type": "Development Tools"
    }, 
    "doctest.UnexpectedException.exc_info": {
        "descr": "A tuple containing information about the unexpected exception, as returned by sys.exc_info().", 
        "name": "doctest.UnexpectedException.exc_info", 
        "params": [], 
        "path": "python/library/doctest#doctest.UnexpectedException.exc_info", 
        "syntax": "UnexpectedException.exc_info", 
        "type": "Development Tools"
    }, 
    "doctest.UnexpectedException.test": {
        "descr": "The DocTest object that was being run when the example failed.", 
        "name": "doctest.UnexpectedException.test", 
        "params": [], 
        "path": "python/library/doctest#doctest.UnexpectedException.test", 
        "syntax": "UnexpectedException.test", 
        "type": "Development Tools"
    }, 
    "doctest.debug": {
        "descr": "Debug the doctests for an object.", 
        "name": "doctest.debug", 
        "params": [], 
        "path": "python/library/doctest#doctest.debug", 
        "syntax": "doctest.debug(module, name, pm=False)", 
        "type": "Development Tools"
    }, 
    "doctest.debug_src": {
        "descr": "Debug the doctests in a string.", 
        "name": "doctest.debug_src", 
        "params": [], 
        "path": "python/library/doctest#doctest.debug_src", 
        "syntax": "doctest.debug_src(src, pm=False, globs=None)", 
        "type": "Development Tools"
    }, 
    "doctest.register_optionflag": {
        "descr": "Create a new option flag with a given name, and return the new flag\u2019s integer value. register_optionflag() can be used when subclassing OutputChecker or DocTestRunner to create new options that are supported by your subclasses. register_optionflag() should always be called using the following idiom:", 
        "name": "doctest.register_optionflag", 
        "params": [], 
        "path": "python/library/doctest#doctest.register_optionflag", 
        "syntax": "doctest.register_optionflag(name)", 
        "type": "Development Tools"
    }, 
    "doctest.run_docstring_examples": {
        "descr": "Test examples associated with object f; for example, f may be a module, function, or class object.", 
        "name": "doctest.run_docstring_examples", 
        "params": [], 
        "path": "python/library/doctest#doctest.run_docstring_examples", 
        "syntax": "doctest.run_docstring_examples(f, globs, verbose=False, name=\"NoName\", compileflags=None, optionflags=0)", 
        "type": "Development Tools"
    }, 
    "doctest.script_from_examples": {
        "descr": "Convert text with examples to a script.", 
        "name": "doctest.script_from_examples", 
        "params": [], 
        "path": "python/library/doctest#doctest.script_from_examples", 
        "syntax": "doctest.script_from_examples(s)", 
        "type": "Development Tools"
    }, 
    "doctest.set_unittest_reportflags": {
        "descr": "Set the doctest reporting flags to use.", 
        "name": "doctest.set_unittest_reportflags", 
        "params": [], 
        "path": "python/library/doctest#doctest.set_unittest_reportflags", 
        "syntax": "doctest.set_unittest_reportflags(flags)", 
        "type": "Development Tools"
    }, 
    "doctest.testfile": {
        "descr": "All arguments except filename are optional, and should be specified in keyword form.", 
        "name": "doctest.testfile", 
        "params": [], 
        "path": "python/library/doctest#doctest.testfile", 
        "syntax": "doctest.testfile(filename, module_relative=True, name=None, package=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, parser=DocTestParser(), encoding=None)", 
        "type": "Development Tools"
    }, 
    "doctest.testmod": {
        "descr": "All arguments are optional, and all except for m should be specified in keyword form.", 
        "name": "doctest.testmod", 
        "params": [], 
        "path": "python/library/doctest#doctest.testmod", 
        "syntax": "doctest.testmod(m=None, name=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, exclude_empty=False)", 
        "type": "Development Tools"
    }, 
    "doctest.testsource": {
        "descr": "Convert the doctest for an object to a script.", 
        "name": "doctest.testsource", 
        "params": [], 
        "path": "python/library/doctest#doctest.testsource", 
        "syntax": "doctest.testsource(module, name)", 
        "type": "Development Tools"
    }, 
    "email.charset.Charset": {
        "descr": "Map character sets to their email properties.", 
        "name": "email.charset.Charset", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset", 
        "syntax": "class email.charset.Charset(input_charset=DEFAULT_CHARSET)", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.__eq__": {
        "descr": "This method allows you to compare two Charset instances for equality.", 
        "name": "email.charset.Charset.__eq__", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.__eq__", 
        "syntax": "__eq__(other)", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.__ne__": {
        "descr": "This method allows you to compare two Charset instances for inequality.", 
        "name": "email.charset.Charset.__ne__", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.__ne__", 
        "syntax": "__ne__(other)", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.__str__": {
        "descr": "Returns input_charset as a string coerced to lower case. __repr__() is an alias for __str__().", 
        "name": "email.charset.Charset.__str__", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.__str__", 
        "syntax": "__str__()", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.body_encode": {
        "descr": "Body-encode the string string.", 
        "name": "email.charset.Charset.body_encode", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.body_encode", 
        "syntax": "body_encode(string)", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.body_encoding": {
        "descr": "Same as header_encoding, but describes the encoding for the mail message\u2019s body, which indeed may be different than the header encoding. Charset.SHORTEST is not allowed for body_encoding.", 
        "name": "email.charset.Charset.body_encoding", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.body_encoding", 
        "syntax": "body_encoding", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.get_body_encoding": {
        "descr": "Return the content transfer encoding used for body encoding.", 
        "name": "email.charset.Charset.get_body_encoding", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.get_body_encoding", 
        "syntax": "get_body_encoding()", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.get_output_charset": {
        "descr": "Return the output character set.", 
        "name": "email.charset.Charset.get_output_charset", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.get_output_charset", 
        "syntax": "get_output_charset()", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.header_encode": {
        "descr": "Header-encode the string string.", 
        "name": "email.charset.Charset.header_encode", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.header_encode", 
        "syntax": "header_encode(string)", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.header_encode_lines": {
        "descr": "Header-encode a string by converting it first to bytes.", 
        "name": "email.charset.Charset.header_encode_lines", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.header_encode_lines", 
        "syntax": "header_encode_lines(string, maxlengths)", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.header_encoding": {
        "descr": "If the character set must be encoded before it can be used in an email header, this attribute will be set to Charset.QP (for quoted-printable), Charset.BASE64 (for base64 encoding), or Charset.SHORTEST for the shortest of QP or BASE64 encoding. Otherwise, it will be None.", 
        "name": "email.charset.Charset.header_encoding", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.header_encoding", 
        "syntax": "header_encoding", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.input_charset": {
        "descr": "The initial character set specified. Common aliases are converted to their official email names (e.g. latin_1 is converted to iso-8859-1). Defaults to 7-bit us-ascii.", 
        "name": "email.charset.Charset.input_charset", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.input_charset", 
        "syntax": "input_charset", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.input_codec": {
        "descr": "The name of the Python codec used to convert the input_charset to Unicode. If no conversion codec is necessary, this attribute will be None.", 
        "name": "email.charset.Charset.input_codec", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.input_codec", 
        "syntax": "input_codec", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.output_charset": {
        "descr": "Some character sets must be converted before they can be used in email headers or bodies. If the input_charset is one of them, this attribute will contain the name of the character set output will be converted to. Otherwise, it will be None.", 
        "name": "email.charset.Charset.output_charset", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.output_charset", 
        "syntax": "output_charset", 
        "type": "Internet Data"
    }, 
    "email.charset.Charset.output_codec": {
        "descr": "The name of the Python codec used to convert Unicode to the output_charset. If no conversion codec is necessary, this attribute will have the same value as the input_codec.", 
        "name": "email.charset.Charset.output_codec", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.Charset.output_codec", 
        "syntax": "output_codec", 
        "type": "Internet Data"
    }, 
    "email.charset.add_alias": {
        "descr": "Add a character set alias. alias is the alias name, e.g. latin-1. canonical is the character set\u2019s canonical name, e.g. iso-8859-1.", 
        "name": "email.charset.add_alias", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.add_alias", 
        "syntax": "email.charset.add_alias(alias, canonical)", 
        "type": "Internet Data"
    }, 
    "email.charset.add_charset": {
        "descr": "Add character properties to the global registry.", 
        "name": "email.charset.add_charset", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.add_charset", 
        "syntax": "email.charset.add_charset(charset, header_enc=None, body_enc=None, output_charset=None)", 
        "type": "Internet Data"
    }, 
    "email.charset.add_codec": {
        "descr": "Add a codec that map characters in the given character set to and from Unicode.", 
        "name": "email.charset.add_codec", 
        "params": [], 
        "path": "python/library/email.charset#email.charset.add_codec", 
        "syntax": "email.charset.add_codec(charset, codecname)", 
        "type": "Internet Data"
    }, 
    "email.encoders.encode_7or8bit": {
        "descr": "This doesn\u2019t actually modify the message\u2019s payload, but it does set the Content-Transfer-Encoding header to either 7bit or 8bit as appropriate, based on the payload data.", 
        "name": "email.encoders.encode_7or8bit", 
        "params": [], 
        "path": "python/library/email.encoders#email.encoders.encode_7or8bit", 
        "syntax": "email.encoders.encode_7or8bit(msg)", 
        "type": "Internet Data"
    }, 
    "email.encoders.encode_base64": {
        "descr": "Encodes the payload into base64 form and sets the Content-Transfer-Encoding header to base64. This is a good encoding to use when most of your payload is unprintable data since it is a more compact form than quoted-printable. The drawback of base64 encoding is that it renders the text non-human readable.", 
        "name": "email.encoders.encode_base64", 
        "params": [], 
        "path": "python/library/email.encoders#email.encoders.encode_base64", 
        "syntax": "email.encoders.encode_base64(msg)", 
        "type": "Internet Data"
    }, 
    "email.encoders.encode_noop": {
        "descr": "This does nothing; it doesn\u2019t even set the Content-Transfer-Encoding header.", 
        "name": "email.encoders.encode_noop", 
        "params": [], 
        "path": "python/library/email.encoders#email.encoders.encode_noop", 
        "syntax": "email.encoders.encode_noop(msg)", 
        "type": "Internet Data"
    }, 
    "email.encoders.encode_quopri": {
        "descr": "Encodes the payload into quoted-printable form and sets the Content-Transfer-Encoding header to quoted-printable [1]. This is a good encoding to use when most of your payload is normal printable data, but contains a few unprintable characters.", 
        "name": "email.encoders.encode_quopri", 
        "params": [], 
        "path": "python/library/email.encoders#email.encoders.encode_quopri", 
        "syntax": "email.encoders.encode_quopri(msg)", 
        "type": "Internet Data"
    }, 
    "email.errors.BoundaryError": {
        "descr": "Raised under some error conditions when parsing the RFC 2822 headers of a message, this class is derived from MessageParseError. It can be raised from the Parser.parse or Parser.parsestr methods.", 
        "name": "email.errors.BoundaryError", 
        "params": [], 
        "path": "python/library/email.errors#email.errors.BoundaryError", 
        "syntax": "exception email.errors.BoundaryError", 
        "type": "Internet Data"
    }, 
    "email.errors.HeaderParseError": {
        "descr": "Raised under some error conditions when parsing the RFC 2822 headers of a message, this class is derived from MessageParseError. It can be raised from the Parser.parse or Parser.parsestr methods.", 
        "name": "email.errors.HeaderParseError", 
        "params": [], 
        "path": "python/library/email.errors#email.errors.HeaderParseError", 
        "syntax": "exception email.errors.HeaderParseError", 
        "type": "Internet Data"
    }, 
    "email.errors.MessageError": {
        "descr": "This is the base class for all exceptions that the email package can raise. It is derived from the standard Exception class and defines no additional methods.", 
        "name": "email.errors.MessageError", 
        "params": [], 
        "path": "python/library/email.errors#email.errors.MessageError", 
        "syntax": "exception email.errors.MessageError", 
        "type": "Internet Data"
    }, 
    "email.errors.MessageParseError": {
        "descr": "This is the base class for exceptions raised by the Parser class. It is derived from MessageError.", 
        "name": "email.errors.MessageParseError", 
        "params": [], 
        "path": "python/library/email.errors#email.errors.MessageParseError", 
        "syntax": "exception email.errors.MessageParseError", 
        "type": "Internet Data"
    }, 
    "email.errors.MultipartConversionError": {
        "descr": "Raised when a payload is added to a Message object using add_payload(), but the payload is already a scalar and the message\u2019s Content-Type main type is not either multipart or missing. MultipartConversionError multiply inherits from MessageError and the built-in TypeError.", 
        "name": "email.errors.MultipartConversionError", 
        "params": [], 
        "path": "python/library/email.errors#email.errors.MultipartConversionError", 
        "syntax": "exception email.errors.MultipartConversionError", 
        "type": "Internet Data"
    }, 
    "email.generator.BytesGenerator": {
        "descr": "The constructor for the BytesGenerator class takes a binary file-like object called outfp for an argument. outfp must support a write() method that accepts binary data.", 
        "name": "email.generator.BytesGenerator", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.BytesGenerator", 
        "syntax": "class email.generator.BytesGenerator(outfp, mangle_from_=True, maxheaderlen=78, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.generator.BytesGenerator.clone": {
        "descr": "Return an independent clone of this BytesGenerator instance with the exact same options.", 
        "name": "email.generator.BytesGenerator.clone", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.BytesGenerator.clone", 
        "syntax": "clone(fp)", 
        "type": "Internet Data"
    }, 
    "email.generator.BytesGenerator.flatten": {
        "descr": "Print the textual representation of the message object structure rooted at msg to the output file specified when the BytesGenerator instance was created. Subparts are visited depth-first and the resulting text will be properly MIME encoded. If the policy option cte_type is 8bit (the default), then any bytes with the high bit set in the original parsed message that have not been modified will be copied faithfully to the output. If cte_type is 7bit, the bytes will be converted as needed using an ASCII-compatible Content-Transfer-Encoding. In particular, RFC-invalid non-ASCII bytes in headers will be encoded using the MIME unknown-8bit character set, thus rendering them RFC-compliant.", 
        "name": "email.generator.BytesGenerator.flatten", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.BytesGenerator.flatten", 
        "syntax": "flatten(msg, unixfrom=False, linesep=None)", 
        "type": "Internet Data"
    }, 
    "email.generator.BytesGenerator.write": {
        "descr": "Write the string s to the underlying file object. s is encoded using the ASCII codec and written to the write method of the outfp outfp passed to the BytesGenerator\u2018s constructor. This provides just enough file-like API for BytesGenerator instances to be used in the print() function.", 
        "name": "email.generator.BytesGenerator.write", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.BytesGenerator.write", 
        "syntax": "write(s)", 
        "type": "Internet Data"
    }, 
    "email.generator.DecodedGenerator": {
        "descr": "This class, derived from Generator walks through all the subparts of a message. If the subpart is of main type text, then it prints the decoded payload of the subpart. Optional _mangle_from_ and maxheaderlen are as with the Generator base class.", 
        "name": "email.generator.DecodedGenerator", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.DecodedGenerator", 
        "syntax": "class email.generator.DecodedGenerator(outfp, mangle_from_=True, maxheaderlen=78, fmt=None)", 
        "type": "Internet Data"
    }, 
    "email.generator.Generator": {
        "descr": "The constructor for the Generator class takes a file-like object called outfp for an argument. outfp must support the write() method and be usable as the output file for the print() function.", 
        "name": "email.generator.Generator", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.Generator", 
        "syntax": "class email.generator.Generator(outfp, mangle_from_=True, maxheaderlen=78, *, policy=None)", 
        "type": "Internet Data"
    }, 
    "email.generator.Generator.clone": {
        "descr": "Return an independent clone of this Generator instance with the exact same options.", 
        "name": "email.generator.Generator.clone", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.Generator.clone", 
        "syntax": "clone(fp)", 
        "type": "Internet Data"
    }, 
    "email.generator.Generator.flatten": {
        "descr": "Print the textual representation of the message object structure rooted at msg to the output file specified when the Generator instance was created. Subparts are visited depth-first and the resulting text will be properly MIME encoded.", 
        "name": "email.generator.Generator.flatten", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.Generator.flatten", 
        "syntax": "flatten(msg, unixfrom=False, linesep=None)", 
        "type": "Internet Data"
    }, 
    "email.generator.Generator.write": {
        "descr": "Write the string s to the underlying file object, i.e. outfp passed to Generator\u2018s constructor. This provides just enough file-like API for Generator instances to be used in the print() function.", 
        "name": "email.generator.Generator.write", 
        "params": [], 
        "path": "python/library/email.generator#email.generator.Generator.write", 
        "syntax": "write(s)", 
        "type": "Internet Data"
    }, 
    "email.header.Header": {
        "descr": "Create a MIME-compliant header that can contain strings in different character sets.", 
        "name": "email.header.Header", 
        "params": [], 
        "path": "python/library/email.header#email.header.Header", 
        "syntax": "class email.header.Header(s=None, charset=None, maxlinelen=None, header_name=None, continuation_ws=' ', errors='strict')", 
        "type": "Internet Data"
    }, 
    "email.header.Header.__eq__": {
        "descr": "This method allows you to compare two Header instances for equality.", 
        "name": "email.header.Header.__eq__", 
        "params": [], 
        "path": "python/library/email.header#email.header.Header.__eq__", 
        "syntax": "__eq__(other)", 
        "type": "Internet Data"
    }, 
    "email.header.Header.__ne__": {
        "descr": "This method allows you to compare two Header instances for inequality.", 
        "name": "email.header.Header.__ne__", 
        "params": [], 
        "path": "python/library/email.header#email.header.Header.__ne__", 
        "syntax": "__ne__(other)", 
        "type": "Internet Data"
    }, 
    "email.header.Header.__str__": {
        "descr": "Returns an approximation of the Header as a string, using an unlimited line length. All pieces are converted to unicode using the specified encoding and joined together appropriately. Any pieces with a charset of 'unknown-8bit' are decoded as ASCII using the 'replace' error handler.", 
        "name": "email.header.Header.__str__", 
        "params": [], 
        "path": "python/library/email.header#email.header.Header.__str__", 
        "syntax": "__str__()", 
        "type": "Internet Data"
    }, 
    "email.header.Header.append": {
        "descr": "Append the string s to the MIME header.", 
        "name": "email.header.Header.append", 
        "params": [], 
        "path": "python/library/email.header#email.header.Header.append", 
        "syntax": "append(s, charset=None, errors='strict')", 
        "type": "Internet Data"
    }, 
    "email.header.Header.encode": {
        "descr": "Encode a message header into an RFC-compliant format, possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings.", 
        "name": "email.header.Header.encode", 
        "params": [], 
        "path": "python/library/email.header#email.header.Header.encode", 
        "syntax": "encode(splitchars=';, \\t', maxlinelen=None, linesep='\\n')", 
        "type": "Internet Data"
    }, 
    "email.header.decode_header": {
        "descr": "Decode a message header value without converting the character set. The header value is in header.", 
        "name": "email.header.decode_header", 
        "params": [], 
        "path": "python/library/email.header#email.header.decode_header", 
        "syntax": "email.header.decode_header(header)", 
        "type": "Internet Data"
    }, 
    "email.header.make_header": {
        "descr": "Create a Header instance from a sequence of pairs as returned by decode_header().", 
        "name": "email.header.make_header", 
        "params": [], 
        "path": "python/library/email.header#email.header.make_header", 
        "syntax": "email.header.make_header(decoded_seq, maxlinelen=None, header_name=None, continuation_ws=' ')", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Address": {
        "descr": "The class used to represent an email address. The general form of an address is:", 
        "name": "email.headerregistry.Address", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Address", 
        "syntax": "class email.headerregistry.Address(display_name='', username='', domain='', addr_spec=None)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Address.__str__": {
        "descr": "The str value of the object is the address quoted according to RFC 5322 rules, but with no Content Transfer Encoding of any non-ASCII characters.", 
        "name": "email.headerregistry.Address.__str__", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Address.__str__", 
        "syntax": "__str__()", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Address.addr_spec": {
        "descr": "The username@domain portion of the address, correctly quoted for use as a bare address (the second form shown above). This attribute is not mutable.", 
        "name": "email.headerregistry.Address.addr_spec", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Address.addr_spec", 
        "syntax": "addr_spec", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Address.display_name": {
        "descr": "The display name portion of the address, if any, with all quoting removed. If the address does not have a display name, this attribute will be an empty string.", 
        "name": "email.headerregistry.Address.display_name", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Address.display_name", 
        "syntax": "display_name", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Address.domain": {
        "descr": "The domain portion of the address.", 
        "name": "email.headerregistry.Address.domain", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Address.domain", 
        "syntax": "domain", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Address.username": {
        "descr": "The username portion of the address, with all quoting removed.", 
        "name": "email.headerregistry.Address.username", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Address.username", 
        "syntax": "username", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.AddressHeader": {
        "descr": "Address headers are one of the most complex structured header types. The AddressHeader class provides a generic interface to any address header.", 
        "name": "email.headerregistry.AddressHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.AddressHeader", 
        "syntax": "class email.headerregistry.AddressHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.AddressHeader.addresses": {
        "descr": "A tuple of Address objects encoding all of the individual addresses from the header value. If the header value contains any groups, the individual addresses from the group are included in the list at the point where the group occurs in the value (that is, the list of addresses is \u201cflattened\u201d into a one dimensional list).", 
        "name": "email.headerregistry.AddressHeader.addresses", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.AddressHeader.addresses", 
        "syntax": "addresses", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.AddressHeader.groups": {
        "descr": "A tuple of Group objects encoding the addresses and groups found in the header value. Addresses that are not part of a group are represented in this list as single-address Groups whose display_name is None.", 
        "name": "email.headerregistry.AddressHeader.groups", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.AddressHeader.groups", 
        "syntax": "groups", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.BaseHeader": {
        "descr": "name and value are passed to BaseHeader from the header_factory call. The string value of any header object is the value fully decoded to unicode.", 
        "name": "email.headerregistry.BaseHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.BaseHeader", 
        "syntax": "class email.headerregistry.BaseHeader(name, value)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.BaseHeader.defects": {
        "descr": "A tuple of HeaderDefect instances reporting any RFC compliance problems found during parsing. The email package tries to be complete about detecting compliance issues. See the errors module for a discussion of the types of defects that may be reported.", 
        "name": "email.headerregistry.BaseHeader.defects", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.BaseHeader.defects", 
        "syntax": "defects", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.BaseHeader.fold": {
        "descr": "Return a string containing linesep characters as required to correctly fold the header according to policy. A cte_type of 8bit will be treated as if it were 7bit, since strings may not contain binary data.", 
        "name": "email.headerregistry.BaseHeader.fold", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.BaseHeader.fold", 
        "syntax": "fold(*, policy)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.BaseHeader.max_count": {
        "descr": "The maximum number of headers of this type that can have the same name. A value of None means unlimited. The BaseHeader value for this attribute is None; it is expected that specialized header classes will override this value as needed.", 
        "name": "email.headerregistry.BaseHeader.max_count", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.BaseHeader.max_count", 
        "syntax": "max_count", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.BaseHeader.name": {
        "descr": "The name of the header (the portion of the field before the \u2018:\u2019). This is exactly the value passed in the header_factory call for name; that is, case is preserved.", 
        "name": "email.headerregistry.BaseHeader.name", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.BaseHeader.name", 
        "syntax": "name", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentDispositionHeader": {
        "descr": "A ParameterizedMIMEHeader class that handles the Content-Disposition header.", 
        "name": "email.headerregistry.ContentDispositionHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentDispositionHeader", 
        "syntax": "class email.headerregistry.ContentDispositionHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentTransferEncoding": {
        "descr": "Handles the Content-Transfer-Encoding header.", 
        "name": "email.headerregistry.ContentTransferEncoding", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentTransferEncoding", 
        "syntax": "class email.headerregistry.ContentTransferEncoding", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentTransferEncoding.cte": {
        "descr": "Valid values are 7bit, 8bit, base64, and quoted-printable. See RFC 2045 for more information.", 
        "name": "email.headerregistry.ContentTransferEncoding.cte", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentTransferEncoding.cte", 
        "syntax": "cte", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentTypeHeader": {
        "descr": "A ParameterizedMIMEHeader class that handles the Content-Type header.", 
        "name": "email.headerregistry.ContentTypeHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentTypeHeader", 
        "syntax": "class email.headerregistry.ContentTypeHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentTypeHeader.content_type": {
        "descr": "The content type string, in the form maintype/subtype.", 
        "name": "email.headerregistry.ContentTypeHeader.content_type", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentTypeHeader.content_type", 
        "syntax": "content_type", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentTypeHeader.maintype": {
        "descr": "", 
        "name": "email.headerregistry.ContentTypeHeader.maintype", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentTypeHeader.maintype", 
        "syntax": "maintype", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ContentTypeHeader.subtype": {
        "descr": "", 
        "name": "email.headerregistry.ContentTypeHeader.subtype", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ContentTypeHeader.subtype", 
        "syntax": "subtype", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.DateHeader": {
        "descr": "RFC 5322 specifies a very specific format for dates within email headers. The DateHeader parser recognizes that date format, as well as recognizing a number of variant forms that are sometimes found \u201cin the wild\u201d.", 
        "name": "email.headerregistry.DateHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.DateHeader", 
        "syntax": "class email.headerregistry.DateHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.DateHeader.datetime": {
        "descr": "If the header value can be recognized as a valid date of one form or another, this attribute will contain a datetime instance representing that date. If the timezone of the input date is specified as -0000 (indicating it is in UTC but contains no information about the source timezone), then datetime will be a naive datetime. If a specific timezone offset is found (including +0000), then datetime will contain an aware datetime that uses datetime.timezone to record the timezone offset.", 
        "name": "email.headerregistry.DateHeader.datetime", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.DateHeader.datetime", 
        "syntax": "datetime", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Group": {
        "descr": "The class used to represent an address group. The general form of an address group is:", 
        "name": "email.headerregistry.Group", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Group", 
        "syntax": "class email.headerregistry.Group(display_name=None, addresses=None)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Group.__str__": {
        "descr": "The str value of a Group is formatted according to RFC 5322, but with no Content Transfer Encoding of any non-ASCII characters. If display_name is none and there is a single Address in the addresses list, the str value will be the same as the str of that single Address.", 
        "name": "email.headerregistry.Group.__str__", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Group.__str__", 
        "syntax": "__str__()", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Group.addresses": {
        "descr": "A possibly empty tuple of Address objects representing the addresses in the group.", 
        "name": "email.headerregistry.Group.addresses", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Group.addresses", 
        "syntax": "addresses", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.Group.display_name": {
        "descr": "The display_name of the group. If it is None and there is exactly one Address in addresses, then the Group represents a single address that is not in a group.", 
        "name": "email.headerregistry.Group.display_name", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.Group.display_name", 
        "syntax": "display_name", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.HeaderRegistry": {
        "descr": "This is the factory used by EmailPolicy by default. HeaderRegistry builds the class used to create a header instance dynamically, using base_class and a specialized class retrieved from a registry that it holds. When a given header name does not appear in the registry, the class specified by default_class is used as the specialized class. When use_default_map is True (the default), the standard mapping of header names to classes is copied in to the registry during initialization. base_class is always the last class in the generated class\u2019s __bases__ list.", 
        "name": "email.headerregistry.HeaderRegistry", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.HeaderRegistry", 
        "syntax": "class email.headerregistry.HeaderRegistry(base_class=BaseHeader, default_class=UnstructuredHeader, use_default_map=True)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.HeaderRegistry.__call__": {
        "descr": "Retrieves the specialized header associated with name from the registry (using default_class if name does not appear in the registry) and composes it with base_class to produce a class, calls the constructed class\u2019s constructor, passing it the same argument list, and finally returns the class instance created thereby.", 
        "name": "email.headerregistry.HeaderRegistry.__call__", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.HeaderRegistry.__call__", 
        "syntax": "__call__(name, value)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.HeaderRegistry.__getitem__": {
        "descr": "Construct and return a class to handle creating a name header.", 
        "name": "email.headerregistry.HeaderRegistry.__getitem__", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.HeaderRegistry.__getitem__", 
        "syntax": "__getitem__(name)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.HeaderRegistry.map_to_type": {
        "descr": "name is the name of the header to be mapped. It will be converted to lower case in the registry. cls is the specialized class to be used, along with base_class, to create the class used to instantiate headers that match name.", 
        "name": "email.headerregistry.HeaderRegistry.map_to_type", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.HeaderRegistry.map_to_type", 
        "syntax": "map_to_type(self, name, cls)", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.MIMEVersionHeader": {
        "descr": "There is really only one valid value for the MIME-Version header, and that is 1.0. For future proofing, this header class supports other valid version numbers. If a version number has a valid value per RFC 2045, then the header object will have non-None values for the following attributes:", 
        "name": "email.headerregistry.MIMEVersionHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.MIMEVersionHeader", 
        "syntax": "class email.headerregistry.MIMEVersionHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.MIMEVersionHeader.major": {
        "descr": "The major version number as an integer", 
        "name": "email.headerregistry.MIMEVersionHeader.major", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.MIMEVersionHeader.major", 
        "syntax": "major", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.MIMEVersionHeader.minor": {
        "descr": "The minor version number as an integer", 
        "name": "email.headerregistry.MIMEVersionHeader.minor", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.MIMEVersionHeader.minor", 
        "syntax": "minor", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.MIMEVersionHeader.version": {
        "descr": "The version number as a string, with any whitespace and/or comments removed.", 
        "name": "email.headerregistry.MIMEVersionHeader.version", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.MIMEVersionHeader.version", 
        "syntax": "version", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ParameterizedMIMEHeader": {
        "descr": "MOME headers all start with the prefix \u2018Content-\u2018. Each specific header has a certain value, described under the class for that header. Some can also take a list of supplemental parameters, which have a common format. This class serves as a base for all the MIME headers that take parameters.", 
        "name": "email.headerregistry.ParameterizedMIMEHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ParameterizedMIMEHeader", 
        "syntax": "class email.headerregistry.ParameterizedMIMEHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.ParameterizedMIMEHeader.params": {
        "descr": "A dictionary mapping parameter names to parameter values.", 
        "name": "email.headerregistry.ParameterizedMIMEHeader.params", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.ParameterizedMIMEHeader.params", 
        "syntax": "params", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.SingleAddressHeader": {
        "descr": "A subclass of AddressHeader that adds one additional attribute:", 
        "name": "email.headerregistry.SingleAddressHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.SingleAddressHeader", 
        "syntax": "class email.headerregistry.SingleAddressHeader", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.SingleAddressHeader.address": {
        "descr": "The single address encoded by the header value. If the header value actually contains more than one address (which would be a violation of the RFC under the default policy), accessing this attribute will result in a ValueError.", 
        "name": "email.headerregistry.SingleAddressHeader.address", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.SingleAddressHeader.address", 
        "syntax": "address", 
        "type": "Internet Data"
    }, 
    "email.headerregistry.UnstructuredHeader": {
        "descr": "An \u201cunstructured\u201d header is the default type of header in RFC 5322. Any header that does not have a specified syntax is treated as unstructured. The classic example of an unstructured header is the Subject header.", 
        "name": "email.headerregistry.UnstructuredHeader", 
        "params": [], 
        "path": "python/library/email.headerregistry#email.headerregistry.UnstructuredHeader", 
        "syntax": "class email.headerregistry.UnstructuredHeader", 
        "type": "Internet Data"
    }, 
    "email.iterators._structure": {
        "descr": "Prints an indented representation of the content types of the message object structure. For example:", 
        "name": "email.iterators._structure", 
        "params": [], 
        "path": "python/library/email.iterators#email.iterators._structure", 
        "syntax": "email.iterators._structure(msg, fp=None, level=0, include_default=False)", 
        "type": "Internet Data"
    }, 
    "email.iterators.body_line_iterator": {
        "descr": "This iterates over all the payloads in all the subparts of msg, returning the string payloads line-by-line. It skips over all the subpart headers, and it skips over any subpart with a payload that isn\u2019t a Python string. This is somewhat equivalent to reading the flat text representation of the message from a file using readline(), skipping over all the intervening headers.", 
        "name": "email.iterators.body_line_iterator", 
        "params": [], 
        "path": "python/library/email.iterators#email.iterators.body_line_iterator", 
        "syntax": "email.iterators.body_line_iterator(msg, decode=False)", 
        "type": "Internet Data"
    }, 
    "email.iterators.typed_subpart_iterator": {
        "descr": "This iterates over all the subparts of msg, returning only those subparts that match the MIME type specified by maintype and subtype.", 
        "name": "email.iterators.typed_subpart_iterator", 
        "params": [], 
        "path": "python/library/email.iterators#email.iterators.typed_subpart_iterator", 
        "syntax": "email.iterators.typed_subpart_iterator(msg, maintype='text', subtype=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message": {
        "descr": "The policy argument determiens the policy that will be used to update the message model. The default value, compat32 maintains backward compatibility with the Python 3.2 version of the email package. For more information see the policy documentation.", 
        "name": "email.message.Message", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message", 
        "syntax": "class email.message.Message(policy=compat32)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.__contains__": {
        "descr": "Return true if the message object has a field named name. Matching is done case-insensitively and name should not include the trailing colon. Used for the in operator, e.g.:", 
        "name": "email.message.Message.__contains__", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.__contains__", 
        "syntax": "__contains__(name)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.__delitem__": {
        "descr": "Delete all occurrences of the field with name name from the message\u2019s headers. No exception is raised if the named field isn\u2019t present in the headers.", 
        "name": "email.message.Message.__delitem__", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.__delitem__", 
        "syntax": "__delitem__(name)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.__getitem__": {
        "descr": "Return the value of the named header field. name should not include the colon field separator. If the header is missing, None is returned; a KeyError is never raised.", 
        "name": "email.message.Message.__getitem__", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.__getitem__", 
        "syntax": "__getitem__(name)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.__len__": {
        "descr": "Return the total number of headers, including duplicates.", 
        "name": "email.message.Message.__len__", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.__len__", 
        "syntax": "__len__()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.__setitem__": {
        "descr": "Add a header to the message with field name name and value val. The field is appended to the end of the message\u2019s existing fields.", 
        "name": "email.message.Message.__setitem__", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.__setitem__", 
        "syntax": "__setitem__(name, val)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.__str__": {
        "descr": "Equivalent to as_string(unixfrom=True).", 
        "name": "email.message.Message.__str__", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.__str__", 
        "syntax": "__str__()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.add_header": {
        "descr": "Extended header setting. This method is similar to __setitem__() except that additional header parameters can be provided as keyword arguments. _name is the header field to add and _value is the primary value for the header.", 
        "name": "email.message.Message.add_header", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.add_header", 
        "syntax": "add_header(_name, _value, **_params)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.as_string": {
        "descr": "Return the entire message flattened as a string. When optional unixfrom is True, the envelope header is included in the returned string. unixfrom defaults to False. Flattening the message may trigger changes to the Message if defaults need to be filled in to complete the transformation to a string (for example, MIME boundaries may be generated or modified).", 
        "name": "email.message.Message.as_string", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.as_string", 
        "syntax": "as_string(unixfrom=False, maxheaderlen=0)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.attach": {
        "descr": "Add the given payload to the current payload, which must be None or a list of Message objects before the call. After the call, the payload will always be a list of Message objects. If you want to set the payload to a scalar object (e.g. a string), use set_payload() instead.", 
        "name": "email.message.Message.attach", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.attach", 
        "syntax": "attach(payload)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.defects": {
        "descr": "The defects attribute contains a list of all the problems found when parsing this message. See email.errors for a detailed description of the possible parsing defects.", 
        "name": "email.message.Message.defects", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.defects", 
        "syntax": "defects", 
        "type": "Internet Data"
    }, 
    "email.message.Message.del_param": {
        "descr": "Remove the given parameter completely from the Content-Type header. The header will be re-written in place without the parameter or its value. All values will be quoted as necessary unless requote is False (the default is True). Optional header specifies an alternative to Content-Type.", 
        "name": "email.message.Message.del_param", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.del_param", 
        "syntax": "del_param(param, header='content-type', requote=True)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.epilogue": {
        "descr": "The epilogue attribute acts the same way as the preamble attribute, except that it contains text that appears between the last boundary and the end of the message.", 
        "name": "email.message.Message.epilogue", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.epilogue", 
        "syntax": "epilogue", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get": {
        "descr": "Return the value of the named header field. This is identical to __getitem__() except that optional failobj is returned if the named header is missing (defaults to None).", 
        "name": "email.message.Message.get", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get", 
        "syntax": "get(name, failobj=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_all": {
        "descr": "Return a list of all the values for the field named name. If there are no such named headers in the message, failobj is returned (defaults to None).", 
        "name": "email.message.Message.get_all", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_all", 
        "syntax": "get_all(name, failobj=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_boundary": {
        "descr": "Return the value of the boundary parameter of the Content-Type header of the message, or failobj if either the header is missing, or has no boundary parameter. The returned string will always be unquoted as per email.utils.unquote().", 
        "name": "email.message.Message.get_boundary", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_boundary", 
        "syntax": "get_boundary(failobj=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_charset": {
        "descr": "Return the Charset instance associated with the message\u2019s payload.", 
        "name": "email.message.Message.get_charset", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_charset", 
        "syntax": "get_charset()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_charsets": {
        "descr": "Return a list containing the character set names in the message. If the message is a multipart, then the list will contain one element for each subpart in the payload, otherwise, it will be a list of length 1.", 
        "name": "email.message.Message.get_charsets", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_charsets", 
        "syntax": "get_charsets(failobj=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_content_charset": {
        "descr": "Return the charset parameter of the Content-Type header, coerced to lower case. If there is no Content-Type header, or if that header has no charset parameter, failobj is returned.", 
        "name": "email.message.Message.get_content_charset", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_content_charset", 
        "syntax": "get_content_charset(failobj=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_content_maintype": {
        "descr": "Return the message\u2019s main content type. This is the maintype part of the string returned by get_content_type().", 
        "name": "email.message.Message.get_content_maintype", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_content_maintype", 
        "syntax": "get_content_maintype()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_content_subtype": {
        "descr": "Return the message\u2019s sub-content type. This is the subtype part of the string returned by get_content_type().", 
        "name": "email.message.Message.get_content_subtype", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_content_subtype", 
        "syntax": "get_content_subtype()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_content_type": {
        "descr": "Return the message\u2019s content type. The returned string is coerced to lower case of the form maintype/subtype. If there was no Content-Type header in the message the default type as given by get_default_type() will be returned. Since according to RFC 2045, messages always have a default type, get_content_type() will always return a value.", 
        "name": "email.message.Message.get_content_type", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_content_type", 
        "syntax": "get_content_type()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_default_type": {
        "descr": "Return the default content type. Most messages have a default content type of text/plain, except for messages that are subparts of multipart/digest containers. Such subparts have a default content type of message/rfc822.", 
        "name": "email.message.Message.get_default_type", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_default_type", 
        "syntax": "get_default_type()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_filename": {
        "descr": "Return the value of the filename parameter of the Content-Disposition header of the message. If the header does not have a filename parameter, this method falls back to looking for the name parameter on the Content-Type header. If neither is found, or the header is missing, then failobj is returned. The returned string will always be unquoted as per email.utils.unquote().", 
        "name": "email.message.Message.get_filename", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_filename", 
        "syntax": "get_filename(failobj=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_param": {
        "descr": "Return the value of the Content-Type header\u2019s parameter param as a string. If the message has no Content-Type header or if there is no such parameter, then failobj is returned (defaults to None).", 
        "name": "email.message.Message.get_param", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_param", 
        "syntax": "get_param(param, failobj=None, header='content-type', unquote=True)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_params": {
        "descr": "Return the message\u2019s Content-Type parameters, as a list. The elements of the returned list are 2-tuples of key/value pairs, as split on the '=' sign. The left hand side of the '=' is the key, while the right hand side is the value. If there is no '=' sign in the parameter the value is the empty string, otherwise the value is as described in get_param() and is unquoted if optional unquote is True (the default).", 
        "name": "email.message.Message.get_params", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_params", 
        "syntax": "get_params(failobj=None, header='content-type', unquote=True)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_payload": {
        "descr": "Return the current payload, which will be a list of Message objects when is_multipart() is True, or a string when is_multipart() is False. If the payload is a list and you mutate the list object, you modify the message\u2019s payload in place.", 
        "name": "email.message.Message.get_payload", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_payload", 
        "syntax": "get_payload(i=None, decode=False)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.get_unixfrom": {
        "descr": "Return the message\u2019s envelope header. Defaults to None if the envelope header was never set.", 
        "name": "email.message.Message.get_unixfrom", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.get_unixfrom", 
        "syntax": "get_unixfrom()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.is_multipart": {
        "descr": "Return True if the message\u2019s payload is a list of sub-Message objects, otherwise return False. When is_multipart() returns False, the payload should be a string object.", 
        "name": "email.message.Message.is_multipart", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.is_multipart", 
        "syntax": "is_multipart()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.items": {
        "descr": "Return a list of 2-tuples containing all the message\u2019s field headers and values.", 
        "name": "email.message.Message.items", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.items", 
        "syntax": "items()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.keys": {
        "descr": "Return a list of all the message\u2019s header field names.", 
        "name": "email.message.Message.keys", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.keys", 
        "syntax": "keys()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.preamble": {
        "descr": "The format of a MIME document allows for some text between the blank line following the headers, and the first multipart boundary string. Normally, this text is never visible in a MIME-aware mail reader because it falls outside the standard MIME armor. However, when viewing the raw text of the message, or when viewing the message in a non-MIME aware reader, this text can become visible.", 
        "name": "email.message.Message.preamble", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.preamble", 
        "syntax": "preamble", 
        "type": "Internet Data"
    }, 
    "email.message.Message.replace_header": {
        "descr": "Replace a header. Replace the first header found in the message that matches _name, retaining header order and field name case. If no matching header was found, a KeyError is raised.", 
        "name": "email.message.Message.replace_header", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.replace_header", 
        "syntax": "replace_header(_name, _value)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_boundary": {
        "descr": "Set the boundary parameter of the Content-Type header to boundary. set_boundary() will always quote boundary if necessary. A HeaderParseError is raised if the message object has no Content-Type header.", 
        "name": "email.message.Message.set_boundary", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_boundary", 
        "syntax": "set_boundary(boundary)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_charset": {
        "descr": "Set the character set of the payload to charset, which can either be a Charset instance (see email.charset), a string naming a character set, or None. If it is a string, it will be converted to a Charset instance. If charset is None, the charset parameter will be removed from the Content-Type header (the message will not be otherwise modified). Anything else will generate a TypeError.", 
        "name": "email.message.Message.set_charset", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_charset", 
        "syntax": "set_charset(charset)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_default_type": {
        "descr": "Set the default content type. ctype should either be text/plain or message/rfc822, although this is not enforced. The default content type is not stored in the Content-Type header.", 
        "name": "email.message.Message.set_default_type", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_default_type", 
        "syntax": "set_default_type(ctype)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_param": {
        "descr": "Set a parameter in the Content-Type header. If the parameter already exists in the header, its value will be replaced with value. If the Content-Type header as not yet been defined for this message, it will be set to text/plain and the new parameter value will be appended as per RFC 2045.", 
        "name": "email.message.Message.set_param", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_param", 
        "syntax": "set_param(param, value, header='Content-Type', requote=True, charset=None, language='')", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_payload": {
        "descr": "Set the entire message object\u2019s payload to payload. It is the client\u2019s responsibility to ensure the payload invariants. Optional charset sets the message\u2019s default character set; see set_charset() for details.", 
        "name": "email.message.Message.set_payload", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_payload", 
        "syntax": "set_payload(payload, charset=None)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_type": {
        "descr": "Set the main type and subtype for the Content-Type header. type must be a string in the form maintype/subtype, otherwise a ValueError is raised.", 
        "name": "email.message.Message.set_type", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_type", 
        "syntax": "set_type(type, header='Content-Type', requote=True)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.set_unixfrom": {
        "descr": "Set the message\u2019s envelope header to unixfrom, which should be a string.", 
        "name": "email.message.Message.set_unixfrom", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.set_unixfrom", 
        "syntax": "set_unixfrom(unixfrom)", 
        "type": "Internet Data"
    }, 
    "email.message.Message.values": {
        "descr": "Return a list of all the message\u2019s field values.", 
        "name": "email.message.Message.values", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.values", 
        "syntax": "values()", 
        "type": "Internet Data"
    }, 
    "email.message.Message.walk": {
        "descr": "The walk() method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use walk() as the iterator in a for loop; each iteration returns the next subpart.", 
        "name": "email.message.Message.walk", 
        "params": [], 
        "path": "python/library/email.message#email.message.Message.walk", 
        "syntax": "walk()", 
        "type": "Internet Data"
    }, 
    "email.message_from_binary_file": {
        "descr": "Return a message object structure tree from an open binary file object. This is exactly equivalent to BytesParser().parse(fp). _class and policy are interpreted as with the Parser class constructor.", 
        "name": "email.message_from_binary_file", 
        "params": [], 
        "path": "python/library/email.parser#email.message_from_binary_file", 
        "syntax": "email.message_from_binary_file(fp, _class=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.message_from_bytes": {
        "descr": "Return a message object structure from a byte string. This is exactly equivalent to BytesParser().parsebytes(s). Optional _class and strict are interpreted as with the Parser class constructor.", 
        "name": "email.message_from_bytes", 
        "params": [], 
        "path": "python/library/email.parser#email.message_from_bytes", 
        "syntax": "email.message_from_bytes(s, _class=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.message_from_file": {
        "descr": "Return a message object structure tree from an open file object. This is exactly equivalent to Parser().parse(fp). _class and policy are interpreted as with the Parser class constructor.", 
        "name": "email.message_from_file", 
        "params": [], 
        "path": "python/library/email.parser#email.message_from_file", 
        "syntax": "email.message_from_file(fp, _class=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.message_from_string": {
        "descr": "Return a message object structure from a string. This is exactly equivalent to Parser().parsestr(s). _class and policy are interpreted as with the Parser class constructor.", 
        "name": "email.message_from_string", 
        "params": [], 
        "path": "python/library/email.parser#email.message_from_string", 
        "syntax": "email.message_from_string(s, _class=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.mime.application.MIMEApplication": {
        "descr": "Module: email.mime.application", 
        "name": "email.mime.application.MIMEApplication", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.application.MIMEApplication", 
        "syntax": "class email.mime.application.MIMEApplication(_data, _subtype='octet-stream', _encoder=email.encoders.encode_base64, **_params)", 
        "type": "Internet Data"
    }, 
    "email.mime.audio.MIMEAudio": {
        "descr": "Module: email.mime.audio", 
        "name": "email.mime.audio.MIMEAudio", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.audio.MIMEAudio", 
        "syntax": "class email.mime.audio.MIMEAudio(_audiodata, _subtype=None, _encoder=email.encoders.encode_base64, **_params)", 
        "type": "Internet Data"
    }, 
    "email.mime.base.MIMEBase": {
        "descr": "Module: email.mime.base", 
        "name": "email.mime.base.MIMEBase", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.base.MIMEBase", 
        "syntax": "class email.mime.base.MIMEBase(_maintype, _subtype, **_params)", 
        "type": "Internet Data"
    }, 
    "email.mime.image.MIMEImage": {
        "descr": "Module: email.mime.image", 
        "name": "email.mime.image.MIMEImage", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.image.MIMEImage", 
        "syntax": "class email.mime.image.MIMEImage(_imagedata, _subtype=None, _encoder=email.encoders.encode_base64, **_params)", 
        "type": "Internet Data"
    }, 
    "email.mime.message.MIMEMessage": {
        "descr": "Module: email.mime.message", 
        "name": "email.mime.message.MIMEMessage", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.message.MIMEMessage", 
        "syntax": "class email.mime.message.MIMEMessage(_msg, _subtype='rfc822')", 
        "type": "Internet Data"
    }, 
    "email.mime.multipart.MIMEMultipart": {
        "descr": "Module: email.mime.multipart", 
        "name": "email.mime.multipart.MIMEMultipart", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.multipart.MIMEMultipart", 
        "syntax": "class email.mime.multipart.MIMEMultipart(_subtype='mixed', boundary=None, _subparts=None, **_params)", 
        "type": "Internet Data"
    }, 
    "email.mime.nonmultipart.MIMENonMultipart": {
        "descr": "Module: email.mime.nonmultipart", 
        "name": "email.mime.nonmultipart.MIMENonMultipart", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.nonmultipart.MIMENonMultipart", 
        "syntax": "class email.mime.nonmultipart.MIMENonMultipart", 
        "type": "Internet Data"
    }, 
    "email.mime.text.MIMEText": {
        "descr": "Module: email.mime.text", 
        "name": "email.mime.text.MIMEText", 
        "params": [], 
        "path": "python/library/email.mime#email.mime.text.MIMEText", 
        "syntax": "class email.mime.text.MIMEText(_text, _subtype='plain', _charset=None)", 
        "type": "Internet Data"
    }, 
    "email.parser.BytesFeedParser": {
        "descr": "Works exactly like FeedParser except that the input to the feed() method must be bytes and not string.", 
        "name": "email.parser.BytesFeedParser", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.BytesFeedParser", 
        "syntax": "class email.parser.BytesFeedParser(_factory=email.message.Message)", 
        "type": "Internet Data"
    }, 
    "email.parser.BytesParser": {
        "descr": "This class is exactly parallel to Parser, but handles bytes input. The _class and strict arguments are interpreted in the same way as for the Parser constructor.", 
        "name": "email.parser.BytesParser", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.BytesParser", 
        "syntax": "class email.parser.BytesParser(_class=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.parser.BytesParser.parse": {
        "descr": "Read all the data from the binary file-like object fp, parse the resulting bytes, and return the message object. fp must support both the readline() and the read() methods on file-like objects.", 
        "name": "email.parser.BytesParser.parse", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.BytesParser.parse", 
        "syntax": "parse(fp, headeronly=False)", 
        "type": "Internet Data"
    }, 
    "email.parser.BytesParser.parsebytes": {
        "descr": "Similar to the parse() method, except it takes a byte string object instead of a file-like object. Calling this method on a byte string is exactly equivalent to wrapping text in a BytesIO instance first and calling parse().", 
        "name": "email.parser.BytesParser.parsebytes", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.BytesParser.parsebytes", 
        "syntax": "parsebytes(bytes, headersonly=False)", 
        "type": "Internet Data"
    }, 
    "email.parser.FeedParser": {
        "descr": "Create a FeedParser instance. Optional _factory is a no-argument callable that will be called whenever a new message object is needed. It defaults to the email.message.Message class.", 
        "name": "email.parser.FeedParser", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.FeedParser", 
        "syntax": "class email.parser.FeedParser(_factory=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.parser.FeedParser.close": {
        "descr": "Closing a FeedParser completes the parsing of all previously fed data, and returns the root message object. It is undefined what happens if you feed more data to a closed FeedParser.", 
        "name": "email.parser.FeedParser.close", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.FeedParser.close", 
        "syntax": "close()", 
        "type": "Internet Data"
    }, 
    "email.parser.FeedParser.feed": {
        "descr": "Feed the FeedParser some more data. data should be a string containing one or more lines. The lines can be partial and the FeedParser will stitch such partial lines together properly. The lines in the string can have any of the common three line endings, carriage return, newline, or carriage return and newline (they can even be mixed).", 
        "name": "email.parser.FeedParser.feed", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.FeedParser.feed", 
        "syntax": "feed(data)", 
        "type": "Internet Data"
    }, 
    "email.parser.Parser": {
        "descr": "The constructor for the Parser class takes an optional argument _class. This must be a callable factory (such as a function or a class), and it is used whenever a sub-message object needs to be created. It defaults to Message (see email.message). The factory will be called without arguments.", 
        "name": "email.parser.Parser", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.Parser", 
        "syntax": "class email.parser.Parser(_class=email.message.Message, *, policy=policy.default)", 
        "type": "Internet Data"
    }, 
    "email.parser.Parser.parse": {
        "descr": "Read all the data from the file-like object fp, parse the resulting text, and return the root message object. fp must support both the readline() and the read() methods on file-like objects.", 
        "name": "email.parser.Parser.parse", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.Parser.parse", 
        "syntax": "parse(fp, headersonly=False)", 
        "type": "Internet Data"
    }, 
    "email.parser.Parser.parsestr": {
        "descr": "Similar to the parse() method, except it takes a string object instead of a file-like object. Calling this method on a string is exactly equivalent to wrapping text in a StringIO instance first and calling parse().", 
        "name": "email.parser.Parser.parsestr", 
        "params": [], 
        "path": "python/library/email.parser#email.parser.Parser.parsestr", 
        "syntax": "parsestr(text, headersonly=False)", 
        "type": "Internet Data"
    }, 
    "email.policy.Compat32": {
        "descr": "This concrete Policy is the backward compatibility policy. It replicates the behavior of the email package in Python 3.2. The policy module also defines an instance of this class, compat32, that is used as the default policy. Thus the default behavior of the email package is to maintain compatibility with Python 3.2.", 
        "name": "email.policy.Compat32", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Compat32", 
        "syntax": "class email.policy.Compat32(**kw)", 
        "type": "Internet Data"
    }, 
    "email.policy.Compat32.fold": {
        "descr": "Headers are folded using the Header folding algorithm, which preserves existing line breaks in the value, and wraps each resulting line to the max_line_length. Non-ASCII binary data are CTE encoded using the unknown-8bit charset.", 
        "name": "email.policy.Compat32.fold", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Compat32.fold", 
        "syntax": "fold(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Compat32.fold_binary": {
        "descr": "Headers are folded using the Header folding algorithm, which preserves existing line breaks in the value, and wraps each resulting line to the max_line_length. If cte_type is 7bit, non-ascii binary data is CTE encoded using the unknown-8bit charset. Otherwise the original source header is used, with its existing line breaks and any (RFC invalid) binary data it may contain.", 
        "name": "email.policy.Compat32.fold_binary", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Compat32.fold_binary", 
        "syntax": "fold_binary(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Compat32.header_fetch_parse": {
        "descr": "If the value contains binary data, it is converted into a Header object using the unknown-8bit charset. Otherwise it is returned unmodified.", 
        "name": "email.policy.Compat32.header_fetch_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Compat32.header_fetch_parse", 
        "syntax": "header_fetch_parse(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Compat32.header_source_parse": {
        "descr": "The name is parsed as everything up to the \u2018:\u2018 and returned unmodified. The value is determined by stripping leading whitespace off the remainder of the first line, joining all subsequent lines together, and stripping any trailing carriage return or linefeed characters.", 
        "name": "email.policy.Compat32.header_source_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Compat32.header_source_parse", 
        "syntax": "header_source_parse(sourcelines)", 
        "type": "Internet Data"
    }, 
    "email.policy.Compat32.header_store_parse": {
        "descr": "The name and value are returned unmodified.", 
        "name": "email.policy.Compat32.header_store_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Compat32.header_store_parse", 
        "syntax": "header_store_parse(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy": {
        "descr": "This concrete Policy provides behavior that is intended to be fully compliant with the current email RFCs. These include (but are not limited to) RFC 5322, RFC 2047, and the current MIME RFCs.", 
        "name": "email.policy.EmailPolicy", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy", 
        "syntax": "class email.policy.EmailPolicy(**kw)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.fold": {
        "descr": "Header folding is controlled by the refold_source policy setting. A value is considered to be a \u2018source value\u2019 if and only if it does not have a name attribute (having a name attribute means it is a header object of some sort). If a source value needs to be refolded according to the policy, it is converted into a custom header object by passing the name and the value with any CR and LF characters removed to the header_factory. Folding of a custom header object is done by calling its fold method with the current policy.", 
        "name": "email.policy.EmailPolicy.fold", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.fold", 
        "syntax": "fold(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.fold_binary": {
        "descr": "The same as fold() if cte_type is 7bit, except that the returned value is bytes.", 
        "name": "email.policy.EmailPolicy.fold_binary", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.fold_binary", 
        "syntax": "fold_binary(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.header_factory": {
        "descr": "A callable that takes two arguments, name and value, where name is a header field name and value is an unfolded header field value, and returns a string subclass that represents that header. A default header_factory (see headerregistry) is provided that understands some of the RFC 5322 header field types. (Currently address fields and date fields have special treatment, while all other fields are treated as unstructured. This list will be completed before the extension is marked stable.)", 
        "name": "email.policy.EmailPolicy.header_factory", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.header_factory", 
        "syntax": "header_factory", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.header_fetch_parse": {
        "descr": "If the value has a name attribute, it is returned to unmodified. Otherwise the name, and the value with any CR or LF characters removed, are passed to the header_factory, and the resulting custom header object is returned. Any surrogateescaped bytes get turned into the unicode unknown-character glyph.", 
        "name": "email.policy.EmailPolicy.header_fetch_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.header_fetch_parse", 
        "syntax": "header_fetch_parse(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.header_max_count": {
        "descr": "Returns the value of the max_count attribute of the specialized class used to represent the header with the given name.", 
        "name": "email.policy.EmailPolicy.header_max_count", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.header_max_count", 
        "syntax": "header_max_count(name)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.header_source_parse": {
        "descr": "The implementation of this method is the same as that for the Compat32 policy.", 
        "name": "email.policy.EmailPolicy.header_source_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.header_source_parse", 
        "syntax": "header_source_parse(sourcelines)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.header_store_parse": {
        "descr": "The name is returned unchanged. If the input value has a name attribute and it matches name ignoring case, the value is returned unchanged. Otherwise the name and value are passed to header_factory, and the resulting custom header object is returned as the value. In this case a ValueError is raised if the input value contains CR or LF characters.", 
        "name": "email.policy.EmailPolicy.header_store_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.header_store_parse", 
        "syntax": "header_store_parse(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.EmailPolicy.refold_source": {
        "descr": "If the value for a header in the Message object originated from a parser (as opposed to being set by a program), this attribute indicates whether or not a generator should refold that value when transforming the message back into stream form. The possible values are:", 
        "name": "email.policy.EmailPolicy.refold_source", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.EmailPolicy.refold_source", 
        "syntax": "refold_source", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy": {
        "descr": "This is the abstract base class for all policy classes. It provides default implementations for a couple of trivial methods, as well as the implementation of the immutability property, the clone() method, and the constructor semantics.", 
        "name": "email.policy.Policy", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy", 
        "syntax": "class email.policy.Policy(**kw)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.clone": {
        "descr": "Return a new Policy instance whose attributes have the same values as the current instance, except where those attributes are given new values by the keyword arguments.", 
        "name": "email.policy.Policy.clone", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.clone", 
        "syntax": "clone(**kw)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.cte_type": {
        "descr": "Controls the type of Content Transfer Encodings that may be or are required to be used. The possible values are:", 
        "name": "email.policy.Policy.cte_type", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.cte_type", 
        "syntax": "cte_type", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.fold": {
        "descr": "The email package calls this method with the name and value currently stored in the Message for a given header. The method should return a string that represents that header \u201cfolded\u201d correctly (according to the policy settings) by composing the name with the value and inserting linesep characters at the appropriate places. See RFC 5322 for a discussion of the rules for folding email headers.", 
        "name": "email.policy.Policy.fold", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.fold", 
        "syntax": "fold(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.fold_binary": {
        "descr": "The same as fold(), except that the returned value should be a bytes object rather than a string.", 
        "name": "email.policy.Policy.fold_binary", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.fold_binary", 
        "syntax": "fold_binary(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.handle_defect": {
        "descr": "Handle a defect found on obj. When the email package calls this method, defect will always be a subclass of Defect.", 
        "name": "email.policy.Policy.handle_defect", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.handle_defect", 
        "syntax": "handle_defect(obj, defect)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.header_fetch_parse": {
        "descr": "The email package calls this method with the name and value currently stored in the Message when that header is requested by the application program, and whatever the method returns is what is passed back to the application as the value of the header being retrieved. Note that there may be more than one header with the same name stored in the Message; the method is passed the specific name and value of the header destined to be returned to the application.", 
        "name": "email.policy.Policy.header_fetch_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.header_fetch_parse", 
        "syntax": "header_fetch_parse(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.header_max_count": {
        "descr": "Return the maximum allowed number of headers named name.", 
        "name": "email.policy.Policy.header_max_count", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.header_max_count", 
        "syntax": "header_max_count(name)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.header_source_parse": {
        "descr": "The email package calls this method with a list of strings, each string ending with the line separation characters found in the source being parsed. The first line includes the field header name and separator. All whitespace in the source is preserved. The method should return the (name, value) tuple that is to be stored in the Message to represent the parsed header.", 
        "name": "email.policy.Policy.header_source_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.header_source_parse", 
        "syntax": "header_source_parse(sourcelines)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.header_store_parse": {
        "descr": "The email package calls this method with the name and value provided by the application program when the application program is modifying a Message programmatically (as opposed to a Message created by a parser). The method should return the (name, value) tuple that is to be stored in the Message to represent the header.", 
        "name": "email.policy.Policy.header_store_parse", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.header_store_parse", 
        "syntax": "header_store_parse(name, value)", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.linesep": {
        "descr": "The string to be used to terminate lines in serialized output. The default is \\n because that\u2019s the internal end-of-line discipline used by Python, though \\r\\n is required by the RFCs.", 
        "name": "email.policy.Policy.linesep", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.linesep", 
        "syntax": "linesep", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.max_line_length": {
        "descr": "The maximum length of any line in the serialized output, not counting the end of line character(s). Default is 78, per RFC 5322. A value of 0 or None indicates that no line wrapping should be done at all.", 
        "name": "email.policy.Policy.max_line_length", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.max_line_length", 
        "syntax": "max_line_length", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.raise_on_defect": {
        "descr": "If True, any defects encountered will be raised as errors. If False (the default), defects will be passed to the register_defect() method.", 
        "name": "email.policy.Policy.raise_on_defect", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.raise_on_defect", 
        "syntax": "raise_on_defect", 
        "type": "Internet Data"
    }, 
    "email.policy.Policy.register_defect": {
        "descr": "Register a defect on obj. In the email package, defect will always be a subclass of Defect.", 
        "name": "email.policy.Policy.register_defect", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.Policy.register_defect", 
        "syntax": "register_defect(obj, defect)", 
        "type": "Internet Data"
    }, 
    "email.policy.default": {
        "descr": "An instance of EmailPolicy with all defaults unchanged. This policy uses the standard Python \\n line endings rather than the RFC-correct \\r\\n.", 
        "name": "email.policy.default", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.default", 
        "syntax": "email.policy.default", 
        "type": "Internet Data"
    }, 
    "email.policy.strict": {
        "descr": "Convenience instance. The same as default except that raise_on_defect is set to True. This allows any policy to be made strict by writing:", 
        "name": "email.policy.strict", 
        "params": [], 
        "path": "python/library/email.policy#email.policy.strict", 
        "syntax": "email.policy.strict", 
        "type": "Internet Data"
    }, 
    "email.utils.collapse_rfc2231_value": {
        "descr": "When a header parameter is encoded in RFC 2231 format, Message.get_param may return a 3-tuple containing the character set, language, and value. collapse_rfc2231_value() turns this into a unicode string. Optional errors is passed to the errors argument of str\u2018s encode() method; it defaults to 'replace'. Optional fallback_charset specifies the character set to use if the one in the RFC 2231 header is not known by Python; it defaults to 'us-ascii'.", 
        "name": "email.utils.collapse_rfc2231_value", 
        "params": [], 
        "path": "python/library/email.util#email.utils.collapse_rfc2231_value", 
        "syntax": "email.utils.collapse_rfc2231_value(value, errors='replace', fallback_charset='us-ascii')", 
        "type": "Internet Data"
    }, 
    "email.utils.decode_params": {
        "descr": "Decode parameters list according to RFC 2231. params is a sequence of 2-tuples containing elements of the form (content-type, string-value).", 
        "name": "email.utils.decode_params", 
        "params": [], 
        "path": "python/library/email.util#email.utils.decode_params", 
        "syntax": "email.utils.decode_params(params)", 
        "type": "Internet Data"
    }, 
    "email.utils.decode_rfc2231": {
        "descr": "Decode the string s according to RFC 2231.", 
        "name": "email.utils.decode_rfc2231", 
        "params": [], 
        "path": "python/library/email.util#email.utils.decode_rfc2231", 
        "syntax": "email.utils.decode_rfc2231(s)", 
        "type": "Internet Data"
    }, 
    "email.utils.encode_rfc2231": {
        "descr": "Encode the string s according to RFC 2231. Optional charset and language, if given is the character set name and language name to use. If neither is given, s is returned as-is. If charset is given but language is not, the string is encoded using the empty string for language.", 
        "name": "email.utils.encode_rfc2231", 
        "params": [], 
        "path": "python/library/email.util#email.utils.encode_rfc2231", 
        "syntax": "email.utils.encode_rfc2231(s, charset=None, language=None)", 
        "type": "Internet Data"
    }, 
    "email.utils.format_datetime": {
        "descr": "Like formatdate, but the input is a datetime instance. If it is a naive datetime, it is assumed to be \u201cUTC with no information about the source timezone\u201d, and the conventional -0000 is used for the timezone. If it is an aware datetime, then the numeric timezone offset is used. If it is an aware timezone with offset zero, then usegmt may be set to True, in which case the string GMT is used instead of the numeric timezone offset. This provides a way to generate standards conformant HTTP date headers.", 
        "name": "email.utils.format_datetime", 
        "params": [], 
        "path": "python/library/email.util#email.utils.format_datetime", 
        "syntax": "email.utils.format_datetime(dt, usegmt=False)", 
        "type": "Internet Data"
    }, 
    "email.utils.formataddr": {
        "descr": "The inverse of parseaddr(), this takes a 2-tuple of the form (realname, email_address) and returns the string value suitable for a To or Cc header. If the first element of pair is false, then the second element is returned unmodified.", 
        "name": "email.utils.formataddr", 
        "params": [], 
        "path": "python/library/email.util#email.utils.formataddr", 
        "syntax": "email.utils.formataddr(pair, charset='utf-8')", 
        "type": "Internet Data"
    }, 
    "email.utils.formatdate": {
        "descr": "Returns a date string as per RFC 2822, e.g.:", 
        "name": "email.utils.formatdate", 
        "params": [], 
        "path": "python/library/email.util#email.utils.formatdate", 
        "syntax": "email.utils.formatdate(timeval=None, localtime=False, usegmt=False)", 
        "type": "Internet Data"
    }, 
    "email.utils.getaddresses": {
        "descr": "This method returns a list of 2-tuples of the form returned by parseaddr(). fieldvalues is a sequence of header field values as might be returned by Message.get_all. Here\u2019s a simple example that gets all the recipients of a message:", 
        "name": "email.utils.getaddresses", 
        "params": [], 
        "path": "python/library/email.util#email.utils.getaddresses", 
        "syntax": "email.utils.getaddresses(fieldvalues)", 
        "type": "Internet Data"
    }, 
    "email.utils.localtime": {
        "descr": "Return local time as an aware datetime object. If called without arguments, return current time. Otherwise dt argument should be a datetime instance, and it is converted to the local time zone according to the system time zone database. If dt is naive (that is, dt.tzinfo is None), it is assumed to be in local time. In this case, a positive or zero value for isdst causes localtime to presume initially that summer time (for example, Daylight Saving Time) is or is not (respectively) in effect for the specified time. A negative value for isdst causes the localtime to attempt to divine whether summer time is in effect for the specified time.", 
        "name": "email.utils.localtime", 
        "params": [], 
        "path": "python/library/email.util#email.utils.localtime", 
        "syntax": "email.utils.localtime(dt=None)", 
        "type": "Internet Data"
    }, 
    "email.utils.make_msgid": {
        "descr": "Returns a string suitable for an RFC 2822-compliant Message-ID header. Optional idstring if given, is a string used to strengthen the uniqueness of the message id. Optional domain if given provides the portion of the msgid after the \u2018@\u2019. The default is the local hostname. It is not normally necessary to override this default, but may be useful certain cases, such as a constructing distributed system that uses a consistent domain name across multiple hosts.", 
        "name": "email.utils.make_msgid", 
        "params": [], 
        "path": "python/library/email.util#email.utils.make_msgid", 
        "syntax": "email.utils.make_msgid(idstring=None, domain=None)", 
        "type": "Internet Data"
    }, 
    "email.utils.mktime_tz": {
        "descr": "Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp. It the timezone item in the tuple is None, assume local time. Minor deficiency: mktime_tz() interprets the first 8 elements of tuple as a local time and then compensates for the timezone difference. This may yield a slight error around changes in daylight savings time, though not worth worrying about for common use.", 
        "name": "email.utils.mktime_tz", 
        "params": [], 
        "path": "python/library/email.util#email.utils.mktime_tz", 
        "syntax": "email.utils.mktime_tz(tuple)", 
        "type": "Internet Data"
    }, 
    "email.utils.parseaddr": {
        "descr": "Parse address \u2013 which should be the value of some address-containing field such as To or Cc \u2013 into its constituent realname and email address parts. Returns a tuple of that information, unless the parse fails, in which case a 2-tuple of ('', '') is returned.", 
        "name": "email.utils.parseaddr", 
        "params": [], 
        "path": "python/library/email.util#email.utils.parseaddr", 
        "syntax": "email.utils.parseaddr(address)", 
        "type": "Internet Data"
    }, 
    "email.utils.parsedate": {
        "descr": "Attempts to parse a date according to the rules in RFC 2822. however, some mailers don\u2019t follow that format as specified, so parsedate() tries to guess correctly in such cases. date is a string containing an RFC 2822 date, such as \"Mon, 20 Nov 1995 19:12:08 -0500\". If it succeeds in parsing the date, parsedate() returns a 9-tuple that can be passed directly to time.mktime(); otherwise None will be returned. Note that indexes 6, 7, and 8 of the result tuple are not usable.", 
        "name": "email.utils.parsedate", 
        "params": [], 
        "path": "python/library/email.util#email.utils.parsedate", 
        "syntax": "email.utils.parsedate(date)", 
        "type": "Internet Data"
    }, 
    "email.utils.parsedate_to_datetime": {
        "descr": "The inverse of format_datetime(). Performs the same function as parsedate(), but on success returns a datetime. If the input date has a timezone of -0000, the datetime will be a naive datetime, and if the date is conforming to the RFCs it will represent a time in UTC but with no indication of the actual source timezone of the message the date comes from. If the input date has any other valid timezone offset, the datetime will be an aware datetime with the corresponding a timezone tzinfo.", 
        "name": "email.utils.parsedate_to_datetime", 
        "params": [], 
        "path": "python/library/email.util#email.utils.parsedate_to_datetime", 
        "syntax": "email.utils.parsedate_to_datetime(date)", 
        "type": "Internet Data"
    }, 
    "email.utils.parsedate_tz": {
        "descr": "Performs the same function as parsedate(), but returns either None or a 10-tuple; the first 9 elements make up a tuple that can be passed directly to time.mktime(), and the tenth is the offset of the date\u2019s timezone from UTC (which is the official term for Greenwich Mean Time) [1]. If the input string has no timezone, the last element of the tuple returned is None. Note that indexes 6, 7, and 8 of the result tuple are not usable.", 
        "name": "email.utils.parsedate_tz", 
        "params": [], 
        "path": "python/library/email.util#email.utils.parsedate_tz", 
        "syntax": "email.utils.parsedate_tz(date)", 
        "type": "Internet Data"
    }, 
    "email.utils.quote": {
        "descr": "Return a new string with backslashes in str replaced by two backslashes, and double quotes replaced by backslash-double quote.", 
        "name": "email.utils.quote", 
        "params": [], 
        "path": "python/library/email.util#email.utils.quote", 
        "syntax": "email.utils.quote(str)", 
        "type": "Internet Data"
    }, 
    "email.utils.unquote": {
        "descr": "Return a new string which is an unquoted version of str. If str ends and begins with double quotes, they are stripped off. Likewise if str ends and begins with angle brackets, they are stripped off.", 
        "name": "email.utils.unquote", 
        "params": [], 
        "path": "python/library/email.util#email.utils.unquote", 
        "syntax": "email.utils.unquote(str)", 
        "type": "Internet Data"
    }, 
    "encode": {
        "descr": "Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Codec Base Classes. For a list of possible encodings, see section Standard Encodings.", 
        "name": "str.encode", 
        "params": [], 
        "path": "python/library/stdtypes#str.encode", 
        "syntax": "str.encode(encoding=\"utf-8\", errors=\"strict\")", 
        "type": "Built-in Types"
    }, 
    "encodings.idna.ToASCII": {
        "descr": "Convert a label to ASCII, as specified in RFC 3490. UseSTD3ASCIIRules is assumed to be false.", 
        "name": "encodings.idna.ToASCII", 
        "params": [], 
        "path": "python/library/codecs#encodings.idna.ToASCII", 
        "syntax": "encodings.idna.ToASCII(label)", 
        "type": "Binary Data"
    }, 
    "encodings.idna.ToUnicode": {
        "descr": "Convert a label to Unicode, as specified in RFC 3490.", 
        "name": "encodings.idna.ToUnicode", 
        "params": [], 
        "path": "python/library/codecs#encodings.idna.ToUnicode", 
        "syntax": "encodings.idna.ToUnicode(label)", 
        "type": "Binary Data"
    }, 
    "encodings.idna.nameprep": {
        "descr": "Return the nameprepped version of label. The implementation currently assumes query strings, so AllowUnassigned is true.", 
        "name": "encodings.idna.nameprep", 
        "params": [], 
        "path": "python/library/codecs#encodings.idna.nameprep", 
        "syntax": "encodings.idna.nameprep(label)", 
        "type": "Binary Data"
    }, 
    "end": {
        "descr": "Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return -1 if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to m.group(g)) is", 
        "name": "re.match.end", 
        "params": [], 
        "path": "python/library/re#re.match.end", 
        "syntax": "match.end([group])", 
        "type": "Text Processing"
    }, 
    "endpos": {
        "descr": "The value of endpos which was passed to the search() or match() method of a regex object. This is the index into the string beyond which the RE engine will not go.", 
        "name": "re.match.endpos", 
        "params": [], 
        "path": "python/library/re#re.match.endpos", 
        "syntax": "match.endpos", 
        "type": "Text Processing"
    }, 
    "endswith": {
        "descr": "Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", 
        "name": "str.endswith", 
        "params": [], 
        "path": "python/library/stdtypes#str.endswith", 
        "syntax": "str.endswith(suffix[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "enumerate": {
        "descr": "Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable.", 
        "name": "enumerate", 
        "params": [], 
        "path": "python/library/functions#enumerate", 
        "syntax": "enumerate(iterable, start=0)", 
        "type": "Built-in Functions"
    }, 
    "eval": {
        "descr": "The arguments are a string and optional globals and locals. If provided, globals must be a dictionary. If provided, locals can be any mapping object.", 
        "name": "eval", 
        "params": [], 
        "path": "python/library/functions#eval", 
        "syntax": "eval(expression, globals=None, locals=None)", 
        "type": "Built-in Functions"
    }, 
    "exec": {
        "descr": "This function supports dynamic execution of Python code. object must be either a string or a code object. If it is a string, the string is parsed as a suite of Python statements which is then executed (unless a syntax error occurs). [1] If it is a code object, it is simply executed. In all cases, the code that\u2019s executed is expected to be valid as file input (see the section \u201cFile input\u201d in the Reference Manual). Be aware that the return and yield statements may not be used outside of function definitions even within the context of code passed to the exec() function. The return value is None.", 
        "name": "exec", 
        "params": [], 
        "path": "python/library/functions#exec", 
        "syntax": "exec(object[, globals[, locals]])", 
        "type": "Built-in Functions"
    }, 
    "exit": {
        "descr": "Objects that when printed, print a message like \u201cUse quit() or Ctrl-D (i.e. EOF) to exit\u201d, and when called, raise SystemExit with the specified exit code.", 
        "name": "exit", 
        "params": [], 
        "path": "python/library/constants#exit", 
        "syntax": "exit(code=None)", 
        "type": "Built-in Constants"
    }, 
    "expand": {
        "descr": "Return the string obtained by doing backslash substitution on the template string template, as done by the sub() method. Escapes such as \\n are converted to the appropriate characters, and numeric backreferences (\\1, \\2) and named backreferences (\\g<1>, \\g<name>) are replaced by the contents of the corresponding group.", 
        "name": "re.match.expand", 
        "params": [], 
        "path": "python/library/re#re.match.expand", 
        "syntax": "match.expand(template)", 
        "type": "Text Processing"
    }, 
    "expandtabs": {
        "descr": "Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\\n) or return (\\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed.", 
        "name": "str.expandtabs", 
        "params": [], 
        "path": "python/library/stdtypes#str.expandtabs", 
        "syntax": "str.expandtabs([tabsize])", 
        "type": "Built-in Types"
    }, 
    "extend": {
        "descr": "Append items from iterable to the end of the array. If iterable is another array, it must have exactly the same type code; if not, TypeError will be raised. If iterable is not an array, it must be iterable and its elements must be the right type to be appended to the array.", 
        "name": "array.array.extend", 
        "params": [], 
        "path": "python/library/array#array.array.extend", 
        "syntax": "array.extend(iterable)", 
        "type": "Data Types"
    }, 
    "faulthandler.cancel_dump_traceback_later": {
        "descr": "Cancel the last call to dump_traceback_later().", 
        "name": "faulthandler.cancel_dump_traceback_later", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.cancel_dump_traceback_later", 
        "syntax": "faulthandler.cancel_dump_traceback_later()", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.disable": {
        "descr": "Disable the fault handler: uninstall the signal handlers installed by enable().", 
        "name": "faulthandler.disable", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.disable", 
        "syntax": "faulthandler.disable()", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.dump_traceback": {
        "descr": "Dump the tracebacks of all threads into file. If all_threads is False, dump only the current thread.", 
        "name": "faulthandler.dump_traceback", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.dump_traceback", 
        "syntax": "faulthandler.dump_traceback(file=sys.stderr, all_threads=True)", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.dump_traceback_later": {
        "descr": "Dump the tracebacks of all threads, after a timeout of timeout seconds, or every timeout seconds if repeat is True. If exit is True, call _exit() with status=1 after dumping the tracebacks. (Note _exit() exits the process immediately, which means it doesn\u2019t do any cleanup like flushing file buffers.) If the function is called twice, the new call replaces previous parameters and resets the timeout. The timer has a sub-second resolution.", 
        "name": "faulthandler.dump_traceback_later", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.dump_traceback_later", 
        "syntax": "faulthandler.dump_traceback_later(timeout, repeat=False, file=sys.stderr, exit=False)", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.enable": {
        "descr": "Enable the fault handler: install handlers for the SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL signals to dump the Python traceback. If all_threads is True, produce tracebacks for every running thread. Otherwise, dump only the current thread.", 
        "name": "faulthandler.enable", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.enable", 
        "syntax": "faulthandler.enable(file=sys.stderr, all_threads=True)", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.is_enabled": {
        "descr": "Check if the fault handler is enabled.", 
        "name": "faulthandler.is_enabled", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.is_enabled", 
        "syntax": "faulthandler.is_enabled()", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.register": {
        "descr": "Register a user signal: install a handler for the signum signal to dump the traceback of all threads, or of the current thread if all_threads is False, into file. Call the previous handler if chain is True.", 
        "name": "faulthandler.register", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.register", 
        "syntax": "faulthandler.register(signum, file=sys.stderr, all_threads=True, chain=False)", 
        "type": "Debugging & Profiling"
    }, 
    "faulthandler.unregister": {
        "descr": "Unregister a user signal: uninstall the handler of the signum signal installed by register(). Return True if the signal was registered, False otherwise.", 
        "name": "faulthandler.unregister", 
        "params": [], 
        "path": "python/library/faulthandler#faulthandler.unregister", 
        "syntax": "faulthandler.unregister(signum)", 
        "type": "Debugging & Profiling"
    }, 
    "fcntl.fcntl": {
        "descr": "Perform the operation op on file descriptor fd (file objects providing a fileno() method are accepted as well). The values used for op are operating system dependent, and are available as constants in the fcntl module, using the same names as used in the relevant C header files. The argument arg is optional, and defaults to the integer value 0. When present, it can either be an integer value, or a string. With the argument missing or an integer value, the return value of this function is the integer return value of the C fcntl() call. When the argument is a string it represents a binary structure, e.g. created by struct.pack(). The binary data is copied to a buffer whose address is passed to the C fcntl() call. The return value after a successful call is the contents of the buffer, converted to a string object. The length of the returned string will be the same as the length of the arg argument. This is limited to 1024 bytes. If the information returned in the buffer by the operating system is larger than 1024 bytes, this is most likely to result in a segmentation violation or a more subtle data corruption.", 
        "name": "fcntl.fcntl", 
        "params": [], 
        "path": "python/library/fcntl#fcntl.fcntl", 
        "syntax": "fcntl.fcntl(fd, op[, arg])", 
        "type": "Unix"
    }, 
    "fcntl.flock": {
        "descr": "Perform the lock operation op on file descriptor fd (file objects providing a fileno() method are accepted as well). See the Unix manual flock(2) for details. (On some systems, this function is emulated using fcntl().)", 
        "name": "fcntl.flock", 
        "params": [], 
        "path": "python/library/fcntl#fcntl.flock", 
        "syntax": "fcntl.flock(fd, op)", 
        "type": "Unix"
    }, 
    "fcntl.ioctl": {
        "descr": "This function is identical to the fcntl() function, except that the argument handling is even more complicated.", 
        "name": "fcntl.ioctl", 
        "params": [], 
        "path": "python/library/fcntl#fcntl.ioctl", 
        "syntax": "fcntl.ioctl(fd, op[, arg[, mutate_flag]])", 
        "type": "Unix"
    }, 
    "fcntl.lockf": {
        "descr": "This is essentially a wrapper around the fcntl() locking calls. fd is the file descriptor of the file to lock or unlock, and operation is one of the following values:", 
        "name": "fcntl.lockf", 
        "params": [], 
        "path": "python/library/fcntl#fcntl.lockf", 
        "syntax": "fcntl.lockf(fd, operation[, length[, start[, whence]]])", 
        "type": "Unix"
    }, 
    "filecmp.cmp": {
        "descr": "Compare the files named f1 and f2, returning True if they seem equal, False otherwise.", 
        "name": "filecmp.cmp", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.cmp", 
        "syntax": "filecmp.cmp(f1, f2, shallow=True)", 
        "type": "File & Directory Access"
    }, 
    "filecmp.cmpfiles": {
        "descr": "Compare the files in the two directories dir1 and dir2 whose names are given by common.", 
        "name": "filecmp.cmpfiles", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.cmpfiles", 
        "syntax": "filecmp.cmpfiles(dir1, dir2, common, shallow=True)", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp": {
        "descr": "Construct a new directory comparison object, to compare the directories a and b. ignore is a list of names to ignore, and defaults to ['RCS', 'CVS', 'tags']. hide is a list of names to hide, and defaults to [os.curdir, os.pardir].", 
        "name": "filecmp.dircmp", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp", 
        "syntax": "class filecmp.dircmp(a, b, ignore=None, hide=None)", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.common": {
        "descr": "Files and subdirectories in both a and b.", 
        "name": "filecmp.dircmp.common", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.common", 
        "syntax": "common", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.common_dirs": {
        "descr": "Subdirectories in both a and b.", 
        "name": "filecmp.dircmp.common_dirs", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.common_dirs", 
        "syntax": "common_dirs", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.common_files": {
        "descr": "Files in both a and b", 
        "name": "filecmp.dircmp.common_files", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.common_files", 
        "syntax": "common_files", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.common_funny": {
        "descr": "Names in both a and b, such that the type differs between the directories, or names for which os.stat() reports an error.", 
        "name": "filecmp.dircmp.common_funny", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.common_funny", 
        "syntax": "common_funny", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.diff_files": {
        "descr": "Files which are in both a and b, whose contents differ according to the class\u2019s file comparison operator.", 
        "name": "filecmp.dircmp.diff_files", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.diff_files", 
        "syntax": "diff_files", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.funny_files": {
        "descr": "Files which are in both a and b, but could not be compared.", 
        "name": "filecmp.dircmp.funny_files", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.funny_files", 
        "syntax": "funny_files", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.left": {
        "descr": "The directory a.", 
        "name": "filecmp.dircmp.left", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.left", 
        "syntax": "left", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.left_list": {
        "descr": "Files and subdirectories in a, filtered by hide and ignore.", 
        "name": "filecmp.dircmp.left_list", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.left_list", 
        "syntax": "left_list", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.left_only": {
        "descr": "Files and subdirectories only in a.", 
        "name": "filecmp.dircmp.left_only", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.left_only", 
        "syntax": "left_only", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.report": {
        "descr": "Print (to sys.stdout) a comparison between a and b.", 
        "name": "filecmp.dircmp.report", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.report", 
        "syntax": "report()", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.report_full_closure": {
        "descr": "Print a comparison between a and b and common subdirectories (recursively).", 
        "name": "filecmp.dircmp.report_full_closure", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.report_full_closure", 
        "syntax": "report_full_closure()", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.report_partial_closure": {
        "descr": "Print a comparison between a and b and common immediate subdirectories.", 
        "name": "filecmp.dircmp.report_partial_closure", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.report_partial_closure", 
        "syntax": "report_partial_closure()", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.right": {
        "descr": "The directory b.", 
        "name": "filecmp.dircmp.right", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.right", 
        "syntax": "right", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.right_list": {
        "descr": "Files and subdirectories in b, filtered by hide and ignore.", 
        "name": "filecmp.dircmp.right_list", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.right_list", 
        "syntax": "right_list", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.right_only": {
        "descr": "Files and subdirectories only in b.", 
        "name": "filecmp.dircmp.right_only", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.right_only", 
        "syntax": "right_only", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.same_files": {
        "descr": "Files which are identical in both a and b, using the class\u2019s file comparison operator.", 
        "name": "filecmp.dircmp.same_files", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.same_files", 
        "syntax": "same_files", 
        "type": "File & Directory Access"
    }, 
    "filecmp.dircmp.subdirs": {
        "descr": "A dictionary mapping names in common_dirs to dircmp objects.", 
        "name": "filecmp.dircmp.subdirs", 
        "params": [], 
        "path": "python/library/filecmp#filecmp.dircmp.subdirs", 
        "syntax": "subdirs", 
        "type": "File & Directory Access"
    }, 
    "fileinput.FileInput": {
        "descr": "Class FileInput is the implementation; its methods filename(), fileno(), lineno(), filelineno(), isfirstline(), isstdin(), nextfile() and close() correspond to the functions of the same name in the module. In addition it has a readline() method which returns the next input line, and a __getitem__() method which implements the sequence behavior. The sequence must be accessed in strictly sequential order; random access and readline() cannot be mixed.", 
        "name": "fileinput.FileInput", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.FileInput", 
        "syntax": "class fileinput.FileInput(files=None, inplace=False, backup='', bufsize=0, mode='r', openhook=None)", 
        "type": "File & Directory Access"
    }, 
    "fileinput.close": {
        "descr": "Close the sequence.", 
        "name": "fileinput.close", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.close", 
        "syntax": "fileinput.close()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.filelineno": {
        "descr": "Return the line number in the current file. Before the first line has been read, returns 0. After the last line of the last file has been read, returns the line number of that line within the file.", 
        "name": "fileinput.filelineno", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.filelineno", 
        "syntax": "fileinput.filelineno()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.filename": {
        "descr": "Return the name of the file currently being read. Before the first line has been read, returns None.", 
        "name": "fileinput.filename", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.filename", 
        "syntax": "fileinput.filename()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.fileno": {
        "descr": "Return the integer \u201cfile descriptor\u201d for the current file. When no file is opened (before the first line and between files), returns -1.", 
        "name": "fileinput.fileno", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.fileno", 
        "syntax": "fileinput.fileno()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.hook_compressed": {
        "descr": "Transparently opens files compressed with gzip and bzip2 (recognized by the extensions '.gz' and '.bz2') using the gzip and bz2 modules. If the filename extension is not '.gz' or '.bz2', the file is opened normally (ie, using open() without any decompression).", 
        "name": "fileinput.hook_compressed", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.hook_compressed", 
        "syntax": "fileinput.hook_compressed(filename, mode)", 
        "type": "File & Directory Access"
    }, 
    "fileinput.hook_encoded": {
        "descr": "Returns a hook which opens each file with codecs.open(), using the given encoding to read the file.", 
        "name": "fileinput.hook_encoded", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.hook_encoded", 
        "syntax": "fileinput.hook_encoded(encoding)", 
        "type": "File & Directory Access"
    }, 
    "fileinput.input": {
        "descr": "Create an instance of the FileInput class. The instance will be used as global state for the functions of this module, and is also returned to use during iteration. The parameters to this function will be passed along to the constructor of the FileInput class.", 
        "name": "fileinput.input", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.input", 
        "syntax": "fileinput.input(files=None, inplace=False, backup='', bufsize=0, mode='r', openhook=None)", 
        "type": "File & Directory Access"
    }, 
    "fileinput.isfirstline": {
        "descr": "Returns true if the line just read is the first line of its file, otherwise returns false.", 
        "name": "fileinput.isfirstline", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.isfirstline", 
        "syntax": "fileinput.isfirstline()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.isstdin": {
        "descr": "Returns true if the last line was read from sys.stdin, otherwise returns false.", 
        "name": "fileinput.isstdin", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.isstdin", 
        "syntax": "fileinput.isstdin()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.lineno": {
        "descr": "Return the cumulative line number of the line that has just been read. Before the first line has been read, returns 0. After the last line of the last file has been read, returns the line number of that line.", 
        "name": "fileinput.lineno", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.lineno", 
        "syntax": "fileinput.lineno()", 
        "type": "File & Directory Access"
    }, 
    "fileinput.nextfile": {
        "descr": "Close the current file so that the next iteration will read the first line from the next file (if any); lines not read from the file will not count towards the cumulative line count. The filename is not changed until after the first line of the next file has been read. Before the first line has been read, this function has no effect; it cannot be used to skip the first file. After the last line of the last file has been read, this function has no effect.", 
        "name": "fileinput.nextfile", 
        "params": [], 
        "path": "python/library/fileinput#fileinput.nextfile", 
        "syntax": "fileinput.nextfile()", 
        "type": "File & Directory Access"
    }, 
    "filter": {
        "descr": "Construct an iterator from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed.", 
        "name": "filter", 
        "params": [], 
        "path": "python/library/functions#filter", 
        "syntax": "filter(function, iterable)", 
        "type": "Built-in Functions"
    }, 
    "find": {
        "descr": "Return the lowest index in the string where substring sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found.", 
        "name": "str.find", 
        "params": [], 
        "path": "python/library/stdtypes#str.find", 
        "syntax": "str.find(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "float": {
        "descr": "If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be '+' or '-'; a '+' sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed:", 
        "name": "float", 
        "params": [], 
        "path": "python/library/functions#float", 
        "syntax": "float([x])", 
        "type": "Built-in Functions"
    }, 
    "float.as_integer_ratio": {
        "descr": "Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs.", 
        "name": "float.as_integer_ratio", 
        "params": [], 
        "path": "python/library/stdtypes#float.as_integer_ratio", 
        "syntax": "float.as_integer_ratio()", 
        "type": "Built-in Types"
    }, 
    "float.fromhex": {
        "descr": "Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace.", 
        "name": "float.fromhex", 
        "params": [], 
        "path": "python/library/stdtypes#float.fromhex", 
        "syntax": "classmethod float.fromhex(s)", 
        "type": "Built-in Types"
    }, 
    "float.hex": {
        "descr": "Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading 0x and a trailing p and exponent.", 
        "name": "float.hex", 
        "params": [], 
        "path": "python/library/stdtypes#float.hex", 
        "syntax": "float.hex()", 
        "type": "Built-in Types"
    }, 
    "float.is_integer": {
        "descr": "Return True if the float instance is finite with integral value, and False otherwise:", 
        "name": "float.is_integer", 
        "params": [], 
        "path": "python/library/stdtypes#float.is_integer", 
        "syntax": "float.is_integer()", 
        "type": "Built-in Types"
    }, 
    "fnmatch.filter": {
        "descr": "Return the subset of the list of names that match pattern. It is the same as [n for n in names if fnmatch(n, pattern)], but implemented more efficiently.", 
        "name": "fnmatch.filter", 
        "params": [], 
        "path": "python/library/fnmatch#fnmatch.filter", 
        "syntax": "fnmatch.filter(names, pattern)", 
        "type": "File & Directory Access"
    }, 
    "fnmatch.fnmatch": {
        "descr": "Test whether the filename string matches the pattern string, returning True or False. If the operating system is case-insensitive, then both parameters will be normalized to all lower- or upper-case before the comparison is performed. fnmatchcase() can be used to perform a case-sensitive comparison, regardless of whether that\u2019s standard for the operating system.", 
        "name": "fnmatch.fnmatch", 
        "params": [], 
        "path": "python/library/fnmatch#fnmatch.fnmatch", 
        "syntax": "fnmatch.fnmatch(filename, pattern)", 
        "type": "File & Directory Access"
    }, 
    "fnmatch.fnmatchcase": {
        "descr": "Test whether filename matches pattern, returning True or False; the comparison is case-sensitive.", 
        "name": "fnmatch.fnmatchcase", 
        "params": [], 
        "path": "python/library/fnmatch#fnmatch.fnmatchcase", 
        "syntax": "fnmatch.fnmatchcase(filename, pattern)", 
        "type": "File & Directory Access"
    }, 
    "fnmatch.translate": {
        "descr": "Return the shell-style pattern converted to a regular expression.", 
        "name": "fnmatch.translate", 
        "params": [], 
        "path": "python/library/fnmatch#fnmatch.translate", 
        "syntax": "fnmatch.translate(pattern)", 
        "type": "File & Directory Access"
    }, 
    "format": {
        "descr": "Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument.", 
        "name": "str.format", 
        "params": [], 
        "path": "python/library/stdtypes#str.format", 
        "syntax": "str.format(*args, **kwargs)", 
        "type": "Built-in Types"
    }, 
    "format_map": {
        "descr": "Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass:", 
        "name": "str.format_map", 
        "params": [], 
        "path": "python/library/stdtypes#str.format_map", 
        "syntax": "str.format_map(mapping)", 
        "type": "Built-in Types"
    }, 
    "fpectl.FloatingPointError": {
        "descr": "After turnon_sigfpe() has been executed, a floating point operation that raises one of the IEEE-754 exceptions Division by Zero, Overflow, or Invalid operation will in turn raise this standard Python exception.", 
        "name": "fpectl.FloatingPointError", 
        "params": [], 
        "path": "python/library/fpectl#fpectl.FloatingPointError", 
        "syntax": "exception fpectl.FloatingPointError", 
        "type": "Runtime"
    }, 
    "fpectl.turnoff_sigfpe": {
        "descr": "Reset default handling of floating point exceptions.", 
        "name": "fpectl.turnoff_sigfpe", 
        "params": [], 
        "path": "python/library/fpectl#fpectl.turnoff_sigfpe", 
        "syntax": "fpectl.turnoff_sigfpe()", 
        "type": "Runtime"
    }, 
    "fpectl.turnon_sigfpe": {
        "descr": "Turn on the generation of SIGFPE, and set up an appropriate signal handler.", 
        "name": "fpectl.turnon_sigfpe", 
        "params": [], 
        "path": "python/library/fpectl#fpectl.turnon_sigfpe", 
        "syntax": "fpectl.turnon_sigfpe()", 
        "type": "Runtime"
    }, 
    "fractions.Fraction": {
        "descr": "The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator. If denominator is 0, it raises a ZeroDivisionError. The second version requires that other_fraction is an instance of numbers.Rational and returns a Fraction instance with the same value. The next two versions accept either a float or a decimal.Decimal instance, and return a Fraction instance with exactly the same value. Note that due to the usual issues with binary floating-point (see Floating Point Arithmetic: Issues and Limitations), the argument to Fraction(1.1) is not exactly equal to 11/10, and so Fraction(1.1) does not return Fraction(11, 10) as one might expect. (But see the documentation for the limit_denominator() method below.) The last version of the constructor expects a string or unicode instance. The usual form for this instance is:", 
        "name": "fractions.Fraction", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction", 
        "syntax": "class fractions.Fraction(numerator=0, denominator=1)", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.__ceil__": {
        "descr": "Returns the least int >= self. This method can also be accessed through the math.ceil() function.", 
        "name": "fractions.Fraction.__ceil__", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.__ceil__", 
        "syntax": "__ceil__()", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.__floor__": {
        "descr": "Returns the greatest int <= self. This method can also be accessed through the math.floor() function:", 
        "name": "fractions.Fraction.__floor__", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.__floor__", 
        "syntax": "__floor__()", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.__round__": {
        "descr": "The first version returns the nearest int to self, rounding half to even. The second version rounds self to the nearest multiple of Fraction(1, 10**ndigits) (logically, if ndigits is negative), again rounding half toward even. This method can also be accessed through the round() function.", 
        "name": "fractions.Fraction.__round__", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.__round__", 
        "syntax": "__round__()", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.denominator": {
        "descr": "Denominator of the Fraction in lowest term.", 
        "name": "fractions.Fraction.denominator", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.denominator", 
        "syntax": "denominator", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.from_decimal": {
        "descr": "This class method constructs a Fraction representing the exact value of dec, which must be a decimal.Decimal instance.", 
        "name": "fractions.Fraction.from_decimal", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.from_decimal", 
        "syntax": "from_decimal(dec)", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.from_float": {
        "descr": "This class method constructs a Fraction representing the exact value of flt, which must be a float. Beware that Fraction.from_float(0.3) is not the same value as Fraction(3, 10)", 
        "name": "fractions.Fraction.from_float", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.from_float", 
        "syntax": "from_float(flt)", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.limit_denominator": {
        "descr": "Finds and returns the closest Fraction to self that has denominator at most max_denominator. This method is useful for finding rational approximations to a given floating-point number:", 
        "name": "fractions.Fraction.limit_denominator", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.limit_denominator", 
        "syntax": "limit_denominator(max_denominator=1000000)", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.Fraction.numerator": {
        "descr": "Numerator of the Fraction in lowest term.", 
        "name": "fractions.Fraction.numerator", 
        "params": [], 
        "path": "python/library/fractions#fractions.Fraction.numerator", 
        "syntax": "numerator", 
        "type": "Numeric & Mathematical"
    }, 
    "fractions.gcd": {
        "descr": "Return the greatest common divisor of the integers a and b. If either a or b is nonzero, then the absolute value of gcd(a, b) is the largest integer that divides both a and b. gcd(a,b) has the same sign as b if b is nonzero; otherwise it takes the sign of a. gcd(0, 0) returns 0.", 
        "name": "fractions.gcd", 
        "params": [], 
        "path": "python/library/fractions#fractions.gcd", 
        "syntax": "fractions.gcd(a, b)", 
        "type": "Numeric & Mathematical"
    }, 
    "from_bytes": {
        "descr": "Return the integer represented by the given array of bytes.", 
        "name": "int.from_bytes", 
        "params": [], 
        "path": "python/library/stdtypes#int.from_bytes", 
        "syntax": "classmethod int.from_bytes(bytes, byteorder, *, signed=False)", 
        "type": "Built-in Types"
    }, 
    "frombytes": {
        "descr": "Appends items from the string, interpreting the string as an array of machine values (as if it had been read from a file using the fromfile() method).", 
        "name": "array.array.frombytes", 
        "params": [], 
        "path": "python/library/array#array.array.frombytes", 
        "syntax": "array.frombytes(s)", 
        "type": "Data Types"
    }, 
    "fromfile": {
        "descr": "Read n items (as machine values) from the file object f and append them to the end of the array. If less than n items are available, EOFError is raised, but the items that were available are still inserted into the array. f must be a real built-in file object; something else with a read() method won\u2019t do.", 
        "name": "array.array.fromfile", 
        "params": [], 
        "path": "python/library/array#array.array.fromfile", 
        "syntax": "array.fromfile(f, n)", 
        "type": "Data Types"
    }, 
    "fromhex": {
        "descr": "Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace.", 
        "name": "float.fromhex", 
        "params": [], 
        "path": "python/library/stdtypes#float.fromhex", 
        "syntax": "classmethod float.fromhex(s)", 
        "type": "Built-in Types"
    }, 
    "fromkeys": {
        "descr": "Create a new dictionary with keys from seq and values set to value.", 
        "name": "dict.fromkeys", 
        "params": [], 
        "path": "python/library/stdtypes#dict.fromkeys", 
        "syntax": "classmethod fromkeys(seq[, value])", 
        "type": "Built-in Types"
    }, 
    "fromlist": {
        "descr": "Append items from the list. This is equivalent to for x in list: a.append(x) except that if there is a type error, the array is unchanged.", 
        "name": "array.array.fromlist", 
        "params": [], 
        "path": "python/library/array#array.array.fromlist", 
        "syntax": "array.fromlist(list)", 
        "type": "Data Types"
    }, 
    "fromstring": {
        "descr": "Deprecated alias for frombytes().", 
        "name": "array.array.fromstring", 
        "params": [], 
        "path": "python/library/array#array.array.fromstring", 
        "syntax": "array.fromstring()", 
        "type": "Data Types"
    }, 
    "fromunicode": {
        "descr": "Extends this array with data from the given unicode string. The array must be a type 'u' array; otherwise a ValueError is raised. Use array.frombytes(unicodestring.encode(enc)) to append Unicode data to an array of some other type.", 
        "name": "array.array.fromunicode", 
        "params": [], 
        "path": "python/library/array#array.array.fromunicode", 
        "syntax": "array.fromunicode(s)", 
        "type": "Data Types"
    }, 
    "frozenset": {
        "descr": "Return a new frozenset object, optionally with elements taken from iterable. frozenset is a built-in class. See frozenset and Set Types \u2014 set, frozenset for documentation about this class.", 
        "name": "frozenset", 
        "params": [], 
        "path": "python/library/functions#frozenset", 
        "syntax": "frozenset([iterable])", 
        "type": "Built-in Functions"
    }, 
    "ftplib.FTP": {
        "descr": "Return a new instance of the FTP class. When host is given, the method call connect(host) is made. When user is given, additionally the method call login(user, passwd, acct) is made (where passwd and acct default to the empty string when not given). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if is not specified, the global default timeout setting will be used). source_address is a 2-tuple (host, port) for the socket to bind to as its source address before connecting.", 
        "name": "ftplib.FTP", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP", 
        "syntax": "class ftplib.FTP(host='', user='', passwd='', acct='', timeout=None, source_address=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.abort": {
        "descr": "Abort a file transfer that is in progress. Using this does not always work, but it\u2019s worth a try.", 
        "name": "ftplib.FTP.abort", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.abort", 
        "syntax": "FTP.abort()", 
        "type": "Internet"
    }, 
    "ftplib.FTP.close": {
        "descr": "Close the connection unilaterally. This should not be applied to an already closed connection such as after a successful call to quit(). After this call the FTP instance should not be used any more (after a call to close() or quit() you cannot reopen the connection by issuing another login() method).", 
        "name": "ftplib.FTP.close", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.close", 
        "syntax": "FTP.close()", 
        "type": "Internet"
    }, 
    "ftplib.FTP.connect": {
        "descr": "Connect to the given host and port. The default port number is 21, as specified by the FTP protocol specification. It is rarely needed to specify a different port number. This function should be called only once for each instance; it should not be called at all if a host was given when the instance was created. All other methods can only be used after a connection has been made. The optional timeout parameter specifies a timeout in seconds for the connection attempt. If no timeout is passed, the global default timeout setting will be used. source_address is a 2-tuple (host, port) for the socket to bind to as its source address before connecting.", 
        "name": "ftplib.FTP.connect", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.connect", 
        "syntax": "FTP.connect(host='', port=0, timeout=None, source_address=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.cwd": {
        "descr": "Set the current directory on the server.", 
        "name": "ftplib.FTP.cwd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.cwd", 
        "syntax": "FTP.cwd(pathname)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.delete": {
        "descr": "Remove the file named filename from the server. If successful, returns the text of the response, otherwise raises error_perm on permission errors or error_reply on other errors.", 
        "name": "ftplib.FTP.delete", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.delete", 
        "syntax": "FTP.delete(filename)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.dir": {
        "descr": "Produce a directory listing as returned by the LIST command, printing it to standard output. The optional argument is a directory to list (default is the current server directory). Multiple arguments can be used to pass non-standard options to the LIST command. If the last argument is a function, it is used as a callback function as for retrlines(); the default prints to sys.stdout. This method returns None.", 
        "name": "ftplib.FTP.dir", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.dir", 
        "syntax": "FTP.dir(argument[, ...])", 
        "type": "Internet"
    }, 
    "ftplib.FTP.getwelcome": {
        "descr": "Return the welcome message sent by the server in reply to the initial connection. (This message sometimes contains disclaimers or help information that may be relevant to the user.)", 
        "name": "ftplib.FTP.getwelcome", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.getwelcome", 
        "syntax": "FTP.getwelcome()", 
        "type": "Internet"
    }, 
    "ftplib.FTP.login": {
        "descr": "Log in as the given user. The passwd and acct parameters are optional and default to the empty string. If no user is specified, it defaults to 'anonymous'. If user is 'anonymous', the default passwd is 'anonymous@'. This function should be called only once for each instance, after a connection has been established; it should not be called at all if a host and user were given when the instance was created. Most FTP commands are only allowed after the client has logged in. The acct parameter supplies \u201caccounting information\u201d; few systems implement this.", 
        "name": "ftplib.FTP.login", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.login", 
        "syntax": "FTP.login(user='anonymous', passwd='', acct='')", 
        "type": "Internet"
    }, 
    "ftplib.FTP.mkd": {
        "descr": "Create a new directory on the server.", 
        "name": "ftplib.FTP.mkd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.mkd", 
        "syntax": "FTP.mkd(pathname)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.mlsd": {
        "descr": "List a directory in a standardized format by using MLSD command (RFC 3659). If path is omitted the current directory is assumed. facts is a list of strings representing the type of information desired (e.g. [\"type\", \"size\", \"perm\"]). Return a generator object yielding a tuple of two elements for every file found in path. First element is the file name, the second one is a dictionary containing facts about the file name. Content of this dictionary might be limited by the facts argument but server is not guaranteed to return all requested facts.", 
        "name": "ftplib.FTP.mlsd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.mlsd", 
        "syntax": "FTP.mlsd(path=\"\", facts=[])", 
        "type": "Internet"
    }, 
    "ftplib.FTP.nlst": {
        "descr": "Return a list of file names as returned by the NLST command. The optional argument is a directory to list (default is the current server directory). Multiple arguments can be used to pass non-standard options to the NLST command.", 
        "name": "ftplib.FTP.nlst", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.nlst", 
        "syntax": "FTP.nlst(argument[, ...])", 
        "type": "Internet"
    }, 
    "ftplib.FTP.ntransfercmd": {
        "descr": "Like transfercmd(), but returns a tuple of the data connection and the expected size of the data. If the expected size could not be computed, None will be returned as the expected size. cmd and rest means the same thing as in transfercmd().", 
        "name": "ftplib.FTP.ntransfercmd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.ntransfercmd", 
        "syntax": "FTP.ntransfercmd(cmd, rest=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.pwd": {
        "descr": "Return the pathname of the current directory on the server.", 
        "name": "ftplib.FTP.pwd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.pwd", 
        "syntax": "FTP.pwd()", 
        "type": "Internet"
    }, 
    "ftplib.FTP.quit": {
        "descr": "Send a QUIT command to the server and close the connection. This is the \u201cpolite\u201d way to close a connection, but it may raise an exception if the server responds with an error to the QUIT command. This implies a call to the close() method which renders the FTP instance useless for subsequent calls (see below).", 
        "name": "ftplib.FTP.quit", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.quit", 
        "syntax": "FTP.quit()", 
        "type": "Internet"
    }, 
    "ftplib.FTP.rename": {
        "descr": "Rename file fromname on the server to toname.", 
        "name": "ftplib.FTP.rename", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.rename", 
        "syntax": "FTP.rename(fromname, toname)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.retrbinary": {
        "descr": "Retrieve a file in binary transfer mode. cmd should be an appropriate RETR command: 'RETR filename'. The callback function is called for each block of data received, with a single string argument giving the data block. The optional blocksize argument specifies the maximum chunk size to read on the low-level socket object created to do the actual transfer (which will also be the largest size of the data blocks passed to callback). A reasonable default is chosen. rest means the same thing as in the transfercmd() method.", 
        "name": "ftplib.FTP.retrbinary", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.retrbinary", 
        "syntax": "FTP.retrbinary(cmd, callback, blocksize=8192, rest=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.retrlines": {
        "descr": "Retrieve a file or directory listing in ASCII transfer mode. cmd should be an appropriate RETR command (see retrbinary()) or a command such as LIST or NLST (usually just the string 'LIST'). LIST retrieves a list of files and information about those files. NLST retrieves a list of file names. The callback function is called for each line with a string argument containing the line with the trailing CRLF stripped. The default callback prints the line to sys.stdout.", 
        "name": "ftplib.FTP.retrlines", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.retrlines", 
        "syntax": "FTP.retrlines(cmd, callback=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.rmd": {
        "descr": "Remove the directory named dirname on the server.", 
        "name": "ftplib.FTP.rmd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.rmd", 
        "syntax": "FTP.rmd(dirname)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.sendcmd": {
        "descr": "Send a simple command string to the server and return the response string.", 
        "name": "ftplib.FTP.sendcmd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.sendcmd", 
        "syntax": "FTP.sendcmd(cmd)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.set_debuglevel": {
        "descr": "Set the instance\u2019s debugging level. This controls the amount of debugging output printed. The default, 0, produces no debugging output. A value of 1 produces a moderate amount of debugging output, generally a single line per request. A value of 2 or higher produces the maximum amount of debugging output, logging each line sent and received on the control connection.", 
        "name": "ftplib.FTP.set_debuglevel", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.set_debuglevel", 
        "syntax": "FTP.set_debuglevel(level)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.set_pasv": {
        "descr": "Enable \u201cpassive\u201d mode if boolean is true, other disable passive mode. Passive mode is on by default.", 
        "name": "ftplib.FTP.set_pasv", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.set_pasv", 
        "syntax": "FTP.set_pasv(boolean)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.size": {
        "descr": "Request the size of the file named filename on the server. On success, the size of the file is returned as an integer, otherwise None is returned. Note that the SIZE command is not standardized, but is supported by many common server implementations.", 
        "name": "ftplib.FTP.size", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.size", 
        "syntax": "FTP.size(filename)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.storbinary": {
        "descr": "Store a file in binary transfer mode. cmd should be an appropriate STOR command: \"STOR filename\". file is a file object (opened in binary mode) which is read until EOF using its read() method in blocks of size blocksize to provide the data to be stored. The blocksize argument defaults to 8192. callback is an optional single parameter callable that is called on each block of data after it is sent. rest means the same thing as in the transfercmd() method.", 
        "name": "ftplib.FTP.storbinary", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.storbinary", 
        "syntax": "FTP.storbinary(cmd, file, blocksize=8192, callback=None, rest=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.storlines": {
        "descr": "Store a file in ASCII transfer mode. cmd should be an appropriate STOR command (see storbinary()). Lines are read until EOF from the file object file (opened in binary mode) using its readline() method to provide the data to be stored. callback is an optional single parameter callable that is called on each line after it is sent.", 
        "name": "ftplib.FTP.storlines", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.storlines", 
        "syntax": "FTP.storlines(cmd, file, callback=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.transfercmd": {
        "descr": "Initiate a transfer over the data connection. If the transfer is active, send a EPRT or PORT command and the transfer command specified by cmd, and accept the connection. If the server is passive, send a EPSV or PASV command, connect to it, and start the transfer command. Either way, return the socket for the connection.", 
        "name": "ftplib.FTP.transfercmd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.transfercmd", 
        "syntax": "FTP.transfercmd(cmd, rest=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP.voidcmd": {
        "descr": "Send a simple command string to the server and handle the response. Return nothing if a response code corresponding to success (codes in the range 200\u2013299) is received. Raise error_reply otherwise.", 
        "name": "ftplib.FTP.voidcmd", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP.voidcmd", 
        "syntax": "FTP.voidcmd(cmd)", 
        "type": "Internet"
    }, 
    "ftplib.FTP_TLS": {
        "descr": "A FTP subclass which adds TLS support to FTP as described in RFC 4217. Connect as usual to port 21 implicitly securing the FTP control connection before authenticating. Securing the data connection requires the user to explicitly ask for it by calling the prot_p() method. keyfile and certfile are optional \u2013 they can contain a PEM formatted private key and certificate chain file name for the SSL connection. context parameter is a ssl.SSLContext object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. source_address is a 2-tuple (host, port) for the socket to bind to as its source address before connecting.", 
        "name": "ftplib.FTP_TLS", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP_TLS", 
        "syntax": "class ftplib.FTP_TLS(host='', user='', passwd='', acct='', keyfile=None, certfile=None, context=None, timeout=None, source_address=None)", 
        "type": "Internet"
    }, 
    "ftplib.FTP_TLS.auth": {
        "descr": "Set up secure control connection by using TLS or SSL, depending on what specified in ssl_version() attribute.", 
        "name": "ftplib.FTP_TLS.auth", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP_TLS.auth", 
        "syntax": "FTP_TLS.auth()", 
        "type": "Internet"
    }, 
    "ftplib.FTP_TLS.ccc": {
        "descr": "Revert control channel back to plaintext. This can be useful to take advantage of firewalls that know how to handle NAT with non-secure FTP without opening fixed ports.", 
        "name": "ftplib.FTP_TLS.ccc", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP_TLS.ccc", 
        "syntax": "FTP_TLS.ccc()", 
        "type": "Internet"
    }, 
    "ftplib.FTP_TLS.prot_c": {
        "descr": "Set up clear text data connection.", 
        "name": "ftplib.FTP_TLS.prot_c", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP_TLS.prot_c", 
        "syntax": "FTP_TLS.prot_c()", 
        "type": "Internet"
    }, 
    "ftplib.FTP_TLS.prot_p": {
        "descr": "Set up secure data connection.", 
        "name": "ftplib.FTP_TLS.prot_p", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP_TLS.prot_p", 
        "syntax": "FTP_TLS.prot_p()", 
        "type": "Internet"
    }, 
    "ftplib.FTP_TLS.ssl_version": {
        "descr": "The SSL version to use (defaults to TLSv1).", 
        "name": "ftplib.FTP_TLS.ssl_version", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.FTP_TLS.ssl_version", 
        "syntax": "FTP_TLS.ssl_version", 
        "type": "Internet"
    }, 
    "ftplib.all_errors": {
        "descr": "The set of all exceptions (as a tuple) that methods of FTP instances may raise as a result of problems with the FTP connection (as opposed to programming errors made by the caller). This set includes the four exceptions listed above as well as OSError.", 
        "name": "ftplib.all_errors", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.all_errors", 
        "syntax": "ftplib.all_errors", 
        "type": "Internet"
    }, 
    "ftplib.error_perm": {
        "descr": "Exception raised when an error code signifying a permanent error (response codes in the range 500\u2013599) is received.", 
        "name": "ftplib.error_perm", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.error_perm", 
        "syntax": "exception ftplib.error_perm", 
        "type": "Internet"
    }, 
    "ftplib.error_proto": {
        "descr": "Exception raised when a reply is received from the server that does not fit the response specifications of the File Transfer Protocol, i.e. begin with a digit in the range 1\u20135.", 
        "name": "ftplib.error_proto", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.error_proto", 
        "syntax": "exception ftplib.error_proto", 
        "type": "Internet"
    }, 
    "ftplib.error_reply": {
        "descr": "Exception raised when an unexpected reply is received from the server.", 
        "name": "ftplib.error_reply", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.error_reply", 
        "syntax": "exception ftplib.error_reply", 
        "type": "Internet"
    }, 
    "ftplib.error_temp": {
        "descr": "Exception raised when an error code signifying a temporary error (response codes in the range 400\u2013499) is received.", 
        "name": "ftplib.error_temp", 
        "params": [], 
        "path": "python/library/ftplib#ftplib.error_temp", 
        "syntax": "exception ftplib.error_temp", 
        "type": "Internet"
    }, 
    "functools.cmp_to_key": {
        "descr": "Transform an old-style comparison function to a key function. Used with tools that accept key functions (such as sorted(), min(), max(), heapq.nlargest(), heapq.nsmallest(), itertools.groupby()). This function is primarily used as a transition tool for programs being converted from Python 2 which supported the use of comparison functions.", 
        "name": "functools.cmp_to_key", 
        "params": [], 
        "path": "python/library/functools#functools.cmp_to_key", 
        "syntax": "functools.cmp_to_key(func)", 
        "type": "Functional Programming"
    }, 
    "functools.lru_cache": {
        "descr": "Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls. It can save time when an expensive or I/O bound function is periodically called with the same arguments.", 
        "name": "functools.lru_cache", 
        "params": [], 
        "path": "python/library/functools#functools.lru_cache", 
        "syntax": "@functools.lru_cache(maxsize=128, typed=False)", 
        "type": "Functional Programming"
    }, 
    "functools.partial": {
        "descr": "Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. If more arguments are supplied to the call, they are appended to args. If additional keyword arguments are supplied, they extend and override keywords. Roughly equivalent to:", 
        "name": "functools.partial", 
        "params": [], 
        "path": "python/library/functools#functools.partial", 
        "syntax": "functools.partial(func, *args, **keywords)", 
        "type": "Functional Programming"
    }, 
    "functools.partial.args": {
        "descr": "The leftmost positional arguments that will be prepended to the positional arguments provided to a partial object call.", 
        "name": "functools.partial.args", 
        "params": [], 
        "path": "python/library/functools#functools.partial.args", 
        "syntax": "partial.args", 
        "type": "Functional Programming"
    }, 
    "functools.partial.func": {
        "descr": "A callable object or function. Calls to the partial object will be forwarded to func with new arguments and keywords.", 
        "name": "functools.partial.func", 
        "params": [], 
        "path": "python/library/functools#functools.partial.func", 
        "syntax": "partial.func", 
        "type": "Functional Programming"
    }, 
    "functools.partial.keywords": {
        "descr": "The keyword arguments that will be supplied when the partial object is called.", 
        "name": "functools.partial.keywords", 
        "params": [], 
        "path": "python/library/functools#functools.partial.keywords", 
        "syntax": "partial.keywords", 
        "type": "Functional Programming"
    }, 
    "functools.reduce": {
        "descr": "Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the sequence. If the optional initializer is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. If initializer is not given and sequence contains only one item, the first item is returned.", 
        "name": "functools.reduce", 
        "params": [], 
        "path": "python/library/functools#functools.reduce", 
        "syntax": "functools.reduce(function, iterable[, initializer])", 
        "type": "Functional Programming"
    }, 
    "functools.total_ordering": {
        "descr": "Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest. This simplifies the effort involved in specifying all of the possible rich comparison operations:", 
        "name": "functools.total_ordering", 
        "params": [], 
        "path": "python/library/functools#functools.total_ordering", 
        "syntax": "@functools.total_ordering", 
        "type": "Functional Programming"
    }, 
    "functools.update_wrapper": {
        "descr": "Update a wrapper function to look like the wrapped function. The optional arguments are tuples to specify which attributes of the original function are assigned directly to the matching attributes on the wrapper function and which attributes of the wrapper function are updated with the corresponding attributes from the original function. The default values for these arguments are the module level constants WRAPPER_ASSIGNMENTS (which assigns to the wrapper function\u2019s __name__, __module__, __annotations__ and __doc__, the documentation string) and WRAPPER_UPDATES (which updates the wrapper function\u2019s __dict__, i.e. the instance dictionary).", 
        "name": "functools.update_wrapper", 
        "params": [], 
        "path": "python/library/functools#functools.update_wrapper", 
        "syntax": "functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)", 
        "type": "Functional Programming"
    }, 
    "functools.wraps": {
        "descr": "This is a convenience function for invoking partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) as a function decorator when defining a wrapper function. For example:", 
        "name": "functools.wraps", 
        "params": [], 
        "path": "python/library/functools#functools.wraps", 
        "syntax": "@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)", 
        "type": "Functional Programming"
    }, 
    "gc.callbacks": {
        "descr": "A list of callbacks that will be invoked by the garbage collector before and after collection. The callbacks will be called with two arguments, phase and info.", 
        "name": "gc.callbacks", 
        "params": [], 
        "path": "python/library/gc#gc.callbacks", 
        "syntax": "gc.callbacks", 
        "type": "Runtime"
    }, 
    "gc.collect": {
        "descr": "With no arguments, run a full collection. The optional argument generation may be an integer specifying which generation to collect (from 0 to 2). A ValueError is raised if the generation number is invalid. The number of unreachable objects found is returned.", 
        "name": "gc.collect", 
        "params": [], 
        "path": "python/library/gc#gc.collect", 
        "syntax": "gc.collect(generations=2)", 
        "type": "Runtime"
    }, 
    "gc.disable": {
        "descr": "Disable automatic garbage collection.", 
        "name": "gc.disable", 
        "params": [], 
        "path": "python/library/gc#gc.disable", 
        "syntax": "gc.disable()", 
        "type": "Runtime"
    }, 
    "gc.enable": {
        "descr": "Enable automatic garbage collection.", 
        "name": "gc.enable", 
        "params": [], 
        "path": "python/library/gc#gc.enable", 
        "syntax": "gc.enable()", 
        "type": "Runtime"
    }, 
    "gc.garbage": {
        "descr": "A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects). By default, this list contains only objects with __del__() methods. Objects that have __del__() methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily in the cycle but reachable only from it. Python doesn\u2019t collect such cycles automatically because, in general, it isn\u2019t possible for Python to guess a safe order in which to run the __del__() methods. If you know a safe order, you can force the issue by examining the garbage list, and explicitly breaking cycles due to your objects within the list. Note that these objects are kept alive even so by virtue of being in the garbage list, so they should be removed from garbage too. For example, after breaking cycles, do del gc.garbage[:] to empty the list. It\u2019s generally better to avoid the issue by not creating cycles containing objects with __del__() methods, and garbage can be examined in that case to verify that no such cycles are being created.", 
        "name": "gc.garbage", 
        "params": [], 
        "path": "python/library/gc#gc.garbage", 
        "syntax": "gc.garbage", 
        "type": "Runtime"
    }, 
    "gc.get_count": {
        "descr": "Return the current collection counts as a tuple of (count0, count1, count2).", 
        "name": "gc.get_count", 
        "params": [], 
        "path": "python/library/gc#gc.get_count", 
        "syntax": "gc.get_count()", 
        "type": "Runtime"
    }, 
    "gc.get_debug": {
        "descr": "Return the debugging flags currently set.", 
        "name": "gc.get_debug", 
        "params": [], 
        "path": "python/library/gc#gc.get_debug", 
        "syntax": "gc.get_debug()", 
        "type": "Runtime"
    }, 
    "gc.get_objects": {
        "descr": "Returns a list of all objects tracked by the collector, excluding the list returned.", 
        "name": "gc.get_objects", 
        "params": [], 
        "path": "python/library/gc#gc.get_objects", 
        "syntax": "gc.get_objects()", 
        "type": "Runtime"
    }, 
    "gc.get_referents": {
        "descr": "Return a list of objects directly referred to by any of the arguments. The referents returned are those objects visited by the arguments\u2019 C-level tp_traverse methods (if any), and may not be all objects actually directly reachable. tp_traverse methods are supported only by objects that support garbage collection, and are only required to visit objects that may be involved in a cycle. So, for example, if an integer is directly reachable from an argument, that integer object may or may not appear in the result list.", 
        "name": "gc.get_referents", 
        "params": [], 
        "path": "python/library/gc#gc.get_referents", 
        "syntax": "gc.get_referents(*objs)", 
        "type": "Runtime"
    }, 
    "gc.get_referrers": {
        "descr": "Return the list of objects that directly refer to any of objs. This function will only locate those containers which support garbage collection; extension types which do refer to other objects but do not support garbage collection will not be found.", 
        "name": "gc.get_referrers", 
        "params": [], 
        "path": "python/library/gc#gc.get_referrers", 
        "syntax": "gc.get_referrers(*objs)", 
        "type": "Runtime"
    }, 
    "gc.get_threshold": {
        "descr": "Return the current collection thresholds as a tuple of (threshold0, threshold1, threshold2).", 
        "name": "gc.get_threshold", 
        "params": [], 
        "path": "python/library/gc#gc.get_threshold", 
        "syntax": "gc.get_threshold()", 
        "type": "Runtime"
    }, 
    "gc.is_tracked": {
        "descr": "Returns True if the object is currently tracked by the garbage collector, False otherwise. As a general rule, instances of atomic types aren\u2019t tracked and instances of non-atomic types (containers, user-defined objects...) are. However, some type-specific optimizations can be present in order to suppress the garbage collector footprint of simple instances (e.g. dicts containing only atomic keys and values):", 
        "name": "gc.is_tracked", 
        "params": [], 
        "path": "python/library/gc#gc.is_tracked", 
        "syntax": "gc.is_tracked(obj)", 
        "type": "Runtime"
    }, 
    "gc.isenabled": {
        "descr": "Returns true if automatic collection is enabled.", 
        "name": "gc.isenabled", 
        "params": [], 
        "path": "python/library/gc#gc.isenabled", 
        "syntax": "gc.isenabled()", 
        "type": "Runtime"
    }, 
    "gc.set_debug": {
        "descr": "Set the garbage collection debugging flags. Debugging information will be written to sys.stderr. See below for a list of debugging flags which can be combined using bit operations to control debugging.", 
        "name": "gc.set_debug", 
        "params": [], 
        "path": "python/library/gc#gc.set_debug", 
        "syntax": "gc.set_debug(flags)", 
        "type": "Runtime"
    }, 
    "gc.set_threshold": {
        "descr": "Set the garbage collection thresholds (the collection frequency). Setting threshold0 to zero disables collection.", 
        "name": "gc.set_threshold", 
        "params": [], 
        "path": "python/library/gc#gc.set_threshold", 
        "syntax": "gc.set_threshold(threshold0[, threshold1[, threshold2]])", 
        "type": "Runtime"
    }, 
    "get": {
        "descr": "Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError.", 
        "name": "dict.get", 
        "params": [], 
        "path": "python/library/stdtypes#dict.get", 
        "syntax": "get(key[, default])", 
        "type": "Built-in Types"
    }, 
    "getattr": {
        "descr": "Return the value of the named attribute of object. name must be a string. If the string is the name of one of the object\u2019s attributes, the result is the value of that attribute. For example, getattr(x, 'foobar') is equivalent to x.foobar. If the named attribute does not exist, default is returned if provided, otherwise AttributeError is raised.", 
        "name": "getattr", 
        "params": [], 
        "path": "python/library/functions#getattr", 
        "syntax": "getattr(object, name[, default])", 
        "type": "Built-in Functions"
    }, 
    "getopt.GetoptError": {
        "descr": "This is raised when an unrecognized option is found in the argument list or when an option requiring an argument is given none. The argument to the exception is a string indicating the cause of the error. For long options, an argument given to an option which does not require one will also cause this exception to be raised. The attributes msg and opt give the error message and related option; if there is no specific option to which the exception relates, opt is an empty string.", 
        "name": "getopt.GetoptError", 
        "params": [], 
        "path": "python/library/getopt#getopt.GetoptError", 
        "syntax": "exception getopt.GetoptError", 
        "type": "Operating System"
    }, 
    "getopt.error": {
        "descr": "Alias for GetoptError; for backward compatibility.", 
        "name": "getopt.error", 
        "params": [], 
        "path": "python/library/getopt#getopt.error", 
        "syntax": "exception getopt.error", 
        "type": "Operating System"
    }, 
    "getopt.getopt": {
        "descr": "Parses command line options and parameter list. args is the argument list to be parsed, without the leading reference to the running program. Typically, this means sys.argv[1:]. shortopts is the string of option letters that the script wants to recognize, with options that require an argument followed by a colon (':'; i.e., the same format that Unix getopt() uses).", 
        "name": "getopt.getopt", 
        "params": [], 
        "path": "python/library/getopt#getopt.getopt", 
        "syntax": "getopt.getopt(args, shortopts, longopts=[])", 
        "type": "Operating System"
    }, 
    "getopt.gnu_getopt": {
        "descr": "This function works like getopt(), except that GNU style scanning mode is used by default. This means that option and non-option arguments may be intermixed. The getopt() function stops processing options as soon as a non-option argument is encountered.", 
        "name": "getopt.gnu_getopt", 
        "params": [], 
        "path": "python/library/getopt#getopt.gnu_getopt", 
        "syntax": "getopt.gnu_getopt(args, shortopts, longopts=[])", 
        "type": "Operating System"
    }, 
    "getpass.GetPassWarning": {
        "descr": "A UserWarning subclass issued when password input may be echoed.", 
        "name": "getpass.GetPassWarning", 
        "params": [], 
        "path": "python/library/getpass#getpass.GetPassWarning", 
        "syntax": "exception getpass.GetPassWarning", 
        "type": "Operating System"
    }, 
    "getpass.getpass": {
        "descr": "Prompt the user for a password without echoing. The user is prompted using the string prompt, which defaults to 'Password: '. On Unix, the prompt is written to the file-like object stream. stream defaults to the controlling terminal (/dev/tty) or if that is unavailable to sys.stderr (this argument is ignored on Windows).", 
        "name": "getpass.getpass", 
        "params": [], 
        "path": "python/library/getpass#getpass.getpass", 
        "syntax": "getpass.getpass(prompt='Password: ', stream=None)", 
        "type": "Operating System"
    }, 
    "getpass.getuser": {
        "descr": "Return the \u201clogin name\u201d of the user. Availability: Unix, Windows.", 
        "name": "getpass.getuser", 
        "params": [], 
        "path": "python/library/getpass#getpass.getuser", 
        "syntax": "getpass.getuser()", 
        "type": "Operating System"
    }, 
    "gettext.GNUTranslations.gettext": {
        "descr": "Look up the message id in the catalog and return the corresponding message string, as a Unicode string. If there is no entry in the catalog for the message id, and a fallback has been set, the look up is forwarded to the fallback\u2019s gettext() method. Otherwise, the message id is returned.", 
        "name": "gettext.GNUTranslations.gettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.GNUTranslations.gettext", 
        "syntax": "GNUTranslations.gettext(message)", 
        "type": "Internationalization"
    }, 
    "gettext.GNUTranslations.lgettext": {
        "descr": "Equivalent to gettext(), but the translation is returned as a bytestring encoded in the selected output charset, or in the preferred system encoding if no encoding was explicitly set with set_output_charset().", 
        "name": "gettext.GNUTranslations.lgettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.GNUTranslations.lgettext", 
        "syntax": "GNUTranslations.lgettext(message)", 
        "type": "Internationalization"
    }, 
    "gettext.GNUTranslations.lngettext": {
        "descr": "Equivalent to gettext(), but the translation is returned as a bytestring encoded in the selected output charset, or in the preferred system encoding if no encoding was explicitly set with set_output_charset().", 
        "name": "gettext.GNUTranslations.lngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.GNUTranslations.lngettext", 
        "syntax": "GNUTranslations.lngettext(singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.GNUTranslations.ngettext": {
        "descr": "Do a plural-forms lookup of a message id. singular is used as the message id for purposes of lookup in the catalog, while n is used to determine which plural form to use. The returned message string is a Unicode string.", 
        "name": "gettext.GNUTranslations.ngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.GNUTranslations.ngettext", 
        "syntax": "GNUTranslations.ngettext(singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations": {
        "descr": "Takes an optional file object fp, which is ignored by the base class. Initializes \u201cprotected\u201d instance variables _info and _charset which are set by derived classes, as well as _fallback, which is set through add_fallback(). It then calls self._parse(fp) if fp is not None.", 
        "name": "gettext.NullTranslations", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations", 
        "syntax": "class gettext.NullTranslations(fp=None)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations._parse": {
        "descr": "No-op\u2019d in the base class, this method takes file object fp, and reads the data from the file, initializing its message catalog. If you have an unsupported message catalog file format, you should override this method to parse your format.", 
        "name": "gettext.NullTranslations._parse", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations._parse", 
        "syntax": "_parse(fp)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.add_fallback": {
        "descr": "Add fallback as the fallback object for the current translation object. A translation object should consult the fallback if it cannot provide a translation for a given message.", 
        "name": "gettext.NullTranslations.add_fallback", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.add_fallback", 
        "syntax": "add_fallback(fallback)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.charset": {
        "descr": "Return the \u201cprotected\u201d _charset variable, which is the encoding of the message catalog file.", 
        "name": "gettext.NullTranslations.charset", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.charset", 
        "syntax": "charset()", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.gettext": {
        "descr": "If a fallback has been set, forward gettext() to the fallback. Otherwise, return the translated message. Overridden in derived classes.", 
        "name": "gettext.NullTranslations.gettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.gettext", 
        "syntax": "gettext(message)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.info": {
        "descr": "Return the \u201cprotected\u201d _info variable.", 
        "name": "gettext.NullTranslations.info", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.info", 
        "syntax": "info()", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.install": {
        "descr": "This method installs self.gettext() into the built-in namespace, binding it to _.", 
        "name": "gettext.NullTranslations.install", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.install", 
        "syntax": "install(names=None)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.lgettext": {
        "descr": "If a fallback has been set, forward lgettext() to the fallback. Otherwise, return the translated message. Overridden in derived classes.", 
        "name": "gettext.NullTranslations.lgettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.lgettext", 
        "syntax": "lgettext(message)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.lngettext": {
        "descr": "If a fallback has been set, forward lngettext() to the fallback. Otherwise, return the translated message. Overridden in derived classes.", 
        "name": "gettext.NullTranslations.lngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.lngettext", 
        "syntax": "lngettext(singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.ngettext": {
        "descr": "If a fallback has been set, forward ngettext() to the fallback. Otherwise, return the translated message. Overridden in derived classes.", 
        "name": "gettext.NullTranslations.ngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.ngettext", 
        "syntax": "ngettext(singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.output_charset": {
        "descr": "Return the \u201cprotected\u201d _output_charset variable, which defines the encoding used to return translated messages in lgettext() and lngettext().", 
        "name": "gettext.NullTranslations.output_charset", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.output_charset", 
        "syntax": "output_charset()", 
        "type": "Internationalization"
    }, 
    "gettext.NullTranslations.set_output_charset": {
        "descr": "Change the \u201cprotected\u201d _output_charset variable, which defines the encoding used to return translated messages.", 
        "name": "gettext.NullTranslations.set_output_charset", 
        "params": [], 
        "path": "python/library/gettext#gettext.NullTranslations.set_output_charset", 
        "syntax": "set_output_charset(charset)", 
        "type": "Internationalization"
    }, 
    "gettext.bind_textdomain_codeset": {
        "descr": "Bind the domain to codeset, changing the encoding of strings returned by the gettext() family of functions. If codeset is omitted, then the current binding is returned.", 
        "name": "gettext.bind_textdomain_codeset", 
        "params": [], 
        "path": "python/library/gettext#gettext.bind_textdomain_codeset", 
        "syntax": "gettext.bind_textdomain_codeset(domain, codeset=None)", 
        "type": "Internationalization"
    }, 
    "gettext.bindtextdomain": {
        "descr": "Bind the domain to the locale directory localedir. More concretely, gettext will look for binary .mo files for the given domain using the path (on Unix): localedir/language/LC_MESSAGES/domain.mo, where languages is searched for in the environment variables LANGUAGE, LC_ALL, LC_MESSAGES, and LANG respectively.", 
        "name": "gettext.bindtextdomain", 
        "params": [], 
        "path": "python/library/gettext#gettext.bindtextdomain", 
        "syntax": "gettext.bindtextdomain(domain, localedir=None)", 
        "type": "Internationalization"
    }, 
    "gettext.dgettext": {
        "descr": "Like gettext(), but look the message up in the specified domain.", 
        "name": "gettext.dgettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.dgettext", 
        "syntax": "gettext.dgettext(domain, message)", 
        "type": "Internationalization"
    }, 
    "gettext.dngettext": {
        "descr": "Like ngettext(), but look the message up in the specified domain.", 
        "name": "gettext.dngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.dngettext", 
        "syntax": "gettext.dngettext(domain, singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.find": {
        "descr": "This function implements the standard .mo file search algorithm. It takes a domain, identical to what textdomain() takes. Optional localedir is as in bindtextdomain() Optional languages is a list of strings, where each string is a language code.", 
        "name": "gettext.find", 
        "params": [], 
        "path": "python/library/gettext#gettext.find", 
        "syntax": "gettext.find(domain, localedir=None, languages=None, all=False)", 
        "type": "Internationalization"
    }, 
    "gettext.gettext": {
        "descr": "Return the localized translation of message, based on the current global domain, language, and locale directory. This function is usually aliased as _() in the local namespace (see examples below).", 
        "name": "gettext.gettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.gettext", 
        "syntax": "gettext.gettext(message)", 
        "type": "Internationalization"
    }, 
    "gettext.install": {
        "descr": "This installs the function _() in Python\u2019s builtins namespace, based on domain, localedir, and codeset which are passed to the function translation().", 
        "name": "gettext.install", 
        "params": [], 
        "path": "python/library/gettext#gettext.install", 
        "syntax": "gettext.install(domain, localedir=None, codeset=None, names=None)", 
        "type": "Internationalization"
    }, 
    "gettext.ldgettext": {
        "descr": "Equivalent to dgettext(), but the translation is returned in the preferred system encoding, if no other encoding was explicitly set with bind_textdomain_codeset().", 
        "name": "gettext.ldgettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.ldgettext", 
        "syntax": "gettext.ldgettext(domain, message)", 
        "type": "Internationalization"
    }, 
    "gettext.ldngettext": {
        "descr": "Equivalent to dngettext(), but the translation is returned in the preferred system encoding, if no other encoding was explicitly set with bind_textdomain_codeset().", 
        "name": "gettext.ldngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.ldngettext", 
        "syntax": "gettext.ldngettext(domain, singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.lgettext": {
        "descr": "Equivalent to gettext(), but the translation is returned in the preferred system encoding, if no other encoding was explicitly set with bind_textdomain_codeset().", 
        "name": "gettext.lgettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.lgettext", 
        "syntax": "gettext.lgettext(message)", 
        "type": "Internationalization"
    }, 
    "gettext.lngettext": {
        "descr": "Equivalent to ngettext(), but the translation is returned in the preferred system encoding, if no other encoding was explicitly set with bind_textdomain_codeset().", 
        "name": "gettext.lngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.lngettext", 
        "syntax": "gettext.lngettext(singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.ngettext": {
        "descr": "Like gettext(), but consider plural forms. If a translation is found, apply the plural formula to n, and return the resulting message (some languages have more than two plural forms). If no translation is found, return singular if n is 1; return plural otherwise.", 
        "name": "gettext.ngettext", 
        "params": [], 
        "path": "python/library/gettext#gettext.ngettext", 
        "syntax": "gettext.ngettext(singular, plural, n)", 
        "type": "Internationalization"
    }, 
    "gettext.textdomain": {
        "descr": "Change or query the current global domain. If domain is None, then the current global domain is returned, otherwise the global domain is set to domain, which is returned.", 
        "name": "gettext.textdomain", 
        "params": [], 
        "path": "python/library/gettext#gettext.textdomain", 
        "syntax": "gettext.textdomain(domain=None)", 
        "type": "Internationalization"
    }, 
    "gettext.translation": {
        "descr": "Return a Translations instance based on the domain, localedir, and languages, which are first passed to find() to get a list of the associated .mo file paths. Instances with identical .mo file names are cached. The actual class instantiated is either class_ if provided, otherwise GNUTranslations. The class\u2019s constructor must take a single file object argument. If provided, codeset will change the charset used to encode translated strings in the lgettext() and lngettext() methods.", 
        "name": "gettext.translation", 
        "params": [], 
        "path": "python/library/gettext#gettext.translation", 
        "syntax": "gettext.translation(domain, localedir=None, languages=None, class_=None, fallback=False, codeset=None)", 
        "type": "Internationalization"
    }, 
    "glob.glob": {
        "descr": "Return a possibly-empty list of path names that match pathname, which must be a string containing a path specification. pathname can be either absolute (like /usr/src/Python-1.5/Makefile) or relative (like ../../Tools/*/*.gif), and can contain shell-style wildcards. Broken symlinks are included in the results (as in the shell).", 
        "name": "glob.glob", 
        "params": [], 
        "path": "python/library/glob#glob.glob", 
        "syntax": "glob.glob(pathname)", 
        "type": "File & Directory Access"
    }, 
    "glob.iglob": {
        "descr": "Return an iterator which yields the same values as glob() without actually storing them all simultaneously.", 
        "name": "glob.iglob", 
        "params": [], 
        "path": "python/library/glob#glob.iglob", 
        "syntax": "glob.iglob(pathname)", 
        "type": "File & Directory Access"
    }, 
    "globals": {
        "descr": "Return a dictionary representing the current global symbol table. This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).", 
        "name": "globals", 
        "params": [], 
        "path": "python/library/functions#globals", 
        "syntax": "globals()", 
        "type": "Built-in Functions"
    }, 
    "group": {
        "descr": "Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned.", 
        "name": "re.match.group", 
        "params": [], 
        "path": "python/library/re#re.match.group", 
        "syntax": "match.group([group1, ...])", 
        "type": "Text Processing"
    }, 
    "groupdict": {
        "descr": "Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name. The default argument is used for groups that did not participate in the match; it defaults to None. For example:", 
        "name": "re.match.groupdict", 
        "params": [], 
        "path": "python/library/re#re.match.groupdict", 
        "syntax": "match.groupdict(default=None)", 
        "type": "Text Processing"
    }, 
    "groups": {
        "descr": "Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to None.", 
        "name": "re.match.groups", 
        "params": [], 
        "path": "python/library/re#re.match.groups", 
        "syntax": "match.groups(default=None)", 
        "type": "Text Processing"
    }, 
    "grp.getgrall": {
        "descr": "Return a list of all available group entries, in arbitrary order.", 
        "name": "grp.getgrall", 
        "params": [], 
        "path": "python/library/grp#grp.getgrall", 
        "syntax": "grp.getgrall()", 
        "type": "Unix"
    }, 
    "grp.getgrgid": {
        "descr": "Return the group database entry for the given numeric group ID. KeyError is raised if the entry asked for cannot be found.", 
        "name": "grp.getgrgid", 
        "params": [], 
        "path": "python/library/grp#grp.getgrgid", 
        "syntax": "grp.getgrgid(gid)", 
        "type": "Unix"
    }, 
    "grp.getgrnam": {
        "descr": "Return the group database entry for the given group name. KeyError is raised if the entry asked for cannot be found.", 
        "name": "grp.getgrnam", 
        "params": [], 
        "path": "python/library/grp#grp.getgrnam", 
        "syntax": "grp.getgrnam(name)", 
        "type": "Unix"
    }, 
    "gzip.GzipFile": {
        "descr": "Constructor for the GzipFile class, which simulates most of the methods of a file object, with the exception of the truncate() method. At least one of fileobj and filename must be given a non-trivial value.", 
        "name": "gzip.GzipFile", 
        "params": [], 
        "path": "python/library/gzip#gzip.GzipFile", 
        "syntax": "class gzip.GzipFile(filename=None, mode=None, compresslevel=9, fileobj=None, mtime=None)", 
        "type": "Data Compression"
    }, 
    "gzip.GzipFile.peek": {
        "descr": "Read n uncompressed bytes without advancing the file position. At most one single read on the compressed stream is done to satisfy the call. The number of bytes returned may be more or less than requested.", 
        "name": "gzip.GzipFile.peek", 
        "params": [], 
        "path": "python/library/gzip#gzip.GzipFile.peek", 
        "syntax": "peek([n])", 
        "type": "Data Compression"
    }, 
    "gzip.compress": {
        "descr": "Compress the data, returning a bytes object containing the compressed data. compresslevel has the same meaning as in the GzipFile constructor above.", 
        "name": "gzip.compress", 
        "params": [], 
        "path": "python/library/gzip#gzip.compress", 
        "syntax": "gzip.compress(data, compresslevel=9)", 
        "type": "Data Compression"
    }, 
    "gzip.decompress": {
        "descr": "Decompress the data, returning a bytes object containing the uncompressed data.", 
        "name": "gzip.decompress", 
        "params": [], 
        "path": "python/library/gzip#gzip.decompress", 
        "syntax": "gzip.decompress(data)", 
        "type": "Data Compression"
    }, 
    "gzip.open": {
        "descr": "Open a gzip-compressed file in binary or text mode, returning a file object.", 
        "name": "gzip.open", 
        "params": [], 
        "path": "python/library/gzip#gzip.open", 
        "syntax": "gzip.open(filename, mode='rb', compresslevel=9, encoding=None, errors=None, newline=None)", 
        "type": "Data Compression"
    }, 
    "hasattr": {
        "descr": "The arguments are an object and a string. The result is True if the string is the name of one of the object\u2019s attributes, False if not. (This is implemented by calling getattr(object, name) and seeing whether it raises an AttributeError or not.)", 
        "name": "hasattr", 
        "params": [], 
        "path": "python/library/functions#hasattr", 
        "syntax": "hasattr(object, name)", 
        "type": "Built-in Functions"
    }, 
    "hash": {
        "descr": "", 
        "name": "hash", 
        "params": [], 
        "path": "python/library/functions#hash", 
        "syntax": "hash(object)", 
        "type": "Built-in Functions"
    }, 
    "hashlib.algorithms_available": {
        "descr": "Contains the names of the hash algorithms that are available in the running Python interpreter. These names will be recognized when passed to new(). algorithms_guaranteed will always be a subset. Duplicate algorithms with different name formats may appear in this set (thanks to OpenSSL).", 
        "name": "hashlib.algorithms_available", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.algorithms_available", 
        "syntax": "hashlib.algorithms_available", 
        "type": "Cryptography"
    }, 
    "hashlib.algorithms_guaranteed": {
        "descr": "Contains the names of the hash algorithms guaranteed to be supported by this module on all platforms.", 
        "name": "hashlib.algorithms_guaranteed", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.algorithms_guaranteed", 
        "syntax": "hashlib.algorithms_guaranteed", 
        "type": "Cryptography"
    }, 
    "hashlib.hash.block_size": {
        "descr": "The internal block size of the hash algorithm in bytes.", 
        "name": "hashlib.hash.block_size", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.hash.block_size", 
        "syntax": "hash.block_size", 
        "type": "Cryptography"
    }, 
    "hashlib.hash.copy": {
        "descr": "Return a copy (\u201cclone\u201d) of the hash object. This can be used to efficiently compute the digests of data sharing a common initial substring.", 
        "name": "hashlib.hash.copy", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.hash.copy", 
        "syntax": "hash.copy()", 
        "type": "Cryptography"
    }, 
    "hashlib.hash.digest": {
        "descr": "Return the digest of the data passed to the update() method so far. This is a bytes object of size digest_size which may contain bytes in the whole range from 0 to 255.", 
        "name": "hashlib.hash.digest", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.hash.digest", 
        "syntax": "hash.digest()", 
        "type": "Cryptography"
    }, 
    "hashlib.hash.digest_size": {
        "descr": "The size of the resulting hash in bytes.", 
        "name": "hashlib.hash.digest_size", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.hash.digest_size", 
        "syntax": "hash.digest_size", 
        "type": "Cryptography"
    }, 
    "hashlib.hash.hexdigest": {
        "descr": "Like digest() except the digest is returned as a string object of double length, containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.", 
        "name": "hashlib.hash.hexdigest", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.hash.hexdigest", 
        "syntax": "hash.hexdigest()", 
        "type": "Cryptography"
    }, 
    "hashlib.hash.update": {
        "descr": "Update the hash object with the object arg, which must be interpretable as a buffer of bytes. Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b).", 
        "name": "hashlib.hash.update", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.hash.update", 
        "syntax": "hash.update(arg)", 
        "type": "Cryptography"
    }, 
    "hashlib.new": {
        "descr": "Is a generic constructor that takes the string name of the desired algorithm as its first parameter. It also exists to allow access to the above listed hashes as well as any other algorithms that your OpenSSL library may offer. The named constructors are much faster than new() and should be preferred.", 
        "name": "hashlib.new", 
        "params": [], 
        "path": "python/library/hashlib#hashlib.new", 
        "syntax": "hashlib.new(name[, data])", 
        "type": "Cryptography"
    }, 
    "heapq.heapify": {
        "descr": "Transform list x into a heap, in-place, in linear time.", 
        "name": "heapq.heapify", 
        "params": [], 
        "path": "python/library/heapq#heapq.heapify", 
        "syntax": "heapq.heapify(x)", 
        "type": "Data Types"
    }, 
    "heapq.heappop": {
        "descr": "Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised.", 
        "name": "heapq.heappop", 
        "params": [], 
        "path": "python/library/heapq#heapq.heappop", 
        "syntax": "heapq.heappop(heap)", 
        "type": "Data Types"
    }, 
    "heapq.heappush": {
        "descr": "Push the value item onto the heap, maintaining the heap invariant.", 
        "name": "heapq.heappush", 
        "params": [], 
        "path": "python/library/heapq#heapq.heappush", 
        "syntax": "heapq.heappush(heap, item)", 
        "type": "Data Types"
    }, 
    "heapq.heappushpop": {
        "descr": "Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop().", 
        "name": "heapq.heappushpop", 
        "params": [], 
        "path": "python/library/heapq#heapq.heappushpop", 
        "syntax": "heapq.heappushpop(heap, item)", 
        "type": "Data Types"
    }, 
    "heapq.heapreplace": {
        "descr": "Pop and return the smallest item from the heap, and also push the new item. The heap size doesn\u2019t change. If the heap is empty, IndexError is raised.", 
        "name": "heapq.heapreplace", 
        "params": [], 
        "path": "python/library/heapq#heapq.heapreplace", 
        "syntax": "heapq.heapreplace(heap, item)", 
        "type": "Data Types"
    }, 
    "heapq.merge": {
        "descr": "Merge multiple sorted inputs into a single sorted output (for example, merge timestamped entries from multiple log files). Returns an iterator over the sorted values.", 
        "name": "heapq.merge", 
        "params": [], 
        "path": "python/library/heapq#heapq.merge", 
        "syntax": "heapq.merge(*iterables)", 
        "type": "Data Types"
    }, 
    "heapq.nlargest": {
        "descr": "Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower Equivalent to: sorted(iterable, key=key, reverse=True)[:n]", 
        "name": "heapq.nlargest", 
        "params": [], 
        "path": "python/library/heapq#heapq.nlargest", 
        "syntax": "heapq.nlargest(n, iterable, key=None)", 
        "type": "Data Types"
    }, 
    "heapq.nsmallest": {
        "descr": "Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in the iterable: key=str.lower Equivalent to: sorted(iterable, key=key)[:n]", 
        "name": "heapq.nsmallest", 
        "params": [], 
        "path": "python/library/heapq#heapq.nsmallest", 
        "syntax": "heapq.nsmallest(n, iterable, key=None)", 
        "type": "Data Types"
    }, 
    "help": {
        "descr": "Invoke the built-in help system. (This function is intended for interactive use.) If no argument is given, the interactive help system starts on the interpreter console. If the argument is a string, then the string is looked up as the name of a module, function, class, method, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is generated.", 
        "name": "help", 
        "params": [], 
        "path": "python/library/functions#help", 
        "syntax": "help([object])", 
        "type": "Built-in Functions"
    }, 
    "hex": {
        "descr": "Convert an integer number to a hexadecimal string. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer.", 
        "name": "hex", 
        "params": [], 
        "path": "python/library/functions#hex", 
        "syntax": "hex(x)", 
        "type": "Built-in Functions"
    }, 
    "hmac.HMAC.copy": {
        "descr": "Return a copy (\u201cclone\u201d) of the hmac object. This can be used to efficiently compute the digests of strings that share a common initial substring.", 
        "name": "hmac.HMAC.copy", 
        "params": [], 
        "path": "python/library/hmac#hmac.HMAC.copy", 
        "syntax": "HMAC.copy()", 
        "type": "Cryptography"
    }, 
    "hmac.HMAC.digest": {
        "descr": "Return the digest of the bytes passed to the update() method so far. This bytes object will be the same length as the digest_size of the digest given to the constructor. It may contain non-ASCII bytes, including NUL bytes.", 
        "name": "hmac.HMAC.digest", 
        "params": [], 
        "path": "python/library/hmac#hmac.HMAC.digest", 
        "syntax": "HMAC.digest()", 
        "type": "Cryptography"
    }, 
    "hmac.HMAC.hexdigest": {
        "descr": "Like digest() except the digest is returned as a string twice the length containing only hexadecimal digits. This may be used to exchange the value safely in email or other non-binary environments.", 
        "name": "hmac.HMAC.hexdigest", 
        "params": [], 
        "path": "python/library/hmac#hmac.HMAC.hexdigest", 
        "syntax": "HMAC.hexdigest()", 
        "type": "Cryptography"
    }, 
    "hmac.HMAC.update": {
        "descr": "Update the hmac object with the bytes object msg. Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a + b).", 
        "name": "hmac.HMAC.update", 
        "params": [], 
        "path": "python/library/hmac#hmac.HMAC.update", 
        "syntax": "HMAC.update(msg)", 
        "type": "Cryptography"
    }, 
    "hmac.compare_digest": {
        "descr": "Return a == b. This function uses an approach designed to prevent timing analysis by avoiding content-based short circuiting behaviour, making it appropriate for cryptography. a and b must both be of the same type: either str (ASCII only, as e.g. returned by HMAC.hexdigest()), or a bytes-like object.", 
        "name": "hmac.compare_digest", 
        "params": [], 
        "path": "python/library/hmac#hmac.compare_digest", 
        "syntax": "hmac.compare_digest(a, b)", 
        "type": "Cryptography"
    }, 
    "hmac.new": {
        "descr": "Return a new hmac object. key is a bytes object giving the secret key. If msg is present, the method call update(msg) is made. digestmod is the digest constructor or module for the HMAC object to use. It defaults to the hashlib.md5 constructor.", 
        "name": "hmac.new", 
        "params": [], 
        "path": "python/library/hmac#hmac.new", 
        "syntax": "hmac.new(key, msg=None, digestmod=None)", 
        "type": "Cryptography"
    }, 
    "html.entities.codepoint2name": {
        "descr": "A dictionary that maps Unicode codepoints to HTML entity names.", 
        "name": "html.entities.codepoint2name", 
        "params": [], 
        "path": "python/library/html.entities#html.entities.codepoint2name", 
        "syntax": "html.entities.codepoint2name", 
        "type": "Structured Markup"
    }, 
    "html.entities.entitydefs": {
        "descr": "A dictionary mapping XHTML 1.0 entity definitions to their replacement text in ISO Latin-1.", 
        "name": "html.entities.entitydefs", 
        "params": [], 
        "path": "python/library/html.entities#html.entities.entitydefs", 
        "syntax": "html.entities.entitydefs", 
        "type": "Structured Markup"
    }, 
    "html.entities.html5": {
        "descr": "A dictionary that maps HTML5 named character references [1] to the equivalent Unicode character(s), e.g. html5['gt;'] == '>'. Note that the trailing semicolon is included in the name (e.g. 'gt;'), however some of the names are accepted by the standard even without the semicolon: in this case the name is present with and without the ';'.", 
        "name": "html.entities.html5", 
        "params": [], 
        "path": "python/library/html.entities#html.entities.html5", 
        "syntax": "html.entities.html5", 
        "type": "Structured Markup"
    }, 
    "html.entities.name2codepoint": {
        "descr": "A dictionary that maps HTML entity names to the Unicode codepoints.", 
        "name": "html.entities.name2codepoint", 
        "params": [], 
        "path": "python/library/html.entities#html.entities.name2codepoint", 
        "syntax": "html.entities.name2codepoint", 
        "type": "Structured Markup"
    }, 
    "html.escape": {
        "descr": "Convert the characters &, < and > in string s to HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. If the optional flag quote is true, the characters (\") and (') are also translated; this helps for inclusion in an HTML attribute value delimited by quotes, as in <a href=\"...\">.", 
        "name": "html.escape", 
        "params": [], 
        "path": "python/library/html#html.escape", 
        "syntax": "html.escape(s, quote=True)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParseError": {
        "descr": "Exception raised by the HTMLParser class when it encounters an error while parsing and strict is True. This exception provides three attributes: msg is a brief message explaining the error, lineno is the number of the line on which the broken construct was detected, and offset is the number of characters into the line at which the construct starts.", 
        "name": "html.parser.HTMLParseError", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParseError", 
        "syntax": "exception html.parser.HTMLParseError", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser": {
        "descr": "Create a parser instance. If strict is False (the default), the parser will accept and parse invalid markup. If strict is True the parser will raise an HTMLParseError exception instead [1] when it\u2019s not able to parse the markup. The use of strict=True is discouraged and the strict argument is deprecated.", 
        "name": "html.parser.HTMLParser", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser", 
        "syntax": "class html.parser.HTMLParser(strict=False)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.close": {
        "descr": "Force processing of all buffered data as if it were followed by an end-of-file mark. This method may be redefined by a derived class to define additional processing at the end of the input, but the redefined version should always call the HTMLParser base class method close().", 
        "name": "html.parser.HTMLParser.close", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.close", 
        "syntax": "HTMLParser.close()", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.feed": {
        "descr": "Feed some text to the parser. It is processed insofar as it consists of complete elements; incomplete data is buffered until more data is fed or close() is called. data must be str.", 
        "name": "html.parser.HTMLParser.feed", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.feed", 
        "syntax": "HTMLParser.feed(data)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.get_starttag_text": {
        "descr": "Return the text of the most recently opened start tag. This should not normally be needed for structured processing, but may be useful in dealing with HTML \u201cas deployed\u201d or for re-generating input with minimal changes (whitespace between attributes can be preserved, etc.).", 
        "name": "html.parser.HTMLParser.get_starttag_text", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.get_starttag_text", 
        "syntax": "HTMLParser.get_starttag_text()", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.getpos": {
        "descr": "Return current line number and offset.", 
        "name": "html.parser.HTMLParser.getpos", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.getpos", 
        "syntax": "HTMLParser.getpos()", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_charref": {
        "descr": "This method is called to process decimal and hexadecimal numeric character references of the form &#NNN; and &#xNNN;. For example, the decimal equivalent for > is &#62;, whereas the hexadecimal is &#x3E;; in this case the method will receive '62' or 'x3E'.", 
        "name": "html.parser.HTMLParser.handle_charref", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_charref", 
        "syntax": "HTMLParser.handle_charref(name)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_comment": {
        "descr": "This method is called when a comment is encountered (e.g. <!--comment-->).", 
        "name": "html.parser.HTMLParser.handle_comment", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_comment", 
        "syntax": "HTMLParser.handle_comment(data)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_data": {
        "descr": "This method is called to process arbitrary data (e.g. text nodes and the content of <script>...</script> and <style>...</style>).", 
        "name": "html.parser.HTMLParser.handle_data", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_data", 
        "syntax": "HTMLParser.handle_data(data)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_decl": {
        "descr": "This method is called to handle an HTML doctype declaration (e.g. <!DOCTYPE html>).", 
        "name": "html.parser.HTMLParser.handle_decl", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_decl", 
        "syntax": "HTMLParser.handle_decl(decl)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_endtag": {
        "descr": "This method is called to handle the end tag of an element (e.g. </div>).", 
        "name": "html.parser.HTMLParser.handle_endtag", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_endtag", 
        "syntax": "HTMLParser.handle_endtag(tag)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_entityref": {
        "descr": "This method is called to process a named character reference of the form &name; (e.g. >), where name is a general entity reference (e.g. 'gt').", 
        "name": "html.parser.HTMLParser.handle_entityref", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_entityref", 
        "syntax": "HTMLParser.handle_entityref(name)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_pi": {
        "descr": "Method called when a processing instruction is encountered. The data parameter will contain the entire processing instruction. For example, for the processing instruction <?proc color='red'>, this method would be called as handle_pi(\"proc color='red'\"). It is intended to be overridden by a derived class; the base class implementation does nothing.", 
        "name": "html.parser.HTMLParser.handle_pi", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_pi", 
        "syntax": "HTMLParser.handle_pi(data)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_startendtag": {
        "descr": "Similar to handle_starttag(), but called when the parser encounters an XHTML-style empty tag (<img ... />). This method may be overridden by subclasses which require this particular lexical information; the default implementation simply calls handle_starttag() and handle_endtag().", 
        "name": "html.parser.HTMLParser.handle_startendtag", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_startendtag", 
        "syntax": "HTMLParser.handle_startendtag(tag, attrs)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.handle_starttag": {
        "descr": "This method is called to handle the start of a tag (e.g. <div id=\"main\">).", 
        "name": "html.parser.HTMLParser.handle_starttag", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.handle_starttag", 
        "syntax": "HTMLParser.handle_starttag(tag, attrs)", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.reset": {
        "descr": "Reset the instance. Loses all unprocessed data. This is called implicitly at instantiation time.", 
        "name": "html.parser.HTMLParser.reset", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.reset", 
        "syntax": "HTMLParser.reset()", 
        "type": "Structured Markup"
    }, 
    "html.parser.HTMLParser.unknown_decl": {
        "descr": "This method is called when an unrecognized declaration is read by the parser.", 
        "name": "html.parser.HTMLParser.unknown_decl", 
        "params": [], 
        "path": "python/library/html.parser#html.parser.HTMLParser.unknown_decl", 
        "syntax": "HTMLParser.unknown_decl(data)", 
        "type": "Structured Markup"
    }, 
    "http.client.BadStatusLine": {
        "descr": "A subclass of HTTPException. Raised if a server responds with a HTTP status code that we don\u2019t understand.", 
        "name": "http.client.BadStatusLine", 
        "params": [], 
        "path": "python/library/http.client#http.client.BadStatusLine", 
        "syntax": "exception http.client.BadStatusLine", 
        "type": "Internet"
    }, 
    "http.client.CannotSendHeader": {
        "descr": "A subclass of ImproperConnectionState.", 
        "name": "http.client.CannotSendHeader", 
        "params": [], 
        "path": "python/library/http.client#http.client.CannotSendHeader", 
        "syntax": "exception http.client.CannotSendHeader", 
        "type": "Internet"
    }, 
    "http.client.CannotSendRequest": {
        "descr": "A subclass of ImproperConnectionState.", 
        "name": "http.client.CannotSendRequest", 
        "params": [], 
        "path": "python/library/http.client#http.client.CannotSendRequest", 
        "syntax": "exception http.client.CannotSendRequest", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection": {
        "descr": "An HTTPConnection instance represents one transaction with an HTTP server. It should be instantiated passing it a host and optional port number. If no port number is passed, the port is extracted from the host string if it has the form host:port, else the default HTTP port (80) is used. If the optional timeout parameter is given, blocking operations (like connection attempts) will timeout after that many seconds (if it is not given, the global default timeout setting is used). The optional source_address parameter may be a tuple of a (host, port) to use as the source address the HTTP connection is made from.", 
        "name": "http.client.HTTPConnection", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection", 
        "syntax": "class http.client.HTTPConnection(host, port=None[, strict][, timeout], source_address=None)", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.close": {
        "descr": "Close the connection to the server.", 
        "name": "http.client.HTTPConnection.close", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.close", 
        "syntax": "HTTPConnection.close()", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.connect": {
        "descr": "Connect to the server specified when the object was created.", 
        "name": "http.client.HTTPConnection.connect", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.connect", 
        "syntax": "HTTPConnection.connect()", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.endheaders": {
        "descr": "Send a blank line to the server, signalling the end of the headers. The optional message_body argument can be used to pass a message body associated with the request. The message body will be sent in the same packet as the message headers if it is string, otherwise it is sent in a separate packet.", 
        "name": "http.client.HTTPConnection.endheaders", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.endheaders", 
        "syntax": "HTTPConnection.endheaders(message_body=None)", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.getresponse": {
        "descr": "Should be called after a request is sent to get the response from the server. Returns an HTTPResponse instance.", 
        "name": "http.client.HTTPConnection.getresponse", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.getresponse", 
        "syntax": "HTTPConnection.getresponse()", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.putheader": {
        "descr": "Send an RFC 822-style header to the server. It sends a line to the server consisting of the header, a colon and a space, and the first argument. If more arguments are given, continuation lines are sent, each consisting of a tab and an argument.", 
        "name": "http.client.HTTPConnection.putheader", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.putheader", 
        "syntax": "HTTPConnection.putheader(header, argument[, ...])", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.putrequest": {
        "descr": "This should be the first call after the connection to the server has been made. It sends a line to the server consisting of the request string, the selector string, and the HTTP version (HTTP/1.1). To disable automatic sending of Host: or Accept-Encoding: headers (for example to accept additional content encodings), specify skip_host or skip_accept_encoding with non-False values.", 
        "name": "http.client.HTTPConnection.putrequest", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.putrequest", 
        "syntax": "HTTPConnection.putrequest(request, selector, skip_host=False, skip_accept_encoding=False)", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.request": {
        "descr": "This will send a request to the server using the HTTP request method method and the selector url. If the body argument is present, it should be string or bytes object of data to send after the headers are finished. Strings are encoded as ISO-8859-1, the default charset for HTTP. To use other encodings, pass a bytes object. The Content-Length header is set to the length of the string.", 
        "name": "http.client.HTTPConnection.request", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.request", 
        "syntax": "HTTPConnection.request(method, url, body=None, headers={})", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.send": {
        "descr": "Send data to the server. This should be used directly only after the endheaders() method has been called and before getresponse() is called.", 
        "name": "http.client.HTTPConnection.send", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.send", 
        "syntax": "HTTPConnection.send(data)", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.set_debuglevel": {
        "descr": "Set the debugging level. The default debug level is 0, meaning no debugging output is printed. Any value greater than 0 will cause all currently defined debug output to be printed to stdout. The debuglevel is passed to any new HTTPResponse objects that are created.", 
        "name": "http.client.HTTPConnection.set_debuglevel", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.set_debuglevel", 
        "syntax": "HTTPConnection.set_debuglevel(level)", 
        "type": "Internet"
    }, 
    "http.client.HTTPConnection.set_tunnel": {
        "descr": "Set the host and the port for HTTP Connect Tunnelling. Normally used when it is required to a HTTPS Connection through a proxy server.", 
        "name": "http.client.HTTPConnection.set_tunnel", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPConnection.set_tunnel", 
        "syntax": "HTTPConnection.set_tunnel(host, port=None, headers=None)", 
        "type": "Internet"
    }, 
    "http.client.HTTPException": {
        "descr": "The base class of the other exceptions in this module. It is a subclass of Exception.", 
        "name": "http.client.HTTPException", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPException", 
        "syntax": "exception http.client.HTTPException", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse": {
        "descr": "Class whose instances are returned upon successful connection. Not instantiated directly by user.", 
        "name": "http.client.HTTPResponse", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse", 
        "syntax": "class http.client.HTTPResponse(sock, debuglevel=0[, strict], method=None, url=None)", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.closed": {
        "descr": "Is True if the stream is closed.", 
        "name": "http.client.HTTPResponse.closed", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.closed", 
        "syntax": "HTTPResponse.closed", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.debuglevel": {
        "descr": "A debugging hook. If debuglevel is greater than zero, messages will be printed to stdout as the response is read and parsed.", 
        "name": "http.client.HTTPResponse.debuglevel", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.debuglevel", 
        "syntax": "HTTPResponse.debuglevel", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.fileno": {
        "descr": "Return the fileno of the underlying socket.", 
        "name": "http.client.HTTPResponse.fileno", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.fileno", 
        "syntax": "HTTPResponse.fileno()", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.getheader": {
        "descr": "Return the value of the header name, or default if there is no header matching name. If there is more than one header with the name name, return all of the values joined by \u2018, \u2018. If \u2018default\u2019 is any iterable other than a single string, its elements are similarly returned joined by commas.", 
        "name": "http.client.HTTPResponse.getheader", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.getheader", 
        "syntax": "HTTPResponse.getheader(name, default=None)", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.getheaders": {
        "descr": "Return a list of (header, value) tuples.", 
        "name": "http.client.HTTPResponse.getheaders", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.getheaders", 
        "syntax": "HTTPResponse.getheaders()", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.msg": {
        "descr": "A http.client.HTTPMessage instance containing the response headers. http.client.HTTPMessage is a subclass of email.message.Message.", 
        "name": "http.client.HTTPResponse.msg", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.msg", 
        "syntax": "HTTPResponse.msg", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.read": {
        "descr": "Reads and returns the response body, or up to the next amt bytes.", 
        "name": "http.client.HTTPResponse.read", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.read", 
        "syntax": "HTTPResponse.read([amt])", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.readinto": {
        "descr": "Reads up to the next len(b) bytes of the response body into the buffer b. Returns the number of bytes read.", 
        "name": "http.client.HTTPResponse.readinto", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.readinto", 
        "syntax": "HTTPResponse.readinto(b)", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.reason": {
        "descr": "Reason phrase returned by server.", 
        "name": "http.client.HTTPResponse.reason", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.reason", 
        "syntax": "HTTPResponse.reason", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.status": {
        "descr": "Status code returned by server.", 
        "name": "http.client.HTTPResponse.status", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.status", 
        "syntax": "HTTPResponse.status", 
        "type": "Internet"
    }, 
    "http.client.HTTPResponse.version": {
        "descr": "HTTP protocol version used by server. 10 for HTTP/1.0, 11 for HTTP/1.1.", 
        "name": "http.client.HTTPResponse.version", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPResponse.version", 
        "syntax": "HTTPResponse.version", 
        "type": "Internet"
    }, 
    "http.client.HTTPSConnection": {
        "descr": "A subclass of HTTPConnection that uses SSL for communication with secure servers. Default port is 443. If context is specified, it must be a ssl.SSLContext instance describing the various SSL options. If context is specified and has a verify_mode of either CERT_OPTIONAL or CERT_REQUIRED, then by default host is matched against the host name(s) allowed by the server\u2019s certificate. If you want to change that behaviour, you can explicitly set check_hostname to False.", 
        "name": "http.client.HTTPSConnection", 
        "params": [], 
        "path": "python/library/http.client#http.client.HTTPSConnection", 
        "syntax": "class http.client.HTTPSConnection(host, port=None, key_file=None, cert_file=None[, strict][, timeout], source_address=None, *, context=None, check_hostname=None)", 
        "type": "Internet"
    }, 
    "http.client.ImproperConnectionState": {
        "descr": "A subclass of HTTPException.", 
        "name": "http.client.ImproperConnectionState", 
        "params": [], 
        "path": "python/library/http.client#http.client.ImproperConnectionState", 
        "syntax": "exception http.client.ImproperConnectionState", 
        "type": "Internet"
    }, 
    "http.client.IncompleteRead": {
        "descr": "A subclass of HTTPException.", 
        "name": "http.client.IncompleteRead", 
        "params": [], 
        "path": "python/library/http.client#http.client.IncompleteRead", 
        "syntax": "exception http.client.IncompleteRead", 
        "type": "Internet"
    }, 
    "http.client.InvalidURL": {
        "descr": "A subclass of HTTPException, raised if a port is given and is either non-numeric or empty.", 
        "name": "http.client.InvalidURL", 
        "params": [], 
        "path": "python/library/http.client#http.client.InvalidURL", 
        "syntax": "exception http.client.InvalidURL", 
        "type": "Internet"
    }, 
    "http.client.NotConnected": {
        "descr": "A subclass of HTTPException.", 
        "name": "http.client.NotConnected", 
        "params": [], 
        "path": "python/library/http.client#http.client.NotConnected", 
        "syntax": "exception http.client.NotConnected", 
        "type": "Internet"
    }, 
    "http.client.ResponseNotReady": {
        "descr": "A subclass of ImproperConnectionState.", 
        "name": "http.client.ResponseNotReady", 
        "params": [], 
        "path": "python/library/http.client#http.client.ResponseNotReady", 
        "syntax": "exception http.client.ResponseNotReady", 
        "type": "Internet"
    }, 
    "http.client.UnimplementedFileMode": {
        "descr": "A subclass of HTTPException.", 
        "name": "http.client.UnimplementedFileMode", 
        "params": [], 
        "path": "python/library/http.client#http.client.UnimplementedFileMode", 
        "syntax": "exception http.client.UnimplementedFileMode", 
        "type": "Internet"
    }, 
    "http.client.UnknownProtocol": {
        "descr": "A subclass of HTTPException.", 
        "name": "http.client.UnknownProtocol", 
        "params": [], 
        "path": "python/library/http.client#http.client.UnknownProtocol", 
        "syntax": "exception http.client.UnknownProtocol", 
        "type": "Internet"
    }, 
    "http.client.UnknownTransferEncoding": {
        "descr": "A subclass of HTTPException.", 
        "name": "http.client.UnknownTransferEncoding", 
        "params": [], 
        "path": "python/library/http.client#http.client.UnknownTransferEncoding", 
        "syntax": "exception http.client.UnknownTransferEncoding", 
        "type": "Internet"
    }, 
    "http.client.responses": {
        "descr": "This dictionary maps the HTTP 1.1 status codes to the W3C names.", 
        "name": "http.client.responses", 
        "params": [], 
        "path": "python/library/http.client#http.client.responses", 
        "syntax": "http.client.responses", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie": {
        "descr": "This class represents Netscape, RFC 2109 and RFC 2965 cookies. It is not expected that users of http.cookiejar construct their own Cookie instances. Instead, if necessary, call make_cookies() on a CookieJar instance.", 
        "name": "http.cookiejar.Cookie", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie", 
        "syntax": "class http.cookiejar.Cookie", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.comment": {
        "descr": "String comment from the server explaining the function of this cookie, or None.", 
        "name": "http.cookiejar.Cookie.comment", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.comment", 
        "syntax": "Cookie.comment", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.comment_url": {
        "descr": "URL linking to a comment from the server explaining the function of this cookie, or None.", 
        "name": "http.cookiejar.Cookie.comment_url", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.comment_url", 
        "syntax": "Cookie.comment_url", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.discard": {
        "descr": "True if this is a session cookie.", 
        "name": "http.cookiejar.Cookie.discard", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.discard", 
        "syntax": "Cookie.discard", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.domain_initial_dot": {
        "descr": "True if the domain explicitly specified by the server began with a dot ('.').", 
        "name": "http.cookiejar.Cookie.domain_initial_dot", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.domain_initial_dot", 
        "syntax": "Cookie.domain_initial_dot", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.domain_specified": {
        "descr": "True if a domain was explicitly specified by the server.", 
        "name": "http.cookiejar.Cookie.domain_specified", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.domain_specified", 
        "syntax": "Cookie.domain_specified", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.expires": {
        "descr": "Integer expiry date in seconds since epoch, or None. See also the is_expired() method.", 
        "name": "http.cookiejar.Cookie.expires", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.expires", 
        "syntax": "Cookie.expires", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.get_nonstandard_attr": {
        "descr": "If cookie has the named cookie-attribute, return its value. Otherwise, return default.", 
        "name": "http.cookiejar.Cookie.get_nonstandard_attr", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.get_nonstandard_attr", 
        "syntax": "Cookie.get_nonstandard_attr(name, default=None)", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.has_nonstandard_attr": {
        "descr": "Return true if cookie has the named cookie-attribute.", 
        "name": "http.cookiejar.Cookie.has_nonstandard_attr", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.has_nonstandard_attr", 
        "syntax": "Cookie.has_nonstandard_attr(name)", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.is_expired": {
        "descr": "True if cookie has passed the time at which the server requested it should expire. If now is given (in seconds since the epoch), return whether the cookie has expired at the specified time.", 
        "name": "http.cookiejar.Cookie.is_expired", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.is_expired", 
        "syntax": "Cookie.is_expired(now=None)", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.name": {
        "descr": "Cookie name (a string).", 
        "name": "http.cookiejar.Cookie.name", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.name", 
        "syntax": "Cookie.name", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.path": {
        "descr": "Cookie path (a string, eg. '/acme/rocket_launchers').", 
        "name": "http.cookiejar.Cookie.path", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.path", 
        "syntax": "Cookie.path", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.port": {
        "descr": "String representing a port or a set of ports (eg. \u201880\u2019, or \u201880,8080\u2019), or None.", 
        "name": "http.cookiejar.Cookie.port", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.port", 
        "syntax": "Cookie.port", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.port_specified": {
        "descr": "True if a port or set of ports was explicitly specified by the server (in the Set-Cookie / Set-Cookie2 header).", 
        "name": "http.cookiejar.Cookie.port_specified", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.port_specified", 
        "syntax": "Cookie.port_specified", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.rfc2109": {
        "descr": "True if this cookie was received as an RFC 2109 cookie (ie. the cookie arrived in a Set-Cookie header, and the value of the Version cookie-attribute in that header was 1). This attribute is provided because http.cookiejar may \u2018downgrade\u2019 RFC 2109 cookies to Netscape cookies, in which case version is 0.", 
        "name": "http.cookiejar.Cookie.rfc2109", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.rfc2109", 
        "syntax": "Cookie.rfc2109", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.secure": {
        "descr": "True if cookie should only be returned over a secure connection.", 
        "name": "http.cookiejar.Cookie.secure", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.secure", 
        "syntax": "Cookie.secure", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.set_nonstandard_attr": {
        "descr": "Set the value of the named cookie-attribute.", 
        "name": "http.cookiejar.Cookie.set_nonstandard_attr", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.set_nonstandard_attr", 
        "syntax": "Cookie.set_nonstandard_attr(name, value)", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.value": {
        "descr": "Cookie value (a string), or None.", 
        "name": "http.cookiejar.Cookie.value", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.value", 
        "syntax": "Cookie.value", 
        "type": "Internet"
    }, 
    "http.cookiejar.Cookie.version": {
        "descr": "Integer or None. Netscape cookies have version 0. RFC 2965 and RFC 2109 cookies have a version cookie-attribute of 1. However, note that http.cookiejar may \u2018downgrade\u2019 RFC 2109 cookies to Netscape cookies, in which case version is 0.", 
        "name": "http.cookiejar.Cookie.version", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.Cookie.version", 
        "syntax": "Cookie.version", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar": {
        "descr": "policy is an object implementing the CookiePolicy interface.", 
        "name": "http.cookiejar.CookieJar", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar", 
        "syntax": "class http.cookiejar.CookieJar(policy=None)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.add_cookie_header": {
        "descr": "Add correct Cookie header to request.", 
        "name": "http.cookiejar.CookieJar.add_cookie_header", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.add_cookie_header", 
        "syntax": "CookieJar.add_cookie_header(request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.clear": {
        "descr": "Clear some cookies.", 
        "name": "http.cookiejar.CookieJar.clear", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.clear", 
        "syntax": "CookieJar.clear([domain[, path[, name]]])", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.clear_session_cookies": {
        "descr": "Discard all session cookies.", 
        "name": "http.cookiejar.CookieJar.clear_session_cookies", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.clear_session_cookies", 
        "syntax": "CookieJar.clear_session_cookies()", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.extract_cookies": {
        "descr": "Extract cookies from HTTP response and store them in the CookieJar, where allowed by policy.", 
        "name": "http.cookiejar.CookieJar.extract_cookies", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.extract_cookies", 
        "syntax": "CookieJar.extract_cookies(response, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.make_cookies": {
        "descr": "Return sequence of Cookie objects extracted from response object.", 
        "name": "http.cookiejar.CookieJar.make_cookies", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.make_cookies", 
        "syntax": "CookieJar.make_cookies(response, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.set_cookie": {
        "descr": "Set a Cookie, without checking with policy to see whether or not it should be set.", 
        "name": "http.cookiejar.CookieJar.set_cookie", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.set_cookie", 
        "syntax": "CookieJar.set_cookie(cookie)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.set_cookie_if_ok": {
        "descr": "Set a Cookie if policy says it\u2019s OK to do so.", 
        "name": "http.cookiejar.CookieJar.set_cookie_if_ok", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.set_cookie_if_ok", 
        "syntax": "CookieJar.set_cookie_if_ok(cookie, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookieJar.set_policy": {
        "descr": "Set the CookiePolicy instance to be used.", 
        "name": "http.cookiejar.CookieJar.set_policy", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookieJar.set_policy", 
        "syntax": "CookieJar.set_policy(policy)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy": {
        "descr": "This class is responsible for deciding whether each cookie should be accepted from / returned to the server.", 
        "name": "http.cookiejar.CookiePolicy", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy", 
        "syntax": "class http.cookiejar.CookiePolicy", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.domain_return_ok": {
        "descr": "Return false if cookies should not be returned, given cookie domain.", 
        "name": "http.cookiejar.CookiePolicy.domain_return_ok", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.domain_return_ok", 
        "syntax": "CookiePolicy.domain_return_ok(domain, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.hide_cookie2": {
        "descr": "Don\u2019t add Cookie2 header to requests (the presence of this header indicates to the server that we understand RFC 2965 cookies).", 
        "name": "http.cookiejar.CookiePolicy.hide_cookie2", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.hide_cookie2", 
        "syntax": "CookiePolicy.hide_cookie2", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.netscape": {
        "descr": "Implement Netscape protocol.", 
        "name": "http.cookiejar.CookiePolicy.netscape", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.netscape", 
        "syntax": "CookiePolicy.netscape", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.path_return_ok": {
        "descr": "Return false if cookies should not be returned, given cookie path.", 
        "name": "http.cookiejar.CookiePolicy.path_return_ok", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.path_return_ok", 
        "syntax": "CookiePolicy.path_return_ok(path, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.return_ok": {
        "descr": "Return boolean value indicating whether cookie should be returned to server.", 
        "name": "http.cookiejar.CookiePolicy.return_ok", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.return_ok", 
        "syntax": "CookiePolicy.return_ok(cookie, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.rfc2965": {
        "descr": "Implement RFC 2965 protocol.", 
        "name": "http.cookiejar.CookiePolicy.rfc2965", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.rfc2965", 
        "syntax": "CookiePolicy.rfc2965", 
        "type": "Internet"
    }, 
    "http.cookiejar.CookiePolicy.set_ok": {
        "descr": "Return boolean value indicating whether cookie should be accepted from server.", 
        "name": "http.cookiejar.CookiePolicy.set_ok", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.CookiePolicy.set_ok", 
        "syntax": "CookiePolicy.set_ok(cookie, request)", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy": {
        "descr": "Constructor arguments should be passed as keyword arguments only. blocked_domains is a sequence of domain names that we never accept cookies from, nor return cookies to. allowed_domains if not None, this is a sequence of the only domains for which we accept and return cookies. For all other arguments, see the documentation for CookiePolicy and DefaultCookiePolicy objects.", 
        "name": "http.cookiejar.DefaultCookiePolicy", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy", 
        "syntax": "class http.cookiejar.DefaultCookiePolicy(blocked_domains=None, allowed_domains=None, netscape=True, rfc2965=False, rfc2109_as_netscape=None, hide_cookie2=False, strict_domain=False, strict_rfc2965_unverifiable=True, strict_ns_unverifiable=False, strict_ns_domain=DefaultCookiePolicy.DomainLiberal, strict_ns_set_initial_dollar=False, strict_ns_set_path=False)", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.DomainLiberal": {
        "descr": "Equivalent to 0 (ie. all of the above Netscape domain strictness flags switched off).", 
        "name": "http.cookiejar.DefaultCookiePolicy.DomainLiberal", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainLiberal", 
        "syntax": "DefaultCookiePolicy.DomainLiberal", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match": {
        "descr": "When setting cookies, require a full RFC 2965 domain-match.", 
        "name": "http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match", 
        "syntax": "DefaultCookiePolicy.DomainRFC2965Match", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.DomainStrict": {
        "descr": "Equivalent to DomainStrictNoDots|DomainStrictNonDomain.", 
        "name": "http.cookiejar.DefaultCookiePolicy.DomainStrict", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrict", 
        "syntax": "DefaultCookiePolicy.DomainStrict", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots": {
        "descr": "When setting cookies, the \u2018host prefix\u2019 must not contain a dot (eg. www.foo.bar.com can\u2019t set a cookie for .bar.com, because www.foo contains a dot).", 
        "name": "http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots", 
        "syntax": "DefaultCookiePolicy.DomainStrictNoDots", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain": {
        "descr": "Cookies that did not explicitly specify a domain cookie-attribute can only be returned to a domain equal to the domain that set the cookie (eg. spam.example.com won\u2019t be returned cookies from example.com that had no domain cookie-attribute).", 
        "name": "http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain", 
        "syntax": "DefaultCookiePolicy.DomainStrictNonDomain", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.allowed_domains": {
        "descr": "Return None, or the sequence of allowed domains (as a tuple).", 
        "name": "http.cookiejar.DefaultCookiePolicy.allowed_domains", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.allowed_domains", 
        "syntax": "DefaultCookiePolicy.allowed_domains()", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.blocked_domains": {
        "descr": "Return the sequence of blocked domains (as a tuple).", 
        "name": "http.cookiejar.DefaultCookiePolicy.blocked_domains", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.blocked_domains", 
        "syntax": "DefaultCookiePolicy.blocked_domains()", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.is_blocked": {
        "descr": "Return whether domain is on the blacklist for setting or receiving cookies.", 
        "name": "http.cookiejar.DefaultCookiePolicy.is_blocked", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.is_blocked", 
        "syntax": "DefaultCookiePolicy.is_blocked(domain)", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.is_not_allowed": {
        "descr": "Return whether domain is not on the whitelist for setting or receiving cookies.", 
        "name": "http.cookiejar.DefaultCookiePolicy.is_not_allowed", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.is_not_allowed", 
        "syntax": "DefaultCookiePolicy.is_not_allowed(domain)", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape": {
        "descr": "If true, request that the CookieJar instance downgrade RFC 2109 cookies (ie. cookies received in a Set-Cookie header with a version cookie-attribute of 1) to Netscape cookies by setting the version attribute of the Cookie instance to 0. The default value is None, in which case RFC 2109 cookies are downgraded if and only if RFC 2965 handling is turned off. Therefore, RFC 2109 cookies are downgraded by default.", 
        "name": "http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape", 
        "syntax": "DefaultCookiePolicy.rfc2109_as_netscape", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.set_allowed_domains": {
        "descr": "Set the sequence of allowed domains, or None.", 
        "name": "http.cookiejar.DefaultCookiePolicy.set_allowed_domains", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.set_allowed_domains", 
        "syntax": "DefaultCookiePolicy.set_allowed_domains(allowed_domains)", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.set_blocked_domains": {
        "descr": "Set the sequence of blocked domains.", 
        "name": "http.cookiejar.DefaultCookiePolicy.set_blocked_domains", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.set_blocked_domains", 
        "syntax": "DefaultCookiePolicy.set_blocked_domains(blocked_domains)", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.strict_domain": {
        "descr": "Don\u2019t allow sites to set two-component domains with country-code top-level domains like .co.uk, .gov.uk, .co.nz.etc. This is far from perfect and isn\u2019t guaranteed to work!", 
        "name": "http.cookiejar.DefaultCookiePolicy.strict_domain", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_domain", 
        "syntax": "DefaultCookiePolicy.strict_domain", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.strict_ns_domain": {
        "descr": "Flags indicating how strict to be with domain-matching rules for Netscape cookies. See below for acceptable values.", 
        "name": "http.cookiejar.DefaultCookiePolicy.strict_ns_domain", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_domain", 
        "syntax": "DefaultCookiePolicy.strict_ns_domain", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar": {
        "descr": "Ignore cookies in Set-Cookie: headers that have names starting with '$'.", 
        "name": "http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar", 
        "syntax": "DefaultCookiePolicy.strict_ns_set_initial_dollar", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.strict_ns_set_path": {
        "descr": "Don\u2019t allow setting cookies whose path doesn\u2019t path-match request URI.", 
        "name": "http.cookiejar.DefaultCookiePolicy.strict_ns_set_path", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_set_path", 
        "syntax": "DefaultCookiePolicy.strict_ns_set_path", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable": {
        "descr": "apply RFC 2965 rules on unverifiable transactions even to Netscape cookies", 
        "name": "http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable", 
        "syntax": "DefaultCookiePolicy.strict_ns_unverifiable", 
        "type": "Internet"
    }, 
    "http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable": {
        "descr": "Follow RFC 2965 rules on unverifiable transactions (usually, an unverifiable transaction is one resulting from a redirect or a request for an image hosted on another site). If this is false, cookies are never blocked on the basis of verifiability", 
        "name": "http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable", 
        "syntax": "DefaultCookiePolicy.strict_rfc2965_unverifiable", 
        "type": "Internet"
    }, 
    "http.cookiejar.FileCookieJar": {
        "descr": "policy is an object implementing the CookiePolicy interface. For the other arguments, see the documentation for the corresponding attributes.", 
        "name": "http.cookiejar.FileCookieJar", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.FileCookieJar", 
        "syntax": "class http.cookiejar.FileCookieJar(filename, delayload=None, policy=None)", 
        "type": "Internet"
    }, 
    "http.cookiejar.FileCookieJar.delayload": {
        "descr": "If true, load cookies lazily from disk. This attribute should not be assigned to. This is only a hint, since this only affects performance, not behaviour (unless the cookies on disk are changing). A CookieJar object may ignore it. None of the FileCookieJar classes included in the standard library lazily loads cookies.", 
        "name": "http.cookiejar.FileCookieJar.delayload", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.FileCookieJar.delayload", 
        "syntax": "FileCookieJar.delayload", 
        "type": "Internet"
    }, 
    "http.cookiejar.FileCookieJar.filename": {
        "descr": "Filename of default file in which to keep cookies. This attribute may be assigned to.", 
        "name": "http.cookiejar.FileCookieJar.filename", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.FileCookieJar.filename", 
        "syntax": "FileCookieJar.filename", 
        "type": "Internet"
    }, 
    "http.cookiejar.FileCookieJar.load": {
        "descr": "Load cookies from a file.", 
        "name": "http.cookiejar.FileCookieJar.load", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.FileCookieJar.load", 
        "syntax": "FileCookieJar.load(filename=None, ignore_discard=False, ignore_expires=False)", 
        "type": "Internet"
    }, 
    "http.cookiejar.FileCookieJar.revert": {
        "descr": "Clear all cookies and reload cookies from a saved file.", 
        "name": "http.cookiejar.FileCookieJar.revert", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.FileCookieJar.revert", 
        "syntax": "FileCookieJar.revert(filename=None, ignore_discard=False, ignore_expires=False)", 
        "type": "Internet"
    }, 
    "http.cookiejar.FileCookieJar.save": {
        "descr": "Save cookies to a file.", 
        "name": "http.cookiejar.FileCookieJar.save", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.FileCookieJar.save", 
        "syntax": "FileCookieJar.save(filename=None, ignore_discard=False, ignore_expires=False)", 
        "type": "Internet"
    }, 
    "http.cookiejar.LWPCookieJar": {
        "descr": "A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library\u2019s Set-Cookie3 file format. This is convenient if you want to store cookies in a human-readable file.", 
        "name": "http.cookiejar.LWPCookieJar", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.LWPCookieJar", 
        "syntax": "class http.cookiejar.LWPCookieJar(filename, delayload=None, policy=None)", 
        "type": "Internet"
    }, 
    "http.cookiejar.LoadError": {
        "descr": "Instances of FileCookieJar raise this exception on failure to load cookies from a file. LoadError is a subclass of OSError.", 
        "name": "http.cookiejar.LoadError", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.LoadError", 
        "syntax": "exception http.cookiejar.LoadError", 
        "type": "Internet"
    }, 
    "http.cookiejar.MozillaCookieJar": {
        "descr": "A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format (which is also used by the Lynx and Netscape browsers).", 
        "name": "http.cookiejar.MozillaCookieJar", 
        "params": [], 
        "path": "python/library/http.cookiejar#http.cookiejar.MozillaCookieJar", 
        "syntax": "class http.cookiejar.MozillaCookieJar(filename, delayload=None, policy=None)", 
        "type": "Internet"
    }, 
    "http.cookies.BaseCookie": {
        "descr": "This class is a dictionary-like object whose keys are strings and whose values are Morsel instances. Note that upon setting a key to a value, the value is first converted to a Morsel containing the key and the value.", 
        "name": "http.cookies.BaseCookie", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.BaseCookie", 
        "syntax": "class http.cookies.BaseCookie([input])", 
        "type": "Internet"
    }, 
    "http.cookies.BaseCookie.js_output": {
        "descr": "Return an embeddable JavaScript snippet, which, if run on a browser which supports JavaScript, will act the same as if the HTTP headers was sent.", 
        "name": "http.cookies.BaseCookie.js_output", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.BaseCookie.js_output", 
        "syntax": "BaseCookie.js_output(attrs=None)", 
        "type": "Internet"
    }, 
    "http.cookies.BaseCookie.load": {
        "descr": "If rawdata is a string, parse it as an HTTP_COOKIE and add the values found there as Morsels. If it is a dictionary, it is equivalent to:", 
        "name": "http.cookies.BaseCookie.load", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.BaseCookie.load", 
        "syntax": "BaseCookie.load(rawdata)", 
        "type": "Internet"
    }, 
    "http.cookies.BaseCookie.output": {
        "descr": "Return a string representation suitable to be sent as HTTP headers. attrs and header are sent to each Morsel\u2018s output() method. sep is used to join the headers together, and is by default the combination '\\r\\n' (CRLF).", 
        "name": "http.cookies.BaseCookie.output", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.BaseCookie.output", 
        "syntax": "BaseCookie.output(attrs=None, header='Set-Cookie:', sep='\\r\\n')", 
        "type": "Internet"
    }, 
    "http.cookies.BaseCookie.value_decode": {
        "descr": "Return a decoded value from a string representation. Return value can be any type. This method does nothing in BaseCookie \u2014 it exists so it can be overridden.", 
        "name": "http.cookies.BaseCookie.value_decode", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.BaseCookie.value_decode", 
        "syntax": "BaseCookie.value_decode(val)", 
        "type": "Internet"
    }, 
    "http.cookies.BaseCookie.value_encode": {
        "descr": "Return an encoded value. val can be any type, but return value must be a string. This method does nothing in BaseCookie \u2014 it exists so it can be overridden", 
        "name": "http.cookies.BaseCookie.value_encode", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.BaseCookie.value_encode", 
        "syntax": "BaseCookie.value_encode(val)", 
        "type": "Internet"
    }, 
    "http.cookies.CookieError": {
        "descr": "Exception failing because of RFC 2109 invalidity: incorrect attributes, incorrect Set-Cookie header, etc.", 
        "name": "http.cookies.CookieError", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.CookieError", 
        "syntax": "exception http.cookies.CookieError", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel": {
        "descr": "Abstract a key/value pair, which has some RFC 2109 attributes.", 
        "name": "http.cookies.Morsel", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel", 
        "syntax": "class http.cookies.Morsel", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.OutputString": {
        "descr": "Return a string representing the Morsel, without any surrounding HTTP or JavaScript.", 
        "name": "http.cookies.Morsel.OutputString", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.OutputString", 
        "syntax": "Morsel.OutputString(attrs=None)", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.coded_value": {
        "descr": "The encoded value of the cookie \u2014 this is what should be sent.", 
        "name": "http.cookies.Morsel.coded_value", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.coded_value", 
        "syntax": "Morsel.coded_value", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.isReservedKey": {
        "descr": "Whether K is a member of the set of keys of a Morsel.", 
        "name": "http.cookies.Morsel.isReservedKey", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.isReservedKey", 
        "syntax": "Morsel.isReservedKey(K)", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.js_output": {
        "descr": "Return an embeddable JavaScript snippet, which, if run on a browser which supports JavaScript, will act the same as if the HTTP header was sent.", 
        "name": "http.cookies.Morsel.js_output", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.js_output", 
        "syntax": "Morsel.js_output(attrs=None)", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.key": {
        "descr": "The name of the cookie.", 
        "name": "http.cookies.Morsel.key", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.key", 
        "syntax": "Morsel.key", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.output": {
        "descr": "Return a string representation of the Morsel, suitable to be sent as an HTTP header. By default, all the attributes are included, unless attrs is given, in which case it should be a list of attributes to use. header is by default \"Set-Cookie:\".", 
        "name": "http.cookies.Morsel.output", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.output", 
        "syntax": "Morsel.output(attrs=None, header='Set-Cookie:')", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.set": {
        "descr": "Set the key, value and coded_value attributes.", 
        "name": "http.cookies.Morsel.set", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.set", 
        "syntax": "Morsel.set(key, value, coded_value)", 
        "type": "Internet"
    }, 
    "http.cookies.Morsel.value": {
        "descr": "The value of the cookie.", 
        "name": "http.cookies.Morsel.value", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.Morsel.value", 
        "syntax": "Morsel.value", 
        "type": "Internet"
    }, 
    "http.cookies.SimpleCookie": {
        "descr": "This class derives from BaseCookie and overrides value_decode() and value_encode() to be the identity and str() respectively.", 
        "name": "http.cookies.SimpleCookie", 
        "params": [], 
        "path": "python/library/http.cookies#http.cookies.SimpleCookie", 
        "syntax": "class http.cookies.SimpleCookie([input])", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler": {
        "descr": "This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; it must be subclassed to handle each request method (e.g. GET or POST). BaseHTTPRequestHandler provides a number of class and instance variables, and methods for use by subclasses.", 
        "name": "http.server.BaseHTTPRequestHandler", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler", 
        "syntax": "class http.server.BaseHTTPRequestHandler(request, client_address, server)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.MessageClass": {
        "descr": "Specifies an email.message.Message-like class to parse HTTP headers. Typically, this is not overridden, and it defaults to http.client.HTTPMessage.", 
        "name": "http.server.BaseHTTPRequestHandler.MessageClass", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.MessageClass", 
        "syntax": "MessageClass", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.address_string": {
        "descr": "Returns the client address.", 
        "name": "http.server.BaseHTTPRequestHandler.address_string", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.address_string", 
        "syntax": "address_string()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.client_address": {
        "descr": "Contains a tuple of the form (host, port) referring to the client\u2019s address.", 
        "name": "http.server.BaseHTTPRequestHandler.client_address", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.client_address", 
        "syntax": "client_address", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.command": {
        "descr": "Contains the command (request type). For example, 'GET'.", 
        "name": "http.server.BaseHTTPRequestHandler.command", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.command", 
        "syntax": "command", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.date_time_string": {
        "descr": "Returns the date and time given by timestamp (which must be None or in the format returned by time.time()), formatted for a message header. If timestamp is omitted, it uses the current date and time.", 
        "name": "http.server.BaseHTTPRequestHandler.date_time_string", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.date_time_string", 
        "syntax": "date_time_string(timestamp=None)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.end_headers": {
        "descr": "Adds a blank line (indicating the end of the HTTP headers in the response) to the headers buffer and calls flush_headers().", 
        "name": "http.server.BaseHTTPRequestHandler.end_headers", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.end_headers", 
        "syntax": "end_headers()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.error_content_type": {
        "descr": "Specifies the Content-Type HTTP header of error responses sent to the client. The default value is 'text/html'.", 
        "name": "http.server.BaseHTTPRequestHandler.error_content_type", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.error_content_type", 
        "syntax": "error_content_type", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.error_message_format": {
        "descr": "Specifies a format string for building an error response to the client. It uses parenthesized, keyed format specifiers, so the format operand must be a dictionary. The code key should be an integer, specifying the numeric HTTP error code value. message should be a string containing a (detailed) error message of what occurred, and explain should be an explanation of the error code number. Default message and explain values can found in the responses class variable.", 
        "name": "http.server.BaseHTTPRequestHandler.error_message_format", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.error_message_format", 
        "syntax": "error_message_format", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.flush_headers": {
        "descr": "Finally send the headers to the output stream and flush the internal headers buffer.", 
        "name": "http.server.BaseHTTPRequestHandler.flush_headers", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.flush_headers", 
        "syntax": "flush_headers()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.handle": {
        "descr": "Calls handle_one_request() once (or, if persistent connections are enabled, multiple times) to handle incoming HTTP requests. You should never need to override it; instead, implement appropriate do_*() methods.", 
        "name": "http.server.BaseHTTPRequestHandler.handle", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.handle", 
        "syntax": "handle()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.handle_expect_100": {
        "descr": "When a HTTP/1.1 compliant server receives a Expect: 100-continue request header it responds back with a 100 Continue followed by 200 OK headers. This method can be overridden to raise an error if the server does not want the client to continue. For e.g. server can chose to send 417 Expectation Failed as a response header and return False.", 
        "name": "http.server.BaseHTTPRequestHandler.handle_expect_100", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.handle_expect_100", 
        "syntax": "handle_expect_100()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.handle_one_request": {
        "descr": "This method will parse and dispatch the request to the appropriate do_*() method. You should never need to override it.", 
        "name": "http.server.BaseHTTPRequestHandler.handle_one_request", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.handle_one_request", 
        "syntax": "handle_one_request()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.headers": {
        "descr": "Holds an instance of the class specified by the MessageClass class variable. This instance parses and manages the headers in the HTTP request.", 
        "name": "http.server.BaseHTTPRequestHandler.headers", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.headers", 
        "syntax": "headers", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.log_date_time_string": {
        "descr": "Returns the current date and time, formatted for logging.", 
        "name": "http.server.BaseHTTPRequestHandler.log_date_time_string", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.log_date_time_string", 
        "syntax": "log_date_time_string()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.log_error": {
        "descr": "Logs an error when a request cannot be fulfilled. By default, it passes the message to log_message(), so it takes the same arguments (format and additional values).", 
        "name": "http.server.BaseHTTPRequestHandler.log_error", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.log_error", 
        "syntax": "log_error(...)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.log_message": {
        "descr": "Logs an arbitrary message to sys.stderr. This is typically overridden to create custom error logging mechanisms. The format argument is a standard printf-style format string, where the additional arguments to log_message() are applied as inputs to the formatting. The client ip address and current date and time are prefixed to every message logged.", 
        "name": "http.server.BaseHTTPRequestHandler.log_message", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.log_message", 
        "syntax": "log_message(format, ...)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.log_request": {
        "descr": "Logs an accepted (successful) request. code should specify the numeric HTTP code associated with the response. If a size of the response is available, then it should be passed as the size parameter.", 
        "name": "http.server.BaseHTTPRequestHandler.log_request", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.log_request", 
        "syntax": "log_request(code='-', size='-')", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.path": {
        "descr": "Contains the request path.", 
        "name": "http.server.BaseHTTPRequestHandler.path", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.path", 
        "syntax": "path", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.protocol_version": {
        "descr": "This specifies the HTTP protocol version used in responses. If set to 'HTTP/1.1', the server will permit HTTP persistent connections; however, your server must then include an accurate Content-Length header (using send_header()) in all of its responses to clients. For backwards compatibility, the setting defaults to 'HTTP/1.0'.", 
        "name": "http.server.BaseHTTPRequestHandler.protocol_version", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.protocol_version", 
        "syntax": "protocol_version", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.request_version": {
        "descr": "Contains the version string from the request. For example, 'HTTP/1.0'.", 
        "name": "http.server.BaseHTTPRequestHandler.request_version", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.request_version", 
        "syntax": "request_version", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.responses": {
        "descr": "This variable contains a mapping of error code integers to two-element tuples containing a short and long message. For example, {code: (shortmessage, longmessage)}. The shortmessage is usually used as the message key in an error response, and longmessage as the explain key (see the error_message_format class variable).", 
        "name": "http.server.BaseHTTPRequestHandler.responses", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.responses", 
        "syntax": "responses", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.rfile": {
        "descr": "Contains an input stream, positioned at the start of the optional input data.", 
        "name": "http.server.BaseHTTPRequestHandler.rfile", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.rfile", 
        "syntax": "rfile", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.send_error": {
        "descr": "Sends and logs a complete error reply to the client. The numeric code specifies the HTTP error code, with message as optional, more specific text. A complete set of headers is sent, followed by text composed using the error_message_format class variable.", 
        "name": "http.server.BaseHTTPRequestHandler.send_error", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.send_error", 
        "syntax": "send_error(code, message=None)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.send_header": {
        "descr": "Adds the HTTP header to an internal buffer which will be written to the output stream when either end_headers() or flush_headers() is invoked. keyword should specify the header keyword, with value specifying its value. Note that, after the send_header calls are done, end_headers() MUST BE called in order to complete the operation.", 
        "name": "http.server.BaseHTTPRequestHandler.send_header", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.send_header", 
        "syntax": "send_header(keyword, value)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.send_response": {
        "descr": "Adds a response header to the headers buffer and logs the accepted request. The HTTP response line is written to the internal buffer, followed by Server and Date headers. The values for these two headers are picked up from the version_string() and date_time_string() methods, respectively. If the server does not intend to send any other headers using the send_header() method, then send_response() should be followed by a end_headers() call.", 
        "name": "http.server.BaseHTTPRequestHandler.send_response", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.send_response", 
        "syntax": "send_response(code, message=None)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.send_response_only": {
        "descr": "Sends the reponse header only, used for the purposes when 100 Continue response is sent by the server to the client. The headers not buffered and sent directly the output stream.If the message is not specified, the HTTP message corresponding the response code is sent.", 
        "name": "http.server.BaseHTTPRequestHandler.send_response_only", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.send_response_only", 
        "syntax": "send_response_only(code, message=None)", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.server": {
        "descr": "Contains the server instance.", 
        "name": "http.server.BaseHTTPRequestHandler.server", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.server", 
        "syntax": "server", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.server_version": {
        "descr": "Specifies the server software version. You may want to override this. The format is multiple whitespace-separated strings, where each string is of the form name[/version]. For example, 'BaseHTTP/0.2'.", 
        "name": "http.server.BaseHTTPRequestHandler.server_version", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.server_version", 
        "syntax": "server_version", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.sys_version": {
        "descr": "Contains the Python system version, in a form usable by the version_string method and the server_version class variable. For example, 'Python/1.4'.", 
        "name": "http.server.BaseHTTPRequestHandler.sys_version", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.sys_version", 
        "syntax": "sys_version", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.version_string": {
        "descr": "Returns the server software\u2019s version string. This is a combination of the server_version and sys_version class variables.", 
        "name": "http.server.BaseHTTPRequestHandler.version_string", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.version_string", 
        "syntax": "version_string()", 
        "type": "Internet"
    }, 
    "http.server.BaseHTTPRequestHandler.wfile": {
        "descr": "Contains the output stream for writing a response back to the client. Proper adherence to the HTTP protocol must be used when writing to this stream.", 
        "name": "http.server.BaseHTTPRequestHandler.wfile", 
        "params": [], 
        "path": "python/library/http.server#http.server.BaseHTTPRequestHandler.wfile", 
        "syntax": "wfile", 
        "type": "Internet"
    }, 
    "http.server.CGIHTTPRequestHandler": {
        "descr": "This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler.", 
        "name": "http.server.CGIHTTPRequestHandler", 
        "params": [], 
        "path": "python/library/http.server#http.server.CGIHTTPRequestHandler", 
        "syntax": "class http.server.CGIHTTPRequestHandler(request, client_address, server)", 
        "type": "Internet"
    }, 
    "http.server.CGIHTTPRequestHandler.cgi_directories": {
        "descr": "This defaults to ['/cgi-bin', '/htbin'] and describes directories to treat as containing CGI scripts.", 
        "name": "http.server.CGIHTTPRequestHandler.cgi_directories", 
        "params": [], 
        "path": "python/library/http.server#http.server.CGIHTTPRequestHandler.cgi_directories", 
        "syntax": "cgi_directories", 
        "type": "Internet"
    }, 
    "http.server.CGIHTTPRequestHandler.do_POST": {
        "descr": "This method serves the 'POST' request type, only allowed for CGI scripts. Error 501, \u201cCan only POST to CGI scripts\u201d, is output when trying to POST to a non-CGI url.", 
        "name": "http.server.CGIHTTPRequestHandler.do_POST", 
        "params": [], 
        "path": "python/library/http.server#http.server.CGIHTTPRequestHandler.do_POST", 
        "syntax": "do_POST()", 
        "type": "Internet"
    }, 
    "http.server.HTTPServer": {
        "descr": "This class builds on the TCPServer class by storing the server address as instance variables named server_name and server_port. The server is accessible by the handler, typically through the handler\u2019s server instance variable.", 
        "name": "http.server.HTTPServer", 
        "params": [], 
        "path": "python/library/http.server#http.server.HTTPServer", 
        "syntax": "class http.server.HTTPServer(server_address, RequestHandlerClass)", 
        "type": "Internet"
    }, 
    "http.server.SimpleHTTPRequestHandler": {
        "descr": "This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests.", 
        "name": "http.server.SimpleHTTPRequestHandler", 
        "params": [], 
        "path": "python/library/http.server#http.server.SimpleHTTPRequestHandler", 
        "syntax": "class http.server.SimpleHTTPRequestHandler(request, client_address, server)", 
        "type": "Internet"
    }, 
    "http.server.SimpleHTTPRequestHandler.do_GET": {
        "descr": "The request is mapped to a local file by interpreting the request as a path relative to the current working directory.", 
        "name": "http.server.SimpleHTTPRequestHandler.do_GET", 
        "params": [], 
        "path": "python/library/http.server#http.server.SimpleHTTPRequestHandler.do_GET", 
        "syntax": "do_GET()", 
        "type": "Internet"
    }, 
    "http.server.SimpleHTTPRequestHandler.do_HEAD": {
        "descr": "This method serves the 'HEAD' request type: it sends the headers it would send for the equivalent GET request. See the do_GET() method for a more complete explanation of the possible headers.", 
        "name": "http.server.SimpleHTTPRequestHandler.do_HEAD", 
        "params": [], 
        "path": "python/library/http.server#http.server.SimpleHTTPRequestHandler.do_HEAD", 
        "syntax": "do_HEAD()", 
        "type": "Internet"
    }, 
    "http.server.SimpleHTTPRequestHandler.extensions_map": {
        "descr": "A dictionary mapping suffixes into MIME types. The default is signified by an empty string, and is considered to be application/octet-stream. The mapping is used case-insensitively, and so should contain only lower-cased keys.", 
        "name": "http.server.SimpleHTTPRequestHandler.extensions_map", 
        "params": [], 
        "path": "python/library/http.server#http.server.SimpleHTTPRequestHandler.extensions_map", 
        "syntax": "extensions_map", 
        "type": "Internet"
    }, 
    "http.server.SimpleHTTPRequestHandler.server_version": {
        "descr": "This will be \"SimpleHTTP/\" + __version__, where __version__ is defined at the module level.", 
        "name": "http.server.SimpleHTTPRequestHandler.server_version", 
        "params": [], 
        "path": "python/library/http.server#http.server.SimpleHTTPRequestHandler.server_version", 
        "syntax": "server_version", 
        "type": "Internet"
    }, 
    "id": {
        "descr": "Return the \u201cidentity\u201d of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.", 
        "name": "id", 
        "params": [], 
        "path": "python/library/functions#id", 
        "syntax": "id(object)", 
        "type": "Built-in Functions"
    }, 
    "imaplib.IMAP4": {
        "descr": "This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If host is not specified, '' (the local host) is used. If port is omitted, the standard IMAP4 port (143) is used.", 
        "name": "imaplib.IMAP4", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4", 
        "syntax": "class imaplib.IMAP4(host='', port=IMAP4_PORT)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.PROTOCOL_VERSION": {
        "descr": "The most recent supported protocol in the CAPABILITY response from the server.", 
        "name": "imaplib.IMAP4.PROTOCOL_VERSION", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.PROTOCOL_VERSION", 
        "syntax": "IMAP4.PROTOCOL_VERSION", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.abort": {
        "descr": "IMAP4 server errors cause this exception to be raised. This is a sub-class of IMAP4.error. Note that closing the instance and instantiating a new one will usually allow recovery from this exception.", 
        "name": "imaplib.IMAP4.abort", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.abort", 
        "syntax": "exception IMAP4.abort", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.append": {
        "descr": "Append message to named mailbox.", 
        "name": "imaplib.IMAP4.append", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.append", 
        "syntax": "IMAP4.append(mailbox, flags, date_time, message)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.authenticate": {
        "descr": "Authenticate command \u2014 requires response processing.", 
        "name": "imaplib.IMAP4.authenticate", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.authenticate", 
        "syntax": "IMAP4.authenticate(mechanism, authobject)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.check": {
        "descr": "Checkpoint mailbox on server.", 
        "name": "imaplib.IMAP4.check", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.check", 
        "syntax": "IMAP4.check()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.close": {
        "descr": "Close currently selected mailbox. Deleted messages are removed from writable mailbox. This is the recommended command before LOGOUT.", 
        "name": "imaplib.IMAP4.close", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.close", 
        "syntax": "IMAP4.close()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.copy": {
        "descr": "Copy message_set messages onto end of new_mailbox.", 
        "name": "imaplib.IMAP4.copy", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.copy", 
        "syntax": "IMAP4.copy(message_set, new_mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.create": {
        "descr": "Create new mailbox named mailbox.", 
        "name": "imaplib.IMAP4.create", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.create", 
        "syntax": "IMAP4.create(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.debug": {
        "descr": "Integer value to control debugging output. The initialize value is taken from the module variable Debug. Values greater than three trace each command.", 
        "name": "imaplib.IMAP4.debug", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.debug", 
        "syntax": "IMAP4.debug", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.delete": {
        "descr": "Delete old mailbox named mailbox.", 
        "name": "imaplib.IMAP4.delete", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.delete", 
        "syntax": "IMAP4.delete(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.deleteacl": {
        "descr": "Delete the ACLs (remove any rights) set for who on mailbox.", 
        "name": "imaplib.IMAP4.deleteacl", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.deleteacl", 
        "syntax": "IMAP4.deleteacl(mailbox, who)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.error": {
        "descr": "Exception raised on any errors. The reason for the exception is passed to the constructor as a string.", 
        "name": "imaplib.IMAP4.error", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.error", 
        "syntax": "exception IMAP4.error", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.expunge": {
        "descr": "Permanently remove deleted items from selected mailbox. Generates an EXPUNGE response for each deleted message. Returned data contains a list of EXPUNGE message numbers in order received.", 
        "name": "imaplib.IMAP4.expunge", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.expunge", 
        "syntax": "IMAP4.expunge()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.fetch": {
        "descr": "Fetch (parts of) messages. message_parts should be a string of message part names enclosed within parentheses, eg: \"(UID BODY[TEXT])\". Returned data are tuples of message part envelope and data.", 
        "name": "imaplib.IMAP4.fetch", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.fetch", 
        "syntax": "IMAP4.fetch(message_set, message_parts)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.getacl": {
        "descr": "Get the ACLs for mailbox. The method is non-standard, but is supported by the Cyrus server.", 
        "name": "imaplib.IMAP4.getacl", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.getacl", 
        "syntax": "IMAP4.getacl(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.getannotation": {
        "descr": "Retrieve the specified ANNOTATIONs for mailbox. The method is non-standard, but is supported by the Cyrus server.", 
        "name": "imaplib.IMAP4.getannotation", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.getannotation", 
        "syntax": "IMAP4.getannotation(mailbox, entry, attribute)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.getquota": {
        "descr": "Get the quota root\u2018s resource usage and limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.", 
        "name": "imaplib.IMAP4.getquota", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.getquota", 
        "syntax": "IMAP4.getquota(root)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.getquotaroot": {
        "descr": "Get the list of quota roots for the named mailbox. This method is part of the IMAP4 QUOTA extension defined in rfc2087.", 
        "name": "imaplib.IMAP4.getquotaroot", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.getquotaroot", 
        "syntax": "IMAP4.getquotaroot(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.list": {
        "descr": "List mailbox names in directory matching pattern. directory defaults to the top-level mail folder, and pattern defaults to match anything. Returned data contains a list of LIST responses.", 
        "name": "imaplib.IMAP4.list", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.list", 
        "syntax": "IMAP4.list([directory[, pattern]])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.login": {
        "descr": "Identify the client using a plaintext password. The password will be quoted.", 
        "name": "imaplib.IMAP4.login", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.login", 
        "syntax": "IMAP4.login(user, password)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.login_cram_md5": {
        "descr": "Force use of CRAM-MD5 authentication when identifying the client to protect the password. Will only work if the server CAPABILITY response includes the phrase AUTH=CRAM-MD5.", 
        "name": "imaplib.IMAP4.login_cram_md5", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.login_cram_md5", 
        "syntax": "IMAP4.login_cram_md5(user, password)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.logout": {
        "descr": "Shutdown connection to server. Returns server BYE response.", 
        "name": "imaplib.IMAP4.logout", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.logout", 
        "syntax": "IMAP4.logout()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.lsub": {
        "descr": "List subscribed mailbox names in directory matching pattern. directory defaults to the top level directory and pattern defaults to match any mailbox. Returned data are tuples of message part envelope and data.", 
        "name": "imaplib.IMAP4.lsub", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.lsub", 
        "syntax": "IMAP4.lsub(directory='\"\"', pattern='*')", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.myrights": {
        "descr": "Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).", 
        "name": "imaplib.IMAP4.myrights", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.myrights", 
        "syntax": "IMAP4.myrights(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.namespace": {
        "descr": "Returns IMAP namespaces as defined in RFC2342.", 
        "name": "imaplib.IMAP4.namespace", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.namespace", 
        "syntax": "IMAP4.namespace()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.noop": {
        "descr": "Send NOOP to server.", 
        "name": "imaplib.IMAP4.noop", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.noop", 
        "syntax": "IMAP4.noop()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.open": {
        "descr": "Opens socket to port at host. This method is implicitly called by the IMAP4 constructor. The connection objects established by this method will be used in the IMAP4.read(), IMAP4.readline(), IMAP4.send(), and IMAP4.shutdown() methods. You may override this method.", 
        "name": "imaplib.IMAP4.open", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.open", 
        "syntax": "IMAP4.open(host, port)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.partial": {
        "descr": "Fetch truncated part of a message. Returned data is a tuple of message part envelope and data.", 
        "name": "imaplib.IMAP4.partial", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.partial", 
        "syntax": "IMAP4.partial(message_num, message_part, start, length)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.proxyauth": {
        "descr": "Assume authentication as user. Allows an authorised administrator to proxy into any user\u2019s mailbox.", 
        "name": "imaplib.IMAP4.proxyauth", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.proxyauth", 
        "syntax": "IMAP4.proxyauth(user)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.read": {
        "descr": "Reads size bytes from the remote server. You may override this method.", 
        "name": "imaplib.IMAP4.read", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.read", 
        "syntax": "IMAP4.read(size)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.readline": {
        "descr": "Reads one line from the remote server. You may override this method.", 
        "name": "imaplib.IMAP4.readline", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.readline", 
        "syntax": "IMAP4.readline()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.readonly": {
        "descr": "This exception is raised when a writable mailbox has its status changed by the server. This is a sub-class of IMAP4.error. Some other client now has write permission, and the mailbox will need to be re-opened to re-obtain write permission.", 
        "name": "imaplib.IMAP4.readonly", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.readonly", 
        "syntax": "exception IMAP4.readonly", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.recent": {
        "descr": "Prompt server for an update. Returned data is None if no new messages, else value of RECENT response.", 
        "name": "imaplib.IMAP4.recent", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.recent", 
        "syntax": "IMAP4.recent()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.rename": {
        "descr": "Rename mailbox named oldmailbox to newmailbox.", 
        "name": "imaplib.IMAP4.rename", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.rename", 
        "syntax": "IMAP4.rename(oldmailbox, newmailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.response": {
        "descr": "Return data for response code if received, or None. Returns the given code, instead of the usual type.", 
        "name": "imaplib.IMAP4.response", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.response", 
        "syntax": "IMAP4.response(code)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.search": {
        "descr": "Search mailbox for matching messages. charset may be None, in which case no CHARSET will be specified in the request to the server. The IMAP protocol requires that at least one criterion be specified; an exception will be raised when the server returns an error.", 
        "name": "imaplib.IMAP4.search", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.search", 
        "syntax": "IMAP4.search(charset, criterion[, ...])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.select": {
        "descr": "Select a mailbox. Returned data is the count of messages in mailbox (EXISTS response). The default mailbox is 'INBOX'. If the readonly flag is set, modifications to the mailbox are not allowed.", 
        "name": "imaplib.IMAP4.select", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.select", 
        "syntax": "IMAP4.select(mailbox='INBOX', readonly=False)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.send": {
        "descr": "Sends data to the remote server. You may override this method.", 
        "name": "imaplib.IMAP4.send", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.send", 
        "syntax": "IMAP4.send(data)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.setacl": {
        "descr": "Set an ACL for mailbox. The method is non-standard, but is supported by the Cyrus server.", 
        "name": "imaplib.IMAP4.setacl", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.setacl", 
        "syntax": "IMAP4.setacl(mailbox, who, what)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.setannotation": {
        "descr": "Set ANNOTATIONs for mailbox. The method is non-standard, but is supported by the Cyrus server.", 
        "name": "imaplib.IMAP4.setannotation", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.setannotation", 
        "syntax": "IMAP4.setannotation(mailbox, entry, attribute[, ...])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.setquota": {
        "descr": "Set the quota root\u2018s resource limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.", 
        "name": "imaplib.IMAP4.setquota", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.setquota", 
        "syntax": "IMAP4.setquota(root, limits)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.shutdown": {
        "descr": "Close connection established in open. This method is implicitly called by IMAP4.logout(). You may override this method.", 
        "name": "imaplib.IMAP4.shutdown", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.shutdown", 
        "syntax": "IMAP4.shutdown()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.socket": {
        "descr": "Returns socket instance used to connect to server.", 
        "name": "imaplib.IMAP4.socket", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.socket", 
        "syntax": "IMAP4.socket()", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.sort": {
        "descr": "The sort command is a variant of search with sorting semantics for the results. Returned data contains a space separated list of matching message numbers.", 
        "name": "imaplib.IMAP4.sort", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.sort", 
        "syntax": "IMAP4.sort(sort_criteria, charset, search_criterion[, ...])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.starttls": {
        "descr": "Send a STARTTLS command. The ssl_context argument is optional and should be a ssl.SSLContext object. This will enable encryption on the IMAP connection.", 
        "name": "imaplib.IMAP4.starttls", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.starttls", 
        "syntax": "IMAP4.starttls(ssl_context=None)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.status": {
        "descr": "Request named status conditions for mailbox.", 
        "name": "imaplib.IMAP4.status", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.status", 
        "syntax": "IMAP4.status(mailbox, names)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.store": {
        "descr": "Alters flag dispositions for messages in mailbox. command is specified by section 6.4.6 of RFC 2060 as being one of \u201cFLAGS\u201d, \u201c+FLAGS\u201d, or \u201c-FLAGS\u201d, optionally with a suffix of \u201d.SILENT\u201d.", 
        "name": "imaplib.IMAP4.store", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.store", 
        "syntax": "IMAP4.store(message_set, command, flag_list)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.subscribe": {
        "descr": "Subscribe to new mailbox.", 
        "name": "imaplib.IMAP4.subscribe", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.subscribe", 
        "syntax": "IMAP4.subscribe(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.thread": {
        "descr": "The thread command is a variant of search with threading semantics for the results. Returned data contains a space separated list of thread members.", 
        "name": "imaplib.IMAP4.thread", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.thread", 
        "syntax": "IMAP4.thread(threading_algorithm, charset, search_criterion[, ...])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.uid": {
        "descr": "Execute command args with messages identified by UID, rather than message number. Returns response appropriate to command. At least one argument must be supplied; if none are provided, the server will return an error and an exception will be raised.", 
        "name": "imaplib.IMAP4.uid", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.uid", 
        "syntax": "IMAP4.uid(command, arg[, ...])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.unsubscribe": {
        "descr": "Unsubscribe from old mailbox.", 
        "name": "imaplib.IMAP4.unsubscribe", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.unsubscribe", 
        "syntax": "IMAP4.unsubscribe(mailbox)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4.xatom": {
        "descr": "Allow simple extension commands notified by server in CAPABILITY response.", 
        "name": "imaplib.IMAP4.xatom", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4.xatom", 
        "syntax": "IMAP4.xatom(name[, ...])", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4_SSL": {
        "descr": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket (to use this class you need a socket module that was compiled with SSL support). If host is not specified, '' (the local host) is used. If port is omitted, the standard IMAP4-over-SSL port (993) is used. keyfile and certfile are also optional - they can contain a PEM formatted private key and certificate chain file for the SSL connection. ssl_context parameter is a ssl.SSLContext object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. Note that the keyfile/certfile parameters are mutually exclusive with ssl_context, a ValueError is raised if keyfile/certfile is provided along with ssl_context.", 
        "name": "imaplib.IMAP4_SSL", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4_SSL", 
        "syntax": "class imaplib.IMAP4_SSL(host='', port=IMAP4_SSL_PORT, keyfile=None, certfile=None, ssl_context=None)", 
        "type": "Internet"
    }, 
    "imaplib.IMAP4_stream": {
        "descr": "This is a subclass derived from IMAP4 that connects to the stdin/stdout file descriptors created by passing command to subprocess.Popen().", 
        "name": "imaplib.IMAP4_stream", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.IMAP4_stream", 
        "syntax": "class imaplib.IMAP4_stream(command)", 
        "type": "Internet"
    }, 
    "imaplib.Int2AP": {
        "descr": "Converts an integer into a string representation using characters from the set [A .. P].", 
        "name": "imaplib.Int2AP", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.Int2AP", 
        "syntax": "imaplib.Int2AP(num)", 
        "type": "Internet"
    }, 
    "imaplib.Internaldate2tuple": {
        "descr": "Parse an IMAP4 INTERNALDATE string and return corresponding local time. The return value is a time.struct_time tuple or None if the string has wrong format.", 
        "name": "imaplib.Internaldate2tuple", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.Internaldate2tuple", 
        "syntax": "imaplib.Internaldate2tuple(datestr)", 
        "type": "Internet"
    }, 
    "imaplib.ParseFlags": {
        "descr": "Converts an IMAP4 FLAGS response to a tuple of individual flags.", 
        "name": "imaplib.ParseFlags", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.ParseFlags", 
        "syntax": "imaplib.ParseFlags(flagstr)", 
        "type": "Internet"
    }, 
    "imaplib.Time2Internaldate": {
        "descr": "Convert date_time to an IMAP4 INTERNALDATE representation. The return value is a string in the form: \"DD-Mmm-YYYY HH:MM:SS +HHMM\" (including double-quotes). The date_time argument can be a number (int or float) representing seconds since epoch (as returned by time.time()), a 9-tuple representing local time an instance of time.struct_time (as returned by time.localtime()), an aware instance of datetime.datetime, or a double-quoted string. In the last case, it is assumed to already be in the correct format.", 
        "name": "imaplib.Time2Internaldate", 
        "params": [], 
        "path": "python/library/imaplib#imaplib.Time2Internaldate", 
        "syntax": "imaplib.Time2Internaldate(date_time)", 
        "type": "Internet"
    }, 
    "imghdr.tests": {
        "descr": "A list of functions performing the individual tests. Each function takes two arguments: the byte-stream and an open file-like object. When what() is called with a byte-stream, the file-like object will be None.", 
        "name": "imghdr.tests", 
        "params": [], 
        "path": "python/library/imghdr#imghdr.tests", 
        "syntax": "imghdr.tests", 
        "type": "Multimedia"
    }, 
    "imghdr.what": {
        "descr": "Tests the image data contained in the file named by filename, and returns a string describing the image type. If optional h is provided, the filename is ignored and h is assumed to contain the byte stream to test.", 
        "name": "imghdr.what", 
        "params": [], 
        "path": "python/library/imghdr#imghdr.what", 
        "syntax": "imghdr.what(filename, h=None)", 
        "type": "Multimedia"
    }, 
    "imp.NullImporter": {
        "descr": "The NullImporter type is a PEP 302 import hook that handles non-directory path strings by failing to find any modules. Calling this type with an existing directory or empty string raises ImportError. Otherwise, a NullImporter instance is returned.", 
        "name": "imp.NullImporter", 
        "params": [], 
        "path": "python/library/imp#imp.NullImporter", 
        "syntax": "class imp.NullImporter(path_string)", 
        "type": "Importing"
    }, 
    "imp.NullImporter.find_module": {
        "descr": "This method always returns None, indicating that the requested module could not be found.", 
        "name": "imp.NullImporter.find_module", 
        "params": [], 
        "path": "python/library/imp#imp.NullImporter.find_module", 
        "syntax": "find_module(fullname[, path])", 
        "type": "Importing"
    }, 
    "imp.acquire_lock": {
        "descr": "Acquire the interpreter\u2019s global import lock for the current thread. This lock should be used by import hooks to ensure thread-safety when importing modules.", 
        "name": "imp.acquire_lock", 
        "params": [], 
        "path": "python/library/imp#imp.acquire_lock", 
        "syntax": "imp.acquire_lock()", 
        "type": "Importing"
    }, 
    "imp.cache_from_source": {
        "descr": "Return the PEP 3147 path to the byte-compiled file associated with the source path. For example, if path is /foo/bar/baz.py the return value would be /foo/bar/__pycache__/baz.cpython-32.pyc for Python 3.2. The cpython-32 string comes from the current magic tag (see get_tag(); if sys.implementation.cache_tag is not defined then NotImplementedError will be raised). The returned path will end in .pyc when __debug__ is True or .pyo for an optimized Python (i.e. __debug__ is False). By passing in True or False for debug_override you can override the system\u2019s value for __debug__ for extension selection.", 
        "name": "imp.cache_from_source", 
        "params": [], 
        "path": "python/library/imp#imp.cache_from_source", 
        "syntax": "imp.cache_from_source(path, debug_override=None)", 
        "type": "Importing"
    }, 
    "imp.find_module": {
        "descr": "Try to find the module name. If path is omitted or None, the list of directory names given by sys.path is searched, but first a few special places are searched: the function tries to find a built-in module with the given name (C_BUILTIN), then a frozen module (PY_FROZEN), and on some systems some other places are looked in as well (on Windows, it looks in the registry which may point to a specific file).", 
        "name": "imp.find_module", 
        "params": [], 
        "path": "python/library/imp#imp.find_module", 
        "syntax": "imp.find_module(name[, path])", 
        "type": "Importing"
    }, 
    "imp.get_magic": {
        "descr": "", 
        "name": "imp.get_magic", 
        "params": [], 
        "path": "python/library/imp#imp.get_magic", 
        "syntax": "imp.get_magic()", 
        "type": "Importing"
    }, 
    "imp.get_suffixes": {
        "descr": "Return a list of 3-element tuples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.", 
        "name": "imp.get_suffixes", 
        "params": [], 
        "path": "python/library/imp#imp.get_suffixes", 
        "syntax": "imp.get_suffixes()", 
        "type": "Importing"
    }, 
    "imp.get_tag": {
        "descr": "Return the PEP 3147 magic tag string matching this version of Python\u2019s magic number, as returned by get_magic().", 
        "name": "imp.get_tag", 
        "params": [], 
        "path": "python/library/imp#imp.get_tag", 
        "syntax": "imp.get_tag()", 
        "type": "Importing"
    }, 
    "imp.load_module": {
        "descr": "Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it will reload the module! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and pathname is the corresponding file name; these can be None and '', respectively, when the module is a package or not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded.", 
        "name": "imp.load_module", 
        "params": [], 
        "path": "python/library/imp#imp.load_module", 
        "syntax": "imp.load_module(name, file, pathname, description)", 
        "type": "Importing"
    }, 
    "imp.lock_held": {
        "descr": "Return True if the global import lock is currently held, else False. On platforms without threads, always return False.", 
        "name": "imp.lock_held", 
        "params": [], 
        "path": "python/library/imp#imp.lock_held", 
        "syntax": "imp.lock_held()", 
        "type": "Importing"
    }, 
    "imp.new_module": {
        "descr": "Return a new empty module object called name. This object is not inserted in sys.modules.", 
        "name": "imp.new_module", 
        "params": [], 
        "path": "python/library/imp#imp.new_module", 
        "syntax": "imp.new_module(name)", 
        "type": "Importing"
    }, 
    "imp.release_lock": {
        "descr": "Release the interpreter\u2019s global import lock. On platforms without threads, this function does nothing.", 
        "name": "imp.release_lock", 
        "params": [], 
        "path": "python/library/imp#imp.release_lock", 
        "syntax": "imp.release_lock()", 
        "type": "Importing"
    }, 
    "imp.reload": {
        "descr": "Reload a previously imported module. The argument must be a module object, so it must have been successfully imported before. This is useful if you have edited the module source file using an external editor and want to try out the new version without leaving the Python interpreter. The return value is the module object (the same as the module argument).", 
        "name": "imp.reload", 
        "params": [], 
        "path": "python/library/imp#imp.reload", 
        "syntax": "imp.reload(module)", 
        "type": "Importing"
    }, 
    "imp.source_from_cache": {
        "descr": "Given the path to a PEP 3147 file name, return the associated source code file path. For example, if path is /foo/bar/__pycache__/baz.cpython-32.pyc the returned path would be /foo/bar/baz.py. path need not exist, however if it does not conform to PEP 3147 format, a ValueError is raised. If sys.implementation.cache_tag is not defined, NotImplementedError is raised.", 
        "name": "imp.source_from_cache", 
        "params": [], 
        "path": "python/library/imp#imp.source_from_cache", 
        "syntax": "imp.source_from_cache(path)", 
        "type": "Importing"
    }, 
    "importlib.__import__": {
        "descr": "An implementation of the built-in __import__() function.", 
        "name": "importlib.__import__", 
        "params": [], 
        "path": "python/library/importlib#importlib.__import__", 
        "syntax": "importlib.__import__(name, globals=None, locals=None, fromlist=(), level=0)", 
        "type": "Importing"
    }, 
    "importlib.abc.ExecutionLoader": {
        "descr": "An abstract base class which inherits from InspectLoader that, when implemented, helps a module to be executed as a script. The ABC represents an optional PEP 302 protocol.", 
        "name": "importlib.abc.ExecutionLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.ExecutionLoader", 
        "syntax": "class importlib.abc.ExecutionLoader", 
        "type": "Importing"
    }, 
    "importlib.abc.ExecutionLoader.get_filename": {
        "descr": "An abstract method that is to return the value of __file__ for the specified module. If no path is available, ImportError is raised.", 
        "name": "importlib.abc.ExecutionLoader.get_filename", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.ExecutionLoader.get_filename", 
        "syntax": "get_filename(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.FileLoader": {
        "descr": "An abstract base class which inherits from ResourceLoader and ExecutionLoader, providing concrete implementations of ResourceLoader.get_data() and ExecutionLoader.get_filename().", 
        "name": "importlib.abc.FileLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.FileLoader", 
        "syntax": "class importlib.abc.FileLoader(fullname, path)", 
        "type": "Importing"
    }, 
    "importlib.abc.FileLoader.get_data": {
        "descr": "Returns the open, binary file for path.", 
        "name": "importlib.abc.FileLoader.get_data", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.FileLoader.get_data", 
        "syntax": "get_data(path)", 
        "type": "Importing"
    }, 
    "importlib.abc.FileLoader.get_filename": {
        "descr": "Returns path.", 
        "name": "importlib.abc.FileLoader.get_filename", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.FileLoader.get_filename", 
        "syntax": "get_filename(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.FileLoader.load_module": {
        "descr": "Calls super\u2019s load_module().", 
        "name": "importlib.abc.FileLoader.load_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.FileLoader.load_module", 
        "syntax": "load_module(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.FileLoader.name": {
        "descr": "The name of the module the loader can handle.", 
        "name": "importlib.abc.FileLoader.name", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.FileLoader.name", 
        "syntax": "name", 
        "type": "Importing"
    }, 
    "importlib.abc.FileLoader.path": {
        "descr": "Path to the file of the module.", 
        "name": "importlib.abc.FileLoader.path", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.FileLoader.path", 
        "syntax": "path", 
        "type": "Importing"
    }, 
    "importlib.abc.Finder": {
        "descr": "An abstract base class representing a finder.", 
        "name": "importlib.abc.Finder", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.Finder", 
        "syntax": "class importlib.abc.Finder", 
        "type": "Importing"
    }, 
    "importlib.abc.Finder.find_module": {
        "descr": "An abstact method for finding a loader for the specified module. Originally specified in PEP 302, this method was meant for use in sys.meta_path and in the path-based import subsystem.", 
        "name": "importlib.abc.Finder.find_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.Finder.find_module", 
        "syntax": "find_module(fullname, path=None)", 
        "type": "Importing"
    }, 
    "importlib.abc.InspectLoader": {
        "descr": "An abstract base class for a loader which implements the optional PEP 302 protocol for loaders that inspect modules.", 
        "name": "importlib.abc.InspectLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.InspectLoader", 
        "syntax": "class importlib.abc.InspectLoader", 
        "type": "Importing"
    }, 
    "importlib.abc.InspectLoader.get_code": {
        "descr": "An abstract method to return the code object for a module. None is returned if the module does not have a code object (e.g. built-in module). ImportError is raised if loader cannot find the requested module.", 
        "name": "importlib.abc.InspectLoader.get_code", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.InspectLoader.get_code", 
        "syntax": "get_code(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.InspectLoader.get_source": {
        "descr": "An abstract method to return the source of a module. It is returned as a text string using universal newlines, translating all recognized line separators into '\\n' characters. Returns None if no source is available (e.g. a built-in module). Raises ImportError if the loader cannot find the module specified.", 
        "name": "importlib.abc.InspectLoader.get_source", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.InspectLoader.get_source", 
        "syntax": "get_source(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.InspectLoader.is_package": {
        "descr": "An abstract method to return a true value if the module is a package, a false value otherwise. ImportError is raised if the loader cannot find the module.", 
        "name": "importlib.abc.InspectLoader.is_package", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.InspectLoader.is_package", 
        "syntax": "is_package(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.Loader": {
        "descr": "An abstract base class for a loader. See PEP 302 for the exact definition for a loader.", 
        "name": "importlib.abc.Loader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.Loader", 
        "syntax": "class importlib.abc.Loader", 
        "type": "Importing"
    }, 
    "importlib.abc.Loader.load_module": {
        "descr": "An abstract method for loading a module. If the module cannot be loaded, ImportError is raised, otherwise the loaded module is returned.", 
        "name": "importlib.abc.Loader.load_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.Loader.load_module", 
        "syntax": "load_module(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.Loader.module_repr": {
        "descr": "An abstract method which when implemented calculates and returns the given module\u2019s repr, as a string.", 
        "name": "importlib.abc.Loader.module_repr", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.Loader.module_repr", 
        "syntax": "module_repr(module)", 
        "type": "Importing"
    }, 
    "importlib.abc.MetaPathFinder": {
        "descr": "An abstract base class representing a meta path finder. For compatibility, this is a subclass of Finder.", 
        "name": "importlib.abc.MetaPathFinder", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.MetaPathFinder", 
        "syntax": "class importlib.abc.MetaPathFinder", 
        "type": "Importing"
    }, 
    "importlib.abc.MetaPathFinder.find_module": {
        "descr": "An abstract method for finding a loader for the specified module. If this is a top-level import, path will be None. Otherwise, this is a search for a subpackage or module and path will be the value of __path__ from the parent package. If a loader cannot be found, None is returned.", 
        "name": "importlib.abc.MetaPathFinder.find_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.MetaPathFinder.find_module", 
        "syntax": "find_module(fullname, path)", 
        "type": "Importing"
    }, 
    "importlib.abc.MetaPathFinder.invalidate_caches": {
        "descr": "An optional method which, when called, should invalidate any internal cache used by the finder. Used by importlib.invalidate_caches() when invalidating the caches of all finders on sys.meta_path.", 
        "name": "importlib.abc.MetaPathFinder.invalidate_caches", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.MetaPathFinder.invalidate_caches", 
        "syntax": "invalidate_caches()", 
        "type": "Importing"
    }, 
    "importlib.abc.PathEntryFinder": {
        "descr": "An abstract base class representing a path entry finder. Though it bears some similarities to MetaPathFinder, PathEntryFinder is meant for use only within the path-based import subsystem provided by PathFinder. This ABC is a subclass of Finder for compatibility.", 
        "name": "importlib.abc.PathEntryFinder", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PathEntryFinder", 
        "syntax": "class importlib.abc.PathEntryFinder", 
        "type": "Importing"
    }, 
    "importlib.abc.PathEntryFinder.find_loader": {
        "descr": "An abstract method for finding a loader for the specified module. Returns a 2-tuple of (loader, portion) where portion is a sequence of file system locations contributing to part of a namespace package. The loader may be None while specifying portion to signify the contribution of the file system locations to a namespace package. An empty list can be used for portion to signify the loader is not part of a package. If loader is None and portion is the empty list then no loader or location for a namespace package were found (i.e. failure to find anything for the module).", 
        "name": "importlib.abc.PathEntryFinder.find_loader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PathEntryFinder.find_loader", 
        "syntax": "find_loader(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PathEntryFinder.find_module": {
        "descr": "A concrete implementation of Finder.find_module() which is equivalent to self.find_loader(fullname)[0].", 
        "name": "importlib.abc.PathEntryFinder.find_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PathEntryFinder.find_module", 
        "syntax": "find_module(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PathEntryFinder.invalidate_caches": {
        "descr": "An optional method which, when called, should invalidate any internal cache used by the finder. Used by PathFinder.invalidate_caches() when invalidating the caches of all cached finders.", 
        "name": "importlib.abc.PathEntryFinder.invalidate_caches", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PathEntryFinder.invalidate_caches", 
        "syntax": "invalidate_caches()", 
        "type": "Importing"
    }, 
    "importlib.abc.PyLoader": {
        "descr": "An abstract base class inheriting from ExecutionLoader and ResourceLoader designed to ease the loading of Python source modules (bytecode is not handled; see SourceLoader for a source/bytecode ABC). A subclass implementing this ABC will only need to worry about exposing how the source code is stored; all other details for loading Python source code will be handled by the concrete implementations of key methods.", 
        "name": "importlib.abc.PyLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyLoader", 
        "syntax": "class importlib.abc.PyLoader", 
        "type": "Importing"
    }, 
    "importlib.abc.PyLoader.get_code": {
        "descr": "A concrete implementation of importlib.abc.InspectLoader.get_code() that creates code objects from Python source code, by requesting the source code (using source_path() and get_data()) and compiling it with the built-in compile() function.", 
        "name": "importlib.abc.PyLoader.get_code", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyLoader.get_code", 
        "syntax": "get_code(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyLoader.get_filename": {
        "descr": "A concrete implementation of importlib.abc.ExecutionLoader.get_filename() that relies on source_path(). If source_path() returns None, then ImportError is raised.", 
        "name": "importlib.abc.PyLoader.get_filename", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyLoader.get_filename", 
        "syntax": "get_filename(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyLoader.get_source": {
        "descr": "A concrete implementation of importlib.abc.InspectLoader.get_source(). Uses importlib.abc.ResourceLoader.get_data() and source_path() to get the source code. It tries to guess the source encoding using tokenize.detect_encoding().", 
        "name": "importlib.abc.PyLoader.get_source", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyLoader.get_source", 
        "syntax": "get_source(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyLoader.load_module": {
        "descr": "A concrete implementation of importlib.abc.Loader.load_module() that loads Python source code. All needed information comes from the abstract methods required by this ABC. The only pertinent assumption made by this method is that when loading a package __path__ is set to [os.path.dirname(__file__)].", 
        "name": "importlib.abc.PyLoader.load_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyLoader.load_module", 
        "syntax": "load_module(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyLoader.source_path": {
        "descr": "An abstract method that returns the path to the source code for a module. Should return None if there is no source code. Raises ImportError if the loader knows it cannot handle the module.", 
        "name": "importlib.abc.PyLoader.source_path", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyLoader.source_path", 
        "syntax": "source_path(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyPycLoader": {
        "descr": "An abstract base class inheriting from PyLoader. This ABC is meant to help in creating loaders that support both Python source and bytecode.", 
        "name": "importlib.abc.PyPycLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyPycLoader", 
        "syntax": "class importlib.abc.PyPycLoader", 
        "type": "Importing"
    }, 
    "importlib.abc.PyPycLoader.bytecode_path": {
        "descr": "An abstract method which returns the path to the bytecode for the specified module, if it exists. It returns None if no bytecode exists (yet). Raises ImportError if the loader knows it cannot handle the module.", 
        "name": "importlib.abc.PyPycLoader.bytecode_path", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyPycLoader.bytecode_path", 
        "syntax": "bytecode_path(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyPycLoader.get_filename": {
        "descr": "A concrete implementation of ExecutionLoader.get_filename() that relies on PyLoader.source_path() and bytecode_path(). If source_path() returns a path, then that value is returned. Else if bytecode_path() returns a path, that path will be returned. If a path is not available from both methods, ImportError is raised.", 
        "name": "importlib.abc.PyPycLoader.get_filename", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyPycLoader.get_filename", 
        "syntax": "get_filename(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyPycLoader.source_mtime": {
        "descr": "An abstract method which returns the modification time for the source code of the specified module. The modification time should be an integer. If there is no source code, return None. If the module cannot be found then ImportError is raised.", 
        "name": "importlib.abc.PyPycLoader.source_mtime", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyPycLoader.source_mtime", 
        "syntax": "source_mtime(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.PyPycLoader.write_bytecode": {
        "descr": "An abstract method which has the loader write bytecode for future use. If the bytecode is written, return True. Return False if the bytecode could not be written. This method should not be called if sys.dont_write_bytecode is true. The bytecode argument should be a bytes string or bytes array.", 
        "name": "importlib.abc.PyPycLoader.write_bytecode", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.PyPycLoader.write_bytecode", 
        "syntax": "write_bytecode(fullname, bytecode)", 
        "type": "Importing"
    }, 
    "importlib.abc.ResourceLoader": {
        "descr": "An abstract base class for a loader which implements the optional PEP 302 protocol for loading arbitrary resources from the storage back-end.", 
        "name": "importlib.abc.ResourceLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.ResourceLoader", 
        "syntax": "class importlib.abc.ResourceLoader", 
        "type": "Importing"
    }, 
    "importlib.abc.ResourceLoader.get_data": {
        "descr": "An abstract method to return the bytes for the data located at path. Loaders that have a file-like storage back-end that allows storing arbitrary data can implement this abstract method to give direct access to the data stored. IOError is to be raised if the path cannot be found. The path is expected to be constructed using a module\u2019s __file__ attribute or an item from a package\u2019s __path__.", 
        "name": "importlib.abc.ResourceLoader.get_data", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.ResourceLoader.get_data", 
        "syntax": "get_data(path)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader": {
        "descr": "An abstract base class for implementing source (and optionally bytecode) file loading. The class inherits from both ResourceLoader and ExecutionLoader, requiring the implementation of:", 
        "name": "importlib.abc.SourceLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader", 
        "syntax": "class importlib.abc.SourceLoader", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.get_code": {
        "descr": "Concrete implementation of InspectLoader.get_code().", 
        "name": "importlib.abc.SourceLoader.get_code", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.get_code", 
        "syntax": "get_code(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.get_source": {
        "descr": "Concrete implementation of InspectLoader.get_source().", 
        "name": "importlib.abc.SourceLoader.get_source", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.get_source", 
        "syntax": "get_source(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.is_package": {
        "descr": "Concrete implementation of InspectLoader.is_package(). A module is determined to be a package if its file path (as provided by ExecutionLoader.get_filename()) is a file named __init__ when the file extension is removed and the module name itself does not end in __init__.", 
        "name": "importlib.abc.SourceLoader.is_package", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.is_package", 
        "syntax": "is_package(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.load_module": {
        "descr": "Concrete implementation of Loader.load_module().", 
        "name": "importlib.abc.SourceLoader.load_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.load_module", 
        "syntax": "load_module(fullname)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.path_mtime": {
        "descr": "Optional abstract method which returns the modification time for the specified path.", 
        "name": "importlib.abc.SourceLoader.path_mtime", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.path_mtime", 
        "syntax": "path_mtime(path)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.path_stats": {
        "descr": "Optional abstract method which returns a dict containing metadata about the specifed path. Supported dictionary keys are:", 
        "name": "importlib.abc.SourceLoader.path_stats", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.path_stats", 
        "syntax": "path_stats(path)", 
        "type": "Importing"
    }, 
    "importlib.abc.SourceLoader.set_data": {
        "descr": "Optional abstract method which writes the specified bytes to a file path. Any intermediate directories which do not exist are to be created automatically.", 
        "name": "importlib.abc.SourceLoader.set_data", 
        "params": [], 
        "path": "python/library/importlib#importlib.abc.SourceLoader.set_data", 
        "syntax": "set_data(path, data)", 
        "type": "Importing"
    }, 
    "importlib.find_loader": {
        "descr": "Find the loader for a module, optionally within the specified path. If the module is in sys.modules, then sys.modules[name].__loader__ is returned (unless the loader would be None, in which case ValueError is raised). Otherwise a search using sys.meta_path is done. None is returned if no loader is found.", 
        "name": "importlib.find_loader", 
        "params": [], 
        "path": "python/library/importlib#importlib.find_loader", 
        "syntax": "importlib.find_loader(name, path=None)", 
        "type": "Importing"
    }, 
    "importlib.import_module": {
        "descr": "Import a module. The name argument specifies what module to import in absolute or relative terms (e.g. either pkg.mod or ..mod). If the name is specified in relative terms, then the package argument must be set to the name of the package which is to act as the anchor for resolving the package name (e.g. import_module('..mod', 'pkg.subpkg') will import pkg.mod).", 
        "name": "importlib.import_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.import_module", 
        "syntax": "importlib.import_module(name, package=None)", 
        "type": "Importing"
    }, 
    "importlib.invalidate_caches": {
        "descr": "Invalidate the internal caches of finders stored at sys.meta_path. If a finder implements invalidate_caches() then it will be called to perform the invalidation. This function should be called if any modules are created/installed while your program is running to guarantee all finders will notice the new module\u2019s existence.", 
        "name": "importlib.invalidate_caches", 
        "params": [], 
        "path": "python/library/importlib#importlib.invalidate_caches", 
        "syntax": "importlib.invalidate_caches()", 
        "type": "Importing"
    }, 
    "importlib.machinery.BYTECODE_SUFFIXES": {
        "descr": "A list of strings representing the recognized file suffixes for bytecode modules. Set to either DEBUG_BYTECODE_SUFFIXES or OPTIMIZED_BYTECODE_SUFFIXES based on whether __debug__ is true.", 
        "name": "importlib.machinery.BYTECODE_SUFFIXES", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.BYTECODE_SUFFIXES", 
        "syntax": "importlib.machinery.BYTECODE_SUFFIXES", 
        "type": "Importing"
    }, 
    "importlib.machinery.BuiltinImporter": {
        "descr": "An importer for built-in modules. All known built-in modules are listed in sys.builtin_module_names. This class implements the importlib.abc.MetaPathFinder and importlib.abc.InspectLoader ABCs.", 
        "name": "importlib.machinery.BuiltinImporter", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.BuiltinImporter", 
        "syntax": "class importlib.machinery.BuiltinImporter", 
        "type": "Importing"
    }, 
    "importlib.machinery.DEBUG_BYTECODE_SUFFIXES": {
        "descr": "A list of strings representing the file suffixes for non-optimized bytecode modules.", 
        "name": "importlib.machinery.DEBUG_BYTECODE_SUFFIXES", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.DEBUG_BYTECODE_SUFFIXES", 
        "syntax": "importlib.machinery.DEBUG_BYTECODE_SUFFIXES", 
        "type": "Importing"
    }, 
    "importlib.machinery.EXTENSION_SUFFIXES": {
        "descr": "A list of strings representing the recognized file suffixes for extension modules.", 
        "name": "importlib.machinery.EXTENSION_SUFFIXES", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.EXTENSION_SUFFIXES", 
        "syntax": "importlib.machinery.EXTENSION_SUFFIXES", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader": {
        "descr": "A concrete implementation of importlib.abc.InspectLoader for extension modules.", 
        "name": "importlib.machinery.ExtensionFileLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader", 
        "syntax": "class importlib.machinery.ExtensionFileLoader(fullname, path)", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader.get_code": {
        "descr": "Returns None as extension modules lack a code object.", 
        "name": "importlib.machinery.ExtensionFileLoader.get_code", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader.get_code", 
        "syntax": "get_code(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader.get_source": {
        "descr": "Returns None as extension modules do not have source code.", 
        "name": "importlib.machinery.ExtensionFileLoader.get_source", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader.get_source", 
        "syntax": "get_source(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader.is_package": {
        "descr": "Returns True if the file path points to a package\u2019s __init__ module based on EXTENSION_SUFFIXES.", 
        "name": "importlib.machinery.ExtensionFileLoader.is_package", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader.is_package", 
        "syntax": "is_package(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader.load_module": {
        "descr": "Loads the extension module if and only if fullname is the same as name or is None.", 
        "name": "importlib.machinery.ExtensionFileLoader.load_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader.load_module", 
        "syntax": "load_module(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader.name": {
        "descr": "Name of the module the loader supports.", 
        "name": "importlib.machinery.ExtensionFileLoader.name", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader.name", 
        "syntax": "name", 
        "type": "Importing"
    }, 
    "importlib.machinery.ExtensionFileLoader.path": {
        "descr": "Path to the extension module.", 
        "name": "importlib.machinery.ExtensionFileLoader.path", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.ExtensionFileLoader.path", 
        "syntax": "path", 
        "type": "Importing"
    }, 
    "importlib.machinery.FileFinder": {
        "descr": "A concrete implementation of importlib.abc.PathEntryFinder which caches results from the file system.", 
        "name": "importlib.machinery.FileFinder", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.FileFinder", 
        "syntax": "class importlib.machinery.FileFinder(path, *loader_details)", 
        "type": "Importing"
    }, 
    "importlib.machinery.FileFinder.find_loader": {
        "descr": "Attempt to find the loader to handle fullname within path.", 
        "name": "importlib.machinery.FileFinder.find_loader", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.FileFinder.find_loader", 
        "syntax": "find_loader(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.FileFinder.invalidate_caches": {
        "descr": "Clear out the internal cache.", 
        "name": "importlib.machinery.FileFinder.invalidate_caches", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.FileFinder.invalidate_caches", 
        "syntax": "invalidate_caches()", 
        "type": "Importing"
    }, 
    "importlib.machinery.FileFinder.path": {
        "descr": "The path the finder will search in.", 
        "name": "importlib.machinery.FileFinder.path", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.FileFinder.path", 
        "syntax": "path", 
        "type": "Importing"
    }, 
    "importlib.machinery.FileFinder.path_hook": {
        "descr": "A class method which returns a closure for use on sys.path_hooks. An instance of FileFinder is returned by the closure using the path argument given to the closure directly and loader_details indirectly.", 
        "name": "importlib.machinery.FileFinder.path_hook", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.FileFinder.path_hook", 
        "syntax": "classmethod path_hook(*loader_details)", 
        "type": "Importing"
    }, 
    "importlib.machinery.FrozenImporter": {
        "descr": "An importer for frozen modules. This class implements the importlib.abc.MetaPathFinder and importlib.abc.InspectLoader ABCs.", 
        "name": "importlib.machinery.FrozenImporter", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.FrozenImporter", 
        "syntax": "class importlib.machinery.FrozenImporter", 
        "type": "Importing"
    }, 
    "importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES": {
        "descr": "A list of strings representing the file suffixes for optimized bytecode modules.", 
        "name": "importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", 
        "syntax": "importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", 
        "type": "Importing"
    }, 
    "importlib.machinery.PathFinder": {
        "descr": "A Finder for sys.path and package __path__ attributes. This class implements the importlib.abc.MetaPathFinder ABC.", 
        "name": "importlib.machinery.PathFinder", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.PathFinder", 
        "syntax": "class importlib.machinery.PathFinder", 
        "type": "Importing"
    }, 
    "importlib.machinery.PathFinder.find_module": {
        "descr": "Class method that attempts to find a loader for the module specified by fullname on sys.path or, if defined, on path. For each path entry that is searched, sys.path_importer_cache is checked. If a non-false object is found then it is used as the path entry finder to look for the module being searched for. If no entry is found in sys.path_importer_cache, then sys.path_hooks is searched for a finder for the path entry and, if found, is stored in sys.path_importer_cache along with being queried about the module. If no finder is ever found then None is both stored in the cache and returned.", 
        "name": "importlib.machinery.PathFinder.find_module", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.PathFinder.find_module", 
        "syntax": "classmethod find_module(fullname, path=None)", 
        "type": "Importing"
    }, 
    "importlib.machinery.PathFinder.invalidate_caches": {
        "descr": "Calls importlib.abc.PathEntryFinder.invalidate_caches() on all finders stored in sys.path_importer_cache.", 
        "name": "importlib.machinery.PathFinder.invalidate_caches", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.PathFinder.invalidate_caches", 
        "syntax": "classmethod invalidate_caches()", 
        "type": "Importing"
    }, 
    "importlib.machinery.SOURCE_SUFFIXES": {
        "descr": "A list of strings representing the recognized file suffixes for source modules.", 
        "name": "importlib.machinery.SOURCE_SUFFIXES", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SOURCE_SUFFIXES", 
        "syntax": "importlib.machinery.SOURCE_SUFFIXES", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourceFileLoader": {
        "descr": "A concrete implementation of importlib.abc.SourceLoader by subclassing importlib.abc.FileLoader and providing some concrete implementations of other methods.", 
        "name": "importlib.machinery.SourceFileLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourceFileLoader", 
        "syntax": "class importlib.machinery.SourceFileLoader(fullname, path)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourceFileLoader.is_package": {
        "descr": "Return true if path appears to be for a package.", 
        "name": "importlib.machinery.SourceFileLoader.is_package", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourceFileLoader.is_package", 
        "syntax": "is_package(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourceFileLoader.name": {
        "descr": "The name of the module that this loader will handle.", 
        "name": "importlib.machinery.SourceFileLoader.name", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourceFileLoader.name", 
        "syntax": "name", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourceFileLoader.path": {
        "descr": "The path to the source file.", 
        "name": "importlib.machinery.SourceFileLoader.path", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourceFileLoader.path", 
        "syntax": "path", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourceFileLoader.path_stats": {
        "descr": "Concrete implementation of importlib.abc.SourceLoader.path_stats().", 
        "name": "importlib.machinery.SourceFileLoader.path_stats", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourceFileLoader.path_stats", 
        "syntax": "path_stats(path)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourceFileLoader.set_data": {
        "descr": "Concrete implementation of importlib.abc.SourceLoader.set_data().", 
        "name": "importlib.machinery.SourceFileLoader.set_data", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourceFileLoader.set_data", 
        "syntax": "set_data(path, data)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourcelessFileLoader": {
        "descr": "A concrete implementation of importlib.abc.FileLoader which can import bytecode files (i.e. no source code files exist).", 
        "name": "importlib.machinery.SourcelessFileLoader", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourcelessFileLoader", 
        "syntax": "class importlib.machinery.SourcelessFileLoader(fullname, path)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourcelessFileLoader.get_code": {
        "descr": "Returns the code object for name created from path.", 
        "name": "importlib.machinery.SourcelessFileLoader.get_code", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourcelessFileLoader.get_code", 
        "syntax": "get_code(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourcelessFileLoader.get_source": {
        "descr": "Returns None as bytecode files have no source when this loader is used.", 
        "name": "importlib.machinery.SourcelessFileLoader.get_source", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourcelessFileLoader.get_source", 
        "syntax": "get_source(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourcelessFileLoader.is_package": {
        "descr": "Determines if the module is a package based on path.", 
        "name": "importlib.machinery.SourcelessFileLoader.is_package", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourcelessFileLoader.is_package", 
        "syntax": "is_package(fullname)", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourcelessFileLoader.name": {
        "descr": "The name of the module the loader will handle.", 
        "name": "importlib.machinery.SourcelessFileLoader.name", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourcelessFileLoader.name", 
        "syntax": "name", 
        "type": "Importing"
    }, 
    "importlib.machinery.SourcelessFileLoader.path": {
        "descr": "The path to the bytecode file.", 
        "name": "importlib.machinery.SourcelessFileLoader.path", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.SourcelessFileLoader.path", 
        "syntax": "path", 
        "type": "Importing"
    }, 
    "importlib.machinery.WindowsRegistryFinder": {
        "descr": "Finder for modules declared in the Windows registry. This class implements the importlib.abc.Finder ABC.", 
        "name": "importlib.machinery.WindowsRegistryFinder", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.WindowsRegistryFinder", 
        "syntax": "class importlib.machinery.WindowsRegistryFinder", 
        "type": "Importing"
    }, 
    "importlib.machinery.all_suffixes": {
        "descr": "Returns a combined list of strings representing all file suffixes for modules recognized by the standard import machinery. This is a helper for code which simply needs to know if a filesystem path potentially refers to a module without needing any details on the kind of module (for example, inspect.getmodulename())", 
        "name": "importlib.machinery.all_suffixes", 
        "params": [], 
        "path": "python/library/importlib#importlib.machinery.all_suffixes", 
        "syntax": "importlib.machinery.all_suffixes()", 
        "type": "Importing"
    }, 
    "importlib.util.module_for_loader": {
        "descr": "A decorator for a loader method, to handle selecting the proper module object to load with. The decorated method is expected to have a call signature taking two positional arguments (e.g. load_module(self, module)) for which the second argument will be the module object to be used by the loader. Note that the decorator will not work on static methods because of the assumption of two arguments.", 
        "name": "importlib.util.module_for_loader", 
        "params": [], 
        "path": "python/library/importlib#importlib.util.module_for_loader", 
        "syntax": "@importlib.util.module_for_loader", 
        "type": "Importing"
    }, 
    "importlib.util.resolve_name": {
        "descr": "Resolve a relative module name to an absolute one.", 
        "name": "importlib.util.resolve_name", 
        "params": [], 
        "path": "python/library/importlib#importlib.util.resolve_name", 
        "syntax": "importlib.util.resolve_name(name, package)", 
        "type": "Importing"
    }, 
    "importlib.util.set_loader": {
        "descr": "", 
        "name": "importlib.util.set_loader", 
        "params": [], 
        "path": "python/library/importlib#importlib.util.set_loader", 
        "syntax": "@importlib.util.set_loader", 
        "type": "Importing"
    }, 
    "importlib.util.set_package": {
        "descr": "A decorator for a loader to set the __package__ attribute on the module returned by the loader. If __package__ is set and has a value other than None it will not be changed. Note that the module returned by the loader is what has the attribute set on and not the module found in sys.modules.", 
        "name": "importlib.util.set_package", 
        "params": [], 
        "path": "python/library/importlib#importlib.util.set_package", 
        "syntax": "@importlib.util.set_package", 
        "type": "Importing"
    }, 
    "index": {
        "descr": "Like find(), but raise ValueError when the substring is not found.", 
        "name": "str.index", 
        "params": [], 
        "path": "python/library/stdtypes#str.index", 
        "syntax": "str.index(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "input": {
        "descr": "If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example:", 
        "name": "input", 
        "params": [], 
        "path": "python/library/functions#input", 
        "syntax": "input([prompt])", 
        "type": "Built-in Functions"
    }, 
    "insert": {
        "descr": "Insert a new item with value x in the array before position i. Negative values are treated as being relative to the end of the array.", 
        "name": "array.array.insert", 
        "params": [], 
        "path": "python/library/array#array.array.insert", 
        "syntax": "array.insert(i, x)", 
        "type": "Data Types"
    }, 
    "inspect.BoundArguments": {
        "descr": "Result of a Signature.bind() or Signature.bind_partial() call. Holds the mapping of arguments to the function\u2019s parameters.", 
        "name": "inspect.BoundArguments", 
        "params": [], 
        "path": "python/library/inspect#inspect.BoundArguments", 
        "syntax": "class inspect.BoundArguments", 
        "type": "Runtime"
    }, 
    "inspect.BoundArguments.args": {
        "descr": "A tuple of positional arguments values. Dynamically computed from the arguments attribute.", 
        "name": "inspect.BoundArguments.args", 
        "params": [], 
        "path": "python/library/inspect#inspect.BoundArguments.args", 
        "syntax": "args", 
        "type": "Runtime"
    }, 
    "inspect.BoundArguments.arguments": {
        "descr": "An ordered, mutable mapping (collections.OrderedDict) of parameters\u2019 names to arguments\u2019 values. Contains only explicitly bound arguments. Changes in arguments will reflect in args and kwargs.", 
        "name": "inspect.BoundArguments.arguments", 
        "params": [], 
        "path": "python/library/inspect#inspect.BoundArguments.arguments", 
        "syntax": "arguments", 
        "type": "Runtime"
    }, 
    "inspect.BoundArguments.kwargs": {
        "descr": "A dict of keyword arguments values. Dynamically computed from the arguments attribute.", 
        "name": "inspect.BoundArguments.kwargs", 
        "params": [], 
        "path": "python/library/inspect#inspect.BoundArguments.kwargs", 
        "syntax": "kwargs", 
        "type": "Runtime"
    }, 
    "inspect.Parameter": {
        "descr": "Parameter objects are immutable. Instead of modifying a Parameter object, you can use Parameter.replace() to create a modified copy.", 
        "name": "inspect.Parameter", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter", 
        "syntax": "class inspect.Parameter(name, kind, *, default=Parameter.empty, annotation=Parameter.empty)", 
        "type": "Runtime"
    }, 
    "inspect.Parameter.annotation": {
        "descr": "The annotation for the parameter. If the parameter has no annotation, this attribute is set to Parameter.empty.", 
        "name": "inspect.Parameter.annotation", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter.annotation", 
        "syntax": "annotation", 
        "type": "Runtime"
    }, 
    "inspect.Parameter.default": {
        "descr": "The default value for the parameter. If the parameter has no default value, this attribute is set to Parameter.empty.", 
        "name": "inspect.Parameter.default", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter.default", 
        "syntax": "default", 
        "type": "Runtime"
    }, 
    "inspect.Parameter.empty": {
        "descr": "A special class-level marker to specify absence of default values and annotations.", 
        "name": "inspect.Parameter.empty", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter.empty", 
        "syntax": "empty", 
        "type": "Runtime"
    }, 
    "inspect.Parameter.kind": {
        "descr": "Describes how argument values are bound to the parameter. Possible values (accessible via Parameter, like Parameter.KEYWORD_ONLY):", 
        "name": "inspect.Parameter.kind", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter.kind", 
        "syntax": "kind", 
        "type": "Runtime"
    }, 
    "inspect.Parameter.name": {
        "descr": "The name of the parameter as a string. Must be a valid python identifier name (with the exception of POSITIONAL_ONLY parameters, which can have it set to None).", 
        "name": "inspect.Parameter.name", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter.name", 
        "syntax": "name", 
        "type": "Runtime"
    }, 
    "inspect.Parameter.replace": {
        "descr": "Create a new Parameter instance based on the instance replaced was invoked on. To override a Parameter attribute, pass the corresponding argument. To remove a default value or/and an annotation from a Parameter, pass Parameter.empty.", 
        "name": "inspect.Parameter.replace", 
        "params": [], 
        "path": "python/library/inspect#inspect.Parameter.replace", 
        "syntax": "replace(*[, name][, kind][, default][, annotation])", 
        "type": "Runtime"
    }, 
    "inspect.Signature": {
        "descr": "A Signature object represents the call signature of a function and its return annotation. For each parameter accepted by the function it stores a Parameter object in its parameters collection.", 
        "name": "inspect.Signature", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature", 
        "syntax": "class inspect.Signature(parameters=None, *, return_annotation=Signature.empty)", 
        "type": "Runtime"
    }, 
    "inspect.Signature.bind": {
        "descr": "Create a mapping from positional and keyword arguments to parameters. Returns BoundArguments if *args and **kwargs match the signature, or raises a TypeError.", 
        "name": "inspect.Signature.bind", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature.bind", 
        "syntax": "bind(*args, **kwargs)", 
        "type": "Runtime"
    }, 
    "inspect.Signature.bind_partial": {
        "descr": "Works the same way as Signature.bind(), but allows the omission of some required arguments (mimics functools.partial() behavior.) Returns BoundArguments, or raises a TypeError if the passed arguments do not match the signature.", 
        "name": "inspect.Signature.bind_partial", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature.bind_partial", 
        "syntax": "bind_partial(*args, **kwargs)", 
        "type": "Runtime"
    }, 
    "inspect.Signature.empty": {
        "descr": "A special class-level marker to specify absence of a return annotation.", 
        "name": "inspect.Signature.empty", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature.empty", 
        "syntax": "empty", 
        "type": "Runtime"
    }, 
    "inspect.Signature.parameters": {
        "descr": "An ordered mapping of parameters\u2019 names to the corresponding Parameter objects.", 
        "name": "inspect.Signature.parameters", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature.parameters", 
        "syntax": "parameters", 
        "type": "Runtime"
    }, 
    "inspect.Signature.replace": {
        "descr": "Create a new Signature instance based on the instance replace was invoked on. It is possible to pass different parameters and/or return_annotation to override the corresponding properties of the base signature. To remove return_annotation from the copied Signature, pass in Signature.empty.", 
        "name": "inspect.Signature.replace", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature.replace", 
        "syntax": "replace(*[, parameters][, return_annotation])", 
        "type": "Runtime"
    }, 
    "inspect.Signature.return_annotation": {
        "descr": "The \u201creturn\u201d annotation for the callable. If the callable has no \u201creturn\u201d annotation, this attribute is set to Signature.empty.", 
        "name": "inspect.Signature.return_annotation", 
        "params": [], 
        "path": "python/library/inspect#inspect.Signature.return_annotation", 
        "syntax": "return_annotation", 
        "type": "Runtime"
    }, 
    "inspect.cleandoc": {
        "descr": "Clean up indentation from docstrings that are indented to line up with blocks of code. Any whitespace that can be uniformly removed from the second line onwards is removed. Also, all tabs are expanded to spaces.", 
        "name": "inspect.cleandoc", 
        "params": [], 
        "path": "python/library/inspect#inspect.cleandoc", 
        "syntax": "inspect.cleandoc(doc)", 
        "type": "Runtime"
    }, 
    "inspect.currentframe": {
        "descr": "Return the frame object for the caller\u2019s stack frame.", 
        "name": "inspect.currentframe", 
        "params": [], 
        "path": "python/library/inspect#inspect.currentframe", 
        "syntax": "inspect.currentframe()", 
        "type": "Runtime"
    }, 
    "inspect.formatargspec": {
        "descr": "Format a pretty argument spec from the values returned by getargspec() or getfullargspec().", 
        "name": "inspect.formatargspec", 
        "params": [], 
        "path": "python/library/inspect#inspect.formatargspec", 
        "syntax": "inspect.formatargspec(args[, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations[, formatarg, formatvarargs, formatvarkw, formatvalue, formatreturns, formatannotations]])", 
        "type": "Runtime"
    }, 
    "inspect.formatargvalues": {
        "descr": "Format a pretty argument spec from the four values returned by getargvalues(). The format* arguments are the corresponding optional formatting functions that are called to turn names and values into strings.", 
        "name": "inspect.formatargvalues", 
        "params": [], 
        "path": "python/library/inspect#inspect.formatargvalues", 
        "syntax": "inspect.formatargvalues(args[, varargs, varkw, locals, formatarg, formatvarargs, formatvarkw, formatvalue])", 
        "type": "Runtime"
    }, 
    "inspect.getargspec": {
        "descr": "Get the names and default values of a Python function\u2019s arguments. A named tuple ArgSpec(args, varargs, keywords, defaults) is returned. args is a list of the argument names. varargs and keywords are the names of the * and ** arguments or None. defaults is a tuple of default argument values or None if there are no default arguments; if this tuple has n elements, they correspond to the last n elements listed in args.", 
        "name": "inspect.getargspec", 
        "params": [], 
        "path": "python/library/inspect#inspect.getargspec", 
        "syntax": "inspect.getargspec(func)", 
        "type": "Runtime"
    }, 
    "inspect.getargvalues": {
        "descr": "Get information about arguments passed into a particular frame. A named tuple ArgInfo(args, varargs, keywords, locals) is returned. args is a list of the argument names. varargs and keywords are the names of the * and ** arguments or None. locals is the locals dictionary of the given frame.", 
        "name": "inspect.getargvalues", 
        "params": [], 
        "path": "python/library/inspect#inspect.getargvalues", 
        "syntax": "inspect.getargvalues(frame)", 
        "type": "Runtime"
    }, 
    "inspect.getattr_static": {
        "descr": "Retrieve attributes without triggering dynamic lookup via the descriptor protocol, __getattr__() or __getattribute__().", 
        "name": "inspect.getattr_static", 
        "params": [], 
        "path": "python/library/inspect#inspect.getattr_static", 
        "syntax": "inspect.getattr_static(obj, attr, default=None)", 
        "type": "Runtime"
    }, 
    "inspect.getcallargs": {
        "descr": "Bind the args and kwds to the argument names of the Python function or method func, as if it was called with them. For bound methods, bind also the first argument (typically named self) to the associated instance. A dict is returned, mapping the argument names (including the names of the * and ** arguments, if any) to their values from args and kwds. In case of invoking func incorrectly, i.e. whenever func(*args, **kwds) would raise an exception because of incompatible signature, an exception of the same type and the same or similar message is raised. For example:", 
        "name": "inspect.getcallargs", 
        "params": [], 
        "path": "python/library/inspect#inspect.getcallargs", 
        "syntax": "inspect.getcallargs(func, *args, **kwds)", 
        "type": "Runtime"
    }, 
    "inspect.getclasstree": {
        "descr": "Arrange the given list of classes into a hierarchy of nested lists. Where a nested list appears, it contains classes derived from the class whose entry immediately precedes the list. Each entry is a 2-tuple containing a class and a tuple of its base classes. If the unique argument is true, exactly one entry appears in the returned structure for each class in the given list. Otherwise, classes using multiple inheritance and their descendants will appear multiple times.", 
        "name": "inspect.getclasstree", 
        "params": [], 
        "path": "python/library/inspect#inspect.getclasstree", 
        "syntax": "inspect.getclasstree(classes, unique=False)", 
        "type": "Runtime"
    }, 
    "inspect.getclosurevars": {
        "descr": "Get the mapping of external name references in a Python function or method func to their current values. A named tuple ClosureVars(nonlocals, globals, builtins, unbound) is returned. nonlocals maps referenced names to lexical closure variables, globals to the function\u2019s module globals and builtins to the builtins visible from the function body. unbound is the set of names referenced in the function that could not be resolved at all given the current module globals and builtins.", 
        "name": "inspect.getclosurevars", 
        "params": [], 
        "path": "python/library/inspect#inspect.getclosurevars", 
        "syntax": "inspect.getclosurevars(func)", 
        "type": "Runtime"
    }, 
    "inspect.getcomments": {
        "descr": "Return in a single string any lines of comments immediately preceding the object\u2019s source code (for a class, function, or method), or at the top of the Python source file (if the object is a module).", 
        "name": "inspect.getcomments", 
        "params": [], 
        "path": "python/library/inspect#inspect.getcomments", 
        "syntax": "inspect.getcomments(object)", 
        "type": "Runtime"
    }, 
    "inspect.getdoc": {
        "descr": "Get the documentation string for an object, cleaned up with cleandoc().", 
        "name": "inspect.getdoc", 
        "params": [], 
        "path": "python/library/inspect#inspect.getdoc", 
        "syntax": "inspect.getdoc(object)", 
        "type": "Runtime"
    }, 
    "inspect.getfile": {
        "descr": "Return the name of the (text or binary) file in which an object was defined. This will fail with a TypeError if the object is a built-in module, class, or function.", 
        "name": "inspect.getfile", 
        "params": [], 
        "path": "python/library/inspect#inspect.getfile", 
        "syntax": "inspect.getfile(object)", 
        "type": "Runtime"
    }, 
    "inspect.getframeinfo": {
        "descr": "Get information about a frame or traceback object. A named tuple Traceback(filename, lineno, function, code_context, index) is returned.", 
        "name": "inspect.getframeinfo", 
        "params": [], 
        "path": "python/library/inspect#inspect.getframeinfo", 
        "syntax": "inspect.getframeinfo(frame, context=1)", 
        "type": "Runtime"
    }, 
    "inspect.getfullargspec": {
        "descr": "Get the names and default values of a Python function\u2019s arguments. A named tuple is returned:", 
        "name": "inspect.getfullargspec", 
        "params": [], 
        "path": "python/library/inspect#inspect.getfullargspec", 
        "syntax": "inspect.getfullargspec(func)", 
        "type": "Runtime"
    }, 
    "inspect.getgeneratorlocals": {
        "descr": "Get the mapping of live local variables in generator to their current values. A dictionary is returned that maps from variable names to values. This is the equivalent of calling locals() in the body of the generator, and all the same caveats apply.", 
        "name": "inspect.getgeneratorlocals", 
        "params": [], 
        "path": "python/library/inspect#inspect.getgeneratorlocals", 
        "syntax": "inspect.getgeneratorlocals(generator)", 
        "type": "Runtime"
    }, 
    "inspect.getgeneratorstate": {
        "descr": "Get current state of a generator-iterator.", 
        "name": "inspect.getgeneratorstate", 
        "params": [], 
        "path": "python/library/inspect#inspect.getgeneratorstate", 
        "syntax": "inspect.getgeneratorstate(generator)", 
        "type": "Runtime"
    }, 
    "inspect.getinnerframes": {
        "descr": "Get a list of frame records for a traceback\u2019s frame and all inner frames. These frames represent calls made as a consequence of frame. The first entry in the list represents traceback; the last entry represents where the exception was raised.", 
        "name": "inspect.getinnerframes", 
        "params": [], 
        "path": "python/library/inspect#inspect.getinnerframes", 
        "syntax": "inspect.getinnerframes(traceback, context=1)", 
        "type": "Runtime"
    }, 
    "inspect.getmembers": {
        "descr": "Return all the members of an object in a list of (name, value) pairs sorted by name. If the optional predicate argument is supplied, only members for which the predicate returns a true value are included.", 
        "name": "inspect.getmembers", 
        "params": [], 
        "path": "python/library/inspect#inspect.getmembers", 
        "syntax": "inspect.getmembers(object[, predicate])", 
        "type": "Runtime"
    }, 
    "inspect.getmodule": {
        "descr": "Try to guess which module an object was defined in.", 
        "name": "inspect.getmodule", 
        "params": [], 
        "path": "python/library/inspect#inspect.getmodule", 
        "syntax": "inspect.getmodule(object)", 
        "type": "Runtime"
    }, 
    "inspect.getmoduleinfo": {
        "descr": "Returns a named tuple ModuleInfo(name, suffix, mode, module_type) of values that describe how Python will interpret the file identified by path if it is a module, or None if it would not be identified as a module. In that tuple, name is the name of the module without the name of any enclosing package, suffix is the trailing part of the file name (which may not be a dot-delimited extension), mode is the open() mode that would be used ('r' or 'rb'), and module_type is an integer giving the type of the module. module_type will have a value which can be compared to the constants defined in the imp module; see the documentation for that module for more information on module types.", 
        "name": "inspect.getmoduleinfo", 
        "params": [], 
        "path": "python/library/inspect#inspect.getmoduleinfo", 
        "syntax": "inspect.getmoduleinfo(path)", 
        "type": "Runtime"
    }, 
    "inspect.getmodulename": {
        "descr": "Return the name of the module named by the file path, without including the names of enclosing packages. The file extension is checked against all of the entries in importlib.machinery.all_suffixes(). If it matches, the final path component is returned with the extension removed. Otherwise, None is returned.", 
        "name": "inspect.getmodulename", 
        "params": [], 
        "path": "python/library/inspect#inspect.getmodulename", 
        "syntax": "inspect.getmodulename(path)", 
        "type": "Runtime"
    }, 
    "inspect.getmro": {
        "descr": "Return a tuple of class cls\u2019s base classes, including cls, in method resolution order. No class appears more than once in this tuple. Note that the method resolution order depends on cls\u2019s type. Unless a very peculiar user-defined metatype is in use, cls will be the first element of the tuple.", 
        "name": "inspect.getmro", 
        "params": [], 
        "path": "python/library/inspect#inspect.getmro", 
        "syntax": "inspect.getmro(cls)", 
        "type": "Runtime"
    }, 
    "inspect.getouterframes": {
        "descr": "Get a list of frame records for a frame and all outer frames. These frames represent the calls that lead to the creation of frame. The first entry in the returned list represents frame; the last entry represents the outermost call on frame\u2018s stack.", 
        "name": "inspect.getouterframes", 
        "params": [], 
        "path": "python/library/inspect#inspect.getouterframes", 
        "syntax": "inspect.getouterframes(frame, context=1)", 
        "type": "Runtime"
    }, 
    "inspect.getsource": {
        "descr": "Return the text of the source code for an object. The argument may be a module, class, method, function, traceback, frame, or code object. The source code is returned as a single string. An OSError is raised if the source code cannot be retrieved.", 
        "name": "inspect.getsource", 
        "params": [], 
        "path": "python/library/inspect#inspect.getsource", 
        "syntax": "inspect.getsource(object)", 
        "type": "Runtime"
    }, 
    "inspect.getsourcefile": {
        "descr": "Return the name of the Python source file in which an object was defined. This will fail with a TypeError if the object is a built-in module, class, or function.", 
        "name": "inspect.getsourcefile", 
        "params": [], 
        "path": "python/library/inspect#inspect.getsourcefile", 
        "syntax": "inspect.getsourcefile(object)", 
        "type": "Runtime"
    }, 
    "inspect.getsourcelines": {
        "descr": "Return a list of source lines and starting line number for an object. The argument may be a module, class, method, function, traceback, frame, or code object. The source code is returned as a list of the lines corresponding to the object and the line number indicates where in the original source file the first line of code was found. An OSError is raised if the source code cannot be retrieved.", 
        "name": "inspect.getsourcelines", 
        "params": [], 
        "path": "python/library/inspect#inspect.getsourcelines", 
        "syntax": "inspect.getsourcelines(object)", 
        "type": "Runtime"
    }, 
    "inspect.isabstract": {
        "descr": "Return true if the object is an abstract base class.", 
        "name": "inspect.isabstract", 
        "params": [], 
        "path": "python/library/inspect#inspect.isabstract", 
        "syntax": "inspect.isabstract(object)", 
        "type": "Runtime"
    }, 
    "inspect.isbuiltin": {
        "descr": "Return true if the object is a built-in function or a bound built-in method.", 
        "name": "inspect.isbuiltin", 
        "params": [], 
        "path": "python/library/inspect#inspect.isbuiltin", 
        "syntax": "inspect.isbuiltin(object)", 
        "type": "Runtime"
    }, 
    "inspect.isclass": {
        "descr": "Return true if the object is a class, whether built-in or created in Python code.", 
        "name": "inspect.isclass", 
        "params": [], 
        "path": "python/library/inspect#inspect.isclass", 
        "syntax": "inspect.isclass(object)", 
        "type": "Runtime"
    }, 
    "inspect.iscode": {
        "descr": "Return true if the object is a code.", 
        "name": "inspect.iscode", 
        "params": [], 
        "path": "python/library/inspect#inspect.iscode", 
        "syntax": "inspect.iscode(object)", 
        "type": "Runtime"
    }, 
    "inspect.isdatadescriptor": {
        "descr": "Return true if the object is a data descriptor.", 
        "name": "inspect.isdatadescriptor", 
        "params": [], 
        "path": "python/library/inspect#inspect.isdatadescriptor", 
        "syntax": "inspect.isdatadescriptor(object)", 
        "type": "Runtime"
    }, 
    "inspect.isframe": {
        "descr": "Return true if the object is a frame.", 
        "name": "inspect.isframe", 
        "params": [], 
        "path": "python/library/inspect#inspect.isframe", 
        "syntax": "inspect.isframe(object)", 
        "type": "Runtime"
    }, 
    "inspect.isfunction": {
        "descr": "Return true if the object is a Python function, which includes functions created by a lambda expression.", 
        "name": "inspect.isfunction", 
        "params": [], 
        "path": "python/library/inspect#inspect.isfunction", 
        "syntax": "inspect.isfunction(object)", 
        "type": "Runtime"
    }, 
    "inspect.isgenerator": {
        "descr": "Return true if the object is a generator.", 
        "name": "inspect.isgenerator", 
        "params": [], 
        "path": "python/library/inspect#inspect.isgenerator", 
        "syntax": "inspect.isgenerator(object)", 
        "type": "Runtime"
    }, 
    "inspect.isgeneratorfunction": {
        "descr": "Return true if the object is a Python generator function.", 
        "name": "inspect.isgeneratorfunction", 
        "params": [], 
        "path": "python/library/inspect#inspect.isgeneratorfunction", 
        "syntax": "inspect.isgeneratorfunction(object)", 
        "type": "Runtime"
    }, 
    "inspect.isgetsetdescriptor": {
        "descr": "Return true if the object is a getset descriptor.", 
        "name": "inspect.isgetsetdescriptor", 
        "params": [], 
        "path": "python/library/inspect#inspect.isgetsetdescriptor", 
        "syntax": "inspect.isgetsetdescriptor(object)", 
        "type": "Runtime"
    }, 
    "inspect.ismemberdescriptor": {
        "descr": "Return true if the object is a member descriptor.", 
        "name": "inspect.ismemberdescriptor", 
        "params": [], 
        "path": "python/library/inspect#inspect.ismemberdescriptor", 
        "syntax": "inspect.ismemberdescriptor(object)", 
        "type": "Runtime"
    }, 
    "inspect.ismethod": {
        "descr": "Return true if the object is a bound method written in Python.", 
        "name": "inspect.ismethod", 
        "params": [], 
        "path": "python/library/inspect#inspect.ismethod", 
        "syntax": "inspect.ismethod(object)", 
        "type": "Runtime"
    }, 
    "inspect.ismethoddescriptor": {
        "descr": "Return true if the object is a method descriptor, but not if ismethod(), isclass(), isfunction() or isbuiltin() are true.", 
        "name": "inspect.ismethoddescriptor", 
        "params": [], 
        "path": "python/library/inspect#inspect.ismethoddescriptor", 
        "syntax": "inspect.ismethoddescriptor(object)", 
        "type": "Runtime"
    }, 
    "inspect.ismodule": {
        "descr": "Return true if the object is a module.", 
        "name": "inspect.ismodule", 
        "params": [], 
        "path": "python/library/inspect#inspect.ismodule", 
        "syntax": "inspect.ismodule(object)", 
        "type": "Runtime"
    }, 
    "inspect.isroutine": {
        "descr": "Return true if the object is a user-defined or built-in function or method.", 
        "name": "inspect.isroutine", 
        "params": [], 
        "path": "python/library/inspect#inspect.isroutine", 
        "syntax": "inspect.isroutine(object)", 
        "type": "Runtime"
    }, 
    "inspect.istraceback": {
        "descr": "Return true if the object is a traceback.", 
        "name": "inspect.istraceback", 
        "params": [], 
        "path": "python/library/inspect#inspect.istraceback", 
        "syntax": "inspect.istraceback(object)", 
        "type": "Runtime"
    }, 
    "inspect.signature": {
        "descr": "Return a Signature object for the given callable:", 
        "name": "inspect.signature", 
        "params": [], 
        "path": "python/library/inspect#inspect.signature", 
        "syntax": "inspect.signature(callable)", 
        "type": "Runtime"
    }, 
    "inspect.stack": {
        "descr": "Return a list of frame records for the caller\u2019s stack. The first entry in the returned list represents the caller; the last entry represents the outermost call on the stack.", 
        "name": "inspect.stack", 
        "params": [], 
        "path": "python/library/inspect#inspect.stack", 
        "syntax": "inspect.stack(context=1)", 
        "type": "Runtime"
    }, 
    "inspect.trace": {
        "descr": "Return a list of frame records for the stack between the current frame and the frame in which an exception currently being handled was raised in. The first entry in the list represents the caller; the last entry represents where the exception was raised.", 
        "name": "inspect.trace", 
        "params": [], 
        "path": "python/library/inspect#inspect.trace", 
        "syntax": "inspect.trace(context=1)", 
        "type": "Runtime"
    }, 
    "instance.__class__": {
        "descr": "The class to which a class instance belongs.", 
        "name": "instance.__class__", 
        "params": [], 
        "path": "python/library/stdtypes#instance.__class__", 
        "syntax": "instance.__class__", 
        "type": "Built-in Types"
    }, 
    "int": {
        "descr": "Convert a number or string x to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero.", 
        "name": "int", 
        "params": [], 
        "path": "python/library/functions#int", 
        "syntax": "int(x=0)", 
        "type": "Built-in Functions"
    }, 
    "int.bit_length": {
        "descr": "Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros:", 
        "name": "int.bit_length", 
        "params": [], 
        "path": "python/library/stdtypes#int.bit_length", 
        "syntax": "int.bit_length()", 
        "type": "Built-in Types"
    }, 
    "int.from_bytes": {
        "descr": "Return the integer represented by the given array of bytes.", 
        "name": "int.from_bytes", 
        "params": [], 
        "path": "python/library/stdtypes#int.from_bytes", 
        "syntax": "classmethod int.from_bytes(bytes, byteorder, *, signed=False)", 
        "type": "Built-in Types"
    }, 
    "int.to_bytes": {
        "descr": "Return an array of bytes representing an integer.", 
        "name": "int.to_bytes", 
        "params": [], 
        "path": "python/library/stdtypes#int.to_bytes", 
        "syntax": "int.to_bytes(length, byteorder, *, signed=False)", 
        "type": "Built-in Types"
    }, 
    "io.BlockingIOError": {
        "descr": "This is a compatibility alias for the builtin BlockingIOError exception.", 
        "name": "io.BlockingIOError", 
        "params": [], 
        "path": "python/library/io#io.BlockingIOError", 
        "syntax": "exception io.BlockingIOError", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase": {
        "descr": "Base class for binary streams that support some kind of buffering. It inherits IOBase. There is no public constructor.", 
        "name": "io.BufferedIOBase", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase", 
        "syntax": "class io.BufferedIOBase", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase.detach": {
        "descr": "Separate the underlying raw stream from the buffer and return it.", 
        "name": "io.BufferedIOBase.detach", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase.detach", 
        "syntax": "detach()", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase.raw": {
        "descr": "The underlying raw stream (a RawIOBase instance) that BufferedIOBase deals with. This is not part of the BufferedIOBase API and may not exist on some implementations.", 
        "name": "io.BufferedIOBase.raw", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase.raw", 
        "syntax": "raw", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase.read": {
        "descr": "Read and return up to n bytes, with at most one call to the underlying raw stream\u2019s read() method. This can be useful if you are implementing your own buffering on top of a BufferedIOBase object.", 
        "name": "io.BufferedIOBase.read", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase.read", 
        "syntax": "read1(n=-1)", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase.read1": {
        "descr": "Read and return up to n bytes, with at most one call to the underlying raw stream\u2019s read() method. This can be useful if you are implementing your own buffering on top of a BufferedIOBase object.", 
        "name": "io.BufferedIOBase.read1", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase.read1", 
        "syntax": "read1(n=-1)", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase.readinto": {
        "descr": "Read up to len(b) bytes into bytearray b and return the number of bytes read.", 
        "name": "io.BufferedIOBase.readinto", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase.readinto", 
        "syntax": "readinto(b)", 
        "type": "Operating System"
    }, 
    "io.BufferedIOBase.write": {
        "descr": "Write the given bytes or bytearray object, b and return the number of bytes written (never less than len(b), since if the write fails an OSError will be raised). Depending on the actual implementation, these bytes may be readily written to the underlying stream, or held in a buffer for performance and latency reasons.", 
        "name": "io.BufferedIOBase.write", 
        "params": [], 
        "path": "python/library/io#io.BufferedIOBase.write", 
        "syntax": "write(b)", 
        "type": "Operating System"
    }, 
    "io.BufferedRWPair": {
        "descr": "A buffered I/O object combining two unidirectional RawIOBase objects \u2013 one readable, the other writeable \u2013 into a single bidirectional endpoint. It inherits BufferedIOBase.", 
        "name": "io.BufferedRWPair", 
        "params": [], 
        "path": "python/library/io#io.BufferedRWPair", 
        "syntax": "class io.BufferedRWPair(reader, writer, buffer_size=DEFAULT_BUFFER_SIZE)", 
        "type": "Operating System"
    }, 
    "io.BufferedRandom": {
        "descr": "A buffered interface to random access streams. It inherits BufferedReader and BufferedWriter, and further supports seek() and tell() functionality.", 
        "name": "io.BufferedRandom", 
        "params": [], 
        "path": "python/library/io#io.BufferedRandom", 
        "syntax": "class io.BufferedRandom(raw, buffer_size=DEFAULT_BUFFER_SIZE)", 
        "type": "Operating System"
    }, 
    "io.BufferedReader": {
        "descr": "A buffer providing higher-level access to a readable, sequential RawIOBase object. It inherits BufferedIOBase. When reading data from this object, a larger amount of data may be requested from the underlying raw stream, and kept in an internal buffer. The buffered data can then be returned directly on subsequent reads.", 
        "name": "io.BufferedReader", 
        "params": [], 
        "path": "python/library/io#io.BufferedReader", 
        "syntax": "class io.BufferedReader(raw, buffer_size=DEFAULT_BUFFER_SIZE)", 
        "type": "Operating System"
    }, 
    "io.BufferedReader.peek": {
        "descr": "Return bytes from the stream without advancing the position. At most one single read on the raw stream is done to satisfy the call. The number of bytes returned may be less or more than requested.", 
        "name": "io.BufferedReader.peek", 
        "params": [], 
        "path": "python/library/io#io.BufferedReader.peek", 
        "syntax": "peek([n])", 
        "type": "Operating System"
    }, 
    "io.BufferedReader.read": {
        "descr": "Read and return up to n bytes with only one call on the raw stream. If at least one byte is buffered, only buffered bytes are returned. Otherwise, one raw stream read call is made.", 
        "name": "io.BufferedReader.read", 
        "params": [], 
        "path": "python/library/io#io.BufferedReader.read", 
        "syntax": "read1(n)", 
        "type": "Operating System"
    }, 
    "io.BufferedReader.read1": {
        "descr": "Read and return up to n bytes with only one call on the raw stream. If at least one byte is buffered, only buffered bytes are returned. Otherwise, one raw stream read call is made.", 
        "name": "io.BufferedReader.read1", 
        "params": [], 
        "path": "python/library/io#io.BufferedReader.read1", 
        "syntax": "read1(n)", 
        "type": "Operating System"
    }, 
    "io.BufferedWriter": {
        "descr": "A buffer providing higher-level access to a writeable, sequential RawIOBase object. It inherits BufferedIOBase. When writing to this object, data is normally placed into an internal buffer. The buffer will be written out to the underlying RawIOBase object under various conditions, including:", 
        "name": "io.BufferedWriter", 
        "params": [], 
        "path": "python/library/io#io.BufferedWriter", 
        "syntax": "class io.BufferedWriter(raw, buffer_size=DEFAULT_BUFFER_SIZE)", 
        "type": "Operating System"
    }, 
    "io.BufferedWriter.flush": {
        "descr": "Force bytes held in the buffer into the raw stream. A BlockingIOError should be raised if the raw stream blocks.", 
        "name": "io.BufferedWriter.flush", 
        "params": [], 
        "path": "python/library/io#io.BufferedWriter.flush", 
        "syntax": "flush()", 
        "type": "Operating System"
    }, 
    "io.BufferedWriter.write": {
        "descr": "Write the bytes or bytearray object, b and return the number of bytes written. When in non-blocking mode, a BlockingIOError is raised if the buffer needs to be written out but the raw stream blocks.", 
        "name": "io.BufferedWriter.write", 
        "params": [], 
        "path": "python/library/io#io.BufferedWriter.write", 
        "syntax": "write(b)", 
        "type": "Operating System"
    }, 
    "io.BytesIO": {
        "descr": "A stream implementation using an in-memory bytes buffer. It inherits BufferedIOBase.", 
        "name": "io.BytesIO", 
        "params": [], 
        "path": "python/library/io#io.BytesIO", 
        "syntax": "class io.BytesIO([initial_bytes])", 
        "type": "Operating System"
    }, 
    "io.BytesIO.getbuffer": {
        "descr": "Return a readable and writable view over the contents of the buffer without copying them. Also, mutating the view will transparently update the contents of the buffer:", 
        "name": "io.BytesIO.getbuffer", 
        "params": [], 
        "path": "python/library/io#io.BytesIO.getbuffer", 
        "syntax": "getbuffer()", 
        "type": "Operating System"
    }, 
    "io.BytesIO.getvalue": {
        "descr": "Return bytes containing the entire contents of the buffer.", 
        "name": "io.BytesIO.getvalue", 
        "params": [], 
        "path": "python/library/io#io.BytesIO.getvalue", 
        "syntax": "getvalue()", 
        "type": "Operating System"
    }, 
    "io.BytesIO.read1": {
        "descr": "In BytesIO, this is the same as read().", 
        "name": "io.BytesIO.read1", 
        "params": [], 
        "path": "python/library/io#io.BytesIO.read1", 
        "syntax": "read1()", 
        "type": "Operating System"
    }, 
    "io.FileIO": {
        "descr": "FileIO represents an OS-level file containing bytes data. It implements the RawIOBase interface (and therefore the IOBase interface, too).", 
        "name": "io.FileIO", 
        "params": [], 
        "path": "python/library/io#io.FileIO", 
        "syntax": "class io.FileIO(name, mode='r', closefd=True, opener=None)", 
        "type": "Operating System"
    }, 
    "io.FileIO.mode": {
        "descr": "The mode as given in the constructor.", 
        "name": "io.FileIO.mode", 
        "params": [], 
        "path": "python/library/io#io.FileIO.mode", 
        "syntax": "mode", 
        "type": "Operating System"
    }, 
    "io.FileIO.name": {
        "descr": "The file name. This is the file descriptor of the file when no name is given in the constructor.", 
        "name": "io.FileIO.name", 
        "params": [], 
        "path": "python/library/io#io.FileIO.name", 
        "syntax": "name", 
        "type": "Operating System"
    }, 
    "io.IOBase": {
        "descr": "The abstract base class for all I/O classes, acting on streams of bytes. There is no public constructor.", 
        "name": "io.IOBase", 
        "params": [], 
        "path": "python/library/io#io.IOBase", 
        "syntax": "class io.IOBase", 
        "type": "Operating System"
    }, 
    "io.IOBase.close": {
        "descr": "Flush and close this stream. This method has no effect if the file is already closed. Once the file is closed, any operation on the file (e.g. reading or writing) will raise a ValueError.", 
        "name": "io.IOBase.close", 
        "params": [], 
        "path": "python/library/io#io.IOBase.close", 
        "syntax": "close()", 
        "type": "Operating System"
    }, 
    "io.IOBase.closed": {
        "descr": "True if the stream is closed.", 
        "name": "io.IOBase.closed", 
        "params": [], 
        "path": "python/library/io#io.IOBase.closed", 
        "syntax": "closed", 
        "type": "Operating System"
    }, 
    "io.IOBase.fileno": {
        "descr": "Return the underlying file descriptor (an integer) of the stream if it exists. An OSError is raised if the IO object does not use a file descriptor.", 
        "name": "io.IOBase.fileno", 
        "params": [], 
        "path": "python/library/io#io.IOBase.fileno", 
        "syntax": "fileno()", 
        "type": "Operating System"
    }, 
    "io.IOBase.flush": {
        "descr": "Flush the write buffers of the stream if applicable. This does nothing for read-only and non-blocking streams.", 
        "name": "io.IOBase.flush", 
        "params": [], 
        "path": "python/library/io#io.IOBase.flush", 
        "syntax": "flush()", 
        "type": "Operating System"
    }, 
    "io.IOBase.isatty": {
        "descr": "Return True if the stream is interactive (i.e., connected to a terminal/tty device).", 
        "name": "io.IOBase.isatty", 
        "params": [], 
        "path": "python/library/io#io.IOBase.isatty", 
        "syntax": "isatty()", 
        "type": "Operating System"
    }, 
    "io.IOBase.readable": {
        "descr": "Return True if the stream can be read from. If False, read() will raise OSError.", 
        "name": "io.IOBase.readable", 
        "params": [], 
        "path": "python/library/io#io.IOBase.readable", 
        "syntax": "readable()", 
        "type": "Operating System"
    }, 
    "io.IOBase.readline": {
        "descr": "Read and return one line from the stream. If limit is specified, at most limit bytes will be read.", 
        "name": "io.IOBase.readline", 
        "params": [], 
        "path": "python/library/io#io.IOBase.readline", 
        "syntax": "readline(limit=-1)", 
        "type": "Operating System"
    }, 
    "io.IOBase.readlines": {
        "descr": "Read and return a list of lines from the stream. hint can be specified to control the number of lines read: no more lines will be read if the total size (in bytes/characters) of all lines so far exceeds hint.", 
        "name": "io.IOBase.readlines", 
        "params": [], 
        "path": "python/library/io#io.IOBase.readlines", 
        "syntax": "readlines(hint=-1)", 
        "type": "Operating System"
    }, 
    "io.IOBase.seek": {
        "descr": "Change the stream position to the given byte offset. offset is interpreted relative to the position indicated by whence. Values for whence are:", 
        "name": "io.IOBase.seek", 
        "params": [], 
        "path": "python/library/io#io.IOBase.seek", 
        "syntax": "seek(offset, whence=SEEK_SET)", 
        "type": "Operating System"
    }, 
    "io.IOBase.seekable": {
        "descr": "Return True if the stream supports random access. If False, seek(), tell() and truncate() will raise OSError.", 
        "name": "io.IOBase.seekable", 
        "params": [], 
        "path": "python/library/io#io.IOBase.seekable", 
        "syntax": "seekable()", 
        "type": "Operating System"
    }, 
    "io.IOBase.tell": {
        "descr": "Return the current stream position.", 
        "name": "io.IOBase.tell", 
        "params": [], 
        "path": "python/library/io#io.IOBase.tell", 
        "syntax": "tell()", 
        "type": "Operating System"
    }, 
    "io.IOBase.truncate": {
        "descr": "Resize the stream to the given size in bytes (or the current position if size is not specified). The current stream position isn\u2019t changed. This resizing can extend or reduce the current file size. In case of extension, the contents of the new file area depend on the platform (on most systems, additional bytes are zero-filled, on Windows they\u2019re undetermined). The new file size is returned.", 
        "name": "io.IOBase.truncate", 
        "params": [], 
        "path": "python/library/io#io.IOBase.truncate", 
        "syntax": "truncate(size=None)", 
        "type": "Operating System"
    }, 
    "io.IOBase.writable": {
        "descr": "Return True if the stream supports writing. If False, write() and truncate() will raise OSError.", 
        "name": "io.IOBase.writable", 
        "params": [], 
        "path": "python/library/io#io.IOBase.writable", 
        "syntax": "writable()", 
        "type": "Operating System"
    }, 
    "io.IOBase.writelines": {
        "descr": "Write a list of lines to the stream. Line separators are not added, so it is usual for each of the lines provided to have a line separator at the end.", 
        "name": "io.IOBase.writelines", 
        "params": [], 
        "path": "python/library/io#io.IOBase.writelines", 
        "syntax": "writelines(lines)", 
        "type": "Operating System"
    }, 
    "io.IncrementalNewlineDecoder": {
        "descr": "A helper codec that decodes newlines for universal newlines mode. It inherits codecs.IncrementalDecoder.", 
        "name": "io.IncrementalNewlineDecoder", 
        "params": [], 
        "path": "python/library/io#io.IncrementalNewlineDecoder", 
        "syntax": "class io.IncrementalNewlineDecoder", 
        "type": "Operating System"
    }, 
    "io.RawIOBase": {
        "descr": "Base class for raw binary I/O. It inherits IOBase. There is no public constructor.", 
        "name": "io.RawIOBase", 
        "params": [], 
        "path": "python/library/io#io.RawIOBase", 
        "syntax": "class io.RawIOBase", 
        "type": "Operating System"
    }, 
    "io.RawIOBase.read": {
        "descr": "Read up to n bytes from the object and return them. As a convenience, if n is unspecified or -1, readall() is called. Otherwise, only one system call is ever made. Fewer than n bytes may be returned if the operating system call returns fewer than n bytes.", 
        "name": "io.RawIOBase.read", 
        "params": [], 
        "path": "python/library/io#io.RawIOBase.read", 
        "syntax": "read(n=-1)", 
        "type": "Operating System"
    }, 
    "io.RawIOBase.readall": {
        "descr": "Read and return all the bytes from the stream until EOF, using multiple calls to the stream if necessary.", 
        "name": "io.RawIOBase.readall", 
        "params": [], 
        "path": "python/library/io#io.RawIOBase.readall", 
        "syntax": "readall()", 
        "type": "Operating System"
    }, 
    "io.RawIOBase.readinto": {
        "descr": "Read up to len(b) bytes into bytearray b and return the number of bytes read. If the object is in non-blocking mode and no bytes are available, None is returned.", 
        "name": "io.RawIOBase.readinto", 
        "params": [], 
        "path": "python/library/io#io.RawIOBase.readinto", 
        "syntax": "readinto(b)", 
        "type": "Operating System"
    }, 
    "io.RawIOBase.write": {
        "descr": "Write the given bytes or bytearray object, b, to the underlying raw stream and return the number of bytes written. This can be less than len(b), depending on specifics of the underlying raw stream, and especially if it is in non-blocking mode. None is returned if the raw stream is set not to block and no single byte could be readily written to it.", 
        "name": "io.RawIOBase.write", 
        "params": [], 
        "path": "python/library/io#io.RawIOBase.write", 
        "syntax": "write(b)", 
        "type": "Operating System"
    }, 
    "io.StringIO": {
        "descr": "An in-memory stream for text I/O.", 
        "name": "io.StringIO", 
        "params": [], 
        "path": "python/library/io#io.StringIO", 
        "syntax": "class io.StringIO(initial_value='', newline='\\n')", 
        "type": "Operating System"
    }, 
    "io.StringIO.getvalue": {
        "descr": "Return a str containing the entire contents of the buffer at any time before the StringIO object\u2019s close() method is called.", 
        "name": "io.StringIO.getvalue", 
        "params": [], 
        "path": "python/library/io#io.StringIO.getvalue", 
        "syntax": "getvalue()", 
        "type": "Operating System"
    }, 
    "io.TextIOBase": {
        "descr": "Base class for text streams. This class provides a character and line based interface to stream I/O. There is no readinto() method because Python\u2019s character strings are immutable. It inherits IOBase. There is no public constructor.", 
        "name": "io.TextIOBase", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase", 
        "syntax": "class io.TextIOBase", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.buffer": {
        "descr": "The underlying binary buffer (a BufferedIOBase instance) that TextIOBase deals with. This is not part of the TextIOBase API and may not exist in some implementations.", 
        "name": "io.TextIOBase.buffer", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.buffer", 
        "syntax": "buffer", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.detach": {
        "descr": "Separate the underlying binary buffer from the TextIOBase and return it.", 
        "name": "io.TextIOBase.detach", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.detach", 
        "syntax": "detach()", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.encoding": {
        "descr": "The name of the encoding used to decode the stream\u2019s bytes into strings, and to encode strings into bytes.", 
        "name": "io.TextIOBase.encoding", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.encoding", 
        "syntax": "encoding", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.errors": {
        "descr": "The error setting of the decoder or encoder.", 
        "name": "io.TextIOBase.errors", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.errors", 
        "syntax": "errors", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.newlines": {
        "descr": "A string, a tuple of strings, or None, indicating the newlines translated so far. Depending on the implementation and the initial constructor flags, this may not be available.", 
        "name": "io.TextIOBase.newlines", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.newlines", 
        "syntax": "newlines", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.read": {
        "descr": "Read and return at most n characters from the stream as a single str. If n is negative or None, reads until EOF.", 
        "name": "io.TextIOBase.read", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.read", 
        "syntax": "read(n)", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.readline": {
        "descr": "Read until newline or EOF and return a single str. If the stream is already at EOF, an empty string is returned.", 
        "name": "io.TextIOBase.readline", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.readline", 
        "syntax": "readline(limit=-1)", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.seek": {
        "descr": "Change the stream position to the given offset. Behaviour depends on the whence parameter:", 
        "name": "io.TextIOBase.seek", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.seek", 
        "syntax": "seek(offset, whence=SEEK_SET)", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.tell": {
        "descr": "Return the current stream position as an opaque number. The number does not usually represent a number of bytes in the underlying binary storage.", 
        "name": "io.TextIOBase.tell", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.tell", 
        "syntax": "tell()", 
        "type": "Operating System"
    }, 
    "io.TextIOBase.write": {
        "descr": "Write the string s to the stream and return the number of characters written.", 
        "name": "io.TextIOBase.write", 
        "params": [], 
        "path": "python/library/io#io.TextIOBase.write", 
        "syntax": "write(s)", 
        "type": "Operating System"
    }, 
    "io.TextIOWrapper": {
        "descr": "A buffered text stream over a BufferedIOBase binary stream. It inherits TextIOBase.", 
        "name": "io.TextIOWrapper", 
        "params": [], 
        "path": "python/library/io#io.TextIOWrapper", 
        "syntax": "class io.TextIOWrapper(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)", 
        "type": "Operating System"
    }, 
    "io.TextIOWrapper.line_buffering": {
        "descr": "Whether line buffering is enabled.", 
        "name": "io.TextIOWrapper.line_buffering", 
        "params": [], 
        "path": "python/library/io#io.TextIOWrapper.line_buffering", 
        "syntax": "line_buffering", 
        "type": "Operating System"
    }, 
    "io.UnsupportedOperation": {
        "descr": "An exception inheriting OSError and ValueError that is raised when an unsupported operation is called on a stream.", 
        "name": "io.UnsupportedOperation", 
        "params": [], 
        "path": "python/library/io#io.UnsupportedOperation", 
        "syntax": "exception io.UnsupportedOperation", 
        "type": "Operating System"
    }, 
    "io.open": {
        "descr": "This is an alias for the builtin open() function.", 
        "name": "io.open", 
        "params": [], 
        "path": "python/library/io#io.open", 
        "syntax": "io.open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)", 
        "type": "Operating System"
    }, 
    "ipaddress.AddressValueError": {
        "descr": "Any value error related to the address.", 
        "name": "ipaddress.AddressValueError", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.AddressValueError", 
        "syntax": "exception ipaddress.AddressValueError(ValueError)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address": {
        "descr": "Construct an IPv4 address. An AddressValueError is raised if address is not a valid IPv4 address.", 
        "name": "ipaddress.IPv4Address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address", 
        "syntax": "class ipaddress.IPv4Address(address)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.compressed": {
        "descr": "The string representation in dotted decimal notation. Leading zeroes are never included in the representation.", 
        "name": "ipaddress.IPv4Address.compressed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.compressed", 
        "syntax": "compressed", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.exploded": {
        "descr": "The string representation in dotted decimal notation. Leading zeroes are never included in the representation.", 
        "name": "ipaddress.IPv4Address.exploded", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.exploded", 
        "syntax": "exploded", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.is_link_local": {
        "descr": "True if the address is reserved for link-local usage. See RFC 3927.", 
        "name": "ipaddress.IPv4Address.is_link_local", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.is_link_local", 
        "syntax": "is_link_local", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.is_loopback": {
        "descr": "True if this is a loopback address. See RFC 3330 (for IPv4) or RFC 2373 (for IPv6).", 
        "name": "ipaddress.IPv4Address.is_loopback", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.is_loopback", 
        "syntax": "is_loopback", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.is_multicast": {
        "descr": "True if the address is reserved for multicast use. See RFC 3171 (for IPv4) or RFC 2373 (for IPv6).", 
        "name": "ipaddress.IPv4Address.is_multicast", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.is_multicast", 
        "syntax": "is_multicast", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.is_private": {
        "descr": "True if the address is allocated for private networks. See RFC 1918 (for IPv4) or RFC 4193 (for IPv6).", 
        "name": "ipaddress.IPv4Address.is_private", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.is_private", 
        "syntax": "is_private", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.is_reserved": {
        "descr": "True if the address is otherwise IETF reserved.", 
        "name": "ipaddress.IPv4Address.is_reserved", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.is_reserved", 
        "syntax": "is_reserved", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.is_unspecified": {
        "descr": "True if the address is unspecified. See RFC 5735 (for IPv4) or RFC 2373 (for IPv6).", 
        "name": "ipaddress.IPv4Address.is_unspecified", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.is_unspecified", 
        "syntax": "is_unspecified", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.max_prefixlen": {
        "descr": "The total number of bits in the address representation for this version: 32 for IPv4, 128 for IPv6.", 
        "name": "ipaddress.IPv4Address.max_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.max_prefixlen", 
        "syntax": "max_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.packed": {
        "descr": "The binary representation of this address - a bytes object of the appropriate length (most significant octet first). This is 4 bytes for IPv4 and 16 bytes for IPv6.", 
        "name": "ipaddress.IPv4Address.packed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.packed", 
        "syntax": "packed", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Address.version": {
        "descr": "The appropriate version number: 4 for IPv4, 6 for IPv6.", 
        "name": "ipaddress.IPv4Address.version", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Address.version", 
        "syntax": "version", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Interface": {
        "descr": "Construct an IPv4 interface. The meaning of address is as in the constructor of IPv4Network, except that arbitrary host addresses are always accepted.", 
        "name": "ipaddress.IPv4Interface", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Interface", 
        "syntax": "class ipaddress.IPv4Interface(address)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Interface.ip": {
        "descr": "The address (IPv4Address) without network information.", 
        "name": "ipaddress.IPv4Interface.ip", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Interface.ip", 
        "syntax": "ip", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Interface.network": {
        "descr": "The network (IPv4Network) this interface belongs to.", 
        "name": "ipaddress.IPv4Interface.network", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Interface.network", 
        "syntax": "network", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Interface.with_hostmask": {
        "descr": "A string representation of the interface with the network as a host mask.", 
        "name": "ipaddress.IPv4Interface.with_hostmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Interface.with_hostmask", 
        "syntax": "with_hostmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Interface.with_netmask": {
        "descr": "A string representation of the interface with the network as a net mask.", 
        "name": "ipaddress.IPv4Interface.with_netmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Interface.with_netmask", 
        "syntax": "with_netmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Interface.with_prefixlen": {
        "descr": "A string representation of the interface with the mask in prefix notation.", 
        "name": "ipaddress.IPv4Interface.with_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Interface.with_prefixlen", 
        "syntax": "with_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network": {
        "descr": "Construct an IPv4 network definition. address can be one of the following:", 
        "name": "ipaddress.IPv4Network", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network", 
        "syntax": "class ipaddress.IPv4Network(address, strict=True)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.address_exclude": {
        "descr": "Computes the network definitions resulting from removing the given network from this one. Returns an iterator of network objects. Raises ValueError if network is not completely contained in this network.", 
        "name": "ipaddress.IPv4Network.address_exclude", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.address_exclude", 
        "syntax": "address_exclude(network)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.broadcast_address": {
        "descr": "The broadcast address for the network. Packets sent to the broadcast address should be received by every host on the network.", 
        "name": "ipaddress.IPv4Network.broadcast_address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.broadcast_address", 
        "syntax": "broadcast_address", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.compare_networks": {
        "descr": "Compare this network to other. In this comparison only the network addresses are considered; host bits aren\u2019t. Returns either -1, 0 or 1.", 
        "name": "ipaddress.IPv4Network.compare_networks", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.compare_networks", 
        "syntax": "compare_networks(other)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.compressed": {
        "descr": "A string representation of the network, with the mask in prefix notation.", 
        "name": "ipaddress.IPv4Network.compressed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.compressed", 
        "syntax": "compressed", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.exploded": {
        "descr": "A string representation of the network, with the mask in prefix notation.", 
        "name": "ipaddress.IPv4Network.exploded", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.exploded", 
        "syntax": "exploded", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.hostmask": {
        "descr": "The host mask, as a string.", 
        "name": "ipaddress.IPv4Network.hostmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.hostmask", 
        "syntax": "hostmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.hosts": {
        "descr": "Returns an iterator over the usable hosts in the network. The usable hosts are all the IP addresses that belong to the network, except the network address itself and the network broadcast address.", 
        "name": "ipaddress.IPv4Network.hosts", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.hosts", 
        "syntax": "hosts()", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.is_link_local": {
        "descr": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv4Network.is_link_local", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.is_link_local", 
        "syntax": "is_link_local", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.is_loopback": {
        "descr": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv4Network.is_loopback", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.is_loopback", 
        "syntax": "is_loopback", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.is_multicast": {
        "descr": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv4Network.is_multicast", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.is_multicast", 
        "syntax": "is_multicast", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.is_private": {
        "descr": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv4Network.is_private", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.is_private", 
        "syntax": "is_private", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.is_reserved": {
        "descr": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv4Network.is_reserved", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.is_reserved", 
        "syntax": "is_reserved", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.is_unspecified": {
        "descr": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv4Network.is_unspecified", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.is_unspecified", 
        "syntax": "is_unspecified", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.max_prefixlen": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv4Network.max_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.max_prefixlen", 
        "syntax": "max_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.network_address": {
        "descr": "The network address for the network. The network address and the prefix length together uniquely define a network.", 
        "name": "ipaddress.IPv4Network.network_address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.network_address", 
        "syntax": "network_address", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.num_addresses": {
        "descr": "The total number of addresses in the network.", 
        "name": "ipaddress.IPv4Network.num_addresses", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.num_addresses", 
        "syntax": "num_addresses", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.overlaps": {
        "descr": "True if this network is partly or wholly contained in other or other is wholly contained in this network.", 
        "name": "ipaddress.IPv4Network.overlaps", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.overlaps", 
        "syntax": "overlaps(other)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.prefixlen": {
        "descr": "Length of the network prefix, in bits.", 
        "name": "ipaddress.IPv4Network.prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.prefixlen", 
        "syntax": "prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.subnets": {
        "descr": "The subnets that join to make the current network definition, depending on the argument values. prefixlen_diff is the amount our prefix length should be increased by. new_prefix is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of prefixlen_diff and new_prefix must be set. Returns an iterator of network objects.", 
        "name": "ipaddress.IPv4Network.subnets", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.subnets", 
        "syntax": "subnets(prefixlen_diff=1, new_prefix=None)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.supernet": {
        "descr": "The supernet containing this network definition, depending on the argument values. prefixlen_diff is the amount our prefix length should be decreased by. new_prefix is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of prefixlen_diff and new_prefix must be set. Returns a single network object.", 
        "name": "ipaddress.IPv4Network.supernet", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.supernet", 
        "syntax": "supernet(prefixlen_diff=1, new_prefix=None)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.version": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv4Network.version", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.version", 
        "syntax": "version", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.with_hostmask": {
        "descr": "A string representation of the network, with the mask in host mask notation.", 
        "name": "ipaddress.IPv4Network.with_hostmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.with_hostmask", 
        "syntax": "with_hostmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.with_netmask": {
        "descr": "A string representation of the network, with the mask in net mask notation.", 
        "name": "ipaddress.IPv4Network.with_netmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.with_netmask", 
        "syntax": "with_netmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv4Network.with_prefixlen": {
        "descr": "A string representation of the network, with the mask in prefix notation.", 
        "name": "ipaddress.IPv4Network.with_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv4Network.with_prefixlen", 
        "syntax": "with_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address": {
        "descr": "Construct an IPv6 address. An AddressValueError is raised if address is not a valid IPv6 address.", 
        "name": "ipaddress.IPv6Address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address", 
        "syntax": "class ipaddress.IPv6Address(address)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.compressed": {
        "descr": "The short form of the address representation, with leading zeroes in groups omitted and the longest sequence of groups consisting entirely of zeroes collapsed to a single empty group.", 
        "name": "ipaddress.IPv6Address.compressed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.compressed", 
        "syntax": "compressed", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.exploded": {
        "descr": "The long form of the address representation, with all leading zeroes and groups consisting entirely of zeroes included.", 
        "name": "ipaddress.IPv6Address.exploded", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.exploded", 
        "syntax": "exploded", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.ipv4_mapped": {
        "descr": "For addresses that appear to be IPv4 mapped addresses (starting with ::FFFF/96), this property will report the embedded IPv4 address. For any other address, this property will be None.", 
        "name": "ipaddress.IPv6Address.ipv4_mapped", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.ipv4_mapped", 
        "syntax": "ipv4_mapped", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_link_local": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.is_link_local", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_link_local", 
        "syntax": "is_link_local", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_loopback": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.is_loopback", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_loopback", 
        "syntax": "is_loopback", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_multicast": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.is_multicast", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_multicast", 
        "syntax": "is_multicast", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_private": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.is_private", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_private", 
        "syntax": "is_private", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_reserved": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.is_reserved", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_reserved", 
        "syntax": "is_reserved", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_site_local": {
        "descr": "True if the address is reserved for site-local usage. Note that the site-local address space has been deprecated by RFC 3879. Use is_private to test if this address is in the space of unique local addresses as defined by RFC 4193.", 
        "name": "ipaddress.IPv6Address.is_site_local", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_site_local", 
        "syntax": "is_site_local", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.is_unspecified": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.is_unspecified", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.is_unspecified", 
        "syntax": "is_unspecified", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.max_prefixlen": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.max_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.max_prefixlen", 
        "syntax": "max_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.packed": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.packed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.packed", 
        "syntax": "packed", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.sixtofour": {
        "descr": "For addresses that appear to be 6to4 addresses (starting with 2002::/16) as defined by RFC 3056, this property will report the embedded IPv4 address. For any other address, this property will be None.", 
        "name": "ipaddress.IPv6Address.sixtofour", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.sixtofour", 
        "syntax": "sixtofour", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.teredo": {
        "descr": "For addresses that appear to be Teredo addresses (starting with 2001::/32) as defined by RFC 4380, this property will report the embedded (server, client) IP address pair. For any other address, this property will be None.", 
        "name": "ipaddress.IPv6Address.teredo", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.teredo", 
        "syntax": "teredo", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Address.version": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Address", 
        "name": "ipaddress.IPv6Address.version", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Address.version", 
        "syntax": "version", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Interface": {
        "descr": "Construct an IPv6 interface. The meaning of address is as in the constructor of IPv6Network, except that arbitrary host addresses are always accepted.", 
        "name": "ipaddress.IPv6Interface", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Interface", 
        "syntax": "class ipaddress.IPv6Interface(address)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Interface.ip": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Interface.", 
        "name": "ipaddress.IPv6Interface.ip", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Interface.ip", 
        "syntax": "ip", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Interface.network": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Interface.", 
        "name": "ipaddress.IPv6Interface.network", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Interface.network", 
        "syntax": "network", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Interface.with_hostmask": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Interface.", 
        "name": "ipaddress.IPv6Interface.with_hostmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Interface.with_hostmask", 
        "syntax": "with_hostmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Interface.with_netmask": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Interface.", 
        "name": "ipaddress.IPv6Interface.with_netmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Interface.with_netmask", 
        "syntax": "with_netmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Interface.with_prefixlen": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Interface.", 
        "name": "ipaddress.IPv6Interface.with_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Interface.with_prefixlen", 
        "syntax": "with_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network": {
        "descr": "Construct an IPv6 network definition. address can be one of the following:", 
        "name": "ipaddress.IPv6Network", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network", 
        "syntax": "class ipaddress.IPv6Network(address, strict=True)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.address_exclude": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.address_exclude", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.address_exclude", 
        "syntax": "address_exclude(network)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.broadcast_address": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.broadcast_address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.broadcast_address", 
        "syntax": "broadcast_address", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.compare_networks": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.compare_networks", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.compare_networks", 
        "syntax": "compare_networks(other)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.compressed": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.compressed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.compressed", 
        "syntax": "compressed", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.exploded": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.exploded", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.exploded", 
        "syntax": "exploded", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.hostmask": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.hostmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.hostmask", 
        "syntax": "hostmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.hosts": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.hosts", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.hosts", 
        "syntax": "hosts()", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_link_local": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.is_link_local", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_link_local", 
        "syntax": "is_link_local", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_loopback": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.is_loopback", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_loopback", 
        "syntax": "is_loopback", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_multicast": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.is_multicast", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_multicast", 
        "syntax": "is_multicast", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_private": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.is_private", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_private", 
        "syntax": "is_private", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_reserved": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.is_reserved", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_reserved", 
        "syntax": "is_reserved", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_site_local": {
        "descr": "These attribute is true for the network as a whole if it is true for both the network address and the broadcast address", 
        "name": "ipaddress.IPv6Network.is_site_local", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_site_local", 
        "syntax": "is_site_local", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.is_unspecified": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.is_unspecified", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.is_unspecified", 
        "syntax": "is_unspecified", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.max_prefixlen": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.max_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.max_prefixlen", 
        "syntax": "max_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.network_address": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.network_address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.network_address", 
        "syntax": "network_address", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.num_addresses": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.num_addresses", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.num_addresses", 
        "syntax": "num_addresses", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.overlaps": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.overlaps", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.overlaps", 
        "syntax": "overlaps(other)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.prefixlen": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.prefixlen", 
        "syntax": "prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.subnets": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.subnets", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.subnets", 
        "syntax": "subnets(prefixlen_diff=1, new_prefix=None)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.supernet": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.supernet", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.supernet", 
        "syntax": "supernet(prefixlen_diff=1, new_prefix=None)", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.version": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.version", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.version", 
        "syntax": "version", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.with_hostmask": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.with_hostmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.with_hostmask", 
        "syntax": "with_hostmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.with_netmask": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.with_netmask", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.with_netmask", 
        "syntax": "with_netmask", 
        "type": "Internet"
    }, 
    "ipaddress.IPv6Network.with_prefixlen": {
        "descr": "Refer to the corresponding attribute documentation in IPv4Network", 
        "name": "ipaddress.IPv6Network.with_prefixlen", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.IPv6Network.with_prefixlen", 
        "syntax": "with_prefixlen", 
        "type": "Internet"
    }, 
    "ipaddress.NetmaskValueError": {
        "descr": "Any value error related to the netmask.", 
        "name": "ipaddress.NetmaskValueError", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.NetmaskValueError", 
        "syntax": "exception ipaddress.NetmaskValueError(ValueError)", 
        "type": "Internet"
    }, 
    "ipaddress.collapse_addresses": {
        "descr": "Return an iterator of the collapsed IPv4Network or IPv6Network objects. addresses is an iterator of IPv4Network or IPv6Network objects. A TypeError is raised if addresses contains mixed version objects.", 
        "name": "ipaddress.collapse_addresses", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.collapse_addresses", 
        "syntax": "ipaddress.collapse_addresses(addresses)", 
        "type": "Internet"
    }, 
    "ipaddress.get_mixed_type_key": {
        "descr": "Return a key suitable for sorting between networks and addresses. Address and Network objects are not sortable by default; they\u2019re fundamentally different, so the expression:", 
        "name": "ipaddress.get_mixed_type_key", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.get_mixed_type_key", 
        "syntax": "ipaddress.get_mixed_type_key(obj)", 
        "type": "Internet"
    }, 
    "ipaddress.ip_address": {
        "descr": "Return an IPv4Address or IPv6Address object depending on the IP address passed as argument. Either IPv4 or IPv6 addresses may be supplied; integers less than 2**32 will be considered to be IPv4 by default. A ValueError is raised if address does not represent a valid IPv4 or IPv6 address.", 
        "name": "ipaddress.ip_address", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.ip_address", 
        "syntax": "ipaddress.ip_address(address)", 
        "type": "Internet"
    }, 
    "ipaddress.ip_interface": {
        "descr": "Return an IPv4Interface or IPv6Interface object depending on the IP address passed as argument. address is a string or integer representing the IP address. Either IPv4 or IPv6 addresses may be supplied; integers less than 2**32 will be considered to be IPv4 by default. A ValueError is raised if address does not represent a valid IPv4 or IPv6 address.", 
        "name": "ipaddress.ip_interface", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.ip_interface", 
        "syntax": "ipaddress.ip_interface(address)", 
        "type": "Internet"
    }, 
    "ipaddress.ip_network": {
        "descr": "Return an IPv4Network or IPv6Network object depending on the IP address passed as argument. address is a string or integer representing the IP network. Either IPv4 or IPv6 networks may be supplied; integers less than 2**32 will be considered to be IPv4 by default. strict is passed to IPv4Network or IPv6Network constructor. A ValueError is raised if address does not represent a valid IPv4 or IPv6 address, or if the network has host bits set.", 
        "name": "ipaddress.ip_network", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.ip_network", 
        "syntax": "ipaddress.ip_network(address, strict=True)", 
        "type": "Internet"
    }, 
    "ipaddress.summarize_address_range": {
        "descr": "Return an iterator of the summarized network range given the first and last IP addresses. first is the first IPv4Address or IPv6Address in the range and last is the last IPv4Address or IPv6Address in the range. A TypeError is raised if first or last are not IP addresses or are not of the same version. A ValueError is raised if last is not greater than first or if first address version is not 4 or 6.", 
        "name": "ipaddress.summarize_address_range", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.summarize_address_range", 
        "syntax": "ipaddress.summarize_address_range(first, last)", 
        "type": "Internet"
    }, 
    "ipaddress.v4_int_to_packed": {
        "descr": "Represent an address as 4 packed bytes in network (big-endian) order. address is an integer representation of an IPv4 IP address. A ValueError is raised if the integer is negative or too large to be an IPv4 IP address.", 
        "name": "ipaddress.v4_int_to_packed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.v4_int_to_packed", 
        "syntax": "ipaddress.v4_int_to_packed(address)", 
        "type": "Internet"
    }, 
    "ipaddress.v6_int_to_packed": {
        "descr": "Represent an address as 16 packed bytes in network (big-endian) order. address is an integer representation of an IPv6 IP address. A ValueError is raised if the integer is negative or too large to be an IPv6 IP address.", 
        "name": "ipaddress.v6_int_to_packed", 
        "params": [], 
        "path": "python/library/ipaddress#ipaddress.v6_int_to_packed", 
        "syntax": "ipaddress.v6_int_to_packed(address)", 
        "type": "Internet"
    }, 
    "is_integer": {
        "descr": "Return True if the float instance is finite with integral value, and False otherwise:", 
        "name": "float.is_integer", 
        "params": [], 
        "path": "python/library/stdtypes#float.is_integer", 
        "syntax": "float.is_integer()", 
        "type": "Built-in Types"
    }, 
    "isalnum": {
        "descr": "Return true if all characters in the string are alphanumeric and there is at least one character, false otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric().", 
        "name": "str.isalnum", 
        "params": [], 
        "path": "python/library/stdtypes#str.isalnum", 
        "syntax": "str.isalnum()", 
        "type": "Built-in Types"
    }, 
    "isalpha": {
        "descr": "Return true if all characters in the string are alphabetic and there is at least one character, false otherwise. Alphabetic characters are those characters defined in the Unicode character database as \u201cLetter\u201d, i.e., those with general category property being one of \u201cLm\u201d, \u201cLt\u201d, \u201cLu\u201d, \u201cLl\u201d, or \u201cLo\u201d. Note that this is different from the \u201cAlphabetic\u201d property defined in the Unicode Standard.", 
        "name": "str.isalpha", 
        "params": [], 
        "path": "python/library/stdtypes#str.isalpha", 
        "syntax": "str.isalpha()", 
        "type": "Built-in Types"
    }, 
    "isdecimal": {
        "descr": "Return true if all characters in the string are decimal characters and there is at least one character, false otherwise. Decimal characters are those from general category \u201cNd\u201d. This category includes digit characters, and all characters that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO.", 
        "name": "str.isdecimal", 
        "params": [], 
        "path": "python/library/stdtypes#str.isdecimal", 
        "syntax": "str.isdecimal()", 
        "type": "Built-in Types"
    }, 
    "isdigit": {
        "descr": "Return true if all characters in the string are digits and there is at least one character, false otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.", 
        "name": "str.isdigit", 
        "params": [], 
        "path": "python/library/stdtypes#str.isdigit", 
        "syntax": "str.isdigit()", 
        "type": "Built-in Types"
    }, 
    "isidentifier": {
        "descr": "Return true if the string is a valid identifier according to the language definition, section Identifiers and keywords.", 
        "name": "str.isidentifier", 
        "params": [], 
        "path": "python/library/stdtypes#str.isidentifier", 
        "syntax": "str.isidentifier()", 
        "type": "Built-in Types"
    }, 
    "isinstance": {
        "descr": "Return true if the object argument is an instance of the classinfo argument, or of a (direct, indirect or virtual) subclass thereof. If object is not an object of the given type, the function always returns false. If classinfo is not a class (type object), it may be a tuple of type objects, or may recursively contain other such tuples (other sequence types are not accepted). If classinfo is not a type or tuple of types and such tuples, a TypeError exception is raised.", 
        "name": "isinstance", 
        "params": [], 
        "path": "python/library/functions#isinstance", 
        "syntax": "isinstance(object, classinfo)", 
        "type": "Built-in Functions"
    }, 
    "islower": {
        "descr": "Return true if all cased characters [4] in the string are lowercase and there is at least one cased character, false otherwise.", 
        "name": "str.islower", 
        "params": [], 
        "path": "python/library/stdtypes#str.islower", 
        "syntax": "str.islower()", 
        "type": "Built-in Types"
    }, 
    "isnumeric": {
        "descr": "Return true if all characters in the string are numeric characters, and there is at least one character, false otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.", 
        "name": "str.isnumeric", 
        "params": [], 
        "path": "python/library/stdtypes#str.isnumeric", 
        "syntax": "str.isnumeric()", 
        "type": "Built-in Types"
    }, 
    "isprintable": {
        "descr": "Return true if all characters in the string are printable or the string is empty, false otherwise. Nonprintable characters are those characters defined in the Unicode character database as \u201cOther\u201d or \u201cSeparator\u201d, excepting the ASCII space (0x20) which is considered printable. (Note that printable characters in this context are those which should not be escaped when repr() is invoked on a string. It has no bearing on the handling of strings written to sys.stdout or sys.stderr.)", 
        "name": "str.isprintable", 
        "params": [], 
        "path": "python/library/stdtypes#str.isprintable", 
        "syntax": "str.isprintable()", 
        "type": "Built-in Types"
    }, 
    "isspace": {
        "descr": "Return true if there are only whitespace characters in the string and there is at least one character, false otherwise. Whitespace characters are those characters defined in the Unicode character database as \u201cOther\u201d or \u201cSeparator\u201d and those with bidirectional property being one of \u201cWS\u201d, \u201cB\u201d, or \u201cS\u201d.", 
        "name": "str.isspace", 
        "params": [], 
        "path": "python/library/stdtypes#str.isspace", 
        "syntax": "str.isspace()", 
        "type": "Built-in Types"
    }, 
    "issubclass": {
        "descr": "Return true if class is a subclass (direct, indirect or virtual) of classinfo. A class is considered a subclass of itself. classinfo may be a tuple of class objects, in which case every entry in classinfo will be checked. In any other case, a TypeError exception is raised.", 
        "name": "issubclass", 
        "params": [], 
        "path": "python/library/functions#issubclass", 
        "syntax": "issubclass(class, classinfo)", 
        "type": "Built-in Functions"
    }, 
    "istitle": {
        "descr": "Return true if the string is a titlecased string and there is at least one character, for example uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return false otherwise.", 
        "name": "str.istitle", 
        "params": [], 
        "path": "python/library/stdtypes#str.istitle", 
        "syntax": "str.istitle()", 
        "type": "Built-in Types"
    }, 
    "isupper": {
        "descr": "Return true if all cased characters [4] in the string are uppercase and there is at least one cased character, false otherwise.", 
        "name": "str.isupper", 
        "params": [], 
        "path": "python/library/stdtypes#str.isupper", 
        "syntax": "str.isupper()", 
        "type": "Built-in Types"
    }, 
    "items": {
        "descr": "Return a new view of the dictionary\u2019s items ((key, value) pairs). See the documentation of view objects.", 
        "name": "dict.items", 
        "params": [], 
        "path": "python/library/stdtypes#dict.items", 
        "syntax": "items()", 
        "type": "Built-in Types"
    }, 
    "itemsize": {
        "descr": "The length in bytes of one array item in the internal representation.", 
        "name": "array.array.itemsize", 
        "params": [], 
        "path": "python/library/array#array.array.itemsize", 
        "syntax": "array.itemsize", 
        "type": "Data Types"
    }, 
    "iter": {
        "descr": "Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, object must be a collection object which supports the iteration protocol (the __iter__() method), or it must support the sequence protocol (the __getitem__() method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then object must be a callable object. The iterator created in this case will call object with no arguments for each call to its __next__() method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned.", 
        "name": "iter", 
        "params": [], 
        "path": "python/library/functions#iter", 
        "syntax": "iter(object[, sentinel])", 
        "type": "Built-in Functions"
    }, 
    "iterator.__iter__": {
        "descr": "Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements. This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API.", 
        "name": "iterator.__iter__", 
        "params": [], 
        "path": "python/library/stdtypes#iterator.__iter__", 
        "syntax": "iterator.__iter__()", 
        "type": "Built-in Types"
    }, 
    "iterator.__next__": {
        "descr": "Return the next item from the container. If there are no further items, raise the StopIteration exception. This method corresponds to the tp_iternext slot of the type structure for Python objects in the Python/C API.", 
        "name": "iterator.__next__", 
        "params": [], 
        "path": "python/library/stdtypes#iterator.__next__", 
        "syntax": "iterator.__next__()", 
        "type": "Built-in Types"
    }, 
    "itertools.accumulate": {
        "descr": "Make an iterator that returns accumulated sums. Elements may be any addable type including Decimal or Fraction. If the optional func argument is supplied, it should be a function of two arguments and it will be used instead of addition.", 
        "name": "itertools.accumulate", 
        "params": [], 
        "path": "python/library/itertools#itertools.accumulate", 
        "syntax": "itertools.accumulate(iterable[, func])", 
        "type": "Functional Programming"
    }, 
    "itertools.chain": {
        "descr": "Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. Used for treating consecutive sequences as a single sequence. Equivalent to:", 
        "name": "itertools.chain", 
        "params": [], 
        "path": "python/library/itertools#itertools.chain", 
        "syntax": "itertools.chain(*iterables)", 
        "type": "Functional Programming"
    }, 
    "itertools.chain.from_iterable": {
        "descr": "Alternate constructor for chain(). Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to:", 
        "name": "itertools.chain.from_iterable", 
        "params": [], 
        "path": "python/library/itertools#itertools.chain.from_iterable", 
        "syntax": "classmethod chain.from_iterable(iterable)", 
        "type": "Functional Programming"
    }, 
    "itertools.combinations": {
        "descr": "Return r length subsequences of elements from the input iterable.", 
        "name": "itertools.combinations", 
        "params": [], 
        "path": "python/library/itertools#itertools.combinations", 
        "syntax": "itertools.combinations(iterable, r)", 
        "type": "Functional Programming"
    }, 
    "itertools.combinations_with_replacement": {
        "descr": "Return r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once.", 
        "name": "itertools.combinations_with_replacement", 
        "params": [], 
        "path": "python/library/itertools#itertools.combinations_with_replacement", 
        "syntax": "itertools.combinations_with_replacement(iterable, r)", 
        "type": "Functional Programming"
    }, 
    "itertools.compress": {
        "descr": "Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True. Stops when either the data or selectors iterables has been exhausted. Equivalent to:", 
        "name": "itertools.compress", 
        "params": [], 
        "path": "python/library/itertools#itertools.compress", 
        "syntax": "itertools.compress(data, selectors)", 
        "type": "Functional Programming"
    }, 
    "itertools.count": {
        "descr": "Make an iterator that returns evenly spaced values starting with number start. Often used as an argument to map() to generate consecutive data points. Also, used with zip() to add sequence numbers. Equivalent to:", 
        "name": "itertools.count", 
        "params": [], 
        "path": "python/library/itertools#itertools.count", 
        "syntax": "itertools.count(start=0, step=1)", 
        "type": "Functional Programming"
    }, 
    "itertools.cycle": {
        "descr": "Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Equivalent to:", 
        "name": "itertools.cycle", 
        "params": [], 
        "path": "python/library/itertools#itertools.cycle", 
        "syntax": "itertools.cycle(iterable)", 
        "type": "Functional Programming"
    }, 
    "itertools.dropwhile": {
        "descr": "Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce any output until the predicate first becomes false, so it may have a lengthy start-up time. Equivalent to:", 
        "name": "itertools.dropwhile", 
        "params": [], 
        "path": "python/library/itertools#itertools.dropwhile", 
        "syntax": "itertools.dropwhile(predicate, iterable)", 
        "type": "Functional Programming"
    }, 
    "itertools.filterfalse": {
        "descr": "Make an iterator that filters elements from iterable returning only those for which the predicate is False. If predicate is None, return the items that are false. Equivalent to:", 
        "name": "itertools.filterfalse", 
        "params": [], 
        "path": "python/library/itertools#itertools.filterfalse", 
        "syntax": "itertools.filterfalse(predicate, iterable)", 
        "type": "Functional Programming"
    }, 
    "itertools.groupby": {
        "descr": "Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.", 
        "name": "itertools.groupby", 
        "params": [], 
        "path": "python/library/itertools#itertools.groupby", 
        "syntax": "itertools.groupby(iterable, key=None)", 
        "type": "Functional Programming"
    }, 
    "itertools.islice": {
        "descr": "Make an iterator that returns selected elements from the iterable. If start is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless step is set higher than one which results in items being skipped. If stop is None, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, islice() does not support negative values for start, stop, or step. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Equivalent to:", 
        "name": "itertools.islice", 
        "params": [], 
        "path": "python/library/itertools#itertools.islice", 
        "syntax": "itertools.islice(iterable, stop)", 
        "type": "Functional Programming"
    }, 
    "itertools.permutations": {
        "descr": "Return successive r length permutations of elements in the iterable.", 
        "name": "itertools.permutations", 
        "params": [], 
        "path": "python/library/itertools#itertools.permutations", 
        "syntax": "itertools.permutations(iterable, r=None)", 
        "type": "Functional Programming"
    }, 
    "itertools.product": {
        "descr": "Cartesian product of input iterables.", 
        "name": "itertools.product", 
        "params": [], 
        "path": "python/library/itertools#itertools.product", 
        "syntax": "itertools.product(*iterables, repeat=1)", 
        "type": "Functional Programming"
    }, 
    "itertools.repeat": {
        "descr": "Make an iterator that returns object over and over again. Runs indefinitely unless the times argument is specified. Used as argument to map() for invariant parameters to the called function. Also used with zip() to create an invariant part of a tuple record. Equivalent to:", 
        "name": "itertools.repeat", 
        "params": [], 
        "path": "python/library/itertools#itertools.repeat", 
        "syntax": "itertools.repeat(object[, times])", 
        "type": "Functional Programming"
    }, 
    "itertools.starmap": {
        "descr": "Make an iterator that computes the function using arguments obtained from the iterable. Used instead of map() when argument parameters are already grouped in tuples from a single iterable (the data has been \u201cpre-zipped\u201d). The difference between map() and starmap() parallels the distinction between function(a,b) and function(*c). Equivalent to:", 
        "name": "itertools.starmap", 
        "params": [], 
        "path": "python/library/itertools#itertools.starmap", 
        "syntax": "itertools.starmap(function, iterable)", 
        "type": "Functional Programming"
    }, 
    "itertools.takewhile": {
        "descr": "Make an iterator that returns elements from the iterable as long as the predicate is true. Equivalent to:", 
        "name": "itertools.takewhile", 
        "params": [], 
        "path": "python/library/itertools#itertools.takewhile", 
        "syntax": "itertools.takewhile(predicate, iterable)", 
        "type": "Functional Programming"
    }, 
    "itertools.tee": {
        "descr": "Return n independent iterators from a single iterable. Equivalent to:", 
        "name": "itertools.tee", 
        "params": [], 
        "path": "python/library/itertools#itertools.tee", 
        "syntax": "itertools.tee(iterable, n=2)", 
        "type": "Functional Programming"
    }, 
    "itertools.zip_longest": {
        "descr": "Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with fillvalue. Iteration continues until the longest iterable is exhausted. Equivalent to:", 
        "name": "itertools.zip_longest", 
        "params": [], 
        "path": "python/library/itertools#itertools.zip_longest", 
        "syntax": "itertools.zip_longest(*iterables, fillvalue=None)", 
        "type": "Functional Programming"
    }, 
    "join": {
        "descr": "Return a string which is the concatenation of the strings in the iterable iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method.", 
        "name": "str.join", 
        "params": [], 
        "path": "python/library/stdtypes#str.join", 
        "syntax": "str.join(iterable)", 
        "type": "Built-in Types"
    }, 
    "json.JSONDecoder": {
        "descr": "Simple JSON decoder.", 
        "name": "json.JSONDecoder", 
        "params": [], 
        "path": "python/library/json#json.JSONDecoder", 
        "syntax": "class json.JSONDecoder(object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None)", 
        "type": "Internet Data"
    }, 
    "json.JSONDecoder.decode": {
        "descr": "Return the Python representation of s (a str instance containing a JSON document)", 
        "name": "json.JSONDecoder.decode", 
        "params": [], 
        "path": "python/library/json#json.JSONDecoder.decode", 
        "syntax": "decode(s)", 
        "type": "Internet Data"
    }, 
    "json.JSONDecoder.raw_decode": {
        "descr": "Decode a JSON document from s (a str beginning with a JSON document) and return a 2-tuple of the Python representation and the index in s where the document ended.", 
        "name": "json.JSONDecoder.raw_decode", 
        "params": [], 
        "path": "python/library/json#json.JSONDecoder.raw_decode", 
        "syntax": "raw_decode(s)", 
        "type": "Internet Data"
    }, 
    "json.JSONEncoder": {
        "descr": "Extensible JSON encoder for Python data structures.", 
        "name": "json.JSONEncoder", 
        "params": [], 
        "path": "python/library/json#json.JSONEncoder", 
        "syntax": "class json.JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)", 
        "type": "Internet Data"
    }, 
    "json.JSONEncoder.default": {
        "descr": "Implement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a TypeError).", 
        "name": "json.JSONEncoder.default", 
        "params": [], 
        "path": "python/library/json#json.JSONEncoder.default", 
        "syntax": "default(o)", 
        "type": "Internet Data"
    }, 
    "json.JSONEncoder.encode": {
        "descr": "Return a JSON string representation of a Python data structure, o. For example:", 
        "name": "json.JSONEncoder.encode", 
        "params": [], 
        "path": "python/library/json#json.JSONEncoder.encode", 
        "syntax": "encode(o)", 
        "type": "Internet Data"
    }, 
    "json.JSONEncoder.iterencode": {
        "descr": "Encode the given object, o, and yield each string representation as available. For example:", 
        "name": "json.JSONEncoder.iterencode", 
        "params": [], 
        "path": "python/library/json#json.JSONEncoder.iterencode", 
        "syntax": "iterencode(o)", 
        "type": "Internet Data"
    }, 
    "json.dump": {
        "descr": "Serialize obj as a JSON formatted stream to fp (a .write()-supporting file-like object) using this conversion table.", 
        "name": "json.dump", 
        "params": [], 
        "path": "python/library/json#json.dump", 
        "syntax": "json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)", 
        "type": "Internet Data"
    }, 
    "json.dumps": {
        "descr": "Serialize obj to a JSON formatted str using this conversion table. The arguments have the same meaning as in dump().", 
        "name": "json.dumps", 
        "params": [], 
        "path": "python/library/json#json.dumps", 
        "syntax": "json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)", 
        "type": "Internet Data"
    }, 
    "json.load": {
        "descr": "Deserialize fp (a .read()-supporting file-like object containing a JSON document) to a Python object using this conversion table.", 
        "name": "json.load", 
        "params": [], 
        "path": "python/library/json#json.load", 
        "syntax": "json.load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)", 
        "type": "Internet Data"
    }, 
    "json.loads": {
        "descr": "Deserialize s (a str instance containing a JSON document) to a Python object using this conversion table.", 
        "name": "json.loads", 
        "params": [], 
        "path": "python/library/json#json.loads", 
        "syntax": "json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)", 
        "type": "Internet Data"
    }, 
    "keys": {
        "descr": "Return a new view of the dictionary\u2019s keys. See the documentation of view objects.", 
        "name": "dict.keys", 
        "params": [], 
        "path": "python/library/stdtypes#dict.keys", 
        "syntax": "keys()", 
        "type": "Built-in Types"
    }, 
    "lastgroup": {
        "descr": "The name of the last matched capturing group, or None if the group didn\u2019t have a name, or if no group was matched at all.", 
        "name": "re.match.lastgroup", 
        "params": [], 
        "path": "python/library/re#re.match.lastgroup", 
        "syntax": "match.lastgroup", 
        "type": "Text Processing"
    }, 
    "lastindex": {
        "descr": "The integer index of the last matched capturing group, or None if no group was matched at all. For example, the expressions (a)b, ((a)(b)), and ((ab)) will have lastindex == 1 if applied to the string 'ab', while the expression (a)(b) will have lastindex == 2, if applied to the same string.", 
        "name": "re.match.lastindex", 
        "params": [], 
        "path": "python/library/re#re.match.lastindex", 
        "syntax": "match.lastindex", 
        "type": "Text Processing"
    }, 
    "len": {
        "descr": "Return the length (the number of items) of an object. The argument may be a sequence (string, tuple or list) or a mapping (dictionary).", 
        "name": "len", 
        "params": [], 
        "path": "python/library/functions#len", 
        "syntax": "len(s)", 
        "type": "Built-in Functions"
    }, 
    "license": {
        "descr": "Objects that when printed, print a message like \u201cType license() to see the full license text\u201d, and when called, display the corresponding text in a pager-like fashion (one screen at a time).", 
        "name": "license", 
        "params": [], 
        "path": "python/library/constants#license", 
        "syntax": "license", 
        "type": "Built-in Constants"
    }, 
    "linecache.checkcache": {
        "descr": "Check the cache for validity. Use this function if files in the cache may have changed on disk, and you require the updated version. If filename is omitted, it will check all the entries in the cache.", 
        "name": "linecache.checkcache", 
        "params": [], 
        "path": "python/library/linecache#linecache.checkcache", 
        "syntax": "linecache.checkcache(filename=None)", 
        "type": "File & Directory Access"
    }, 
    "linecache.clearcache": {
        "descr": "Clear the cache. Use this function if you no longer need lines from files previously read using getline().", 
        "name": "linecache.clearcache", 
        "params": [], 
        "path": "python/library/linecache#linecache.clearcache", 
        "syntax": "linecache.clearcache()", 
        "type": "File & Directory Access"
    }, 
    "linecache.getline": {
        "descr": "Get line lineno from file named filename. This function will never raise an exception \u2014 it will return '' on errors (the terminating newline character will be included for lines that are found).", 
        "name": "linecache.getline", 
        "params": [], 
        "path": "python/library/linecache#linecache.getline", 
        "syntax": "linecache.getline(filename, lineno, module_globals=None)", 
        "type": "File & Directory Access"
    }, 
    "list": {
        "descr": "Rather than being a function, list is actually a mutable sequence type, as documented in Lists and Sequence Types \u2014 list, tuple, range.", 
        "name": "list", 
        "params": [], 
        "path": "python/library/functions#list", 
        "syntax": "list([iterable])", 
        "type": "Built-in Functions"
    }, 
    "list.sort": {
        "descr": "This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state).", 
        "name": "list.sort", 
        "params": [], 
        "path": "python/library/stdtypes#list.sort", 
        "syntax": "sort(*, key=None, reverse=None)", 
        "type": "Built-in Types"
    }, 
    "ljust": {
        "descr": "Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is a space). The original string is returned if width is less than or equal to len(s).", 
        "name": "str.ljust", 
        "params": [], 
        "path": "python/library/stdtypes#str.ljust", 
        "syntax": "str.ljust(width[, fillchar])", 
        "type": "Built-in Types"
    }, 
    "locale.Error": {
        "descr": "Exception raised when the locale passed to setlocale() is not recognized.", 
        "name": "locale.Error", 
        "params": [], 
        "path": "python/library/locale#locale.Error", 
        "syntax": "exception locale.Error", 
        "type": "Internationalization"
    }, 
    "locale.atof": {
        "descr": "Converts a string to a floating point number, following the LC_NUMERIC settings.", 
        "name": "locale.atof", 
        "params": [], 
        "path": "python/library/locale#locale.atof", 
        "syntax": "locale.atof(string)", 
        "type": "Internationalization"
    }, 
    "locale.atoi": {
        "descr": "Converts a string to an integer, following the LC_NUMERIC conventions.", 
        "name": "locale.atoi", 
        "params": [], 
        "path": "python/library/locale#locale.atoi", 
        "syntax": "locale.atoi(string)", 
        "type": "Internationalization"
    }, 
    "locale.currency": {
        "descr": "Formats a number val according to the current LC_MONETARY settings.", 
        "name": "locale.currency", 
        "params": [], 
        "path": "python/library/locale#locale.currency", 
        "syntax": "locale.currency(val, symbol=True, grouping=False, international=False)", 
        "type": "Internationalization"
    }, 
    "locale.format": {
        "descr": "Formats a number val according to the current LC_NUMERIC setting. The format follows the conventions of the % operator. For floating point values, the decimal point is modified if appropriate. If grouping is true, also takes the grouping into account.", 
        "name": "locale.format", 
        "params": [], 
        "path": "python/library/locale#locale.format", 
        "syntax": "locale.format(format, val, grouping=False, monetary=False)", 
        "type": "Internationalization"
    }, 
    "locale.format_string": {
        "descr": "Processes formatting specifiers as in format % val, but takes the current locale settings into account.", 
        "name": "locale.format_string", 
        "params": [], 
        "path": "python/library/locale#locale.format_string", 
        "syntax": "locale.format_string(format, val, grouping=False)", 
        "type": "Internationalization"
    }, 
    "locale.getdefaultlocale": {
        "descr": "Tries to determine the default locale settings and returns them as a tuple of the form (language code, encoding).", 
        "name": "locale.getdefaultlocale", 
        "params": [], 
        "path": "python/library/locale#locale.getdefaultlocale", 
        "syntax": "locale.getdefaultlocale([envvars])", 
        "type": "Internationalization"
    }, 
    "locale.getlocale": {
        "descr": "Returns the current setting for the given locale category as sequence containing language code, encoding. category may be one of the LC_* values except LC_ALL. It defaults to LC_CTYPE.", 
        "name": "locale.getlocale", 
        "params": [], 
        "path": "python/library/locale#locale.getlocale", 
        "syntax": "locale.getlocale(category=LC_CTYPE)", 
        "type": "Internationalization"
    }, 
    "locale.getpreferredencoding": {
        "descr": "Return the encoding used for text data, according to user preferences. User preferences are expressed differently on different systems, and might not be available programmatically on some systems, so this function only returns a guess.", 
        "name": "locale.getpreferredencoding", 
        "params": [], 
        "path": "python/library/locale#locale.getpreferredencoding", 
        "syntax": "locale.getpreferredencoding(do_setlocale=True)", 
        "type": "Internationalization"
    }, 
    "locale.localeconv": {
        "descr": "Returns the database of the local conventions as a dictionary. This dictionary has the following strings as keys:", 
        "name": "locale.localeconv", 
        "params": [], 
        "path": "python/library/locale#locale.localeconv", 
        "syntax": "locale.localeconv()", 
        "type": "Internationalization"
    }, 
    "locale.nl_langinfo": {
        "descr": "Return some locale-specific information as a string. This function is not available on all systems, and the set of possible options might also vary across platforms. The possible argument values are numbers, for which symbolic constants are available in the locale module.", 
        "name": "locale.nl_langinfo", 
        "params": [], 
        "path": "python/library/locale#locale.nl_langinfo", 
        "syntax": "locale.nl_langinfo(option)", 
        "type": "Internationalization"
    }, 
    "locale.normalize": {
        "descr": "Returns a normalized locale code for the given locale name. The returned locale code is formatted for use with setlocale(). If normalization fails, the original name is returned unchanged.", 
        "name": "locale.normalize", 
        "params": [], 
        "path": "python/library/locale#locale.normalize", 
        "syntax": "locale.normalize(localename)", 
        "type": "Internationalization"
    }, 
    "locale.resetlocale": {
        "descr": "Sets the locale for category to the default setting.", 
        "name": "locale.resetlocale", 
        "params": [], 
        "path": "python/library/locale#locale.resetlocale", 
        "syntax": "locale.resetlocale(category=LC_ALL)", 
        "type": "Internationalization"
    }, 
    "locale.setlocale": {
        "descr": "If locale is given and not None, setlocale() modifies the locale setting for the category. The available categories are listed in the data description below. locale may be a string, or an iterable of two strings (language code and encoding). If it\u2019s an iterable, it\u2019s converted to a locale name using the locale aliasing engine. An empty string specifies the user\u2019s default settings. If the modification of the locale fails, the exception Error is raised. If successful, the new locale setting is returned.", 
        "name": "locale.setlocale", 
        "params": [], 
        "path": "python/library/locale#locale.setlocale", 
        "syntax": "locale.setlocale(category, locale=None)", 
        "type": "Internationalization"
    }, 
    "locale.str": {
        "descr": "Formats a floating point number using the same format as the built-in function str(float), but takes the decimal point into account.", 
        "name": "locale.str", 
        "params": [], 
        "path": "python/library/locale#locale.str", 
        "syntax": "locale.str(float)", 
        "type": "Internationalization"
    }, 
    "locale.strcoll": {
        "descr": "Compares two strings according to the current LC_COLLATE setting. As any other compare function, returns a negative, or a positive value, or 0, depending on whether string1 collates before or after string2 or is equal to it.", 
        "name": "locale.strcoll", 
        "params": [], 
        "path": "python/library/locale#locale.strcoll", 
        "syntax": "locale.strcoll(string1, string2)", 
        "type": "Internationalization"
    }, 
    "locale.strxfrm": {
        "descr": "Transforms a string to one that can be used in locale-aware comparisons. For example, strxfrm(s1) < strxfrm(s2) is equivalent to strcoll(s1, s2) < 0. This function can be used when the same string is compared repeatedly, e.g. when collating a sequence of strings.", 
        "name": "locale.strxfrm", 
        "params": [], 
        "path": "python/library/locale#locale.strxfrm", 
        "syntax": "locale.strxfrm(string)", 
        "type": "Internationalization"
    }, 
    "locals": {
        "descr": "Update and return a dictionary representing the current local symbol table. Free variables are returned by locals() when it is called in function blocks, but not in class blocks.", 
        "name": "locals", 
        "params": [], 
        "path": "python/library/functions#locals", 
        "syntax": "locals()", 
        "type": "Built-in Functions"
    }, 
    "logging.FileHandler": {
        "descr": "Returns a new instance of the FileHandler class. The specified file is opened and used as the stream for logging. If mode is not specified, 'a' is used. If encoding is not None, it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to emit(). By default, the file grows indefinitely.", 
        "name": "logging.FileHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.FileHandler", 
        "syntax": "class logging.FileHandler(filename, mode='a', encoding=None, delay=False)", 
        "type": "Logging"
    }, 
    "logging.FileHandler.close": {
        "descr": "Closes the file.", 
        "name": "logging.FileHandler.close", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.FileHandler.close", 
        "syntax": "close()", 
        "type": "Logging"
    }, 
    "logging.FileHandler.emit": {
        "descr": "Outputs the record to the file.", 
        "name": "logging.FileHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.FileHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.Filter": {
        "descr": "Returns an instance of the Filter class. If name is specified, it names a logger which, together with its children, will have its events allowed through the filter. If name is the empty string, allows every event.", 
        "name": "logging.Filter", 
        "params": [], 
        "path": "python/library/logging#logging.Filter", 
        "syntax": "class logging.Filter(name='')", 
        "type": "Logging"
    }, 
    "logging.Filter.filter": {
        "descr": "Is the specified record to be logged? Returns zero for no, nonzero for yes. If deemed appropriate, the record may be modified in-place by this method.", 
        "name": "logging.Filter.filter", 
        "params": [], 
        "path": "python/library/logging#logging.Filter.filter", 
        "syntax": "filter(record)", 
        "type": "Logging"
    }, 
    "logging.Formatter": {
        "descr": "Returns a new instance of the Formatter class. The instance is initialized with a format string for the message as a whole, as well as a format string for the date/time portion of a message. If no fmt is specified, '%(message)s' is used. If no datefmt is specified, the ISO8601 date format is used.", 
        "name": "logging.Formatter", 
        "params": [], 
        "path": "python/library/logging#logging.Formatter", 
        "syntax": "class logging.Formatter(fmt=None, datefmt=None, style='%')", 
        "type": "Logging"
    }, 
    "logging.Formatter.format": {
        "descr": "The record\u2019s attribute dictionary is used as the operand to a string formatting operation. Returns the resulting string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using msg % args. If the formatting string contains '(asctime)', formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Note that the formatted exception information is cached in attribute exc_text. This is useful because the exception information can be pickled and sent across the wire, but you should be careful if you have more than one Formatter subclass which customizes the formatting of exception information. In this case, you will have to clear the cached value after a formatter has done its formatting, so that the next formatter to handle the event doesn\u2019t use the cached value but recalculates it afresh.", 
        "name": "logging.Formatter.format", 
        "params": [], 
        "path": "python/library/logging#logging.Formatter.format", 
        "syntax": "format(record)", 
        "type": "Logging"
    }, 
    "logging.Formatter.formatException": {
        "descr": "Formats the specified exception information (a standard exception tuple as returned by sys.exc_info()) as a string. This default implementation just uses traceback.print_exception(). The resulting string is returned.", 
        "name": "logging.Formatter.formatException", 
        "params": [], 
        "path": "python/library/logging#logging.Formatter.formatException", 
        "syntax": "formatException(exc_info)", 
        "type": "Logging"
    }, 
    "logging.Formatter.formatStack": {
        "descr": "Formats the specified stack information (a string as returned by traceback.print_stack(), but with the last newline removed) as a string. This default implementation just returns the input value.", 
        "name": "logging.Formatter.formatStack", 
        "params": [], 
        "path": "python/library/logging#logging.Formatter.formatStack", 
        "syntax": "formatStack(stack_info)", 
        "type": "Logging"
    }, 
    "logging.Formatter.formatTime": {
        "descr": "This method should be called from format() by a formatter which wants to make use of a formatted time. This method can be overridden in formatters to provide for any specific requirement, but the basic behavior is as follows: if datefmt (a string) is specified, it is used with time.strftime() to format the creation time of the record. Otherwise, the ISO8601 format is used. The resulting string is returned.", 
        "name": "logging.Formatter.formatTime", 
        "params": [], 
        "path": "python/library/logging#logging.Formatter.formatTime", 
        "syntax": "formatTime(record, datefmt=None)", 
        "type": "Logging"
    }, 
    "logging.Handler.__init__": {
        "descr": "Initializes the Handler instance by setting its level, setting the list of filters to the empty list and creating a lock (using createLock()) for serializing access to an I/O mechanism.", 
        "name": "logging.Handler.__init__", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.__init__", 
        "syntax": "Handler.__init__(level=NOTSET)", 
        "type": "Logging"
    }, 
    "logging.Handler.acquire": {
        "descr": "Acquires the thread lock created with createLock().", 
        "name": "logging.Handler.acquire", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.acquire", 
        "syntax": "Handler.acquire()", 
        "type": "Logging"
    }, 
    "logging.Handler.addFilter": {
        "descr": "Adds the specified filter filt to this handler.", 
        "name": "logging.Handler.addFilter", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.addFilter", 
        "syntax": "Handler.addFilter(filt)", 
        "type": "Logging"
    }, 
    "logging.Handler.close": {
        "descr": "Tidy up any resources used by the handler. This version does no output but removes the handler from an internal list of handlers which is closed when shutdown() is called. Subclasses should ensure that this gets called from overridden close() methods.", 
        "name": "logging.Handler.close", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.close", 
        "syntax": "Handler.close()", 
        "type": "Logging"
    }, 
    "logging.Handler.createLock": {
        "descr": "Initializes a thread lock which can be used to serialize access to underlying I/O functionality which may not be threadsafe.", 
        "name": "logging.Handler.createLock", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.createLock", 
        "syntax": "Handler.createLock()", 
        "type": "Logging"
    }, 
    "logging.Handler.emit": {
        "descr": "Do whatever it takes to actually log the specified logging record. This version is intended to be implemented by subclasses and so raises a NotImplementedError.", 
        "name": "logging.Handler.emit", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.emit", 
        "syntax": "Handler.emit(record)", 
        "type": "Logging"
    }, 
    "logging.Handler.filter": {
        "descr": "Applies this handler\u2019s filters to the record and returns a true value if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be emitted. If one returns a false value, the handler will not emit the record.", 
        "name": "logging.Handler.filter", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.filter", 
        "syntax": "Handler.filter(record)", 
        "type": "Logging"
    }, 
    "logging.Handler.flush": {
        "descr": "Ensure all logging output has been flushed. This version does nothing and is intended to be implemented by subclasses.", 
        "name": "logging.Handler.flush", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.flush", 
        "syntax": "Handler.flush()", 
        "type": "Logging"
    }, 
    "logging.Handler.format": {
        "descr": "Do formatting for a record - if a formatter is set, use it. Otherwise, use the default formatter for the module.", 
        "name": "logging.Handler.format", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.format", 
        "syntax": "Handler.format(record)", 
        "type": "Logging"
    }, 
    "logging.Handler.handle": {
        "descr": "Conditionally emits the specified logging record, depending on filters which may have been added to the handler. Wraps the actual emission of the record with acquisition/release of the I/O thread lock.", 
        "name": "logging.Handler.handle", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.handle", 
        "syntax": "Handler.handle(record)", 
        "type": "Logging"
    }, 
    "logging.Handler.handleError": {
        "descr": "This method should be called from handlers when an exception is encountered during an emit() call. If the module-level attribute raiseExceptions is False, exceptions get silently ignored. This is what is mostly wanted for a logging system - most users will not care about errors in the logging system, they are more interested in application errors. You could, however, replace this with a custom handler if you wish. The specified record is the one which was being processed when the exception occurred. (The default value of raiseExceptions is True, as that is more useful during development).", 
        "name": "logging.Handler.handleError", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.handleError", 
        "syntax": "Handler.handleError(record)", 
        "type": "Logging"
    }, 
    "logging.Handler.release": {
        "descr": "Releases the thread lock acquired with acquire().", 
        "name": "logging.Handler.release", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.release", 
        "syntax": "Handler.release()", 
        "type": "Logging"
    }, 
    "logging.Handler.removeFilter": {
        "descr": "Removes the specified filter filt from this handler.", 
        "name": "logging.Handler.removeFilter", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.removeFilter", 
        "syntax": "Handler.removeFilter(filt)", 
        "type": "Logging"
    }, 
    "logging.Handler.setFormatter": {
        "descr": "Sets the Formatter for this handler to form.", 
        "name": "logging.Handler.setFormatter", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.setFormatter", 
        "syntax": "Handler.setFormatter(form)", 
        "type": "Logging"
    }, 
    "logging.Handler.setLevel": {
        "descr": "Sets the threshold for this handler to lvl. Logging messages which are less severe than lvl will be ignored. When a handler is created, the level is set to NOTSET (which causes all messages to be processed).", 
        "name": "logging.Handler.setLevel", 
        "params": [], 
        "path": "python/library/logging#logging.Handler.setLevel", 
        "syntax": "Handler.setLevel(lvl)", 
        "type": "Logging"
    }, 
    "logging.LogRecord": {
        "descr": "Contains all the information pertinent to the event being logged.", 
        "name": "logging.LogRecord", 
        "params": [], 
        "path": "python/library/logging#logging.LogRecord", 
        "syntax": "class logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None)", 
        "type": "Logging"
    }, 
    "logging.LogRecord.getMessage": {
        "descr": "Returns the message for this LogRecord instance after merging any user-supplied arguments with the message. If the user-supplied message argument to the logging call is not a string, str() is called on it to convert it to a string. This allows use of user-defined classes as messages, whose __str__ method can return the actual format string to be used.", 
        "name": "logging.LogRecord.getMessage", 
        "params": [], 
        "path": "python/library/logging#logging.LogRecord.getMessage", 
        "syntax": "getMessage()", 
        "type": "Logging"
    }, 
    "logging.Logger": {
        "descr": "If this evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger. Messages are passed directly to the ancestor loggers\u2019 handlers - neither the level nor filters of the ancestor loggers in question are considered.", 
        "name": "logging.Logger", 
        "params": [], 
        "path": "python/library/logging#logging.Logger", 
        "syntax": "class logging.Logger", 
        "type": "Logging"
    }, 
    "logging.Logger.addFilter": {
        "descr": "Adds the specified filter filt to this logger.", 
        "name": "logging.Logger.addFilter", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.addFilter", 
        "syntax": "Logger.addFilter(filt)", 
        "type": "Logging"
    }, 
    "logging.Logger.addHandler": {
        "descr": "Adds the specified handler hdlr to this logger.", 
        "name": "logging.Logger.addHandler", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.addHandler", 
        "syntax": "Logger.addHandler(hdlr)", 
        "type": "Logging"
    }, 
    "logging.Logger.critical": {
        "descr": "Logs a message with level CRITICAL on this logger. The arguments are interpreted as for debug().", 
        "name": "logging.Logger.critical", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.critical", 
        "syntax": "Logger.critical(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.Logger.debug": {
        "descr": "Logs a message with level DEBUG on this logger. The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)", 
        "name": "logging.Logger.debug", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.debug", 
        "syntax": "Logger.debug(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.Logger.error": {
        "descr": "Logs a message with level ERROR on this logger. The arguments are interpreted as for debug().", 
        "name": "logging.Logger.error", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.error", 
        "syntax": "Logger.error(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.Logger.exception": {
        "descr": "Logs a message with level ERROR on this logger. The arguments are interpreted as for debug(). Exception info is added to the logging message. This method should only be called from an exception handler.", 
        "name": "logging.Logger.exception", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.exception", 
        "syntax": "Logger.exception(msg, *args)", 
        "type": "Logging"
    }, 
    "logging.Logger.filter": {
        "descr": "Applies this logger\u2019s filters to the record and returns a true value if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be processed (passed to handlers). If one returns a false value, no further processing of the record occurs.", 
        "name": "logging.Logger.filter", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.filter", 
        "syntax": "Logger.filter(record)", 
        "type": "Logging"
    }, 
    "logging.Logger.findCaller": {
        "descr": "Finds the caller\u2019s source filename and line number. Returns the filename, line number, function name and stack information as a 4-element tuple. The stack information is returned as None unless stack_info is True.", 
        "name": "logging.Logger.findCaller", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.findCaller", 
        "syntax": "Logger.findCaller(stack_info=False)", 
        "type": "Logging"
    }, 
    "logging.Logger.getChild": {
        "descr": "Returns a logger which is a descendant to this logger, as determined by the suffix. Thus, logging.getLogger('abc').getChild('def.ghi') would return the same logger as would be returned by logging.getLogger('abc.def.ghi'). This is a convenience method, useful when the parent logger is named using e.g. __name__ rather than a literal string.", 
        "name": "logging.Logger.getChild", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.getChild", 
        "syntax": "Logger.getChild(suffix)", 
        "type": "Logging"
    }, 
    "logging.Logger.getEffectiveLevel": {
        "descr": "Indicates the effective level for this logger. If a value other than NOTSET has been set using setLevel(), it is returned. Otherwise, the hierarchy is traversed towards the root until a value other than NOTSET is found, and that value is returned.", 
        "name": "logging.Logger.getEffectiveLevel", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.getEffectiveLevel", 
        "syntax": "Logger.getEffectiveLevel()", 
        "type": "Logging"
    }, 
    "logging.Logger.handle": {
        "descr": "Handles a record by passing it to all handlers associated with this logger and its ancestors (until a false value of propagate is found). This method is used for unpickled records received from a socket, as well as those created locally. Logger-level filtering is applied using filter().", 
        "name": "logging.Logger.handle", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.handle", 
        "syntax": "Logger.handle(record)", 
        "type": "Logging"
    }, 
    "logging.Logger.hasHandlers": {
        "descr": "Checks to see if this logger has any handlers configured. This is done by looking for handlers in this logger and its parents in the logger hierarchy. Returns True if a handler was found, else False. The method stops searching up the hierarchy whenever a logger with the \u2018propagate\u2019 attribute set to False is found - that will be the last logger which is checked for the existence of handlers.", 
        "name": "logging.Logger.hasHandlers", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.hasHandlers", 
        "syntax": "Logger.hasHandlers()", 
        "type": "Logging"
    }, 
    "logging.Logger.info": {
        "descr": "Logs a message with level INFO on this logger. The arguments are interpreted as for debug().", 
        "name": "logging.Logger.info", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.info", 
        "syntax": "Logger.info(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.Logger.isEnabledFor": {
        "descr": "Indicates if a message of severity lvl would be processed by this logger. This method checks first the module-level level set by logging.disable(lvl) and then the logger\u2019s effective level as determined by getEffectiveLevel().", 
        "name": "logging.Logger.isEnabledFor", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.isEnabledFor", 
        "syntax": "Logger.isEnabledFor(lvl)", 
        "type": "Logging"
    }, 
    "logging.Logger.log": {
        "descr": "Logs a message with integer level lvl on this logger. The other arguments are interpreted as for debug().", 
        "name": "logging.Logger.log", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.log", 
        "syntax": "Logger.log(lvl, msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.Logger.makeRecord": {
        "descr": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances.", 
        "name": "logging.Logger.makeRecord", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.makeRecord", 
        "syntax": "Logger.makeRecord(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)", 
        "type": "Logging"
    }, 
    "logging.Logger.propagate": {
        "descr": "If this evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger. Messages are passed directly to the ancestor loggers\u2019 handlers - neither the level nor filters of the ancestor loggers in question are considered.", 
        "name": "logging.Logger.propagate", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.propagate", 
        "syntax": "Logger.propagate", 
        "type": "Logging"
    }, 
    "logging.Logger.removeFilter": {
        "descr": "Removes the specified filter filt from this logger.", 
        "name": "logging.Logger.removeFilter", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.removeFilter", 
        "syntax": "Logger.removeFilter(filt)", 
        "type": "Logging"
    }, 
    "logging.Logger.removeHandler": {
        "descr": "Removes the specified handler hdlr from this logger.", 
        "name": "logging.Logger.removeHandler", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.removeHandler", 
        "syntax": "Logger.removeHandler(hdlr)", 
        "type": "Logging"
    }, 
    "logging.Logger.setLevel": {
        "descr": "Sets the threshold for this logger to lvl. Logging messages which are less severe than lvl will be ignored. When a logger is created, the level is set to NOTSET (which causes all messages to be processed when the logger is the root logger, or delegation to the parent when the logger is a non-root logger). Note that the root logger is created with level WARNING.", 
        "name": "logging.Logger.setLevel", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.setLevel", 
        "syntax": "Logger.setLevel(lvl)", 
        "type": "Logging"
    }, 
    "logging.Logger.warning": {
        "descr": "Logs a message with level WARNING on this logger. The arguments are interpreted as for debug().", 
        "name": "logging.Logger.warning", 
        "params": [], 
        "path": "python/library/logging#logging.Logger.warning", 
        "syntax": "Logger.warning(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.LoggerAdapter": {
        "descr": "Returns an instance of LoggerAdapter initialized with an underlying Logger instance and a dict-like object.", 
        "name": "logging.LoggerAdapter", 
        "params": [], 
        "path": "python/library/logging#logging.LoggerAdapter", 
        "syntax": "class logging.LoggerAdapter(logger, extra)", 
        "type": "Logging"
    }, 
    "logging.LoggerAdapter.process": {
        "descr": "Modifies the message and/or keyword arguments passed to a logging call in order to insert contextual information. This implementation takes the object passed as extra to the constructor and adds it to kwargs using key \u2018extra\u2019. The return value is a (msg, kwargs) tuple which has the (possibly modified) versions of the arguments passed in.", 
        "name": "logging.LoggerAdapter.process", 
        "params": [], 
        "path": "python/library/logging#logging.LoggerAdapter.process", 
        "syntax": "process(msg, kwargs)", 
        "type": "Logging"
    }, 
    "logging.NullHandler": {
        "descr": "Returns a new instance of the NullHandler class.", 
        "name": "logging.NullHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.NullHandler", 
        "syntax": "class logging.NullHandler", 
        "type": "Logging"
    }, 
    "logging.NullHandler.createLock": {
        "descr": "This method returns None for the lock, since there is no underlying I/O to which access needs to be serialized.", 
        "name": "logging.NullHandler.createLock", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.NullHandler.createLock", 
        "syntax": "createLock()", 
        "type": "Logging"
    }, 
    "logging.NullHandler.emit": {
        "descr": "This method does nothing.", 
        "name": "logging.NullHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.NullHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.NullHandler.handle": {
        "descr": "This method does nothing.", 
        "name": "logging.NullHandler.handle", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.NullHandler.handle", 
        "syntax": "handle(record)", 
        "type": "Logging"
    }, 
    "logging.StreamHandler": {
        "descr": "Returns a new instance of the StreamHandler class. If stream is specified, the instance will use it for logging output; otherwise, sys.stderr will be used.", 
        "name": "logging.StreamHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.StreamHandler", 
        "syntax": "class logging.StreamHandler(stream=None)", 
        "type": "Logging"
    }, 
    "logging.StreamHandler.emit": {
        "descr": "If a formatter is specified, it is used to format the record. The record is then written to the stream with a terminator. If exception information is present, it is formatted using traceback.print_exception() and appended to the stream.", 
        "name": "logging.StreamHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.StreamHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.StreamHandler.flush": {
        "descr": "Flushes the stream by calling its flush() method. Note that the close() method is inherited from Handler and so does no output, so an explicit flush() call may be needed at times.", 
        "name": "logging.StreamHandler.flush", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.StreamHandler.flush", 
        "syntax": "flush()", 
        "type": "Logging"
    }, 
    "logging.addLevelName": {
        "descr": "Associates level lvl with text levelName in an internal dictionary, which is used to map numeric levels to a textual representation, for example when a Formatter formats a message. This function can also be used to define your own levels. The only constraints are that all levels used must be registered using this function, levels should be positive integers and they should increase in increasing order of severity.", 
        "name": "logging.addLevelName", 
        "params": [], 
        "path": "python/library/logging#logging.addLevelName", 
        "syntax": "logging.addLevelName(lvl, levelName)", 
        "type": "Logging"
    }, 
    "logging.basicConfig": {
        "descr": "Does basic configuration for the logging system by creating a StreamHandler with a default Formatter and adding it to the root logger. The functions debug(), info(), warning(), error() and critical() will call basicConfig() automatically if no handlers are defined for the root logger.", 
        "name": "logging.basicConfig", 
        "params": [], 
        "path": "python/library/logging#logging.basicConfig", 
        "syntax": "logging.basicConfig(**kwargs)", 
        "type": "Logging"
    }, 
    "logging.captureWarnings": {
        "descr": "This function is used to turn the capture of warnings by logging on and off.", 
        "name": "logging.captureWarnings", 
        "params": [], 
        "path": "python/library/logging#logging.captureWarnings", 
        "syntax": "logging.captureWarnings(capture)", 
        "type": "Logging"
    }, 
    "logging.config.dictConfig": {
        "descr": "Takes the logging configuration from a dictionary. The contents of this dictionary are described in Configuration dictionary schema below.", 
        "name": "logging.config.dictConfig", 
        "params": [], 
        "path": "python/library/logging.config#logging.config.dictConfig", 
        "syntax": "logging.config.dictConfig(config)", 
        "type": "Logging"
    }, 
    "logging.config.fileConfig": {
        "descr": "Reads the logging configuration from a configparser-format file named fname. The format of the file should be as described in Configuration file format. This function can be called several times from an application, allowing an end user to select from various pre-canned configurations (if the developer provides a mechanism to present the choices and load the chosen configuration).", 
        "name": "logging.config.fileConfig", 
        "params": [], 
        "path": "python/library/logging.config#logging.config.fileConfig", 
        "syntax": "logging.config.fileConfig(fname, defaults=None, disable_existing_loggers=True)", 
        "type": "Logging"
    }, 
    "logging.config.listen": {
        "descr": "Starts up a socket server on the specified port, and listens for new configurations. If no port is specified, the module\u2019s default DEFAULT_LOGGING_CONFIG_PORT is used. Logging configurations will be sent as a file suitable for processing by fileConfig(). Returns a Thread instance on which you can call start() to start the server, and which you can join() when appropriate. To stop the server, call stopListening().", 
        "name": "logging.config.listen", 
        "params": [], 
        "path": "python/library/logging.config#logging.config.listen", 
        "syntax": "logging.config.listen(port=DEFAULT_LOGGING_CONFIG_PORT)", 
        "type": "Logging"
    }, 
    "logging.config.stopListening": {
        "descr": "Stops the listening server which was created with a call to listen(). This is typically called before calling join() on the return value from listen().", 
        "name": "logging.config.stopListening", 
        "params": [], 
        "path": "python/library/logging.config#logging.config.stopListening", 
        "syntax": "logging.config.stopListening()", 
        "type": "Logging"
    }, 
    "logging.critical": {
        "descr": "Logs a message with level CRITICAL on the root logger. The arguments are interpreted as for debug().", 
        "name": "logging.critical", 
        "params": [], 
        "path": "python/library/logging#logging.critical", 
        "syntax": "logging.critical(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.debug": {
        "descr": "Logs a message with level DEBUG on the root logger. The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)", 
        "name": "logging.debug", 
        "params": [], 
        "path": "python/library/logging#logging.debug", 
        "syntax": "logging.debug(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.disable": {
        "descr": "Provides an overriding level lvl for all loggers which takes precedence over the logger\u2019s own level. When the need arises to temporarily throttle logging output down across the whole application, this function can be useful. Its effect is to disable all logging calls of severity lvl and below, so that if you call it with a value of INFO, then all INFO and DEBUG events would be discarded, whereas those of severity WARNING and above would be processed according to the logger\u2019s effective level. If logging.disable(logging.NOTSET) is called, it effectively removes this overriding level, so that logging output again depends on the effective levels of individual loggers.", 
        "name": "logging.disable", 
        "params": [], 
        "path": "python/library/logging#logging.disable", 
        "syntax": "logging.disable(lvl)", 
        "type": "Logging"
    }, 
    "logging.error": {
        "descr": "Logs a message with level ERROR on the root logger. The arguments are interpreted as for debug().", 
        "name": "logging.error", 
        "params": [], 
        "path": "python/library/logging#logging.error", 
        "syntax": "logging.error(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.exception": {
        "descr": "Logs a message with level ERROR on the root logger. The arguments are interpreted as for debug(). Exception info is added to the logging message. This function should only be called from an exception handler.", 
        "name": "logging.exception", 
        "params": [], 
        "path": "python/library/logging#logging.exception", 
        "syntax": "logging.exception(msg, *args)", 
        "type": "Logging"
    }, 
    "logging.getLevelName": {
        "descr": "Returns the textual representation of logging level lvl. If the level is one of the predefined levels CRITICAL, ERROR, WARNING, INFO or DEBUG then you get the corresponding string. If you have associated levels with names using addLevelName() then the name you have associated with lvl is returned. If a numeric value corresponding to one of the defined levels is passed in, the corresponding string representation is returned. Otherwise, the string \u2018Level %s\u2019 % lvl is returned.", 
        "name": "logging.getLevelName", 
        "params": [], 
        "path": "python/library/logging#logging.getLevelName", 
        "syntax": "logging.getLevelName(lvl)", 
        "type": "Logging"
    }, 
    "logging.getLogRecordFactory": {
        "descr": "Return a callable which is used to create a LogRecord.", 
        "name": "logging.getLogRecordFactory", 
        "params": [], 
        "path": "python/library/logging#logging.getLogRecordFactory", 
        "syntax": "logging.getLogRecordFactory()", 
        "type": "Logging"
    }, 
    "logging.getLogger": {
        "descr": "Return a logger with the specified name or, if name is None, return a logger which is the root logger of the hierarchy. If specified, the name is typically a dot-separated hierarchical name like \u2018a\u2019, \u2018a.b\u2019 or \u2018a.b.c.d\u2019. Choice of these names is entirely up to the developer who is using logging.", 
        "name": "logging.getLogger", 
        "params": [], 
        "path": "python/library/logging#logging.getLogger", 
        "syntax": "logging.getLogger(name=None)", 
        "type": "Logging"
    }, 
    "logging.getLoggerClass": {
        "descr": "Return either the standard Logger class, or the last class passed to setLoggerClass(). This function may be called from within a new class definition, to ensure that installing a customized Logger class will not undo customizations already applied by other code. For example:", 
        "name": "logging.getLoggerClass", 
        "params": [], 
        "path": "python/library/logging#logging.getLoggerClass", 
        "syntax": "logging.getLoggerClass()", 
        "type": "Logging"
    }, 
    "logging.handlers.BaseRotatingHandler": {
        "descr": "The parameters are as for FileHandler. The attributes are:", 
        "name": "logging.handlers.BaseRotatingHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BaseRotatingHandler", 
        "syntax": "class logging.handlers.BaseRotatingHandler(filename, mode, encoding=None, delay=False)", 
        "type": "Logging"
    }, 
    "logging.handlers.BaseRotatingHandler.namer": {
        "descr": "If this attribute is set to a callable, the rotation_filename() method delegates to this callable. The parameters passed to the callable are those passed to rotation_filename().", 
        "name": "logging.handlers.BaseRotatingHandler.namer", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BaseRotatingHandler.namer", 
        "syntax": "namer", 
        "type": "Logging"
    }, 
    "logging.handlers.BaseRotatingHandler.rotate": {
        "descr": "When rotating, rotate the current log.", 
        "name": "logging.handlers.BaseRotatingHandler.rotate", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BaseRotatingHandler.rotate", 
        "syntax": "rotate(source, dest)", 
        "type": "Logging"
    }, 
    "logging.handlers.BaseRotatingHandler.rotation_filename": {
        "descr": "Modify the filename of a log file when rotating.", 
        "name": "logging.handlers.BaseRotatingHandler.rotation_filename", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BaseRotatingHandler.rotation_filename", 
        "syntax": "rotation_filename(default_name)", 
        "type": "Logging"
    }, 
    "logging.handlers.BaseRotatingHandler.rotator": {
        "descr": "If this attribute is set to a callable, the rotate() method delegates to this callable. The parameters passed to the callable are those passed to rotate().", 
        "name": "logging.handlers.BaseRotatingHandler.rotator", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BaseRotatingHandler.rotator", 
        "syntax": "rotator", 
        "type": "Logging"
    }, 
    "logging.handlers.BufferingHandler": {
        "descr": "Initializes the handler with a buffer of the specified capacity.", 
        "name": "logging.handlers.BufferingHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BufferingHandler", 
        "syntax": "class logging.handlers.BufferingHandler(capacity)", 
        "type": "Logging"
    }, 
    "logging.handlers.BufferingHandler.emit": {
        "descr": "Appends the record to the buffer. If shouldFlush() returns true, calls flush() to process the buffer.", 
        "name": "logging.handlers.BufferingHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BufferingHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.BufferingHandler.flush": {
        "descr": "You can override this to implement custom flushing behavior. This version just zaps the buffer to empty.", 
        "name": "logging.handlers.BufferingHandler.flush", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BufferingHandler.flush", 
        "syntax": "flush()", 
        "type": "Logging"
    }, 
    "logging.handlers.BufferingHandler.shouldFlush": {
        "descr": "Returns true if the buffer is up to capacity. This method can be overridden to implement custom flushing strategies.", 
        "name": "logging.handlers.BufferingHandler.shouldFlush", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.BufferingHandler.shouldFlush", 
        "syntax": "shouldFlush(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.DatagramHandler": {
        "descr": "Returns a new instance of the DatagramHandler class intended to communicate with a remote machine whose address is given by host and port.", 
        "name": "logging.handlers.DatagramHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.DatagramHandler", 
        "syntax": "class logging.handlers.DatagramHandler(host, port)", 
        "type": "Logging"
    }, 
    "logging.handlers.DatagramHandler.emit": {
        "descr": "Pickles the record\u2019s attribute dictionary and writes it to the socket in binary format. If there is an error with the socket, silently drops the packet. To unpickle the record at the receiving end into a LogRecord, use the makeLogRecord() function.", 
        "name": "logging.handlers.DatagramHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.DatagramHandler.emit", 
        "syntax": "emit()", 
        "type": "Logging"
    }, 
    "logging.handlers.DatagramHandler.makeSocket": {
        "descr": "The factory method of SocketHandler is here overridden to create a UDP socket (socket.SOCK_DGRAM).", 
        "name": "logging.handlers.DatagramHandler.makeSocket", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.DatagramHandler.makeSocket", 
        "syntax": "makeSocket()", 
        "type": "Logging"
    }, 
    "logging.handlers.DatagramHandler.send": {
        "descr": "Send a pickled string to a socket.", 
        "name": "logging.handlers.DatagramHandler.send", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.DatagramHandler.send", 
        "syntax": "send(s)", 
        "type": "Logging"
    }, 
    "logging.handlers.HTTPHandler": {
        "descr": "Returns a new instance of the HTTPHandler class. The host can be of the form host:port, should you need to use a specific port number. If no method is specified, GET is used. If secure is true, an HTTPS connection will be used. If credentials is specified, it should be a 2-tuple consisting of userid and password, which will be placed in an HTTP \u2018Authorization\u2019 header using Basic authentication. If you specify credentials, you should also specify secure=True so that your userid and password are not passed in cleartext across the wire.", 
        "name": "logging.handlers.HTTPHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.HTTPHandler", 
        "syntax": "class logging.handlers.HTTPHandler(host, url, method='GET', secure=False, credentials=None)", 
        "type": "Logging"
    }, 
    "logging.handlers.HTTPHandler.emit": {
        "descr": "Sends the record to the Web server as a percent-encoded dictionary.", 
        "name": "logging.handlers.HTTPHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.HTTPHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.MemoryHandler": {
        "descr": "Returns a new instance of the MemoryHandler class. The instance is initialized with a buffer size of capacity. If flushLevel is not specified, ERROR is used. If no target is specified, the target will need to be set using setTarget() before this handler does anything useful.", 
        "name": "logging.handlers.MemoryHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.MemoryHandler", 
        "syntax": "class logging.handlers.MemoryHandler(capacity, flushLevel=ERROR, target=None)", 
        "type": "Logging"
    }, 
    "logging.handlers.MemoryHandler.close": {
        "descr": "Calls flush(), sets the target to None and clears the buffer.", 
        "name": "logging.handlers.MemoryHandler.close", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.MemoryHandler.close", 
        "syntax": "close()", 
        "type": "Logging"
    }, 
    "logging.handlers.MemoryHandler.flush": {
        "descr": "For a MemoryHandler, flushing means just sending the buffered records to the target, if there is one. The buffer is also cleared when this happens. Override if you want different behavior.", 
        "name": "logging.handlers.MemoryHandler.flush", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.MemoryHandler.flush", 
        "syntax": "flush()", 
        "type": "Logging"
    }, 
    "logging.handlers.MemoryHandler.setTarget": {
        "descr": "Sets the target handler for this handler.", 
        "name": "logging.handlers.MemoryHandler.setTarget", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.MemoryHandler.setTarget", 
        "syntax": "setTarget(target)", 
        "type": "Logging"
    }, 
    "logging.handlers.MemoryHandler.shouldFlush": {
        "descr": "Checks for buffer full or a record at the flushLevel or higher.", 
        "name": "logging.handlers.MemoryHandler.shouldFlush", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.MemoryHandler.shouldFlush", 
        "syntax": "shouldFlush(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.NTEventLogHandler": {
        "descr": "Returns a new instance of the NTEventLogHandler class. The appname is used to define the application name as it appears in the event log. An appropriate registry entry is created using this name. The dllname should give the fully qualified pathname of a .dll or .exe which contains message definitions to hold in the log (if not specified, 'win32service.pyd' is used - this is installed with the Win32 extensions and contains some basic placeholder message definitions. Note that use of these placeholders will make your event logs big, as the entire message source is held in the log. If you want slimmer logs, you have to pass in the name of your own .dll or .exe which contains the message definitions you want to use in the event log). The logtype is one of 'Application', 'System' or 'Security', and defaults to 'Application'.", 
        "name": "logging.handlers.NTEventLogHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.NTEventLogHandler", 
        "syntax": "class logging.handlers.NTEventLogHandler(appname, dllname=None, logtype='Application')", 
        "type": "Logging"
    }, 
    "logging.handlers.NTEventLogHandler.close": {
        "descr": "At this point, you can remove the application name from the registry as a source of event log entries. However, if you do this, you will not be able to see the events as you intended in the Event Log Viewer - it needs to be able to access the registry to get the .dll name. The current version does not do this.", 
        "name": "logging.handlers.NTEventLogHandler.close", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.NTEventLogHandler.close", 
        "syntax": "close()", 
        "type": "Logging"
    }, 
    "logging.handlers.NTEventLogHandler.emit": {
        "descr": "Determines the message ID, event category and event type, and then logs the message in the NT event log.", 
        "name": "logging.handlers.NTEventLogHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.NTEventLogHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.NTEventLogHandler.getEventCategory": {
        "descr": "Returns the event category for the record. Override this if you want to specify your own categories. This version returns 0.", 
        "name": "logging.handlers.NTEventLogHandler.getEventCategory", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.NTEventLogHandler.getEventCategory", 
        "syntax": "getEventCategory(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.NTEventLogHandler.getEventType": {
        "descr": "Returns the event type for the record. Override this if you want to specify your own types. This version does a mapping using the handler\u2019s typemap attribute, which is set up in __init__() to a dictionary which contains mappings for DEBUG, INFO, WARNING, ERROR and CRITICAL. If you are using your own levels, you will either need to override this method or place a suitable dictionary in the handler\u2019s typemap attribute.", 
        "name": "logging.handlers.NTEventLogHandler.getEventType", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.NTEventLogHandler.getEventType", 
        "syntax": "getEventType(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.NTEventLogHandler.getMessageID": {
        "descr": "Returns the message ID for the record. If you are using your own messages, you could do this by having the msg passed to the logger being an ID rather than a format string. Then, in here, you could use a dictionary lookup to get the message ID. This version returns 1, which is the base message ID in win32service.pyd.", 
        "name": "logging.handlers.NTEventLogHandler.getMessageID", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.NTEventLogHandler.getMessageID", 
        "syntax": "getMessageID(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueHandler": {
        "descr": "Returns a new instance of the QueueHandler class. The instance is initialized with the queue to send messages to. The queue can be any queue- like object; it\u2019s used as-is by the enqueue() method, which needs to know how to send messages to it.", 
        "name": "logging.handlers.QueueHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueHandler", 
        "syntax": "class logging.handlers.QueueHandler(queue)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueHandler.emit": {
        "descr": "Enqueues the result of preparing the LogRecord.", 
        "name": "logging.handlers.QueueHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueHandler.enqueue": {
        "descr": "Enqueues the record on the queue using put_nowait(); you may want to override this if you want to use blocking behaviour, or a timeout, or a customized queue implementation.", 
        "name": "logging.handlers.QueueHandler.enqueue", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueHandler.enqueue", 
        "syntax": "enqueue(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueHandler.prepare": {
        "descr": "Prepares a record for queuing. The object returned by this method is enqueued.", 
        "name": "logging.handlers.QueueHandler.prepare", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueHandler.prepare", 
        "syntax": "prepare(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener": {
        "descr": "Returns a new instance of the QueueListener class. The instance is initialized with the queue to send messages to and a list of handlers which will handle entries placed on the queue. The queue can be any queue- like object; it\u2019s passed as-is to the dequeue() method, which needs to know how to get messages from it.", 
        "name": "logging.handlers.QueueListener", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener", 
        "syntax": "class logging.handlers.QueueListener(queue, *handlers)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener.dequeue": {
        "descr": "Dequeues a record and return it, optionally blocking.", 
        "name": "logging.handlers.QueueListener.dequeue", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener.dequeue", 
        "syntax": "dequeue(block)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener.enqueue_sentinel": {
        "descr": "Writes a sentinel to the queue to tell the listener to quit. This implementation uses put_nowait(). You may want to override this method if you want to use timeouts or work with custom queue implementations.", 
        "name": "logging.handlers.QueueListener.enqueue_sentinel", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener.enqueue_sentinel", 
        "syntax": "enqueue_sentinel()", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener.handle": {
        "descr": "Handle a record.", 
        "name": "logging.handlers.QueueListener.handle", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener.handle", 
        "syntax": "handle(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener.prepare": {
        "descr": "Prepare a record for handling.", 
        "name": "logging.handlers.QueueListener.prepare", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener.prepare", 
        "syntax": "prepare(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener.start": {
        "descr": "Starts the listener.", 
        "name": "logging.handlers.QueueListener.start", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener.start", 
        "syntax": "start()", 
        "type": "Logging"
    }, 
    "logging.handlers.QueueListener.stop": {
        "descr": "Stops the listener.", 
        "name": "logging.handlers.QueueListener.stop", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.QueueListener.stop", 
        "syntax": "stop()", 
        "type": "Logging"
    }, 
    "logging.handlers.RotatingFileHandler": {
        "descr": "Returns a new instance of the RotatingFileHandler class. The specified file is opened and used as the stream for logging. If mode is not specified, 'a' is used. If encoding is not None, it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to emit(). By default, the file grows indefinitely.", 
        "name": "logging.handlers.RotatingFileHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.RotatingFileHandler", 
        "syntax": "class logging.handlers.RotatingFileHandler(filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=0)", 
        "type": "Logging"
    }, 
    "logging.handlers.RotatingFileHandler.doRollover": {
        "descr": "Does a rollover, as described above.", 
        "name": "logging.handlers.RotatingFileHandler.doRollover", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.RotatingFileHandler.doRollover", 
        "syntax": "doRollover()", 
        "type": "Logging"
    }, 
    "logging.handlers.RotatingFileHandler.emit": {
        "descr": "Outputs the record to the file, catering for rollover as described previously.", 
        "name": "logging.handlers.RotatingFileHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.RotatingFileHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.SMTPHandler": {
        "descr": "Returns a new instance of the SMTPHandler class. The instance is initialized with the from and to addresses and subject line of the email. The toaddrs should be a list of strings. To specify a non-standard SMTP port, use the (host, port) tuple format for the mailhost argument. If you use a string, the standard SMTP port is used. If your SMTP server requires authentication, you can specify a (username, password) tuple for the credentials argument.", 
        "name": "logging.handlers.SMTPHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SMTPHandler", 
        "syntax": "class logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0)", 
        "type": "Logging"
    }, 
    "logging.handlers.SMTPHandler.emit": {
        "descr": "Formats the record and sends it to the specified addressees.", 
        "name": "logging.handlers.SMTPHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SMTPHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.SMTPHandler.getSubject": {
        "descr": "If you want to specify a subject line which is record-dependent, override this method.", 
        "name": "logging.handlers.SMTPHandler.getSubject", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SMTPHandler.getSubject", 
        "syntax": "getSubject(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler": {
        "descr": "Returns a new instance of the SocketHandler class intended to communicate with a remote machine whose address is given by host and port.", 
        "name": "logging.handlers.SocketHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler", 
        "syntax": "class logging.handlers.SocketHandler(host, port)", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.close": {
        "descr": "Closes the socket.", 
        "name": "logging.handlers.SocketHandler.close", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.close", 
        "syntax": "close()", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.createSocket": {
        "descr": "Tries to create a socket; on failure, uses an exponential back-off algorithm. On intial failure, the handler will drop the message it was trying to send. When subsequent messages are handled by the same instance, it will not try connecting until some time has passed. The default parameters are such that the initial delay is one second, and if after that delay the connection still can\u2019t be made, the handler will double the delay each time up to a maximum of 30 seconds.", 
        "name": "logging.handlers.SocketHandler.createSocket", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.createSocket", 
        "syntax": "createSocket()", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.emit": {
        "descr": "Pickles the record\u2019s attribute dictionary and writes it to the socket in binary format. If there is an error with the socket, silently drops the packet. If the connection was previously lost, re-establishes the connection. To unpickle the record at the receiving end into a LogRecord, use the makeLogRecord() function.", 
        "name": "logging.handlers.SocketHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.emit", 
        "syntax": "emit()", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.handleError": {
        "descr": "Handles an error which has occurred during emit(). The most likely cause is a lost connection. Closes the socket so that we can retry on the next event.", 
        "name": "logging.handlers.SocketHandler.handleError", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.handleError", 
        "syntax": "handleError()", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.makePickle": {
        "descr": "Pickles the record\u2019s attribute dictionary in binary format with a length prefix, and returns it ready for transmission across the socket.", 
        "name": "logging.handlers.SocketHandler.makePickle", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.makePickle", 
        "syntax": "makePickle(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.makeSocket": {
        "descr": "This is a factory method which allows subclasses to define the precise type of socket they want. The default implementation creates a TCP socket (socket.SOCK_STREAM).", 
        "name": "logging.handlers.SocketHandler.makeSocket", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.makeSocket", 
        "syntax": "makeSocket()", 
        "type": "Logging"
    }, 
    "logging.handlers.SocketHandler.send": {
        "descr": "Send a pickled string packet to the socket. This function allows for partial sends which can happen when the network is busy.", 
        "name": "logging.handlers.SocketHandler.send", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SocketHandler.send", 
        "syntax": "send(packet)", 
        "type": "Logging"
    }, 
    "logging.handlers.SysLogHandler": {
        "descr": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose address is given by address in the form of a (host, port) tuple. If address is not specified, ('localhost', 514) is used. The address is used to open a socket. An alternative to providing a (host, port) tuple is providing an address as a string, for example \u2018/dev/log\u2019. In this case, a Unix domain socket is used to send the message to the syslog. If facility is not specified, LOG_USER is used. The type of socket opened depends on the socktype argument, which defaults to socket.SOCK_DGRAM and thus opens a UDP socket. To open a TCP socket (for use with the newer syslog daemons such as rsyslog), specify a value of socket.SOCK_STREAM.", 
        "name": "logging.handlers.SysLogHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SysLogHandler", 
        "syntax": "class logging.handlers.SysLogHandler(address=('localhost', SYSLOG_UDP_PORT), facility=LOG_USER, socktype=socket.SOCK_DGRAM)", 
        "type": "Logging"
    }, 
    "logging.handlers.SysLogHandler.close": {
        "descr": "Closes the socket to the remote host.", 
        "name": "logging.handlers.SysLogHandler.close", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SysLogHandler.close", 
        "syntax": "close()", 
        "type": "Logging"
    }, 
    "logging.handlers.SysLogHandler.emit": {
        "descr": "The record is formatted, and then sent to the syslog server. If exception information is present, it is not sent to the server.", 
        "name": "logging.handlers.SysLogHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SysLogHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.SysLogHandler.encodePriority": {
        "descr": "Encodes the facility and priority into an integer. You can pass in strings or integers - if strings are passed, internal mapping dictionaries are used to convert them to integers.", 
        "name": "logging.handlers.SysLogHandler.encodePriority", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SysLogHandler.encodePriority", 
        "syntax": "encodePriority(facility, priority)", 
        "type": "Logging"
    }, 
    "logging.handlers.SysLogHandler.mapPriority": {
        "descr": "Maps a logging level name to a syslog priority name. You may need to override this if you are using custom levels, or if the default algorithm is not suitable for your needs. The default algorithm maps DEBUG, INFO, WARNING, ERROR and CRITICAL to the equivalent syslog names, and all other level names to \u2018warning\u2019.", 
        "name": "logging.handlers.SysLogHandler.mapPriority", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.SysLogHandler.mapPriority", 
        "syntax": "mapPriority(levelname)", 
        "type": "Logging"
    }, 
    "logging.handlers.TimedRotatingFileHandler": {
        "descr": "Returns a new instance of the TimedRotatingFileHandler class. The specified file is opened and used as the stream for logging. On rotating it also sets the filename suffix. Rotating happens based on the product of when and interval.", 
        "name": "logging.handlers.TimedRotatingFileHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.TimedRotatingFileHandler", 
        "syntax": "class logging.handlers.TimedRotatingFileHandler(filename, when='h', interval=1, backupCount=0, encoding=None, delay=False, utc=False)", 
        "type": "Logging"
    }, 
    "logging.handlers.TimedRotatingFileHandler.doRollover": {
        "descr": "Does a rollover, as described above.", 
        "name": "logging.handlers.TimedRotatingFileHandler.doRollover", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.TimedRotatingFileHandler.doRollover", 
        "syntax": "doRollover()", 
        "type": "Logging"
    }, 
    "logging.handlers.TimedRotatingFileHandler.emit": {
        "descr": "Outputs the record to the file, catering for rollover as described above.", 
        "name": "logging.handlers.TimedRotatingFileHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.TimedRotatingFileHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.handlers.WatchedFileHandler": {
        "descr": "Returns a new instance of the WatchedFileHandler class. The specified file is opened and used as the stream for logging. If mode is not specified, 'a' is used. If encoding is not None, it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to emit(). By default, the file grows indefinitely.", 
        "name": "logging.handlers.WatchedFileHandler", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.WatchedFileHandler", 
        "syntax": "class logging.handlers.WatchedFileHandler(filename[, mode[, encoding[, delay]]])", 
        "type": "Logging"
    }, 
    "logging.handlers.WatchedFileHandler.emit": {
        "descr": "Outputs the record to the file, but first checks to see if the file has changed. If it has, the existing stream is flushed and closed and the file opened again, before outputting the record to the file.", 
        "name": "logging.handlers.WatchedFileHandler.emit", 
        "params": [], 
        "path": "python/library/logging.handlers#logging.handlers.WatchedFileHandler.emit", 
        "syntax": "emit(record)", 
        "type": "Logging"
    }, 
    "logging.info": {
        "descr": "Logs a message with level INFO on the root logger. The arguments are interpreted as for debug().", 
        "name": "logging.info", 
        "params": [], 
        "path": "python/library/logging#logging.info", 
        "syntax": "logging.info(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.lastResort": {
        "descr": "A \u201chandler of last resort\u201d is available through this attribute. This is a StreamHandler writing to sys.stderr with a level of WARNING, and is used to handle logging events in the absence of any logging configuration. The end result is to just print the message to sys.stderr. This replaces the earlier error message saying that \u201cno handlers could be found for logger XYZ\u201d. If you need the earlier behaviour for some reason, lastResort can be set to None.", 
        "name": "logging.lastResort", 
        "params": [], 
        "path": "python/library/logging#logging.lastResort", 
        "syntax": "logging.lastResort", 
        "type": "Logging"
    }, 
    "logging.log": {
        "descr": "Logs a message with level level on the root logger. The other arguments are interpreted as for debug().", 
        "name": "logging.log", 
        "params": [], 
        "path": "python/library/logging#logging.log", 
        "syntax": "logging.log(level, msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "logging.makeLogRecord": {
        "descr": "Creates and returns a new LogRecord instance whose attributes are defined by attrdict. This function is useful for taking a pickled LogRecord attribute dictionary, sent over a socket, and reconstituting it as a LogRecord instance at the receiving end.", 
        "name": "logging.makeLogRecord", 
        "params": [], 
        "path": "python/library/logging#logging.makeLogRecord", 
        "syntax": "logging.makeLogRecord(attrdict)", 
        "type": "Logging"
    }, 
    "logging.setLogRecordFactory": {
        "descr": "Set a callable which is used to create a LogRecord.", 
        "name": "logging.setLogRecordFactory", 
        "params": [], 
        "path": "python/library/logging#logging.setLogRecordFactory", 
        "syntax": "logging.setLogRecordFactory(factory)", 
        "type": "Logging"
    }, 
    "logging.setLoggerClass": {
        "descr": "Tells the logging system to use the class klass when instantiating a logger. The class should define __init__() such that only a name argument is required, and the __init__() should call Logger.__init__(). This function is typically called before any loggers are instantiated by applications which need to use custom logger behavior.", 
        "name": "logging.setLoggerClass", 
        "params": [], 
        "path": "python/library/logging#logging.setLoggerClass", 
        "syntax": "logging.setLoggerClass(klass)", 
        "type": "Logging"
    }, 
    "logging.shutdown": {
        "descr": "Informs the logging system to perform an orderly shutdown by flushing and closing all handlers. This should be called at application exit and no further use of the logging system should be made after this call.", 
        "name": "logging.shutdown", 
        "params": [], 
        "path": "python/library/logging#logging.shutdown", 
        "syntax": "logging.shutdown()", 
        "type": "Logging"
    }, 
    "logging.warning": {
        "descr": "Logs a message with level WARNING on the root logger. The arguments are interpreted as for debug().", 
        "name": "logging.warning", 
        "params": [], 
        "path": "python/library/logging#logging.warning", 
        "syntax": "logging.warning(msg, *args, **kwargs)", 
        "type": "Logging"
    }, 
    "lower": {
        "descr": "Return a copy of the string with all the cased characters [4] converted to lowercase.", 
        "name": "str.lower", 
        "params": [], 
        "path": "python/library/stdtypes#str.lower", 
        "syntax": "str.lower()", 
        "type": "Built-in Types"
    }, 
    "lstrip": {
        "descr": "Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped:", 
        "name": "str.lstrip", 
        "params": [], 
        "path": "python/library/stdtypes#str.lstrip", 
        "syntax": "str.lstrip([chars])", 
        "type": "Built-in Types"
    }, 
    "lzma.LZMACompressor": {
        "descr": "Create a compressor object, which can be used to compress data incrementally.", 
        "name": "lzma.LZMACompressor", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMACompressor", 
        "syntax": "class lzma.LZMACompressor(format=FORMAT_XZ, check=-1, preset=None, filters=None)", 
        "type": "Data Compression"
    }, 
    "lzma.LZMACompressor.compress": {
        "descr": "Compress data (a bytes object), returning a bytes object containing compressed data for at least part of the input. Some of data may be buffered internally, for use in later calls to compress() and flush(). The returned data should be concatenated with the output of any previous calls to compress().", 
        "name": "lzma.LZMACompressor.compress", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMACompressor.compress", 
        "syntax": "compress(data)", 
        "type": "Data Compression"
    }, 
    "lzma.LZMACompressor.flush": {
        "descr": "Finish the compression process, returning a bytes object containing any data stored in the compressor\u2019s internal buffers.", 
        "name": "lzma.LZMACompressor.flush", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMACompressor.flush", 
        "syntax": "flush()", 
        "type": "Data Compression"
    }, 
    "lzma.LZMADecompressor": {
        "descr": "Create a decompressor object, which can be used to decompress data incrementally.", 
        "name": "lzma.LZMADecompressor", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMADecompressor", 
        "syntax": "class lzma.LZMADecompressor(format=FORMAT_AUTO, memlimit=None, filters=None)", 
        "type": "Data Compression"
    }, 
    "lzma.LZMADecompressor.check": {
        "descr": "The ID of the integrity check used by the input stream. This may be CHECK_UNKNOWN until enough of the input has been decoded to determine what integrity check it uses.", 
        "name": "lzma.LZMADecompressor.check", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMADecompressor.check", 
        "syntax": "check", 
        "type": "Data Compression"
    }, 
    "lzma.LZMADecompressor.decompress": {
        "descr": "Decompress data (a bytes object), returning a bytes object containing the decompressed data for at least part of the input. Some of data may be buffered internally, for use in later calls to decompress(). The returned data should be concatenated with the output of any previous calls to decompress().", 
        "name": "lzma.LZMADecompressor.decompress", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMADecompressor.decompress", 
        "syntax": "decompress(data)", 
        "type": "Data Compression"
    }, 
    "lzma.LZMADecompressor.eof": {
        "descr": "True if the end-of-stream marker has been reached.", 
        "name": "lzma.LZMADecompressor.eof", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMADecompressor.eof", 
        "syntax": "eof", 
        "type": "Data Compression"
    }, 
    "lzma.LZMADecompressor.unused_data": {
        "descr": "Data found after the end of the compressed stream.", 
        "name": "lzma.LZMADecompressor.unused_data", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMADecompressor.unused_data", 
        "syntax": "unused_data", 
        "type": "Data Compression"
    }, 
    "lzma.LZMAError": {
        "descr": "This exception is raised when an error occurs during compression or decompression, or while initializing the compressor/decompressor state.", 
        "name": "lzma.LZMAError", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMAError", 
        "syntax": "exception lzma.LZMAError", 
        "type": "Data Compression"
    }, 
    "lzma.LZMAFile": {
        "descr": "Open an LZMA-compressed file in binary mode.", 
        "name": "lzma.LZMAFile", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMAFile", 
        "syntax": "class lzma.LZMAFile(filename=None, mode=\"r\", *, format=None, check=-1, preset=None, filters=None)", 
        "type": "Data Compression"
    }, 
    "lzma.LZMAFile.peek": {
        "descr": "Return buffered data without advancing the file position. At least one byte of data will be returned, unless EOF has been reached. The exact number of bytes returned is unspecified (the size argument is ignored).", 
        "name": "lzma.LZMAFile.peek", 
        "params": [], 
        "path": "python/library/lzma#lzma.LZMAFile.peek", 
        "syntax": "peek(size=-1)", 
        "type": "Data Compression"
    }, 
    "lzma.compress": {
        "descr": "Compress data (a bytes object), returning the compressed data as a bytes object.", 
        "name": "lzma.compress", 
        "params": [], 
        "path": "python/library/lzma#lzma.compress", 
        "syntax": "lzma.compress(data, format=FORMAT_XZ, check=-1, preset=None, filters=None)", 
        "type": "Data Compression"
    }, 
    "lzma.decompress": {
        "descr": "Decompress data (a bytes object), returning the uncompressed data as a bytes object.", 
        "name": "lzma.decompress", 
        "params": [], 
        "path": "python/library/lzma#lzma.decompress", 
        "syntax": "lzma.decompress(data, format=FORMAT_AUTO, memlimit=None, filters=None)", 
        "type": "Data Compression"
    }, 
    "lzma.is_check_supported": {
        "descr": "Returns true if the given integrity check is supported on this system.", 
        "name": "lzma.is_check_supported", 
        "params": [], 
        "path": "python/library/lzma#lzma.is_check_supported", 
        "syntax": "lzma.is_check_supported(check)", 
        "type": "Data Compression"
    }, 
    "lzma.open": {
        "descr": "Open an LZMA-compressed file in binary or text mode, returning a file object.", 
        "name": "lzma.open", 
        "params": [], 
        "path": "python/library/lzma#lzma.open", 
        "syntax": "lzma.open(filename, mode=\"rb\", *, format=None, check=-1, preset=None, filters=None, encoding=None, errors=None, newline=None)", 
        "type": "Data Compression"
    }, 
    "mailbox.Babyl": {
        "descr": "A subclass of Mailbox for mailboxes in Babyl format. Parameter factory is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If factory is None, BabylMessage is used as the default message representation. If create is True, the mailbox is created if it does not exist.", 
        "name": "mailbox.Babyl", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Babyl", 
        "syntax": "class mailbox.Babyl(path, factory=None, create=True)", 
        "type": "Internet Data"
    }, 
    "mailbox.Babyl.get_file": {
        "descr": "In Babyl mailboxes, the headers of a message are not stored contiguously with the body of the message. To generate a file-like representation, the headers and body are copied together into a io.BytesIO instance, which has an API identical to that of a file. As a result, the file-like object is truly independent of the underlying mailbox but does not save memory compared to a string representation.", 
        "name": "mailbox.Babyl.get_file", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Babyl.get_file", 
        "syntax": "get_file(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Babyl.get_labels": {
        "descr": "Return a list of the names of all user-defined labels used in the mailbox.", 
        "name": "mailbox.Babyl.get_labels", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Babyl.get_labels", 
        "syntax": "get_labels()", 
        "type": "Internet Data"
    }, 
    "mailbox.Babyl.lock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls.", 
        "name": "mailbox.Babyl.lock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Babyl.lock", 
        "syntax": "lock()", 
        "type": "Internet Data"
    }, 
    "mailbox.Babyl.unlock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls.", 
        "name": "mailbox.Babyl.unlock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Babyl.unlock", 
        "syntax": "unlock()", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage": {
        "descr": "A message with Babyl-specific behaviors. Parameter message has the same meaning as with the Message constructor.", 
        "name": "mailbox.BabylMessage", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage", 
        "syntax": "class mailbox.BabylMessage(message=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.add_label": {
        "descr": "Add label to the list of labels on the message.", 
        "name": "mailbox.BabylMessage.add_label", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.add_label", 
        "syntax": "add_label(label)", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.get_labels": {
        "descr": "Return a list of labels on the message.", 
        "name": "mailbox.BabylMessage.get_labels", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.get_labels", 
        "syntax": "get_labels()", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.get_visible": {
        "descr": "Return an Message instance whose headers are the message\u2019s visible headers and whose body is empty.", 
        "name": "mailbox.BabylMessage.get_visible", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.get_visible", 
        "syntax": "get_visible()", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.remove_label": {
        "descr": "Remove label from the list of labels on the message.", 
        "name": "mailbox.BabylMessage.remove_label", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.remove_label", 
        "syntax": "remove_label(label)", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.set_labels": {
        "descr": "Set the list of labels on the message to labels.", 
        "name": "mailbox.BabylMessage.set_labels", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.set_labels", 
        "syntax": "set_labels(labels)", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.set_visible": {
        "descr": "Set the message\u2019s visible headers to be the same as the headers in message. Parameter visible should be a Message instance, an email.message.Message instance, a string, or a file-like object (which should be open in text mode).", 
        "name": "mailbox.BabylMessage.set_visible", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.set_visible", 
        "syntax": "set_visible(visible)", 
        "type": "Internet Data"
    }, 
    "mailbox.BabylMessage.update_visible": {
        "descr": "When a BabylMessage instance\u2019s original headers are modified, the visible headers are not automatically modified to correspond. This method updates the visible headers as follows: each visible header with a corresponding original header is set to the value of the original header, each visible header without a corresponding original header is removed, and any of Date, From, Reply-To, To, CC, and Subject that are present in the original headers but not the visible headers are added to the visible headers.", 
        "name": "mailbox.BabylMessage.update_visible", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.BabylMessage.update_visible", 
        "syntax": "update_visible()", 
        "type": "Internet Data"
    }, 
    "mailbox.Error": {
        "descr": "The based class for all other module-specific exceptions.", 
        "name": "mailbox.Error", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Error", 
        "syntax": "exception mailbox.Error", 
        "type": "Internet Data"
    }, 
    "mailbox.ExternalClashError": {
        "descr": "Raised when some mailbox-related condition beyond the control of the program causes it to be unable to proceed, such as when failing to acquire a lock that another program already holds a lock, or when a uniquely-generated file name already exists.", 
        "name": "mailbox.ExternalClashError", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.ExternalClashError", 
        "syntax": "exception mailbox.ExternalClashError", 
        "type": "Internet Data"
    }, 
    "mailbox.FormatError": {
        "descr": "Raised when the data in a file cannot be parsed, such as when an MH instance attempts to read a corrupted .mh_sequences file.", 
        "name": "mailbox.FormatError", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.FormatError", 
        "syntax": "exception mailbox.FormatError", 
        "type": "Internet Data"
    }, 
    "mailbox.MH": {
        "descr": "A subclass of Mailbox for mailboxes in MH format. Parameter factory is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If factory is None, MHMessage is used as the default message representation. If create is True, the mailbox is created if it does not exist.", 
        "name": "mailbox.MH", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH", 
        "syntax": "class mailbox.MH(path, factory=None, create=True)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.__delitem__": {
        "descr": "These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.", 
        "name": "mailbox.MH.__delitem__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.__delitem__", 
        "syntax": "__delitem__(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.add_folder": {
        "descr": "Create a folder whose name is folder and return an MH instance representing it.", 
        "name": "mailbox.MH.add_folder", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.add_folder", 
        "syntax": "add_folder(folder)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.close": {
        "descr": "MH instances do not keep any open files, so this method is equivalent to unlock().", 
        "name": "mailbox.MH.close", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.close", 
        "syntax": "close()", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.discard": {
        "descr": "These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.", 
        "name": "mailbox.MH.discard", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.discard", 
        "syntax": "discard(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.flush": {
        "descr": "All changes to MH mailboxes are immediately applied, so this method does nothing.", 
        "name": "mailbox.MH.flush", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.flush", 
        "syntax": "flush()", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.get_file": {
        "descr": "Depending upon the host platform, it may not be possible to remove the underlying message while the returned file remains open.", 
        "name": "mailbox.MH.get_file", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.get_file", 
        "syntax": "get_file(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.get_folder": {
        "descr": "Return an MH instance representing the folder whose name is folder. A NoSuchMailboxError exception is raised if the folder does not exist.", 
        "name": "mailbox.MH.get_folder", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.get_folder", 
        "syntax": "get_folder(folder)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.get_sequences": {
        "descr": "Return a dictionary of sequence names mapped to key lists. If there are no sequences, the empty dictionary is returned.", 
        "name": "mailbox.MH.get_sequences", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.get_sequences", 
        "syntax": "get_sequences()", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.list_folders": {
        "descr": "Return a list of the names of all folders.", 
        "name": "mailbox.MH.list_folders", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.list_folders", 
        "syntax": "list_folders()", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.lock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls. For MH mailboxes, locking the mailbox means locking the .mh_sequences file and, only for the duration of any operations that affect them, locking individual message files.", 
        "name": "mailbox.MH.lock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.lock", 
        "syntax": "lock()", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.pack": {
        "descr": "Rename messages in the mailbox as necessary to eliminate gaps in numbering. Entries in the sequences list are updated correspondingly.", 
        "name": "mailbox.MH.pack", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.pack", 
        "syntax": "pack()", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.remove": {
        "descr": "These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.", 
        "name": "mailbox.MH.remove", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.remove", 
        "syntax": "remove(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.remove_folder": {
        "descr": "Delete the folder whose name is folder. If the folder contains any messages, a NotEmptyError exception will be raised and the folder will not be deleted.", 
        "name": "mailbox.MH.remove_folder", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.remove_folder", 
        "syntax": "remove_folder(folder)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.set_sequences": {
        "descr": "Re-define the sequences that exist in the mailbox based upon sequences, a dictionary of names mapped to key lists, like returned by get_sequences().", 
        "name": "mailbox.MH.set_sequences", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.set_sequences", 
        "syntax": "set_sequences(sequences)", 
        "type": "Internet Data"
    }, 
    "mailbox.MH.unlock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls. For MH mailboxes, locking the mailbox means locking the .mh_sequences file and, only for the duration of any operations that affect them, locking individual message files.", 
        "name": "mailbox.MH.unlock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MH.unlock", 
        "syntax": "unlock()", 
        "type": "Internet Data"
    }, 
    "mailbox.MHMessage": {
        "descr": "A message with MH-specific behaviors. Parameter message has the same meaning as with the Message constructor.", 
        "name": "mailbox.MHMessage", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MHMessage", 
        "syntax": "class mailbox.MHMessage(message=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.MHMessage.add_sequence": {
        "descr": "Add sequence to the list of sequences that include this message.", 
        "name": "mailbox.MHMessage.add_sequence", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MHMessage.add_sequence", 
        "syntax": "add_sequence(sequence)", 
        "type": "Internet Data"
    }, 
    "mailbox.MHMessage.get_sequences": {
        "descr": "Return a list of the names of sequences that include this message.", 
        "name": "mailbox.MHMessage.get_sequences", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MHMessage.get_sequences", 
        "syntax": "get_sequences()", 
        "type": "Internet Data"
    }, 
    "mailbox.MHMessage.remove_sequence": {
        "descr": "Remove sequence from the list of sequences that include this message.", 
        "name": "mailbox.MHMessage.remove_sequence", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MHMessage.remove_sequence", 
        "syntax": "remove_sequence(sequence)", 
        "type": "Internet Data"
    }, 
    "mailbox.MHMessage.set_sequences": {
        "descr": "Set the list of sequences that include this message.", 
        "name": "mailbox.MHMessage.set_sequences", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MHMessage.set_sequences", 
        "syntax": "set_sequences(sequences)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDF": {
        "descr": "A subclass of Mailbox for mailboxes in MMDF format. Parameter factory is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If factory is None, MMDFMessage is used as the default message representation. If create is True, the mailbox is created if it does not exist.", 
        "name": "mailbox.MMDF", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDF", 
        "syntax": "class mailbox.MMDF(path, factory=None, create=True)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDF.get_file": {
        "descr": "Using the file after calling flush() or close() on the MMDF instance may yield unpredictable results or raise an exception.", 
        "name": "mailbox.MMDF.get_file", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDF.get_file", 
        "syntax": "get_file(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDF.lock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls.", 
        "name": "mailbox.MMDF.lock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDF.lock", 
        "syntax": "lock()", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDF.unlock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls.", 
        "name": "mailbox.MMDF.unlock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDF.unlock", 
        "syntax": "unlock()", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage": {
        "descr": "A message with MMDF-specific behaviors. Parameter message has the same meaning as with the Message constructor.", 
        "name": "mailbox.MMDFMessage", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage", 
        "syntax": "class mailbox.MMDFMessage(message=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage.add_flag": {
        "descr": "Set the flag(s) specified by flag without changing other flags. To add more than one flag at a time, flag may be a string of more than one character.", 
        "name": "mailbox.MMDFMessage.add_flag", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage.add_flag", 
        "syntax": "add_flag(flag)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage.get_flags": {
        "descr": "Return a string specifying the flags that are currently set. If the message complies with the conventional format, the result is the concatenation in the following order of zero or one occurrence of each of 'R', 'O', 'D', 'F', and 'A'.", 
        "name": "mailbox.MMDFMessage.get_flags", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage.get_flags", 
        "syntax": "get_flags()", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage.get_from": {
        "descr": "Return a string representing the \u201cFrom \u201d line that marks the start of the message in an mbox mailbox. The leading \u201cFrom \u201d and the trailing newline are excluded.", 
        "name": "mailbox.MMDFMessage.get_from", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage.get_from", 
        "syntax": "get_from()", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage.remove_flag": {
        "descr": "Unset the flag(s) specified by flag without changing other flags. To remove more than one flag at a time, flag maybe a string of more than one character.", 
        "name": "mailbox.MMDFMessage.remove_flag", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage.remove_flag", 
        "syntax": "remove_flag(flag)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage.set_flags": {
        "descr": "Set the flags specified by flags and unset all others. Parameter flags should be the concatenation in any order of zero or more occurrences of each of 'R', 'O', 'D', 'F', and 'A'.", 
        "name": "mailbox.MMDFMessage.set_flags", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage.set_flags", 
        "syntax": "set_flags(flags)", 
        "type": "Internet Data"
    }, 
    "mailbox.MMDFMessage.set_from": {
        "descr": "Set the \u201cFrom \u201d line to from_, which should be specified without a leading \u201cFrom \u201d or trailing newline. For convenience, time_ may be specified and will be formatted appropriately and appended to from_. If time_ is specified, it should be a time.struct_time instance, a tuple suitable for passing to time.strftime(), or True (to use time.gmtime()).", 
        "name": "mailbox.MMDFMessage.set_from", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MMDFMessage.set_from", 
        "syntax": "set_from(from_, time_=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox": {
        "descr": "A mailbox, which may be inspected and modified.", 
        "name": "mailbox.Mailbox", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox", 
        "syntax": "class mailbox.Mailbox", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.__contains__": {
        "descr": "Return True if key corresponds to a message, False otherwise.", 
        "name": "mailbox.Mailbox.__contains__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.__contains__", 
        "syntax": "__contains__(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.__delitem__": {
        "descr": "Delete the message corresponding to key from the mailbox.", 
        "name": "mailbox.Mailbox.__delitem__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.__delitem__", 
        "syntax": "__delitem__(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.__getitem__": {
        "descr": "Return a representation of the message corresponding to key. If no such message exists, default is returned if the method was called as get() and a KeyError exception is raised if the method was called as __getitem__(). The message is represented as an instance of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.__getitem__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.__getitem__", 
        "syntax": "__getitem__(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.__iter__": {
        "descr": "Return an iterator over representations of all messages if called as itervalues() or __iter__() or return a list of such representations if called as values(). The messages are represented as instances of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.__iter__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.__iter__", 
        "syntax": "__iter__()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.__len__": {
        "descr": "Return a count of messages in the mailbox.", 
        "name": "mailbox.Mailbox.__len__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.__len__", 
        "syntax": "__len__()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.__setitem__": {
        "descr": "Replace the message corresponding to key with message. Raise a KeyError exception if no message already corresponds to key.", 
        "name": "mailbox.Mailbox.__setitem__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.__setitem__", 
        "syntax": "__setitem__(key, message)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.add": {
        "descr": "Add message to the mailbox and return the key that has been assigned to it.", 
        "name": "mailbox.Mailbox.add", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.add", 
        "syntax": "add(message)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.clear": {
        "descr": "Delete all messages from the mailbox.", 
        "name": "mailbox.Mailbox.clear", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.clear", 
        "syntax": "clear()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.close": {
        "descr": "Flush the mailbox, unlock it if necessary, and close any open files. For some Mailbox subclasses, this method does nothing.", 
        "name": "mailbox.Mailbox.close", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.close", 
        "syntax": "close()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.discard": {
        "descr": "Delete the message corresponding to key from the mailbox.", 
        "name": "mailbox.Mailbox.discard", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.discard", 
        "syntax": "discard(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.flush": {
        "descr": "Write any pending changes to the filesystem. For some Mailbox subclasses, changes are always written immediately and flush() does nothing, but you should still make a habit of calling this method.", 
        "name": "mailbox.Mailbox.flush", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.flush", 
        "syntax": "flush()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.get": {
        "descr": "Return a representation of the message corresponding to key. If no such message exists, default is returned if the method was called as get() and a KeyError exception is raised if the method was called as __getitem__(). The message is represented as an instance of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.get", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.get", 
        "syntax": "get(key, default=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.get_bytes": {
        "descr": "Return a byte representation of the message corresponding to key, or raise a KeyError exception if no such message exists.", 
        "name": "mailbox.Mailbox.get_bytes", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.get_bytes", 
        "syntax": "get_bytes(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.get_file": {
        "descr": "Return a file-like representation of the message corresponding to key, or raise a KeyError exception if no such message exists. The file-like object behaves as if open in binary mode. This file should be closed once it is no longer needed.", 
        "name": "mailbox.Mailbox.get_file", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.get_file", 
        "syntax": "get_file(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.get_message": {
        "descr": "Return a representation of the message corresponding to key as an instance of the appropriate format-specific Message subclass, or raise a KeyError exception if no such message exists.", 
        "name": "mailbox.Mailbox.get_message", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.get_message", 
        "syntax": "get_message(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.get_string": {
        "descr": "Return a string representation of the message corresponding to key, or raise a KeyError exception if no such message exists. The message is processed through email.message.Message to convert it to a 7bit clean representation.", 
        "name": "mailbox.Mailbox.get_string", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.get_string", 
        "syntax": "get_string(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.items": {
        "descr": "Return an iterator over (key, message) pairs, where key is a key and message is a message representation, if called as iteritems() or return a list of such pairs if called as items(). The messages are represented as instances of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.items", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.items", 
        "syntax": "items()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.iteritems": {
        "descr": "Return an iterator over (key, message) pairs, where key is a key and message is a message representation, if called as iteritems() or return a list of such pairs if called as items(). The messages are represented as instances of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.iteritems", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.iteritems", 
        "syntax": "iteritems()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.iterkeys": {
        "descr": "Return an iterator over all keys if called as iterkeys() or return a list of keys if called as keys().", 
        "name": "mailbox.Mailbox.iterkeys", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.iterkeys", 
        "syntax": "iterkeys()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.itervalues": {
        "descr": "Return an iterator over representations of all messages if called as itervalues() or __iter__() or return a list of such representations if called as values(). The messages are represented as instances of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.itervalues", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.itervalues", 
        "syntax": "itervalues()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.keys": {
        "descr": "Return an iterator over all keys if called as iterkeys() or return a list of keys if called as keys().", 
        "name": "mailbox.Mailbox.keys", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.keys", 
        "syntax": "keys()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.lock": {
        "descr": "Acquire an exclusive advisory lock on the mailbox so that other processes know not to modify it. An ExternalClashError is raised if the lock is not available. The particular locking mechanisms used depend upon the mailbox format. You should always lock the mailbox before making any modifications to its contents.", 
        "name": "mailbox.Mailbox.lock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.lock", 
        "syntax": "lock()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.pop": {
        "descr": "Return a representation of the message corresponding to key and delete the message. If no such message exists, return default. The message is represented as an instance of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.pop", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.pop", 
        "syntax": "pop(key, default=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.popitem": {
        "descr": "Return an arbitrary (key, message) pair, where key is a key and message is a message representation, and delete the corresponding message. If the mailbox is empty, raise a KeyError exception. The message is represented as an instance of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.popitem", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.popitem", 
        "syntax": "popitem()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.remove": {
        "descr": "Delete the message corresponding to key from the mailbox.", 
        "name": "mailbox.Mailbox.remove", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.remove", 
        "syntax": "remove(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.unlock": {
        "descr": "Release the lock on the mailbox, if any.", 
        "name": "mailbox.Mailbox.unlock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.unlock", 
        "syntax": "unlock()", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.update": {
        "descr": "Parameter arg should be a key-to-message mapping or an iterable of (key, message) pairs. Updates the mailbox so that, for each given key and message, the message corresponding to key is set to message as if by using __setitem__(). As with __setitem__(), each key must already correspond to a message in the mailbox or else a KeyError exception will be raised, so in general it is incorrect for arg to be a Mailbox instance.", 
        "name": "mailbox.Mailbox.update", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.update", 
        "syntax": "update(arg)", 
        "type": "Internet Data"
    }, 
    "mailbox.Mailbox.values": {
        "descr": "Return an iterator over representations of all messages if called as itervalues() or __iter__() or return a list of such representations if called as values(). The messages are represented as instances of the appropriate format-specific Message subclass unless a custom message factory was specified when the Mailbox instance was initialized.", 
        "name": "mailbox.Mailbox.values", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Mailbox.values", 
        "syntax": "values()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir": {
        "descr": "A subclass of Mailbox for mailboxes in Maildir format. Parameter factory is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If factory is None, MaildirMessage is used as the default message representation. If create is True, the mailbox is created if it does not exist.", 
        "name": "mailbox.Maildir", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir", 
        "syntax": "class mailbox.Maildir(dirname, factory=None, create=True)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.__setitem__": {
        "descr": "", 
        "name": "mailbox.Maildir.__setitem__", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.__setitem__", 
        "syntax": "__setitem__(key, message)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.add": {
        "descr": "", 
        "name": "mailbox.Maildir.add", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.add", 
        "syntax": "add(message)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.add_folder": {
        "descr": "Create a folder whose name is folder and return a Maildir instance representing it.", 
        "name": "mailbox.Maildir.add_folder", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.add_folder", 
        "syntax": "add_folder(folder)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.clean": {
        "descr": "Delete temporary files from the mailbox that have not been accessed in the last 36 hours. The Maildir specification says that mail-reading programs should do this occasionally.", 
        "name": "mailbox.Maildir.clean", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.clean", 
        "syntax": "clean()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.close": {
        "descr": "Maildir instances do not keep any open files and the underlying mailboxes do not support locking, so this method does nothing.", 
        "name": "mailbox.Maildir.close", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.close", 
        "syntax": "close()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.flush": {
        "descr": "All changes to Maildir mailboxes are immediately applied, so this method does nothing.", 
        "name": "mailbox.Maildir.flush", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.flush", 
        "syntax": "flush()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.get_file": {
        "descr": "Depending upon the host platform, it may not be possible to modify or remove the underlying message while the returned file remains open.", 
        "name": "mailbox.Maildir.get_file", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.get_file", 
        "syntax": "get_file(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.get_folder": {
        "descr": "Return a Maildir instance representing the folder whose name is folder. A NoSuchMailboxError exception is raised if the folder does not exist.", 
        "name": "mailbox.Maildir.get_folder", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.get_folder", 
        "syntax": "get_folder(folder)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.list_folders": {
        "descr": "Return a list of the names of all folders.", 
        "name": "mailbox.Maildir.list_folders", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.list_folders", 
        "syntax": "list_folders()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.lock": {
        "descr": "Maildir mailboxes do not support (or require) locking, so these methods do nothing.", 
        "name": "mailbox.Maildir.lock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.lock", 
        "syntax": "lock()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.remove_folder": {
        "descr": "Delete the folder whose name is folder. If the folder contains any messages, a NotEmptyError exception will be raised and the folder will not be deleted.", 
        "name": "mailbox.Maildir.remove_folder", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.remove_folder", 
        "syntax": "remove_folder(folder)", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.unlock": {
        "descr": "Maildir mailboxes do not support (or require) locking, so these methods do nothing.", 
        "name": "mailbox.Maildir.unlock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.unlock", 
        "syntax": "unlock()", 
        "type": "Internet Data"
    }, 
    "mailbox.Maildir.update": {
        "descr": "", 
        "name": "mailbox.Maildir.update", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Maildir.update", 
        "syntax": "update(arg)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage": {
        "descr": "A message with Maildir-specific behaviors. Parameter message has the same meaning as with the Message constructor.", 
        "name": "mailbox.MaildirMessage", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage", 
        "syntax": "class mailbox.MaildirMessage(message=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.add_flag": {
        "descr": "Set the flag(s) specified by flag without changing other flags. To add more than one flag at a time, flag may be a string of more than one character. The current \u201cinfo\u201d is overwritten whether or not it contains experimental information rather than flags.", 
        "name": "mailbox.MaildirMessage.add_flag", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.add_flag", 
        "syntax": "add_flag(flag)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.get_date": {
        "descr": "Return the delivery date of the message as a floating-point number representing seconds since the epoch.", 
        "name": "mailbox.MaildirMessage.get_date", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.get_date", 
        "syntax": "get_date()", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.get_flags": {
        "descr": "Return a string specifying the flags that are currently set. If the message complies with the standard Maildir format, the result is the concatenation in alphabetical order of zero or one occurrence of each of 'D', 'F', 'P', 'R', 'S', and 'T'. The empty string is returned if no flags are set or if \u201cinfo\u201d contains experimental semantics.", 
        "name": "mailbox.MaildirMessage.get_flags", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.get_flags", 
        "syntax": "get_flags()", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.get_info": {
        "descr": "Return a string containing the \u201cinfo\u201d for a message. This is useful for accessing and modifying \u201cinfo\u201d that is experimental (i.e., not a list of flags).", 
        "name": "mailbox.MaildirMessage.get_info", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.get_info", 
        "syntax": "get_info()", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.get_subdir": {
        "descr": "Return either \u201cnew\u201d (if the message should be stored in the new subdirectory) or \u201ccur\u201d (if the message should be stored in the cur subdirectory).", 
        "name": "mailbox.MaildirMessage.get_subdir", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.get_subdir", 
        "syntax": "get_subdir()", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.remove_flag": {
        "descr": "Unset the flag(s) specified by flag without changing other flags. To remove more than one flag at a time, flag maybe a string of more than one character. If \u201cinfo\u201d contains experimental information rather than flags, the current \u201cinfo\u201d is not modified.", 
        "name": "mailbox.MaildirMessage.remove_flag", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.remove_flag", 
        "syntax": "remove_flag(flag)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.set_date": {
        "descr": "Set the delivery date of the message to date, a floating-point number representing seconds since the epoch.", 
        "name": "mailbox.MaildirMessage.set_date", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.set_date", 
        "syntax": "set_date(date)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.set_flags": {
        "descr": "Set the flags specified by flags and unset all others.", 
        "name": "mailbox.MaildirMessage.set_flags", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.set_flags", 
        "syntax": "set_flags(flags)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.set_info": {
        "descr": "Set \u201cinfo\u201d to info, which should be a string.", 
        "name": "mailbox.MaildirMessage.set_info", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.set_info", 
        "syntax": "set_info(info)", 
        "type": "Internet Data"
    }, 
    "mailbox.MaildirMessage.set_subdir": {
        "descr": "Set the subdirectory the message should be stored in. Parameter subdir must be either \u201cnew\u201d or \u201ccur\u201d.", 
        "name": "mailbox.MaildirMessage.set_subdir", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.MaildirMessage.set_subdir", 
        "syntax": "set_subdir(subdir)", 
        "type": "Internet Data"
    }, 
    "mailbox.Message": {
        "descr": "A subclass of the email.message module\u2019s Message. Subclasses of mailbox.Message add mailbox-format-specific state and behavior.", 
        "name": "mailbox.Message", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.Message", 
        "syntax": "class mailbox.Message(message=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.NoSuchMailboxError": {
        "descr": "Raised when a mailbox is expected but is not found, such as when instantiating a Mailbox subclass with a path that does not exist (and with the create parameter set to False), or when opening a folder that does not exist.", 
        "name": "mailbox.NoSuchMailboxError", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.NoSuchMailboxError", 
        "syntax": "exception mailbox.NoSuchMailboxError", 
        "type": "Internet Data"
    }, 
    "mailbox.NotEmptyError": {
        "descr": "Raised when a mailbox is not empty but is expected to be, such as when deleting a folder that contains messages.", 
        "name": "mailbox.NotEmptyError", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.NotEmptyError", 
        "syntax": "exception mailbox.NotEmptyError", 
        "type": "Internet Data"
    }, 
    "mailbox.mbox": {
        "descr": "A subclass of Mailbox for mailboxes in mbox format. Parameter factory is a callable object that accepts a file-like message representation (which behaves as if opened in binary mode) and returns a custom representation. If factory is None, mboxMessage is used as the default message representation. If create is True, the mailbox is created if it does not exist.", 
        "name": "mailbox.mbox", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mbox", 
        "syntax": "class mailbox.mbox(path, factory=None, create=True)", 
        "type": "Internet Data"
    }, 
    "mailbox.mbox.get_file": {
        "descr": "Using the file after calling flush() or close() on the mbox instance may yield unpredictable results or raise an exception.", 
        "name": "mailbox.mbox.get_file", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mbox.get_file", 
        "syntax": "get_file(key)", 
        "type": "Internet Data"
    }, 
    "mailbox.mbox.lock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls.", 
        "name": "mailbox.mbox.lock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mbox.lock", 
        "syntax": "lock()", 
        "type": "Internet Data"
    }, 
    "mailbox.mbox.unlock": {
        "descr": "Three locking mechanisms are used\u2014dot locking and, if available, the flock() and lockf() system calls.", 
        "name": "mailbox.mbox.unlock", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mbox.unlock", 
        "syntax": "unlock()", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage": {
        "descr": "A message with mbox-specific behaviors. Parameter message has the same meaning as with the Message constructor.", 
        "name": "mailbox.mboxMessage", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage", 
        "syntax": "class mailbox.mboxMessage(message=None)", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage.add_flag": {
        "descr": "Set the flag(s) specified by flag without changing other flags. To add more than one flag at a time, flag may be a string of more than one character.", 
        "name": "mailbox.mboxMessage.add_flag", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage.add_flag", 
        "syntax": "add_flag(flag)", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage.get_flags": {
        "descr": "Return a string specifying the flags that are currently set. If the message complies with the conventional format, the result is the concatenation in the following order of zero or one occurrence of each of 'R', 'O', 'D', 'F', and 'A'.", 
        "name": "mailbox.mboxMessage.get_flags", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage.get_flags", 
        "syntax": "get_flags()", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage.get_from": {
        "descr": "Return a string representing the \u201cFrom \u201d line that marks the start of the message in an mbox mailbox. The leading \u201cFrom \u201d and the trailing newline are excluded.", 
        "name": "mailbox.mboxMessage.get_from", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage.get_from", 
        "syntax": "get_from()", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage.remove_flag": {
        "descr": "Unset the flag(s) specified by flag without changing other flags. To remove more than one flag at a time, flag maybe a string of more than one character.", 
        "name": "mailbox.mboxMessage.remove_flag", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage.remove_flag", 
        "syntax": "remove_flag(flag)", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage.set_flags": {
        "descr": "Set the flags specified by flags and unset all others. Parameter flags should be the concatenation in any order of zero or more occurrences of each of 'R', 'O', 'D', 'F', and 'A'.", 
        "name": "mailbox.mboxMessage.set_flags", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage.set_flags", 
        "syntax": "set_flags(flags)", 
        "type": "Internet Data"
    }, 
    "mailbox.mboxMessage.set_from": {
        "descr": "Set the \u201cFrom \u201d line to from_, which should be specified without a leading \u201cFrom \u201d or trailing newline. For convenience, time_ may be specified and will be formatted appropriately and appended to from_. If time_ is specified, it should be a time.struct_time instance, a tuple suitable for passing to time.strftime(), or True (to use time.gmtime()).", 
        "name": "mailbox.mboxMessage.set_from", 
        "params": [], 
        "path": "python/library/mailbox#mailbox.mboxMessage.set_from", 
        "syntax": "set_from(from_, time_=None)", 
        "type": "Internet Data"
    }, 
    "mailcap.findmatch": {
        "descr": "Return a 2-tuple; the first element is a string containing the command line to be executed (which can be passed to os.system()), and the second element is the mailcap entry for a given MIME type. If no matching MIME type can be found, (None, None) is returned.", 
        "name": "mailcap.findmatch", 
        "params": [], 
        "path": "python/library/mailcap#mailcap.findmatch", 
        "syntax": "mailcap.findmatch(caps, MIMEtype, key='view', filename='/dev/null', plist=[])", 
        "type": "Internet Data"
    }, 
    "mailcap.getcaps": {
        "descr": "Returns a dictionary mapping MIME types to a list of mailcap file entries. This dictionary must be passed to the findmatch() function. An entry is stored as a list of dictionaries, but it shouldn\u2019t be necessary to know the details of this representation.", 
        "name": "mailcap.getcaps", 
        "params": [], 
        "path": "python/library/mailcap#mailcap.getcaps", 
        "syntax": "mailcap.getcaps()", 
        "type": "Internet Data"
    }, 
    "map": {
        "descr": "Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see itertools.starmap().", 
        "name": "map", 
        "params": [], 
        "path": "python/library/functions#map", 
        "syntax": "map(function, iterable, ...)", 
        "type": "Built-in Functions"
    }, 
    "marshal.dump": {
        "descr": "Write the value on the open file. The value must be a supported type. The file must be an open file object such as sys.stdout or returned by open() or os.popen(). It must be opened in binary mode ('wb' or 'w+b').", 
        "name": "marshal.dump", 
        "params": [], 
        "path": "python/library/marshal#marshal.dump", 
        "syntax": "marshal.dump(value, file[, version])", 
        "type": "Data Persistence"
    }, 
    "marshal.dumps": {
        "descr": "Return the string that would be written to a file by dump(value, file). The value must be a supported type. Raise a ValueError exception if value has (or contains an object that has) an unsupported type.", 
        "name": "marshal.dumps", 
        "params": [], 
        "path": "python/library/marshal#marshal.dumps", 
        "syntax": "marshal.dumps(value[, version])", 
        "type": "Data Persistence"
    }, 
    "marshal.load": {
        "descr": "Read one value from the open file and return it. If no valid value is read (e.g. because the data has a different Python version\u2019s incompatible marshal format), raise EOFError, ValueError or TypeError. The file must be an open file object opened in binary mode ('rb' or 'r+b').", 
        "name": "marshal.load", 
        "params": [], 
        "path": "python/library/marshal#marshal.load", 
        "syntax": "marshal.load(file)", 
        "type": "Data Persistence"
    }, 
    "marshal.loads": {
        "descr": "Convert the string to a value. If no valid value is found, raise EOFError, ValueError or TypeError. Extra characters in the string are ignored.", 
        "name": "marshal.loads", 
        "params": [], 
        "path": "python/library/marshal#marshal.loads", 
        "syntax": "marshal.loads(string)", 
        "type": "Data Persistence"
    }, 
    "marshal.version": {
        "descr": "Indicates the format that the module uses. Version 0 is the historical format, version 1 shares interned strings and version 2 uses a binary format for floating point numbers. The current version is 2.", 
        "name": "marshal.version", 
        "params": [], 
        "path": "python/library/marshal#marshal.version", 
        "syntax": "marshal.version", 
        "type": "Data Persistence"
    }, 
    "math.acos": {
        "descr": "Return the arc cosine of x, in radians.", 
        "name": "math.acos", 
        "params": [], 
        "path": "python/library/math#math.acos", 
        "syntax": "math.acos(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.acosh": {
        "descr": "Return the inverse hyperbolic cosine of x.", 
        "name": "math.acosh", 
        "params": [], 
        "path": "python/library/math#math.acosh", 
        "syntax": "math.acosh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.asin": {
        "descr": "Return the arc sine of x, in radians.", 
        "name": "math.asin", 
        "params": [], 
        "path": "python/library/math#math.asin", 
        "syntax": "math.asin(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.asinh": {
        "descr": "Return the inverse hyperbolic sine of x.", 
        "name": "math.asinh", 
        "params": [], 
        "path": "python/library/math#math.asinh", 
        "syntax": "math.asinh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.atan": {
        "descr": "Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4.", 
        "name": "math.atan", 
        "params": [], 
        "path": "python/library/math#math.atan", 
        "syntax": "math.atan2(y, x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.atan2": {
        "descr": "Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4.", 
        "name": "math.atan2", 
        "params": [], 
        "path": "python/library/math#math.atan2", 
        "syntax": "math.atan2(y, x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.atanh": {
        "descr": "Return the inverse hyperbolic tangent of x.", 
        "name": "math.atanh", 
        "params": [], 
        "path": "python/library/math#math.atanh", 
        "syntax": "math.atanh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.ceil": {
        "descr": "Return the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to x.__ceil__(), which should return an Integral value.", 
        "name": "math.ceil", 
        "params": [], 
        "path": "python/library/math#math.ceil", 
        "syntax": "math.ceil(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.copysign": {
        "descr": "Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, copysign(1.0, -0.0) returns -1.0.", 
        "name": "math.copysign", 
        "params": [], 
        "path": "python/library/math#math.copysign", 
        "syntax": "math.copysign(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.cos": {
        "descr": "Return the cosine of x radians.", 
        "name": "math.cos", 
        "params": [], 
        "path": "python/library/math#math.cos", 
        "syntax": "math.cos(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.cosh": {
        "descr": "Return the hyperbolic cosine of x.", 
        "name": "math.cosh", 
        "params": [], 
        "path": "python/library/math#math.cosh", 
        "syntax": "math.cosh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.degrees": {
        "descr": "Converts angle x from radians to degrees.", 
        "name": "math.degrees", 
        "params": [], 
        "path": "python/library/math#math.degrees", 
        "syntax": "math.degrees(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.e": {
        "descr": "The mathematical constant e = 2.718281..., to available precision.", 
        "name": "math.e", 
        "params": [], 
        "path": "python/library/math#math.e", 
        "syntax": "math.e", 
        "type": "Numeric & Mathematical"
    }, 
    "math.erf": {
        "descr": "Return the error function at x.", 
        "name": "math.erf", 
        "params": [], 
        "path": "python/library/math#math.erf", 
        "syntax": "math.erf(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.erfc": {
        "descr": "Return the complementary error function at x. The complementary error function is defined as 1.0 - erf(x). It is used for large values of x where a subtraction from one would cause a loss of significance.", 
        "name": "math.erfc", 
        "params": [], 
        "path": "python/library/math#math.erfc", 
        "syntax": "math.erfc(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.exp": {
        "descr": "Return e**x.", 
        "name": "math.exp", 
        "params": [], 
        "path": "python/library/math#math.exp", 
        "syntax": "math.exp(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.expm1": {
        "descr": "Return e**x - 1. For small floats x, the subtraction in exp(x) - 1 can result in a significant loss of precision; the expm1() function provides a way to compute this quantity to full precision:", 
        "name": "math.expm1", 
        "params": [], 
        "path": "python/library/math#math.expm1", 
        "syntax": "math.expm1(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.fabs": {
        "descr": "Return the absolute value of x.", 
        "name": "math.fabs", 
        "params": [], 
        "path": "python/library/math#math.fabs", 
        "syntax": "math.fabs(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.factorial": {
        "descr": "Return x factorial. Raises ValueError if x is not integral or is negative.", 
        "name": "math.factorial", 
        "params": [], 
        "path": "python/library/math#math.factorial", 
        "syntax": "math.factorial(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.floor": {
        "descr": "Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to x.__floor__(), which should return an Integral value.", 
        "name": "math.floor", 
        "params": [], 
        "path": "python/library/math#math.floor", 
        "syntax": "math.floor(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.fmod": {
        "descr": "Return fmod(x, y), as defined by the platform C library. Note that the Python expression x % y may not return the same result. The intent of the C standard is that fmod(x, y) be exactly (mathematically; to infinite precision) equal to x - n*y for some integer n such that the result has the same sign as x and magnitude less than abs(y). Python\u2019s x % y returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but the result of Python\u2019s -1e-100 % 1e100 is 1e100-1e-100, which cannot be represented exactly as a float, and rounds to the surprising 1e100. For this reason, function fmod() is generally preferred when working with floats, while Python\u2019s x % y is preferred when working with integers.", 
        "name": "math.fmod", 
        "params": [], 
        "path": "python/library/math#math.fmod", 
        "syntax": "math.fmod(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.frexp": {
        "descr": "Return the mantissa and exponent of x as the pair (m, e). m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to \u201cpick apart\u201d the internal representation of a float in a portable way.", 
        "name": "math.frexp", 
        "params": [], 
        "path": "python/library/math#math.frexp", 
        "syntax": "math.frexp(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.fsum": {
        "descr": "Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums:", 
        "name": "math.fsum", 
        "params": [], 
        "path": "python/library/math#math.fsum", 
        "syntax": "math.fsum(iterable)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.gamma": {
        "descr": "Return the Gamma function at x.", 
        "name": "math.gamma", 
        "params": [], 
        "path": "python/library/math#math.gamma", 
        "syntax": "math.gamma(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.hypot": {
        "descr": "Return the Euclidean norm, sqrt(x*x + y*y). This is the length of the vector from the origin to point (x, y).", 
        "name": "math.hypot", 
        "params": [], 
        "path": "python/library/math#math.hypot", 
        "syntax": "math.hypot(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.isfinite": {
        "descr": "Return True if x is neither an infinity nor a NaN, and False otherwise. (Note that 0.0 is considered finite.)", 
        "name": "math.isfinite", 
        "params": [], 
        "path": "python/library/math#math.isfinite", 
        "syntax": "math.isfinite(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.isinf": {
        "descr": "Return True if x is a positive or negative infinity, and False otherwise.", 
        "name": "math.isinf", 
        "params": [], 
        "path": "python/library/math#math.isinf", 
        "syntax": "math.isinf(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.isnan": {
        "descr": "Return True if x is a NaN (not a number), and False otherwise.", 
        "name": "math.isnan", 
        "params": [], 
        "path": "python/library/math#math.isnan", 
        "syntax": "math.isnan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.ldexp": {
        "descr": "Return x * (2**i). This is essentially the inverse of function frexp().", 
        "name": "math.ldexp", 
        "params": [], 
        "path": "python/library/math#math.ldexp", 
        "syntax": "math.ldexp(x, i)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.lgamma": {
        "descr": "Return the natural logarithm of the absolute value of the Gamma function at x.", 
        "name": "math.lgamma", 
        "params": [], 
        "path": "python/library/math#math.lgamma", 
        "syntax": "math.lgamma(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.log": {
        "descr": "Return the base-10 logarithm of x. This is usually more accurate than log(x, 10).", 
        "name": "math.log", 
        "params": [], 
        "path": "python/library/math#math.log", 
        "syntax": "math.log10(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.log10": {
        "descr": "Return the base-10 logarithm of x. This is usually more accurate than log(x, 10).", 
        "name": "math.log10", 
        "params": [], 
        "path": "python/library/math#math.log10", 
        "syntax": "math.log10(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.log1p": {
        "descr": "Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero.", 
        "name": "math.log1p", 
        "params": [], 
        "path": "python/library/math#math.log1p", 
        "syntax": "math.log1p(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.log2": {
        "descr": "Return the base-2 logarithm of x. This is usually more accurate than log(x, 2).", 
        "name": "math.log2", 
        "params": [], 
        "path": "python/library/math#math.log2", 
        "syntax": "math.log2(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.modf": {
        "descr": "Return the fractional and integer parts of x. Both results carry the sign of x and are floats.", 
        "name": "math.modf", 
        "params": [], 
        "path": "python/library/math#math.modf", 
        "syntax": "math.modf(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.pi": {
        "descr": "The mathematical constant \u03c0 = 3.141592..., to available precision.", 
        "name": "math.pi", 
        "params": [], 
        "path": "python/library/math#math.pi", 
        "syntax": "math.pi", 
        "type": "Numeric & Mathematical"
    }, 
    "math.pow": {
        "descr": "Return x raised to the power y. Exceptional cases follow Annex \u2018F\u2019 of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.", 
        "name": "math.pow", 
        "params": [], 
        "path": "python/library/math#math.pow", 
        "syntax": "math.pow(x, y)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.radians": {
        "descr": "Converts angle x from degrees to radians.", 
        "name": "math.radians", 
        "params": [], 
        "path": "python/library/math#math.radians", 
        "syntax": "math.radians(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.sin": {
        "descr": "Return the sine of x radians.", 
        "name": "math.sin", 
        "params": [], 
        "path": "python/library/math#math.sin", 
        "syntax": "math.sin(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.sinh": {
        "descr": "Return the hyperbolic sine of x.", 
        "name": "math.sinh", 
        "params": [], 
        "path": "python/library/math#math.sinh", 
        "syntax": "math.sinh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.sqrt": {
        "descr": "Return the square root of x.", 
        "name": "math.sqrt", 
        "params": [], 
        "path": "python/library/math#math.sqrt", 
        "syntax": "math.sqrt(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.tan": {
        "descr": "Return the tangent of x radians.", 
        "name": "math.tan", 
        "params": [], 
        "path": "python/library/math#math.tan", 
        "syntax": "math.tan(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.tanh": {
        "descr": "Return the hyperbolic tangent of x.", 
        "name": "math.tanh", 
        "params": [], 
        "path": "python/library/math#math.tanh", 
        "syntax": "math.tanh(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "math.trunc": {
        "descr": "Return the Real value x truncated to an Integral (usually an integer). Delegates to x.__trunc__().", 
        "name": "math.trunc", 
        "params": [], 
        "path": "python/library/math#math.trunc", 
        "syntax": "math.trunc(x)", 
        "type": "Numeric & Mathematical"
    }, 
    "max": {
        "descr": "Return the largest item in an iterable or the largest of two or more arguments.", 
        "name": "max", 
        "params": [], 
        "path": "python/library/functions#max", 
        "syntax": "max(iterable, *[, key])", 
        "type": "Built-in Functions"
    }, 
    "memoryview": {
        "descr": "Return a \u201cmemory view\u201d object created from the given argument. See Memory Views for more information.", 
        "name": "memoryview", 
        "params": [], 
        "path": "python/library/functions#memoryview", 
        "syntax": "memoryview(obj)", 
        "type": "Built-in Functions"
    }, 
    "memoryview.__eq__": {
        "descr": "A memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operands\u2019 respective format codes are interpreted using struct syntax.", 
        "name": "memoryview.__eq__", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.__eq__", 
        "syntax": "__eq__(exporter)", 
        "type": "Built-in Types"
    }, 
    "memoryview.c_contiguous": {
        "descr": "A bool indicating whether the memory is C-contiguous.", 
        "name": "memoryview.c_contiguous", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.c_contiguous", 
        "syntax": "c_contiguous", 
        "type": "Built-in Types"
    }, 
    "memoryview.cast": {
        "descr": "Cast a memoryview to a new format or shape. shape defaults to [byte_length//new_itemsize], which means that the result view will be one-dimensional. The return value is a new memoryview, but the buffer itself is not copied. Supported casts are 1D -> C-contiguous and C-contiguous -> 1D.", 
        "name": "memoryview.cast", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.cast", 
        "syntax": "cast(format[, shape])", 
        "type": "Built-in Types"
    }, 
    "memoryview.contiguous": {
        "descr": "A bool indicating whether the memory is contiguous.", 
        "name": "memoryview.contiguous", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.contiguous", 
        "syntax": "contiguous", 
        "type": "Built-in Types"
    }, 
    "memoryview.f_contiguous": {
        "descr": "A bool indicating whether the memory is Fortran contiguous.", 
        "name": "memoryview.f_contiguous", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.f_contiguous", 
        "syntax": "f_contiguous", 
        "type": "Built-in Types"
    }, 
    "memoryview.format": {
        "descr": "A string containing the format (in struct module style) for each element in the view. A memoryview can be created from exporters with arbitrary format strings, but some methods (e.g. tolist()) are restricted to native single element formats.", 
        "name": "memoryview.format", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.format", 
        "syntax": "format", 
        "type": "Built-in Types"
    }, 
    "memoryview.itemsize": {
        "descr": "The size in bytes of each element of the memoryview:", 
        "name": "memoryview.itemsize", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.itemsize", 
        "syntax": "itemsize", 
        "type": "Built-in Types"
    }, 
    "memoryview.nbytes": {
        "descr": "nbytes == product(shape) * itemsize == len(m.tobytes()). This is the amount of space in bytes that the array would use in a contiguous representation. It is not necessarily equal to len(m):", 
        "name": "memoryview.nbytes", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.nbytes", 
        "syntax": "nbytes", 
        "type": "Built-in Types"
    }, 
    "memoryview.ndim": {
        "descr": "An integer indicating how many dimensions of a multi-dimensional array the memory represents.", 
        "name": "memoryview.ndim", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.ndim", 
        "syntax": "ndim", 
        "type": "Built-in Types"
    }, 
    "memoryview.obj": {
        "descr": "The underlying object of the memoryview:", 
        "name": "memoryview.obj", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.obj", 
        "syntax": "obj", 
        "type": "Built-in Types"
    }, 
    "memoryview.readonly": {
        "descr": "A bool indicating whether the memory is read only.", 
        "name": "memoryview.readonly", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.readonly", 
        "syntax": "readonly", 
        "type": "Built-in Types"
    }, 
    "memoryview.release": {
        "descr": "Release the underlying buffer exposed by the memoryview object. Many objects take special actions when a view is held on them (for example, a bytearray would temporarily forbid resizing); therefore, calling release() is handy to remove these restrictions (and free any dangling resources) as soon as possible.", 
        "name": "memoryview.release", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.release", 
        "syntax": "release()", 
        "type": "Built-in Types"
    }, 
    "memoryview.shape": {
        "descr": "A tuple of integers the length of ndim giving the shape of the memory as an N-dimensional array.", 
        "name": "memoryview.shape", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.shape", 
        "syntax": "shape", 
        "type": "Built-in Types"
    }, 
    "memoryview.strides": {
        "descr": "A tuple of integers the length of ndim giving the size in bytes to access each element for each dimension of the array.", 
        "name": "memoryview.strides", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.strides", 
        "syntax": "strides", 
        "type": "Built-in Types"
    }, 
    "memoryview.suboffsets": {
        "descr": "Used internally for PIL-style arrays. The value is informational only.", 
        "name": "memoryview.suboffsets", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.suboffsets", 
        "syntax": "suboffsets", 
        "type": "Built-in Types"
    }, 
    "memoryview.tobytes": {
        "descr": "Return the data in the buffer as a bytestring. This is equivalent to calling the bytes constructor on the memoryview.", 
        "name": "memoryview.tobytes", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.tobytes", 
        "syntax": "tobytes()", 
        "type": "Built-in Types"
    }, 
    "memoryview.tolist": {
        "descr": "Return the data in the buffer as a list of elements.", 
        "name": "memoryview.tolist", 
        "params": [], 
        "path": "python/library/stdtypes#memoryview.tolist", 
        "syntax": "tolist()", 
        "type": "Built-in Types"
    }, 
    "mimetypes.MimeTypes": {
        "descr": "This class represents a MIME-types database. By default, it provides access to the same database as the rest of this module. The initial database is a copy of that provided by the module, and may be extended by loading additional mime.types-style files into the database using the read() or readfp() methods. The mapping dictionaries may also be cleared before loading additional data if the default data is not desired.", 
        "name": "mimetypes.MimeTypes", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes", 
        "syntax": "class mimetypes.MimeTypes(filenames=(), strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.encodings_map": {
        "descr": "Dictionary mapping filename extensions to encoding types. This is initially a copy of the global encodings_map defined in the module.", 
        "name": "mimetypes.MimeTypes.encodings_map", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.encodings_map", 
        "syntax": "MimeTypes.encodings_map", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.guess_all_extensions": {
        "descr": "Similar to the guess_all_extensions() function, using the tables stored as part of the object.", 
        "name": "mimetypes.MimeTypes.guess_all_extensions", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.guess_all_extensions", 
        "syntax": "MimeTypes.guess_all_extensions(type, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.guess_extension": {
        "descr": "Similar to the guess_extension() function, using the tables stored as part of the object.", 
        "name": "mimetypes.MimeTypes.guess_extension", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.guess_extension", 
        "syntax": "MimeTypes.guess_extension(type, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.guess_type": {
        "descr": "Similar to the guess_type() function, using the tables stored as part of the object.", 
        "name": "mimetypes.MimeTypes.guess_type", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.guess_type", 
        "syntax": "MimeTypes.guess_type(url, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.read": {
        "descr": "Load MIME information from a file named filename. This uses readfp() to parse the file.", 
        "name": "mimetypes.MimeTypes.read", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.read", 
        "syntax": "MimeTypes.read(filename, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.read_windows_registry": {
        "descr": "Load MIME type information from the Windows registry. Availability: Windows.", 
        "name": "mimetypes.MimeTypes.read_windows_registry", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.read_windows_registry", 
        "syntax": "MimeTypes.read_windows_registry(strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.readfp": {
        "descr": "Load MIME type information from an open file fp. The file must have the format of the standard mime.types files.", 
        "name": "mimetypes.MimeTypes.readfp", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.readfp", 
        "syntax": "MimeTypes.readfp(fp, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.suffix_map": {
        "descr": "Dictionary mapping suffixes to suffixes. This is used to allow recognition of encoded files for which the encoding and the type are indicated by the same extension. For example, the .tgz extension is mapped to .tar.gz to allow the encoding and type to be recognized separately. This is initially a copy of the global suffix_map defined in the module.", 
        "name": "mimetypes.MimeTypes.suffix_map", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.suffix_map", 
        "syntax": "MimeTypes.suffix_map", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.types_map": {
        "descr": "Tuple containing two dictionaries, mapping filename extensions to MIME types: the first dictionary is for the non-standards types and the second one is for the standard types. They are initialized by common_types and types_map.", 
        "name": "mimetypes.MimeTypes.types_map", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.types_map", 
        "syntax": "MimeTypes.types_map", 
        "type": "Internet Data"
    }, 
    "mimetypes.MimeTypes.types_map_inv": {
        "descr": "Tuple containing two dictionaries, mapping MIME types to a list of filename extensions: the first dictionary is for the non-standards types and the second one is for the standard types. They are initialized by common_types and types_map.", 
        "name": "mimetypes.MimeTypes.types_map_inv", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.MimeTypes.types_map_inv", 
        "syntax": "MimeTypes.types_map_inv", 
        "type": "Internet Data"
    }, 
    "mimetypes.add_type": {
        "descr": "Add a mapping from the MIME type type to the extension ext. When the extension is already known, the new type will replace the old one. When the type is already known the extension will be added to the list of known extensions.", 
        "name": "mimetypes.add_type", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.add_type", 
        "syntax": "mimetypes.add_type(type, ext, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.common_types": {
        "descr": "Dictionary mapping filename extensions to non-standard, but commonly found MIME types.", 
        "name": "mimetypes.common_types", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.common_types", 
        "syntax": "mimetypes.common_types", 
        "type": "Internet Data"
    }, 
    "mimetypes.encodings_map": {
        "descr": "Dictionary mapping filename extensions to encoding types.", 
        "name": "mimetypes.encodings_map", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.encodings_map", 
        "syntax": "mimetypes.encodings_map", 
        "type": "Internet Data"
    }, 
    "mimetypes.guess_all_extensions": {
        "descr": "Guess the extensions for a file based on its MIME type, given by type. The return value is a list of strings giving all possible filename extensions, including the leading dot ('.'). The extensions are not guaranteed to have been associated with any particular data stream, but would be mapped to the MIME type type by guess_type().", 
        "name": "mimetypes.guess_all_extensions", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.guess_all_extensions", 
        "syntax": "mimetypes.guess_all_extensions(type, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.guess_extension": {
        "descr": "Guess the extension for a file based on its MIME type, given by type. The return value is a string giving a filename extension, including the leading dot ('.'). The extension is not guaranteed to have been associated with any particular data stream, but would be mapped to the MIME type type by guess_type(). If no extension can be guessed for type, None is returned.", 
        "name": "mimetypes.guess_extension", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.guess_extension", 
        "syntax": "mimetypes.guess_extension(type, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.guess_type": {
        "descr": "encoding is None for no encoding or the name of the program used to encode (e.g. compress or gzip). The encoding is suitable for use as a Content-Encoding header, not as a Content-Transfer-Encoding header. The mappings are table driven. Encoding suffixes are case sensitive; type suffixes are first tried case sensitively, then case insensitively.", 
        "name": "mimetypes.guess_type", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.guess_type", 
        "syntax": "mimetypes.guess_type(url, strict=True)", 
        "type": "Internet Data"
    }, 
    "mimetypes.init": {
        "descr": "Initialize the internal data structures. If given, files must be a sequence of file names which should be used to augment the default type map. If omitted, the file names to use are taken from knownfiles; on Windows, the current registry settings are loaded. Each file named in files or knownfiles takes precedence over those named before it. Calling init() repeatedly is allowed.", 
        "name": "mimetypes.init", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.init", 
        "syntax": "mimetypes.init(files=None)", 
        "type": "Internet Data"
    }, 
    "mimetypes.inited": {
        "descr": "Flag indicating whether or not the global data structures have been initialized. This is set to True by init().", 
        "name": "mimetypes.inited", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.inited", 
        "syntax": "mimetypes.inited", 
        "type": "Internet Data"
    }, 
    "mimetypes.knownfiles": {
        "descr": "", 
        "name": "mimetypes.knownfiles", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.knownfiles", 
        "syntax": "mimetypes.knownfiles", 
        "type": "Internet Data"
    }, 
    "mimetypes.read_mime_types": {
        "descr": "Load the type map given in the file filename, if it exists. The type map is returned as a dictionary mapping filename extensions, including the leading dot ('.'), to strings of the form 'type/subtype'. If the file filename does not exist or cannot be read, None is returned.", 
        "name": "mimetypes.read_mime_types", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.read_mime_types", 
        "syntax": "mimetypes.read_mime_types(filename)", 
        "type": "Internet Data"
    }, 
    "mimetypes.suffix_map": {
        "descr": "Dictionary mapping suffixes to suffixes. This is used to allow recognition of encoded files for which the encoding and the type are indicated by the same extension. For example, the .tgz extension is mapped to .tar.gz to allow the encoding and type to be recognized separately.", 
        "name": "mimetypes.suffix_map", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.suffix_map", 
        "syntax": "mimetypes.suffix_map", 
        "type": "Internet Data"
    }, 
    "mimetypes.types_map": {
        "descr": "Dictionary mapping filename extensions to MIME types.", 
        "name": "mimetypes.types_map", 
        "params": [], 
        "path": "python/library/mimetypes#mimetypes.types_map", 
        "syntax": "mimetypes.types_map", 
        "type": "Internet Data"
    }, 
    "min": {
        "descr": "Return the smallest item in an iterable or the smallest of two or more arguments.", 
        "name": "min", 
        "params": [], 
        "path": "python/library/functions#min", 
        "syntax": "min(iterable, *[, key])", 
        "type": "Built-in Functions"
    }, 
    "mmap.close": {
        "descr": "Closes the mmap. Subsequent calls to other methods of the object will result in a ValueError exception being raised. This will not close the open file.", 
        "name": "mmap.close", 
        "params": [], 
        "path": "python/library/mmap#mmap.close", 
        "syntax": "mmap.close()", 
        "type": "Networking"
    }, 
    "mmap.closed": {
        "descr": "True if the file is closed.", 
        "name": "mmap.closed", 
        "params": [], 
        "path": "python/library/mmap#mmap.closed", 
        "syntax": "mmap.closed", 
        "type": "Networking"
    }, 
    "mmap.find": {
        "descr": "Returns the lowest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure.", 
        "name": "mmap.find", 
        "params": [], 
        "path": "python/library/mmap#mmap.find", 
        "syntax": "mmap.find(sub[, start[, end]])", 
        "type": "Networking"
    }, 
    "mmap.flush": {
        "descr": "Flushes changes made to the in-memory copy of a file back to disk. Without use of this call there is no guarantee that changes are written back before the object is destroyed. If offset and size are specified, only changes to the given range of bytes will be flushed to disk; otherwise, the whole extent of the mapping is flushed.", 
        "name": "mmap.flush", 
        "params": [], 
        "path": "python/library/mmap#mmap.flush", 
        "syntax": "mmap.flush([offset[, size]])", 
        "type": "Networking"
    }, 
    "mmap.mmap": {
        "descr": "(Windows version) Maps length bytes from the file specified by the file handle fileno, and creates a mmap object. If length is larger than the current size of the file, the file is extended to contain length bytes. If length is 0, the maximum length of the map is the current size of the file, except that if the file is empty Windows raises an exception (you cannot create an empty mapping on Windows).", 
        "name": "mmap.mmap", 
        "params": [], 
        "path": "python/library/mmap#mmap.mmap", 
        "syntax": "class mmap.mmap(fileno, length, tagname=None, access=ACCESS_DEFAULT[, offset])", 
        "type": "Networking"
    }, 
    "mmap.move": {
        "descr": "Copy the count bytes starting at offset src to the destination index dest. If the mmap was created with ACCESS_READ, then calls to move will raise a TypeError exception.", 
        "name": "mmap.move", 
        "params": [], 
        "path": "python/library/mmap#mmap.move", 
        "syntax": "mmap.move(dest, src, count)", 
        "type": "Networking"
    }, 
    "mmap.read": {
        "descr": "Return a bytes containing up to n bytes starting from the current file position. If the argument is omitted, None or negative, return all bytes from the current file position to the end of the mapping. The file position is updated to point after the bytes that were returned.", 
        "name": "mmap.read", 
        "params": [], 
        "path": "python/library/mmap#mmap.read", 
        "syntax": "mmap.read([n])", 
        "type": "Networking"
    }, 
    "mmap.read_byte": {
        "descr": "Returns a byte at the current file position as an integer, and advances the file position by 1.", 
        "name": "mmap.read_byte", 
        "params": [], 
        "path": "python/library/mmap#mmap.read_byte", 
        "syntax": "mmap.read_byte()", 
        "type": "Networking"
    }, 
    "mmap.readline": {
        "descr": "Returns a single line, starting at the current file position and up to the next newline.", 
        "name": "mmap.readline", 
        "params": [], 
        "path": "python/library/mmap#mmap.readline", 
        "syntax": "mmap.readline()", 
        "type": "Networking"
    }, 
    "mmap.resize": {
        "descr": "Resizes the map and the underlying file, if any. If the mmap was created with ACCESS_READ or ACCESS_COPY, resizing the map will raise a TypeError exception.", 
        "name": "mmap.resize", 
        "params": [], 
        "path": "python/library/mmap#mmap.resize", 
        "syntax": "mmap.resize(newsize)", 
        "type": "Networking"
    }, 
    "mmap.rfind": {
        "descr": "Returns the highest index in the object where the subsequence sub is found, such that sub is contained in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. Returns -1 on failure.", 
        "name": "mmap.rfind", 
        "params": [], 
        "path": "python/library/mmap#mmap.rfind", 
        "syntax": "mmap.rfind(sub[, start[, end]])", 
        "type": "Networking"
    }, 
    "mmap.seek": {
        "descr": "Set the file\u2019s current position. whence argument is optional and defaults to os.SEEK_SET or 0 (absolute file positioning); other values are os.SEEK_CUR or 1 (seek relative to the current position) and os.SEEK_END or 2 (seek relative to the file\u2019s end).", 
        "name": "mmap.seek", 
        "params": [], 
        "path": "python/library/mmap#mmap.seek", 
        "syntax": "mmap.seek(pos[, whence])", 
        "type": "Networking"
    }, 
    "mmap.size": {
        "descr": "Return the length of the file, which can be larger than the size of the memory-mapped area.", 
        "name": "mmap.size", 
        "params": [], 
        "path": "python/library/mmap#mmap.size", 
        "syntax": "mmap.size()", 
        "type": "Networking"
    }, 
    "mmap.tell": {
        "descr": "Returns the current position of the file pointer.", 
        "name": "mmap.tell", 
        "params": [], 
        "path": "python/library/mmap#mmap.tell", 
        "syntax": "mmap.tell()", 
        "type": "Networking"
    }, 
    "mmap.write": {
        "descr": "Write the bytes in bytes into memory at the current position of the file pointer; the file position is updated to point after the bytes that were written. If the mmap was created with ACCESS_READ, then writing to it will raise a TypeError exception.", 
        "name": "mmap.write", 
        "params": [], 
        "path": "python/library/mmap#mmap.write", 
        "syntax": "mmap.write(bytes)", 
        "type": "Networking"
    }, 
    "mmap.write_byte": {
        "descr": "Write the integer byte into memory at the current position of the file pointer; the file position is advanced by 1. If the mmap was created with ACCESS_READ, then writing to it will raise a TypeError exception.", 
        "name": "mmap.write_byte", 
        "params": [], 
        "path": "python/library/mmap#mmap.write_byte", 
        "syntax": "mmap.write_byte(byte)", 
        "type": "Networking"
    }, 
    "modulefinder.AddPackagePath": {
        "descr": "Record that the package named pkg_name can be found in the specified path.", 
        "name": "modulefinder.AddPackagePath", 
        "params": [], 
        "path": "python/library/modulefinder#modulefinder.AddPackagePath", 
        "syntax": "modulefinder.AddPackagePath(pkg_name, path)", 
        "type": "Importing"
    }, 
    "modulefinder.ModuleFinder": {
        "descr": "This class provides run_script() and report() methods to determine the set of modules imported by a script. path can be a list of directories to search for modules; if not specified, sys.path is used. debug sets the debugging level; higher values make the class print debugging messages about what it\u2019s doing. excludes is a list of module names to exclude from the analysis. replace_paths is a list of (oldpath, newpath) tuples that will be replaced in module paths.", 
        "name": "modulefinder.ModuleFinder", 
        "params": [], 
        "path": "python/library/modulefinder#modulefinder.ModuleFinder", 
        "syntax": "class modulefinder.ModuleFinder(path=None, debug=0, excludes=[], replace_paths=[])", 
        "type": "Importing"
    }, 
    "modulefinder.ModuleFinder.modules": {
        "descr": "A dictionary mapping module names to modules. See Example usage of ModuleFinder", 
        "name": "modulefinder.ModuleFinder.modules", 
        "params": [], 
        "path": "python/library/modulefinder#modulefinder.ModuleFinder.modules", 
        "syntax": "modules", 
        "type": "Importing"
    }, 
    "modulefinder.ModuleFinder.report": {
        "descr": "Print a report to standard output that lists the modules imported by the script and their paths, as well as modules that are missing or seem to be missing.", 
        "name": "modulefinder.ModuleFinder.report", 
        "params": [], 
        "path": "python/library/modulefinder#modulefinder.ModuleFinder.report", 
        "syntax": "report()", 
        "type": "Importing"
    }, 
    "modulefinder.ModuleFinder.run_script": {
        "descr": "Analyze the contents of the pathname file, which must contain Python code.", 
        "name": "modulefinder.ModuleFinder.run_script", 
        "params": [], 
        "path": "python/library/modulefinder#modulefinder.ModuleFinder.run_script", 
        "syntax": "run_script(pathname)", 
        "type": "Importing"
    }, 
    "modulefinder.ReplacePackage": {
        "descr": "Allows specifying that the module named oldname is in fact the package named newname.", 
        "name": "modulefinder.ReplacePackage", 
        "params": [], 
        "path": "python/library/modulefinder#modulefinder.ReplacePackage", 
        "syntax": "modulefinder.ReplacePackage(oldname, newname)", 
        "type": "Importing"
    }, 
    "msilib.Binary": {
        "descr": "Represents entries in the Binary table; inserting such an object using add_data() reads the file named filename into the table.", 
        "name": "msilib.Binary", 
        "params": [], 
        "path": "python/library/msilib#msilib.Binary", 
        "syntax": "class msilib.Binary(filename)", 
        "type": "MS Windows"
    }, 
    "msilib.CAB": {
        "descr": "The class CAB represents a CAB file. During MSI construction, files will be added simultaneously to the Files table, and to a CAB file. Then, when all files have been added, the CAB file can be written, then added to the MSI file.", 
        "name": "msilib.CAB", 
        "params": [], 
        "path": "python/library/msilib#msilib.CAB", 
        "syntax": "class msilib.CAB(name)", 
        "type": "MS Windows"
    }, 
    "msilib.CAB.append": {
        "descr": "Add the file with the pathname full to the CAB file, under the name logical. If there is already a file named logical, a new file name is created.", 
        "name": "msilib.CAB.append", 
        "params": [], 
        "path": "python/library/msilib#msilib.CAB.append", 
        "syntax": "append(full, file, logical)", 
        "type": "MS Windows"
    }, 
    "msilib.CAB.commit": {
        "descr": "Generate a CAB file, add it as a stream to the MSI file, put it into the Media table, and remove the generated file from the disk.", 
        "name": "msilib.CAB.commit", 
        "params": [], 
        "path": "python/library/msilib#msilib.CAB.commit", 
        "syntax": "commit(database)", 
        "type": "MS Windows"
    }, 
    "msilib.Control": {
        "descr": "Base class of the dialog controls. dlg is the dialog object the control belongs to, and name is the control\u2019s name.", 
        "name": "msilib.Control", 
        "params": [], 
        "path": "python/library/msilib#msilib.Control", 
        "syntax": "class msilib.Control(dlg, name)", 
        "type": "MS Windows"
    }, 
    "msilib.Control.condition": {
        "descr": "Make an entry into the ControlCondition table for this control.", 
        "name": "msilib.Control.condition", 
        "params": [], 
        "path": "python/library/msilib#msilib.Control.condition", 
        "syntax": "condition(action, condition)", 
        "type": "MS Windows"
    }, 
    "msilib.Control.event": {
        "descr": "Make an entry into the ControlEvent table for this control.", 
        "name": "msilib.Control.event", 
        "params": [], 
        "path": "python/library/msilib#msilib.Control.event", 
        "syntax": "event(event, argument, condition=1, ordering=None)", 
        "type": "MS Windows"
    }, 
    "msilib.Control.mapping": {
        "descr": "Make an entry into the EventMapping table for this control.", 
        "name": "msilib.Control.mapping", 
        "params": [], 
        "path": "python/library/msilib#msilib.Control.mapping", 
        "syntax": "mapping(event, attribute)", 
        "type": "MS Windows"
    }, 
    "msilib.CreateRecord": {
        "descr": "Return a new record object by calling MSICreateRecord(). count is the number of fields of the record.", 
        "name": "msilib.CreateRecord", 
        "params": [], 
        "path": "python/library/msilib#msilib.CreateRecord", 
        "syntax": "msilib.CreateRecord(count)", 
        "type": "MS Windows"
    }, 
    "msilib.Database.Commit": {
        "descr": "Commit the changes pending in the current transaction, by calling MSIDatabaseCommit().", 
        "name": "msilib.Database.Commit", 
        "params": [], 
        "path": "python/library/msilib#msilib.Database.Commit", 
        "syntax": "Database.Commit()", 
        "type": "MS Windows"
    }, 
    "msilib.Database.GetSummaryInformation": {
        "descr": "Return a new summary information object, by calling MsiGetSummaryInformation(). count is the maximum number of updated values.", 
        "name": "msilib.Database.GetSummaryInformation", 
        "params": [], 
        "path": "python/library/msilib#msilib.Database.GetSummaryInformation", 
        "syntax": "Database.GetSummaryInformation(count)", 
        "type": "MS Windows"
    }, 
    "msilib.Database.OpenView": {
        "descr": "Return a view object, by calling MSIDatabaseOpenView(). sql is the SQL statement to execute.", 
        "name": "msilib.Database.OpenView", 
        "params": [], 
        "path": "python/library/msilib#msilib.Database.OpenView", 
        "syntax": "Database.OpenView(sql)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog": {
        "descr": "Return a new Dialog object. An entry in the Dialog table is made, with the specified coordinates, dialog attributes, title, name of the first, default, and cancel controls.", 
        "name": "msilib.Dialog", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog", 
        "syntax": "class msilib.Dialog(db, name, x, y, w, h, attr, title, first, default, cancel)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.bitmap": {
        "descr": "Add and return a Bitmap control.", 
        "name": "msilib.Dialog.bitmap", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.bitmap", 
        "syntax": "bitmap(name, x, y, width, height, text)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.checkbox": {
        "descr": "Add and return a CheckBox control.", 
        "name": "msilib.Dialog.checkbox", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.checkbox", 
        "syntax": "checkbox(name, x, y, width, height, attributes, property, text, next_control)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.control": {
        "descr": "Return a new Control object. An entry in the Control table is made with the specified parameters.", 
        "name": "msilib.Dialog.control", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.control", 
        "syntax": "control(name, type, x, y, width, height, attributes, property, text, control_next, help)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.line": {
        "descr": "Add and return a Line control.", 
        "name": "msilib.Dialog.line", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.line", 
        "syntax": "line(name, x, y, width, height)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.pushbutton": {
        "descr": "Add and return a PushButton control.", 
        "name": "msilib.Dialog.pushbutton", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.pushbutton", 
        "syntax": "pushbutton(name, x, y, width, height, attributes, text, next_control)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.radiogroup": {
        "descr": "Add and return a RadioButtonGroup control.", 
        "name": "msilib.Dialog.radiogroup", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.radiogroup", 
        "syntax": "radiogroup(name, x, y, width, height, attributes, property, text, next_control)", 
        "type": "MS Windows"
    }, 
    "msilib.Dialog.text": {
        "descr": "Add and return a Text control.", 
        "name": "msilib.Dialog.text", 
        "params": [], 
        "path": "python/library/msilib#msilib.Dialog.text", 
        "syntax": "text(name, x, y, width, height, attributes, text)", 
        "type": "MS Windows"
    }, 
    "msilib.Directory": {
        "descr": "Create a new directory in the Directory table. There is a current component at each point in time for the directory, which is either explicitly created through start_component(), or implicitly when files are added for the first time. Files are added into the current component, and into the cab file. To create a directory, a base directory object needs to be specified (can be None), the path to the physical directory, and a logical directory name. default specifies the DefaultDir slot in the directory table. componentflags specifies the default flags that new components get.", 
        "name": "msilib.Directory", 
        "params": [], 
        "path": "python/library/msilib#msilib.Directory", 
        "syntax": "class msilib.Directory(database, cab, basedir, physical, logical, default[, componentflags])", 
        "type": "MS Windows"
    }, 
    "msilib.Directory.add_file": {
        "descr": "Add a file to the current component of the directory, starting a new one if there is no current component. By default, the file name in the source and the file table will be identical. If the src file is specified, it is interpreted relative to the current directory. Optionally, a version and a language can be specified for the entry in the File table.", 
        "name": "msilib.Directory.add_file", 
        "params": [], 
        "path": "python/library/msilib#msilib.Directory.add_file", 
        "syntax": "add_file(file, src=None, version=None, language=None)", 
        "type": "MS Windows"
    }, 
    "msilib.Directory.glob": {
        "descr": "Add a list of files to the current component as specified in the glob pattern. Individual files can be excluded in the exclude list.", 
        "name": "msilib.Directory.glob", 
        "params": [], 
        "path": "python/library/msilib#msilib.Directory.glob", 
        "syntax": "glob(pattern, exclude=None)", 
        "type": "MS Windows"
    }, 
    "msilib.Directory.remove_pyc": {
        "descr": "Remove .pyc/.pyo files on uninstall.", 
        "name": "msilib.Directory.remove_pyc", 
        "params": [], 
        "path": "python/library/msilib#msilib.Directory.remove_pyc", 
        "syntax": "remove_pyc()", 
        "type": "MS Windows"
    }, 
    "msilib.Directory.start_component": {
        "descr": "Add an entry to the Component table, and make this component the current component for this directory. If no component name is given, the directory name is used. If no feature is given, the current feature is used. If no flags are given, the directory\u2019s default flags are used. If no keyfile is given, the KeyPath is left null in the Component table.", 
        "name": "msilib.Directory.start_component", 
        "params": [], 
        "path": "python/library/msilib#msilib.Directory.start_component", 
        "syntax": "start_component(component=None, feature=None, flags=None, keyfile=None, uuid=None)", 
        "type": "MS Windows"
    }, 
    "msilib.FCICreate": {
        "descr": "Create a new CAB file named cabname. files must be a list of tuples, each containing the name of the file on disk, and the name of the file inside the CAB file.", 
        "name": "msilib.FCICreate", 
        "params": [], 
        "path": "python/library/msilib#msilib.FCICreate", 
        "syntax": "msilib.FCICreate(cabname, files)", 
        "type": "MS Windows"
    }, 
    "msilib.Feature": {
        "descr": "Add a new record to the Feature table, using the values id, parent.id, title, desc, display, level, directory, and attributes. The resulting feature object can be passed to the start_component() method of Directory.", 
        "name": "msilib.Feature", 
        "params": [], 
        "path": "python/library/msilib#msilib.Feature", 
        "syntax": "class msilib.Feature(db, id, title, desc, display, level=1, parent=None, directory=None, attributes=0)", 
        "type": "MS Windows"
    }, 
    "msilib.Feature.set_current": {
        "descr": "Make this feature the current feature of msilib. New components are automatically added to the default feature, unless a feature is explicitly specified.", 
        "name": "msilib.Feature.set_current", 
        "params": [], 
        "path": "python/library/msilib#msilib.Feature.set_current", 
        "syntax": "set_current()", 
        "type": "MS Windows"
    }, 
    "msilib.OpenDatabase": {
        "descr": "Return a new database object by calling MsiOpenDatabase. path is the file name of the MSI file; persist can be one of the constants MSIDBOPEN_CREATEDIRECT, MSIDBOPEN_CREATE, MSIDBOPEN_DIRECT, MSIDBOPEN_READONLY, or MSIDBOPEN_TRANSACT, and may include the flag MSIDBOPEN_PATCHFILE. See the Microsoft documentation for the meaning of these flags; depending on the flags, an existing database is opened, or a new one created.", 
        "name": "msilib.OpenDatabase", 
        "params": [], 
        "path": "python/library/msilib#msilib.OpenDatabase", 
        "syntax": "msilib.OpenDatabase(path, persist)", 
        "type": "MS Windows"
    }, 
    "msilib.RadioButtonGroup": {
        "descr": "Create a radio button control named name. property is the installer property that gets set when a radio button is selected.", 
        "name": "msilib.RadioButtonGroup", 
        "params": [], 
        "path": "python/library/msilib#msilib.RadioButtonGroup", 
        "syntax": "class msilib.RadioButtonGroup(dlg, name, property)", 
        "type": "MS Windows"
    }, 
    "msilib.RadioButtonGroup.add": {
        "descr": "Add a radio button named name to the group, at the coordinates x, y, width, height, and with the label text. If value is None, it defaults to name.", 
        "name": "msilib.RadioButtonGroup.add", 
        "params": [], 
        "path": "python/library/msilib#msilib.RadioButtonGroup.add", 
        "syntax": "add(name, x, y, width, height, text, value=None)", 
        "type": "MS Windows"
    }, 
    "msilib.Record.ClearData": {
        "descr": "Set all fields of the record to 0, through MsiRecordClearData().", 
        "name": "msilib.Record.ClearData", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.ClearData", 
        "syntax": "Record.ClearData()", 
        "type": "MS Windows"
    }, 
    "msilib.Record.GetFieldCount": {
        "descr": "Return the number of fields of the record, through MsiRecordGetFieldCount().", 
        "name": "msilib.Record.GetFieldCount", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.GetFieldCount", 
        "syntax": "Record.GetFieldCount()", 
        "type": "MS Windows"
    }, 
    "msilib.Record.GetInteger": {
        "descr": "Return the value of field as an integer where possible. field must be an integer.", 
        "name": "msilib.Record.GetInteger", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.GetInteger", 
        "syntax": "Record.GetInteger(field)", 
        "type": "MS Windows"
    }, 
    "msilib.Record.GetString": {
        "descr": "Return the value of field as a string where possible. field must be an integer.", 
        "name": "msilib.Record.GetString", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.GetString", 
        "syntax": "Record.GetString(field)", 
        "type": "MS Windows"
    }, 
    "msilib.Record.SetInteger": {
        "descr": "Set field to value through MsiRecordSetInteger(). Both field and value must be an integer.", 
        "name": "msilib.Record.SetInteger", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.SetInteger", 
        "syntax": "Record.SetInteger(field, value)", 
        "type": "MS Windows"
    }, 
    "msilib.Record.SetStream": {
        "descr": "Set field to the contents of the file named value, through MsiRecordSetStream(). field must be an integer; value a string.", 
        "name": "msilib.Record.SetStream", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.SetStream", 
        "syntax": "Record.SetStream(field, value)", 
        "type": "MS Windows"
    }, 
    "msilib.Record.SetString": {
        "descr": "Set field to value through MsiRecordSetString(). field must be an integer; value a string.", 
        "name": "msilib.Record.SetString", 
        "params": [], 
        "path": "python/library/msilib#msilib.Record.SetString", 
        "syntax": "Record.SetString(field, value)", 
        "type": "MS Windows"
    }, 
    "msilib.SummaryInformation.GetProperty": {
        "descr": "Return a property of the summary, through MsiSummaryInfoGetProperty(). field is the name of the property, and can be one of the constants PID_CODEPAGE, PID_TITLE, PID_SUBJECT, PID_AUTHOR, PID_KEYWORDS, PID_COMMENTS, PID_TEMPLATE, PID_LASTAUTHOR, PID_REVNUMBER, PID_LASTPRINTED, PID_CREATE_DTM, PID_LASTSAVE_DTM, PID_PAGECOUNT, PID_WORDCOUNT, PID_CHARCOUNT, PID_APPNAME, or PID_SECURITY.", 
        "name": "msilib.SummaryInformation.GetProperty", 
        "params": [], 
        "path": "python/library/msilib#msilib.SummaryInformation.GetProperty", 
        "syntax": "SummaryInformation.GetProperty(field)", 
        "type": "MS Windows"
    }, 
    "msilib.SummaryInformation.GetPropertyCount": {
        "descr": "Return the number of summary properties, through MsiSummaryInfoGetPropertyCount().", 
        "name": "msilib.SummaryInformation.GetPropertyCount", 
        "params": [], 
        "path": "python/library/msilib#msilib.SummaryInformation.GetPropertyCount", 
        "syntax": "SummaryInformation.GetPropertyCount()", 
        "type": "MS Windows"
    }, 
    "msilib.SummaryInformation.Persist": {
        "descr": "Write the modified properties to the summary information stream, using MsiSummaryInfoPersist().", 
        "name": "msilib.SummaryInformation.Persist", 
        "params": [], 
        "path": "python/library/msilib#msilib.SummaryInformation.Persist", 
        "syntax": "SummaryInformation.Persist()", 
        "type": "MS Windows"
    }, 
    "msilib.SummaryInformation.SetProperty": {
        "descr": "Set a property through MsiSummaryInfoSetProperty(). field can have the same values as in GetProperty(), value is the new value of the property. Possible value types are integer and string.", 
        "name": "msilib.SummaryInformation.SetProperty", 
        "params": [], 
        "path": "python/library/msilib#msilib.SummaryInformation.SetProperty", 
        "syntax": "SummaryInformation.SetProperty(field, value)", 
        "type": "MS Windows"
    }, 
    "msilib.UuidCreate": {
        "descr": "Return the string representation of a new unique identifier. This wraps the Windows API functions UuidCreate() and UuidToString().", 
        "name": "msilib.UuidCreate", 
        "params": [], 
        "path": "python/library/msilib#msilib.UuidCreate", 
        "syntax": "msilib.UuidCreate()", 
        "type": "MS Windows"
    }, 
    "msilib.View.Close": {
        "descr": "Close the view, through MsiViewClose().", 
        "name": "msilib.View.Close", 
        "params": [], 
        "path": "python/library/msilib#msilib.View.Close", 
        "syntax": "View.Close()", 
        "type": "MS Windows"
    }, 
    "msilib.View.Execute": {
        "descr": "Execute the SQL query of the view, through MSIViewExecute(). If params is not None, it is a record describing actual values of the parameter tokens in the query.", 
        "name": "msilib.View.Execute", 
        "params": [], 
        "path": "python/library/msilib#msilib.View.Execute", 
        "syntax": "View.Execute(params)", 
        "type": "MS Windows"
    }, 
    "msilib.View.Fetch": {
        "descr": "Return a result record of the query, through calling MsiViewFetch().", 
        "name": "msilib.View.Fetch", 
        "params": [], 
        "path": "python/library/msilib#msilib.View.Fetch", 
        "syntax": "View.Fetch()", 
        "type": "MS Windows"
    }, 
    "msilib.View.GetColumnInfo": {
        "descr": "Return a record describing the columns of the view, through calling MsiViewGetColumnInfo(). kind can be either MSICOLINFO_NAMES or MSICOLINFO_TYPES.", 
        "name": "msilib.View.GetColumnInfo", 
        "params": [], 
        "path": "python/library/msilib#msilib.View.GetColumnInfo", 
        "syntax": "View.GetColumnInfo(kind)", 
        "type": "MS Windows"
    }, 
    "msilib.View.Modify": {
        "descr": "Modify the view, by calling MsiViewModify(). kind can be one of MSIMODIFY_SEEK, MSIMODIFY_REFRESH, MSIMODIFY_INSERT, MSIMODIFY_UPDATE, MSIMODIFY_ASSIGN, MSIMODIFY_REPLACE, MSIMODIFY_MERGE, MSIMODIFY_DELETE, MSIMODIFY_INSERT_TEMPORARY, MSIMODIFY_VALIDATE, MSIMODIFY_VALIDATE_NEW, MSIMODIFY_VALIDATE_FIELD, or MSIMODIFY_VALIDATE_DELETE.", 
        "name": "msilib.View.Modify", 
        "params": [], 
        "path": "python/library/msilib#msilib.View.Modify", 
        "syntax": "View.Modify(kind, data)", 
        "type": "MS Windows"
    }, 
    "msilib.add_data": {
        "descr": "Add all records to the table named table in database.", 
        "name": "msilib.add_data", 
        "params": [], 
        "path": "python/library/msilib#msilib.add_data", 
        "syntax": "msilib.add_data(database, table, records)", 
        "type": "MS Windows"
    }, 
    "msilib.add_stream": {
        "descr": "Add the file path into the _Stream table of database, with the stream name name.", 
        "name": "msilib.add_stream", 
        "params": [], 
        "path": "python/library/msilib#msilib.add_stream", 
        "syntax": "msilib.add_stream(database, name, path)", 
        "type": "MS Windows"
    }, 
    "msilib.add_tables": {
        "descr": "Add all table content from module to database. module must contain an attribute tables listing all tables for which content should be added, and one attribute per table that has the actual content.", 
        "name": "msilib.add_tables", 
        "params": [], 
        "path": "python/library/msilib#msilib.add_tables", 
        "syntax": "msilib.add_tables(database, module)", 
        "type": "MS Windows"
    }, 
    "msilib.gen_uuid": {
        "descr": "Return a new UUID, in the format that MSI typically requires (i.e. in curly braces, and with all hexdigits in upper-case).", 
        "name": "msilib.gen_uuid", 
        "params": [], 
        "path": "python/library/msilib#msilib.gen_uuid", 
        "syntax": "msilib.gen_uuid()", 
        "type": "MS Windows"
    }, 
    "msilib.init_database": {
        "descr": "Create and return a new database name, initialize it with schema, and set the properties ProductName, ProductCode, ProductVersion, and Manufacturer.", 
        "name": "msilib.init_database", 
        "params": [], 
        "path": "python/library/msilib#msilib.init_database", 
        "syntax": "msilib.init_database(name, schema, ProductName, ProductCode, ProductVersion, Manufacturer)", 
        "type": "MS Windows"
    }, 
    "msilib.schema": {
        "descr": "This is the standard MSI schema for MSI 2.0, with the tables variable providing a list of table definitions, and _Validation_records providing the data for MSI validation.", 
        "name": "msilib.schema", 
        "params": [], 
        "path": "python/library/msilib#msilib.schema", 
        "syntax": "msilib.schema", 
        "type": "MS Windows"
    }, 
    "msilib.sequence": {
        "descr": "This module contains table contents for the standard sequence tables: AdminExecuteSequence, AdminUISequence, AdvtExecuteSequence, InstallExecuteSequence, and InstallUISequence.", 
        "name": "msilib.sequence", 
        "params": [], 
        "path": "python/library/msilib#msilib.sequence", 
        "syntax": "msilib.sequence", 
        "type": "MS Windows"
    }, 
    "msilib.text": {
        "descr": "This module contains definitions for the UIText and ActionText tables, for the standard installer actions.", 
        "name": "msilib.text", 
        "params": [], 
        "path": "python/library/msilib#msilib.text", 
        "syntax": "msilib.text", 
        "type": "MS Windows"
    }, 
    "msvcrt.get_osfhandle": {
        "descr": "Return the file handle for the file descriptor fd. Raises OSError if fd is not recognized.", 
        "name": "msvcrt.get_osfhandle", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.get_osfhandle", 
        "syntax": "msvcrt.get_osfhandle(fd)", 
        "type": "MS Windows"
    }, 
    "msvcrt.getch": {
        "descr": "Read a keypress and return the resulting character as a byte string. Nothing is echoed to the console. This call will block if a keypress is not already available, but will not wait for Enter to be pressed. If the pressed key was a special function key, this will return '\\000' or '\\xe0'; the next call will return the keycode. The Control-C keypress cannot be read with this function.", 
        "name": "msvcrt.getch", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.getch", 
        "syntax": "msvcrt.getch()", 
        "type": "MS Windows"
    }, 
    "msvcrt.getche": {
        "descr": "Similar to getch(), but the keypress will be echoed if it represents a printable character.", 
        "name": "msvcrt.getche", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.getche", 
        "syntax": "msvcrt.getche()", 
        "type": "MS Windows"
    }, 
    "msvcrt.getwch": {
        "descr": "Wide char variant of getch(), returning a Unicode value.", 
        "name": "msvcrt.getwch", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.getwch", 
        "syntax": "msvcrt.getwch()", 
        "type": "MS Windows"
    }, 
    "msvcrt.getwche": {
        "descr": "Wide char variant of getche(), returning a Unicode value.", 
        "name": "msvcrt.getwche", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.getwche", 
        "syntax": "msvcrt.getwche()", 
        "type": "MS Windows"
    }, 
    "msvcrt.heapmin": {
        "descr": "Force the malloc() heap to clean itself up and return unused blocks to the operating system. On failure, this raises OSError.", 
        "name": "msvcrt.heapmin", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.heapmin", 
        "syntax": "msvcrt.heapmin()", 
        "type": "MS Windows"
    }, 
    "msvcrt.kbhit": {
        "descr": "Return true if a keypress is waiting to be read.", 
        "name": "msvcrt.kbhit", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.kbhit", 
        "syntax": "msvcrt.kbhit()", 
        "type": "MS Windows"
    }, 
    "msvcrt.locking": {
        "descr": "Lock part of a file based on file descriptor fd from the C runtime. Raises OSError on failure. The locked region of the file extends from the current file position for nbytes bytes, and may continue beyond the end of the file. mode must be one of the LK_* constants listed below. Multiple regions in a file may be locked at the same time, but may not overlap. Adjacent regions are not merged; they must be unlocked individually.", 
        "name": "msvcrt.locking", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.locking", 
        "syntax": "msvcrt.locking(fd, mode, nbytes)", 
        "type": "MS Windows"
    }, 
    "msvcrt.open_osfhandle": {
        "descr": "Create a C runtime file descriptor from the file handle handle. The flags parameter should be a bitwise OR of os.O_APPEND, os.O_RDONLY, and os.O_TEXT. The returned file descriptor may be used as a parameter to os.fdopen() to create a file object.", 
        "name": "msvcrt.open_osfhandle", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.open_osfhandle", 
        "syntax": "msvcrt.open_osfhandle(handle, flags)", 
        "type": "MS Windows"
    }, 
    "msvcrt.putch": {
        "descr": "Print the byte string char to the console without buffering.", 
        "name": "msvcrt.putch", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.putch", 
        "syntax": "msvcrt.putch(char)", 
        "type": "MS Windows"
    }, 
    "msvcrt.putwch": {
        "descr": "Wide char variant of putch(), accepting a Unicode value.", 
        "name": "msvcrt.putwch", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.putwch", 
        "syntax": "msvcrt.putwch(unicode_char)", 
        "type": "MS Windows"
    }, 
    "msvcrt.setmode": {
        "descr": "Set the line-end translation mode for the file descriptor fd. To set it to text mode, flags should be os.O_TEXT; for binary, it should be os.O_BINARY.", 
        "name": "msvcrt.setmode", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.setmode", 
        "syntax": "msvcrt.setmode(fd, flags)", 
        "type": "MS Windows"
    }, 
    "msvcrt.ungetch": {
        "descr": "Cause the byte string char to be \u201cpushed back\u201d into the console buffer; it will be the next character read by getch() or getche().", 
        "name": "msvcrt.ungetch", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.ungetch", 
        "syntax": "msvcrt.ungetch(char)", 
        "type": "MS Windows"
    }, 
    "msvcrt.ungetwch": {
        "descr": "Wide char variant of ungetch(), accepting a Unicode value.", 
        "name": "msvcrt.ungetwch", 
        "params": [], 
        "path": "python/library/msvcrt#msvcrt.ungetwch", 
        "syntax": "msvcrt.ungetwch(unicode_char)", 
        "type": "MS Windows"
    }, 
    "multiprocessing.Array": {
        "descr": "Return a ctypes array allocated from shared memory. By default the return value is actually a synchronized wrapper for the array.", 
        "name": "multiprocessing.Array", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Array", 
        "syntax": "multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.AuthenticationError": {
        "descr": "Raised when there is an authentication error.", 
        "name": "multiprocessing.AuthenticationError", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.AuthenticationError", 
        "syntax": "exception multiprocessing.AuthenticationError", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Barrier": {
        "descr": "A barrier object: a clone of threading.Barrier.", 
        "name": "multiprocessing.Barrier", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Barrier", 
        "syntax": "class multiprocessing.Barrier(parties[, action[, timeout]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.BoundedSemaphore": {
        "descr": "A bounded semaphore object: a clone of threading.BoundedSemaphore.", 
        "name": "multiprocessing.BoundedSemaphore", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.BoundedSemaphore", 
        "syntax": "class multiprocessing.BoundedSemaphore([value])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.BufferTooShort": {
        "descr": "Exception raised by Connection.recv_bytes_into() when the supplied buffer object is too small for the message read.", 
        "name": "multiprocessing.BufferTooShort", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.BufferTooShort", 
        "syntax": "exception multiprocessing.BufferTooShort", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Condition": {
        "descr": "A condition variable: an alias for threading.Condition.", 
        "name": "multiprocessing.Condition", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Condition", 
        "syntax": "class multiprocessing.Condition([lock])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection": {
        "descr": "Send an object to the other end of the connection which should be read using recv().", 
        "name": "multiprocessing.Connection", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection", 
        "syntax": "class multiprocessing.Connection", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.close": {
        "descr": "Close the connection.", 
        "name": "multiprocessing.Connection.close", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.close", 
        "syntax": "close()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.fileno": {
        "descr": "Return the file descriptor or handle used by the connection.", 
        "name": "multiprocessing.Connection.fileno", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.fileno", 
        "syntax": "fileno()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.poll": {
        "descr": "Return whether there is any data available to be read.", 
        "name": "multiprocessing.Connection.poll", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.poll", 
        "syntax": "poll([timeout])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.recv": {
        "descr": "Return an object sent from the other end of the connection using send(). Blocks until there its something to receive. Raises EOFError if there is nothing left to receive and the other end was closed.", 
        "name": "multiprocessing.Connection.recv", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.recv", 
        "syntax": "recv()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.recv_bytes": {
        "descr": "Return a complete message of byte data sent from the other end of the connection as a string. Blocks until there is something to receive. Raises EOFError if there is nothing left to receive and the other end has closed.", 
        "name": "multiprocessing.Connection.recv_bytes", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.recv_bytes", 
        "syntax": "recv_bytes([maxlength])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.recv_bytes_into": {
        "descr": "Read into buffer a complete message of byte data sent from the other end of the connection and return the number of bytes in the message. Blocks until there is something to receive. Raises EOFError if there is nothing left to receive and the other end was closed.", 
        "name": "multiprocessing.Connection.recv_bytes_into", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.recv_bytes_into", 
        "syntax": "recv_bytes_into(buffer[, offset])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.send": {
        "descr": "Send an object to the other end of the connection which should be read using recv().", 
        "name": "multiprocessing.Connection.send", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.send", 
        "syntax": "send(obj)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Connection.send_bytes": {
        "descr": "Send byte data from a bytes-like object as a complete message.", 
        "name": "multiprocessing.Connection.send_bytes", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Connection.send_bytes", 
        "syntax": "send_bytes(buffer[, offset[, size]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Event": {
        "descr": "A clone of threading.Event.", 
        "name": "multiprocessing.Event", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Event", 
        "syntax": "class multiprocessing.Event", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.JoinableQueue": {
        "descr": "JoinableQueue, a Queue subclass, is a queue which additionally has task_done() and join() methods.", 
        "name": "multiprocessing.JoinableQueue", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.JoinableQueue", 
        "syntax": "class multiprocessing.JoinableQueue([maxsize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.JoinableQueue.join": {
        "descr": "Block until all items in the queue have been gotten and processed.", 
        "name": "multiprocessing.JoinableQueue.join", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.JoinableQueue.join", 
        "syntax": "join()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.JoinableQueue.task_done": {
        "descr": "Indicate that a formerly enqueued task is complete. Used by queue consumers. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.", 
        "name": "multiprocessing.JoinableQueue.task_done", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.JoinableQueue.task_done", 
        "syntax": "task_done()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Lock": {
        "descr": "A non-recursive lock object: a clone of threading.Lock.", 
        "name": "multiprocessing.Lock", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Lock", 
        "syntax": "class multiprocessing.Lock", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Pipe": {
        "descr": "Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.", 
        "name": "multiprocessing.Pipe", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Pipe", 
        "syntax": "multiprocessing.Pipe([duplex])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process": {
        "descr": "Process objects represent activity that is run in a separate process. The Process class has equivalents of all the methods of threading.Thread.", 
        "name": "multiprocessing.Process", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process", 
        "syntax": "class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.authkey": {
        "descr": "The process\u2019s authentication key (a byte string).", 
        "name": "multiprocessing.Process.authkey", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.authkey", 
        "syntax": "authkey", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.daemon": {
        "descr": "The process\u2019s daemon flag, a Boolean value. This must be set before start() is called.", 
        "name": "multiprocessing.Process.daemon", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.daemon", 
        "syntax": "daemon", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.exitcode": {
        "descr": "The child\u2019s exit code. This will be None if the process has not yet terminated. A negative value -N indicates that the child was terminated by signal N.", 
        "name": "multiprocessing.Process.exitcode", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.exitcode", 
        "syntax": "exitcode", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.is_alive": {
        "descr": "Return whether the process is alive.", 
        "name": "multiprocessing.Process.is_alive", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.is_alive", 
        "syntax": "is_alive()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.join": {
        "descr": "If the optional argument timeout is None (the default), the method blocks until the process whose join() method is called terminates. If timeout is a positive number, it blocks at most timeout seconds.", 
        "name": "multiprocessing.Process.join", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.join", 
        "syntax": "join([timeout])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.name": {
        "descr": "The process\u2019s name. The name is a string used for identification purposes only. It has no semantics. Multiple processes may be given the same name.", 
        "name": "multiprocessing.Process.name", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.name", 
        "syntax": "name", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.pid": {
        "descr": "Return the process ID. Before the process is spawned, this will be None.", 
        "name": "multiprocessing.Process.pid", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.pid", 
        "syntax": "pid", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.run": {
        "descr": "Method representing the process\u2019s activity.", 
        "name": "multiprocessing.Process.run", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.run", 
        "syntax": "run()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.sentinel": {
        "descr": "A numeric handle of a system object which will become \u201cready\u201d when the process ends.", 
        "name": "multiprocessing.Process.sentinel", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.sentinel", 
        "syntax": "sentinel", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.start": {
        "descr": "Start the process\u2019s activity.", 
        "name": "multiprocessing.Process.start", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.start", 
        "syntax": "start()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Process.terminate": {
        "descr": "Terminate the process. On Unix this is done using the SIGTERM signal; on Windows TerminateProcess() is used. Note that exit handlers and finally clauses, etc., will not be executed.", 
        "name": "multiprocessing.Process.terminate", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Process.terminate", 
        "syntax": "terminate()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.ProcessError": {
        "descr": "The base class of all multiprocessing exceptions.", 
        "name": "multiprocessing.ProcessError", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.ProcessError", 
        "syntax": "exception multiprocessing.ProcessError", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue": {
        "descr": "Returns a process shared queue implemented using a pipe and a few locks/semaphores. When a process first puts an item on the queue a feeder thread is started which transfers objects from a buffer into the pipe.", 
        "name": "multiprocessing.Queue", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue", 
        "syntax": "class multiprocessing.Queue([maxsize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.cancel_join_thread": {
        "descr": "Prevent join_thread() from blocking. In particular, this prevents the background thread from being joined automatically when the process exits \u2013 see join_thread().", 
        "name": "multiprocessing.Queue.cancel_join_thread", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.cancel_join_thread", 
        "syntax": "cancel_join_thread()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.close": {
        "descr": "Indicate that no more data will be put on this queue by the current process. The background thread will quit once it has flushed all buffered data to the pipe. This is called automatically when the queue is garbage collected.", 
        "name": "multiprocessing.Queue.close", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.close", 
        "syntax": "close()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.empty": {
        "descr": "Return True if the queue is empty, False otherwise. Because of multithreading/multiprocessing semantics, this is not reliable.", 
        "name": "multiprocessing.Queue.empty", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.empty", 
        "syntax": "empty()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.full": {
        "descr": "Return True if the queue is full, False otherwise. Because of multithreading/multiprocessing semantics, this is not reliable.", 
        "name": "multiprocessing.Queue.full", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.full", 
        "syntax": "full()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.get": {
        "descr": "Remove and return an item from the queue. If optional args block is True (the default) and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the queue.Empty exception if no item was available within that time. Otherwise (block is False), return an item if one is immediately available, else raise the queue.Empty exception (timeout is ignored in that case).", 
        "name": "multiprocessing.Queue.get", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.get", 
        "syntax": "get([block[, timeout]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.get_nowait": {
        "descr": "Equivalent to get(False).", 
        "name": "multiprocessing.Queue.get_nowait", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.get_nowait", 
        "syntax": "get_nowait()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.join_thread": {
        "descr": "Join the background thread. This can only be used after close() has been called. It blocks until the background thread exits, ensuring that all data in the buffer has been flushed to the pipe.", 
        "name": "multiprocessing.Queue.join_thread", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.join_thread", 
        "syntax": "join_thread()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.put": {
        "descr": "Put obj into the queue. If the optional argument block is True (the default) and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the queue.Full exception if no free slot was available within that time. Otherwise (block is False), put an item on the queue if a free slot is immediately available, else raise the queue.Full exception (timeout is ignored in that case).", 
        "name": "multiprocessing.Queue.put", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.put", 
        "syntax": "put(obj[, block[, timeout]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.put_nowait": {
        "descr": "Equivalent to put(obj, False).", 
        "name": "multiprocessing.Queue.put_nowait", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.put_nowait", 
        "syntax": "put_nowait(obj)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Queue.qsize": {
        "descr": "Return the approximate size of the queue. Because of multithreading/multiprocessing semantics, this number is not reliable.", 
        "name": "multiprocessing.Queue.qsize", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Queue.qsize", 
        "syntax": "qsize()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.RLock": {
        "descr": "A recursive lock object: a clone of threading.RLock.", 
        "name": "multiprocessing.RLock", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.RLock", 
        "syntax": "class multiprocessing.RLock", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Semaphore": {
        "descr": "A semaphore object: a clone of threading.Semaphore.", 
        "name": "multiprocessing.Semaphore", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Semaphore", 
        "syntax": "class multiprocessing.Semaphore([value])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.SimpleQueue": {
        "descr": "It is a simplified Queue type, very close to a locked Pipe.", 
        "name": "multiprocessing.SimpleQueue", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.SimpleQueue", 
        "syntax": "class multiprocessing.SimpleQueue", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.SimpleQueue.empty": {
        "descr": "Return True if the queue is empty, False otherwise.", 
        "name": "multiprocessing.SimpleQueue.empty", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.SimpleQueue.empty", 
        "syntax": "empty()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.SimpleQueue.get": {
        "descr": "Remove and return an item from the queue.", 
        "name": "multiprocessing.SimpleQueue.get", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.SimpleQueue.get", 
        "syntax": "get()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.SimpleQueue.put": {
        "descr": "Put item into the queue.", 
        "name": "multiprocessing.SimpleQueue.put", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.SimpleQueue.put", 
        "syntax": "put(item)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.TimeoutError": {
        "descr": "Raised by methods with a timeout when the timeout expires.", 
        "name": "multiprocessing.TimeoutError", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.TimeoutError", 
        "syntax": "exception multiprocessing.TimeoutError", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.Value": {
        "descr": "Return a ctypes object allocated from shared memory. By default the return value is actually a synchronized wrapper for the object. The object itself can be accessed via the value attribute of a Value.", 
        "name": "multiprocessing.Value", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.Value", 
        "syntax": "multiprocessing.Value(typecode_or_type, *args, lock=True)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.active_children": {
        "descr": "Return list of all live children of the current process.", 
        "name": "multiprocessing.active_children", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.active_children", 
        "syntax": "multiprocessing.active_children()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.Client": {
        "descr": "Attempt to set up a connection to the listener which is using address address, returning a Connection.", 
        "name": "multiprocessing.connection.Client", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.Client", 
        "syntax": "multiprocessing.connection.Client(address[, family[, authenticate[, authkey]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.Listener": {
        "descr": "A wrapper for a bound socket or Windows named pipe which is \u2018listening\u2019 for connections.", 
        "name": "multiprocessing.connection.Listener", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.Listener", 
        "syntax": "class multiprocessing.connection.Listener([address[, family[, backlog[, authenticate[, authkey]]]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.Listener.accept": {
        "descr": "Accept a connection on the bound socket or named pipe of the listener object and return a Connection object. If authentication is attempted and fails, then AuthenticationError is raised.", 
        "name": "multiprocessing.connection.Listener.accept", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.Listener.accept", 
        "syntax": "accept()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.Listener.address": {
        "descr": "The address which is being used by the Listener object.", 
        "name": "multiprocessing.connection.Listener.address", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.Listener.address", 
        "syntax": "address", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.Listener.close": {
        "descr": "Close the bound socket or named pipe of the listener object. This is called automatically when the listener is garbage collected. However it is advisable to call it explicitly.", 
        "name": "multiprocessing.connection.Listener.close", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.Listener.close", 
        "syntax": "close()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.Listener.last_accepted": {
        "descr": "The address from which the last accepted connection came. If this is unavailable then it is None.", 
        "name": "multiprocessing.connection.Listener.last_accepted", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.Listener.last_accepted", 
        "syntax": "last_accepted", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.answer_challenge": {
        "descr": "Receive a message, calculate the digest of the message using authkey as the key, and then send the digest back.", 
        "name": "multiprocessing.connection.answer_challenge", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.answer_challenge", 
        "syntax": "multiprocessing.connection.answer_challenge(connection, authkey)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.deliver_challenge": {
        "descr": "Send a randomly generated message to the other end of the connection and wait for a reply.", 
        "name": "multiprocessing.connection.deliver_challenge", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.deliver_challenge", 
        "syntax": "multiprocessing.connection.deliver_challenge(connection, authkey)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.connection.wait": {
        "descr": "Wait till an object in object_list is ready. Returns the list of those objects in object_list which are ready. If timeout is a float then the call blocks for at most that many seconds. If timeout is None then it will block for an unlimited period. A negative timeout is equivalent to a zero timeout.", 
        "name": "multiprocessing.connection.wait", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.connection.wait", 
        "syntax": "multiprocessing.connection.wait(object_list, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.cpu_count": {
        "descr": "Return the number of CPUs in the system. May raise NotImplementedError.", 
        "name": "multiprocessing.cpu_count", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.cpu_count", 
        "syntax": "multiprocessing.cpu_count()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.current_process": {
        "descr": "Return the Process object corresponding to the current process.", 
        "name": "multiprocessing.current_process", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.current_process", 
        "syntax": "multiprocessing.current_process()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.freeze_support": {
        "descr": "Add support for when a program which uses multiprocessing has been frozen to produce a Windows executable. (Has been tested with py2exe, PyInstaller and cx_Freeze.)", 
        "name": "multiprocessing.freeze_support", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.freeze_support", 
        "syntax": "multiprocessing.freeze_support()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.get_logger": {
        "descr": "Returns the logger used by multiprocessing. If necessary, a new one will be created.", 
        "name": "multiprocessing.get_logger", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.get_logger", 
        "syntax": "multiprocessing.get_logger()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.log_to_stderr": {
        "descr": "This function performs a call to get_logger() but in addition to returning the logger created by get_logger, it adds a handler which sends output to sys.stderr using format '[%(levelname)s/%(processName)s] %(message)s'.", 
        "name": "multiprocessing.log_to_stderr", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.log_to_stderr", 
        "syntax": "multiprocessing.log_to_stderr()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager": {
        "descr": "Create a BaseManager object.", 
        "name": "multiprocessing.managers.BaseManager", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager", 
        "syntax": "class multiprocessing.managers.BaseManager([address[, authkey]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager.address": {
        "descr": "The address used by the manager.", 
        "name": "multiprocessing.managers.BaseManager.address", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager.address", 
        "syntax": "address", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager.connect": {
        "descr": "Connect a local manager object to a remote manager process:", 
        "name": "multiprocessing.managers.BaseManager.connect", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager.connect", 
        "syntax": "connect()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager.get_server": {
        "descr": "Returns a Server object which represents the actual server under the control of the Manager. The Server object supports the serve_forever() method:", 
        "name": "multiprocessing.managers.BaseManager.get_server", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager.get_server", 
        "syntax": "get_server()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager.register": {
        "descr": "A classmethod which can be used for registering a type or callable with the manager class.", 
        "name": "multiprocessing.managers.BaseManager.register", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager.register", 
        "syntax": "register(typeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager.shutdown": {
        "descr": "Stop the process used by the manager. This is only available if start() has been used to start the server process.", 
        "name": "multiprocessing.managers.BaseManager.shutdown", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager.shutdown", 
        "syntax": "shutdown()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseManager.start": {
        "descr": "Start a subprocess to start the manager. If initializer is not None then the subprocess will call initializer(*initargs) when it starts.", 
        "name": "multiprocessing.managers.BaseManager.start", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseManager.start", 
        "syntax": "start([initializer[, initargs]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseProxy": {
        "descr": "Proxy objects are instances of subclasses of BaseProxy.", 
        "name": "multiprocessing.managers.BaseProxy", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseProxy", 
        "syntax": "class multiprocessing.managers.BaseProxy", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseProxy.__repr__": {
        "descr": "Return a representation of the proxy object.", 
        "name": "multiprocessing.managers.BaseProxy.__repr__", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseProxy.__repr__", 
        "syntax": "__repr__()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseProxy.__str__": {
        "descr": "Return the representation of the referent.", 
        "name": "multiprocessing.managers.BaseProxy.__str__", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseProxy.__str__", 
        "syntax": "__str__()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseProxy._callmethod": {
        "descr": "Call and return the result of a method of the proxy\u2019s referent.", 
        "name": "multiprocessing.managers.BaseProxy._callmethod", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseProxy._callmethod", 
        "syntax": "_callmethod(methodname[, args[, kwds]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.BaseProxy._getvalue": {
        "descr": "Return a copy of the referent.", 
        "name": "multiprocessing.managers.BaseProxy._getvalue", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.BaseProxy._getvalue", 
        "syntax": "_getvalue()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager": {
        "descr": "A subclass of BaseManager which can be used for the synchronization of processes. Objects of this type are returned by multiprocessing.Manager().", 
        "name": "multiprocessing.managers.SyncManager", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager", 
        "syntax": "class multiprocessing.managers.SyncManager", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Array": {
        "descr": "Create an array and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Array", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Array", 
        "syntax": "Array(typecode, sequence)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Barrier": {
        "descr": "Create a shared threading.Barrier object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Barrier", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Barrier", 
        "syntax": "Barrier(parties[, action[, timeout]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.BoundedSemaphore": {
        "descr": "Create a shared threading.BoundedSemaphore object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.BoundedSemaphore", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.BoundedSemaphore", 
        "syntax": "BoundedSemaphore([value])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Condition": {
        "descr": "Create a shared threading.Condition object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Condition", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Condition", 
        "syntax": "Condition([lock])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Event": {
        "descr": "Create a shared threading.Event object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Event", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Event", 
        "syntax": "Event()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Lock": {
        "descr": "Create a shared threading.Lock object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Lock", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Lock", 
        "syntax": "Lock()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Namespace": {
        "descr": "Create a shared Namespace object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Namespace", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Namespace", 
        "syntax": "Namespace()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Queue": {
        "descr": "Create a shared queue.Queue object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Queue", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Queue", 
        "syntax": "Queue([maxsize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.RLock": {
        "descr": "Create a shared threading.RLock object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.RLock", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.RLock", 
        "syntax": "RLock()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Semaphore": {
        "descr": "Create a shared threading.Semaphore object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Semaphore", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Semaphore", 
        "syntax": "Semaphore([value])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.Value": {
        "descr": "Create an object with a writable value attribute and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.Value", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.Value", 
        "syntax": "Value(typecode, value)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.dict": {
        "descr": "Create a shared dict object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.dict", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.dict", 
        "syntax": "dict()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.managers.SyncManager.list": {
        "descr": "Create a shared list object and return a proxy for it.", 
        "name": "multiprocessing.managers.SyncManager.list", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.managers.SyncManager.list", 
        "syntax": "list()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.AsyncResult": {
        "descr": "The class of the result returned by Pool.apply_async() and Pool.map_async().", 
        "name": "multiprocessing.pool.AsyncResult", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.AsyncResult", 
        "syntax": "class multiprocessing.pool.AsyncResult", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.AsyncResult.get": {
        "descr": "Return the result when it arrives. If timeout is not None and the result does not arrive within timeout seconds then multiprocessing.TimeoutError is raised. If the remote call raised an exception then that exception will be reraised by get().", 
        "name": "multiprocessing.pool.AsyncResult.get", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.AsyncResult.get", 
        "syntax": "get([timeout])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.AsyncResult.ready": {
        "descr": "Return whether the call has completed.", 
        "name": "multiprocessing.pool.AsyncResult.ready", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.AsyncResult.ready", 
        "syntax": "ready()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.AsyncResult.successful": {
        "descr": "Return whether the call completed without raising an exception. Will raise AssertionError if the result is not ready.", 
        "name": "multiprocessing.pool.AsyncResult.successful", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.AsyncResult.successful", 
        "syntax": "successful()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.AsyncResult.wait": {
        "descr": "Wait until the result is available or until timeout seconds pass.", 
        "name": "multiprocessing.pool.AsyncResult.wait", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.AsyncResult.wait", 
        "syntax": "wait([timeout])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool": {
        "descr": "A process pool object which controls a pool of worker processes to which jobs can be submitted. It supports asynchronous results with timeouts and callbacks and has a parallel map implementation.", 
        "name": "multiprocessing.pool.Pool", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool", 
        "syntax": "class multiprocessing.pool.Pool([processes[, initializer[, initargs[, maxtasksperchild]]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.apply": {
        "descr": "Call func with arguments args and keyword arguments kwds. It blocks until the result is ready. Given this blocks, apply_async() is better suited for performing work in parallel. Additionally, func is only executed in one of the workers of the pool.", 
        "name": "multiprocessing.pool.Pool.apply", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.apply", 
        "syntax": "apply(func[, args[, kwds]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.apply_async": {
        "descr": "A variant of the apply() method which returns a result object.", 
        "name": "multiprocessing.pool.Pool.apply_async", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.apply_async", 
        "syntax": "apply_async(func[, args[, kwds[, callback[, error_callback]]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.close": {
        "descr": "Prevents any more tasks from being submitted to the pool. Once all the tasks have been completed the worker processes will exit.", 
        "name": "multiprocessing.pool.Pool.close", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.close", 
        "syntax": "close()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.imap": {
        "descr": "A lazier version of map().", 
        "name": "multiprocessing.pool.Pool.imap", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.imap", 
        "syntax": "imap(func, iterable[, chunksize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.imap_unordered": {
        "descr": "The same as imap() except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be \u201ccorrect\u201d.)", 
        "name": "multiprocessing.pool.Pool.imap_unordered", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.imap_unordered", 
        "syntax": "imap_unordered(func, iterable[, chunksize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.join": {
        "descr": "Wait for the worker processes to exit. One must call close() or terminate() before using join().", 
        "name": "multiprocessing.pool.Pool.join", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.join", 
        "syntax": "join()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.map": {
        "descr": "A parallel equivalent of the map() built-in function (it supports only one iterable argument though). It blocks until the result is ready.", 
        "name": "multiprocessing.pool.Pool.map", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.map", 
        "syntax": "map(func, iterable[, chunksize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.map_async": {
        "descr": "A variant of the map() method which returns a result object.", 
        "name": "multiprocessing.pool.Pool.map_async", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.map_async", 
        "syntax": "map_async(func, iterable[, chunksize[, callback[, error_callback]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.starmap": {
        "descr": "Like map() except that the elements of the iterable are expected to be iterables that are unpacked as arguments.", 
        "name": "multiprocessing.pool.Pool.starmap", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.starmap", 
        "syntax": "starmap(func, iterable[, chunksize])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.starmap_async": {
        "descr": "A combination of starmap() and map_async() that iterates over iterable of iterables and calls func with the iterables unpacked. Returns a result object.", 
        "name": "multiprocessing.pool.Pool.starmap_async", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.starmap_async", 
        "syntax": "starmap_async(func, iterable[, chunksize[, callback[, error_back]]])", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.pool.Pool.terminate": {
        "descr": "Stops the worker processes immediately without completing outstanding work. When the pool object is garbage collected terminate() will be called immediately.", 
        "name": "multiprocessing.pool.Pool.terminate", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.pool.Pool.terminate", 
        "syntax": "terminate()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.set_executable": {
        "descr": "Sets the path of the Python interpreter to use when starting a child process. (By default sys.executable is used). Embedders will probably need to do some thing like", 
        "name": "multiprocessing.set_executable", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.set_executable", 
        "syntax": "multiprocessing.set_executable()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.Array": {
        "descr": "The same as RawArray() except that depending on the value of lock a process-safe synchronization wrapper may be returned instead of a raw ctypes array.", 
        "name": "multiprocessing.sharedctypes.Array", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.Array", 
        "syntax": "multiprocessing.sharedctypes.Array(typecode_or_type, size_or_initializer, *, lock=True)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.RawArray": {
        "descr": "Return a ctypes array allocated from shared memory.", 
        "name": "multiprocessing.sharedctypes.RawArray", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.RawArray", 
        "syntax": "multiprocessing.sharedctypes.RawArray(typecode_or_type, size_or_initializer)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.RawValue": {
        "descr": "Return a ctypes object allocated from shared memory.", 
        "name": "multiprocessing.sharedctypes.RawValue", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.RawValue", 
        "syntax": "multiprocessing.sharedctypes.RawValue(typecode_or_type, *args)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.Value": {
        "descr": "The same as RawValue() except that depending on the value of lock a process-safe synchronization wrapper may be returned instead of a raw ctypes object.", 
        "name": "multiprocessing.sharedctypes.Value", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.Value", 
        "syntax": "multiprocessing.sharedctypes.Value(typecode_or_type, *args, lock=True)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.copy": {
        "descr": "Return a ctypes object allocated from shared memory which is a copy of the ctypes object obj.", 
        "name": "multiprocessing.sharedctypes.copy", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.copy", 
        "syntax": "multiprocessing.sharedctypes.copy(obj)", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.multiprocessing.Manager": {
        "descr": "Returns a started SyncManager object which can be used for sharing objects between processes. The returned manager object corresponds to a spawned child process and has methods which will create shared objects and return corresponding proxies.", 
        "name": "multiprocessing.sharedctypes.multiprocessing.Manager", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.multiprocessing.Manager", 
        "syntax": "multiprocessing.Manager()", 
        "type": "Concurrent Execution"
    }, 
    "multiprocessing.sharedctypes.synchronized": {
        "descr": "Return a process-safe wrapper object for a ctypes object which uses lock to synchronize access. If lock is None (the default) then a multiprocessing.RLock object is created automatically.", 
        "name": "multiprocessing.sharedctypes.synchronized", 
        "params": [], 
        "path": "python/library/multiprocessing#multiprocessing.sharedctypes.synchronized", 
        "syntax": "multiprocessing.sharedctypes.synchronized(obj[, lock])", 
        "type": "Concurrent Execution"
    }, 
    "netrc.NetrcParseError": {
        "descr": "Exception raised by the netrc class when syntactical errors are encountered in source text. Instances of this exception provide three interesting attributes: msg is a textual explanation of the error, filename is the name of the source file, and lineno gives the line number on which the error was found.", 
        "name": "netrc.NetrcParseError", 
        "params": [], 
        "path": "python/library/netrc#netrc.NetrcParseError", 
        "syntax": "exception netrc.NetrcParseError", 
        "type": "File Formats"
    }, 
    "netrc.netrc": {
        "descr": "A netrc instance or subclass instance encapsulates data from a netrc file. The initialization argument, if present, specifies the file to parse. If no argument is given, the file .netrc in the user\u2019s home directory will be read. Parse errors will raise NetrcParseError with diagnostic information including the file name, line number, and terminating token. If no argument is specified on a POSIX system, the presence of passwords in the .netrc file will raise a NetrcParseError if the file ownership or permissions are insecure (owned by a user other than the user running the process, or accessible for read or write by any other user). This implements security behavior equivalent to that of ftp and other programs that use .netrc.", 
        "name": "netrc.netrc", 
        "params": [], 
        "path": "python/library/netrc#netrc.netrc", 
        "syntax": "class netrc.netrc([file])", 
        "type": "File Formats"
    }, 
    "netrc.netrc.__repr__": {
        "descr": "Dump the class data as a string in the format of a netrc file. (This discards comments and may reorder the entries.)", 
        "name": "netrc.netrc.__repr__", 
        "params": [], 
        "path": "python/library/netrc#netrc.netrc.__repr__", 
        "syntax": "netrc.__repr__()", 
        "type": "File Formats"
    }, 
    "netrc.netrc.authenticators": {
        "descr": "Return a 3-tuple (login, account, password) of authenticators for host. If the netrc file did not contain an entry for the given host, return the tuple associated with the \u2018default\u2019 entry. If neither matching host nor default entry is available, return None.", 
        "name": "netrc.netrc.authenticators", 
        "params": [], 
        "path": "python/library/netrc#netrc.netrc.authenticators", 
        "syntax": "netrc.authenticators(host)", 
        "type": "File Formats"
    }, 
    "netrc.netrc.hosts": {
        "descr": "Dictionary mapping host names to (login, account, password) tuples. The \u2018default\u2019 entry, if any, is represented as a pseudo-host by that name.", 
        "name": "netrc.netrc.hosts", 
        "params": [], 
        "path": "python/library/netrc#netrc.netrc.hosts", 
        "syntax": "netrc.hosts", 
        "type": "File Formats"
    }, 
    "netrc.netrc.macros": {
        "descr": "Dictionary mapping macro names to string lists.", 
        "name": "netrc.netrc.macros", 
        "params": [], 
        "path": "python/library/netrc#netrc.netrc.macros", 
        "syntax": "netrc.macros", 
        "type": "File Formats"
    }, 
    "next": {
        "descr": "Retrieve the next item from the iterator by calling its __next__() method. If default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised.", 
        "name": "next", 
        "params": [], 
        "path": "python/library/functions#next", 
        "syntax": "next(iterator[, default])", 
        "type": "Built-in Functions"
    }, 
    "nis.cat": {
        "descr": "Return a dictionary mapping key to value such that match(key, mapname)==value. Note that both keys and values of the dictionary are arbitrary arrays of bytes.", 
        "name": "nis.cat", 
        "params": [], 
        "path": "python/library/nis#nis.cat", 
        "syntax": "nis.cat(mapname, domain=default_domain)", 
        "type": "Unix"
    }, 
    "nis.error": {
        "descr": "An error raised when a NIS function returns an error code.", 
        "name": "nis.error", 
        "params": [], 
        "path": "python/library/nis#nis.error", 
        "syntax": "exception nis.error", 
        "type": "Unix"
    }, 
    "nis.get_default_domain": {
        "descr": "Return the system default NIS domain.", 
        "name": "nis.get_default_domain", 
        "params": [], 
        "path": "python/library/nis#nis.get_default_domain", 
        "syntax": "nis.get_default_domain()", 
        "type": "Unix"
    }, 
    "nis.maps": {
        "descr": "Return a list of all valid maps.", 
        "name": "nis.maps", 
        "params": [], 
        "path": "python/library/nis#nis.maps", 
        "syntax": "nis.maps(domain=default_domain)", 
        "type": "Unix"
    }, 
    "nis.match": {
        "descr": "Return the match for key in map mapname, or raise an error (nis.error) if there is none. Both should be strings, key is 8-bit clean. Return value is an arbitrary array of bytes (may contain NULL and other joys).", 
        "name": "nis.match", 
        "params": [], 
        "path": "python/library/nis#nis.match", 
        "syntax": "nis.match(key, mapname, domain=default_domain)", 
        "type": "Unix"
    }, 
    "nntplib.NNTP": {
        "descr": "Return a new NNTP object, representing a connection to the NNTP server running on host host, listening at port port. An optional timeout can be specified for the socket connection. If the optional user and password are provided, or if suitable credentials are present in /.netrc and the optional flag usenetrc is true, the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server. If the optional flag readermode is true, then a mode reader command is sent before authentication is performed. Reader mode is sometimes necessary if you are connecting to an NNTP server on the local machine and intend to call reader-specific commands, such as group. If you get unexpected NNTPPermanentErrors, you might need to set readermode. NNTP class supports the with statement to unconditionally consume socket.error exceptions and to close the NNTP connection when done. Here is a sample on how using it:", 
        "name": "nntplib.NNTP", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP", 
        "syntax": "class nntplib.NNTP(host, port=119, user=None, password=None, readermode=None, usenetrc=False[, timeout])", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.article": {
        "descr": "Send an ARTICLE command, where message_spec has the same meaning as for stat(). Return a tuple (response, info) where info is a namedtuple with three attributes number, message_id and lines (in that order). number is the article number in the group (or 0 if the information is not available), message_id the message id as a string, and lines a list of lines (without terminating newlines) comprising the raw message including headers and body.", 
        "name": "nntplib.NNTP.article", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.article", 
        "syntax": "NNTP.article(message_spec=None, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.body": {
        "descr": "Same as article(), but sends a BODY command. The lines returned (or written to file) will only contain the message body, not the headers.", 
        "name": "nntplib.NNTP.body", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.body", 
        "syntax": "NNTP.body(message_spec=None, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.date": {
        "descr": "Return a pair (response, date). date is a datetime object containing the current date and time of the server.", 
        "name": "nntplib.NNTP.date", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.date", 
        "syntax": "NNTP.date()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.description": {
        "descr": "Get a description for a single group group. If more than one group matches (if \u2018group\u2019 is a real wildmat string), return the first match. If no group matches, return an empty string.", 
        "name": "nntplib.NNTP.description", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.description", 
        "syntax": "NNTP.description(group)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.descriptions": {
        "descr": "Send a LIST NEWSGROUPS command, where grouppattern is a wildmat string as specified in RFC 3977 (it\u2019s essentially the same as DOS or UNIX shell wildcard strings). Return a pair (response, descriptions), where descriptions is a dictionary mapping group names to textual descriptions.", 
        "name": "nntplib.NNTP.descriptions", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.descriptions", 
        "syntax": "NNTP.descriptions(grouppattern)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.getcapabilities": {
        "descr": "Return the RFC 3977 capabilities advertised by the server, as a dict instance mapping capability names to (possibly empty) lists of values. On legacy servers which don\u2019t understand the CAPABILITIES command, an empty dictionary is returned instead.", 
        "name": "nntplib.NNTP.getcapabilities", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.getcapabilities", 
        "syntax": "NNTP.getcapabilities()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.getwelcome": {
        "descr": "Return the welcome message sent by the server in reply to the initial connection. (This message sometimes contains disclaimers or help information that may be relevant to the user.)", 
        "name": "nntplib.NNTP.getwelcome", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.getwelcome", 
        "syntax": "NNTP.getwelcome()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.group": {
        "descr": "Send a GROUP command, where name is the group name. The group is selected as the current group, if it exists. Return a tuple (response, count, first, last, name) where count is the (estimated) number of articles in the group, first is the first article number in the group, last is the last article number in the group, and name is the group name.", 
        "name": "nntplib.NNTP.group", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.group", 
        "syntax": "NNTP.group(name)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.head": {
        "descr": "Same as article(), but sends a HEAD command. The lines returned (or written to file) will only contain the message headers, not the body.", 
        "name": "nntplib.NNTP.head", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.head", 
        "syntax": "NNTP.head(message_spec=None, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.help": {
        "descr": "Send a HELP command. Return a pair (response, list) where list is a list of help strings.", 
        "name": "nntplib.NNTP.help", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.help", 
        "syntax": "NNTP.help(*, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.ihave": {
        "descr": "Send an IHAVE command. message_id is the id of the message to send to the server (enclosed in '<' and '>'). The data parameter and the return value are the same as for post().", 
        "name": "nntplib.NNTP.ihave", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.ihave", 
        "syntax": "NNTP.ihave(message_id, data)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.last": {
        "descr": "Send a LAST command. Return as for stat().", 
        "name": "nntplib.NNTP.last", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.last", 
        "syntax": "NNTP.last()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.list": {
        "descr": "Send a LIST or LIST ACTIVE command. Return a pair (response, list) where list is a list of tuples representing all the groups available from this NNTP server, optionally matching the pattern string group_pattern. Each tuple has the form (group, last, first, flag), where group is a group name, last and first are the last and first article numbers, and flag usually takes one of these values:", 
        "name": "nntplib.NNTP.list", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.list", 
        "syntax": "NNTP.list(group_pattern=None, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.login": {
        "descr": "Send AUTHINFO commands with the user name and password. If user and password are None and usenetrc is true, credentials from ~/.netrc will be used if possible.", 
        "name": "nntplib.NNTP.login", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.login", 
        "syntax": "NNTP.login(user=None, password=None, usenetrc=True)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.newgroups": {
        "descr": "Send a NEWGROUPS command. The date argument should be a datetime.date or datetime.datetime object. Return a pair (response, groups) where groups is a list representing the groups that are new since the given date. If file is supplied, though, then groups will be empty.", 
        "name": "nntplib.NNTP.newgroups", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.newgroups", 
        "syntax": "NNTP.newgroups(date, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.newnews": {
        "descr": "Send a NEWNEWS command. Here, group is a group name or '*', and date has the same meaning as for newgroups(). Return a pair (response, articles) where articles is a list of message ids.", 
        "name": "nntplib.NNTP.newnews", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.newnews", 
        "syntax": "NNTP.newnews(group, date, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.next": {
        "descr": "Send a NEXT command. Return as for stat().", 
        "name": "nntplib.NNTP.next", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.next", 
        "syntax": "NNTP.next()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.nntp_implementation": {
        "descr": "A string describing the software name and version of the NNTP server, or None if not advertised by the server.", 
        "name": "nntplib.NNTP.nntp_implementation", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.nntp_implementation", 
        "syntax": "NNTP.nntp_implementation", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.nntp_version": {
        "descr": "An integer representing the version of the NNTP protocol supported by the server. In practice, this should be 2 for servers advertising RFC 3977 compliance and 1 for others.", 
        "name": "nntplib.NNTP.nntp_version", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.nntp_version", 
        "syntax": "NNTP.nntp_version", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.over": {
        "descr": "Send a OVER command, or a XOVER command on legacy servers. message_spec can be either a string representing a message id, or a (first, last) tuple of numbers indicating a range of articles in the current group, or a (first, None) tuple indicating a range of articles starting from first to the last article in the current group, or None to select the current article in the current group.", 
        "name": "nntplib.NNTP.over", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.over", 
        "syntax": "NNTP.over(message_spec, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.post": {
        "descr": "Post an article using the POST command. The data argument is either a file object opened for binary reading, or any iterable of bytes objects (representing raw lines of the article to be posted). It should represent a well-formed news article, including the required headers. The post() method automatically escapes lines beginning with . and appends the termination line.", 
        "name": "nntplib.NNTP.post", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.post", 
        "syntax": "NNTP.post(data)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.quit": {
        "descr": "Send a QUIT command and close the connection. Once this method has been called, no other methods of the NNTP object should be called.", 
        "name": "nntplib.NNTP.quit", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.quit", 
        "syntax": "NNTP.quit()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.set_debuglevel": {
        "descr": "Set the instance\u2019s debugging level. This controls the amount of debugging output printed. The default, 0, produces no debugging output. A value of 1 produces a moderate amount of debugging output, generally a single line per request or response. A value of 2 or higher produces the maximum amount of debugging output, logging each line sent and received on the connection (including message text).", 
        "name": "nntplib.NNTP.set_debuglevel", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.set_debuglevel", 
        "syntax": "NNTP.set_debuglevel(level)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.slave": {
        "descr": "Send a SLAVE command. Return the server\u2019s response.", 
        "name": "nntplib.NNTP.slave", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.slave", 
        "syntax": "NNTP.slave()", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.starttls": {
        "descr": "Send a STARTTLS command. The ssl_context argument is optional and should be a ssl.SSLContext object. This will enable encryption on the NNTP connection.", 
        "name": "nntplib.NNTP.starttls", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.starttls", 
        "syntax": "NNTP.starttls(ssl_context=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.stat": {
        "descr": "Send a STAT command, where message_spec is either a message id (enclosed in '<' and '>') or an article number in the current group. If message_spec is omitted or None, the current article in the current group is considered. Return a triple (response, number, id) where number is the article number and id is the message id.", 
        "name": "nntplib.NNTP.stat", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.stat", 
        "syntax": "NNTP.stat(message_spec=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.xhdr": {
        "descr": "Send an XHDR command. The hdr argument is a header keyword, e.g. 'subject'. The str argument should have the form 'first-last' where first and last are the first and last article numbers to search. Return a pair (response, list), where list is a list of pairs (id, text), where id is an article number (as a string) and text is the text of the requested header for that article. If the file parameter is supplied, then the output of the XHDR command is stored in a file. If file is a string, then the method will open a file with that name, write to it then close it. If file is a file object, then it will start calling write() on it to store the lines of the command output. If file is supplied, then the returned list is an empty list.", 
        "name": "nntplib.NNTP.xhdr", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.xhdr", 
        "syntax": "NNTP.xhdr(hdr, str, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.xover": {
        "descr": "Send an XOVER command. start and end are article numbers delimiting the range of articles to select. The return value is the same of for over(). It is recommended to use over() instead, since it will automatically use the newer OVER command if available.", 
        "name": "nntplib.NNTP.xover", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.xover", 
        "syntax": "NNTP.xover(start, end, *, file=None)", 
        "type": "Internet"
    }, 
    "nntplib.NNTP.xpath": {
        "descr": "Return a pair (resp, path), where path is the directory path to the article with message ID id. Most of the time, this extension is not enabled by NNTP server administrators.", 
        "name": "nntplib.NNTP.xpath", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP.xpath", 
        "syntax": "NNTP.xpath(id)", 
        "type": "Internet"
    }, 
    "nntplib.NNTPDataError": {
        "descr": "Exception raised when there is some error in the response data.", 
        "name": "nntplib.NNTPDataError", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPDataError", 
        "syntax": "exception nntplib.NNTPDataError", 
        "type": "Internet"
    }, 
    "nntplib.NNTPError": {
        "descr": "Derived from the standard exception Exception, this is the base class for all exceptions raised by the nntplib module. Instances of this class have the following attribute:", 
        "name": "nntplib.NNTPError", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPError", 
        "syntax": "exception nntplib.NNTPError", 
        "type": "Internet"
    }, 
    "nntplib.NNTPError.response": {
        "descr": "The response of the server if available, as a str object.", 
        "name": "nntplib.NNTPError.response", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPError.response", 
        "syntax": "response", 
        "type": "Internet"
    }, 
    "nntplib.NNTPPermanentError": {
        "descr": "Exception raised when a response code in the range 500\u2013599 is received.", 
        "name": "nntplib.NNTPPermanentError", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPPermanentError", 
        "syntax": "exception nntplib.NNTPPermanentError", 
        "type": "Internet"
    }, 
    "nntplib.NNTPProtocolError": {
        "descr": "Exception raised when a reply is received from the server that does not begin with a digit in the range 1\u20135.", 
        "name": "nntplib.NNTPProtocolError", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPProtocolError", 
        "syntax": "exception nntplib.NNTPProtocolError", 
        "type": "Internet"
    }, 
    "nntplib.NNTPReplyError": {
        "descr": "Exception raised when an unexpected reply is received from the server.", 
        "name": "nntplib.NNTPReplyError", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPReplyError", 
        "syntax": "exception nntplib.NNTPReplyError", 
        "type": "Internet"
    }, 
    "nntplib.NNTPTemporaryError": {
        "descr": "Exception raised when a response code in the range 400\u2013499 is received.", 
        "name": "nntplib.NNTPTemporaryError", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTPTemporaryError", 
        "syntax": "exception nntplib.NNTPTemporaryError", 
        "type": "Internet"
    }, 
    "nntplib.NNTP_SSL": {
        "descr": "Return a new NNTP_SSL object, representing an encrypted connection to the NNTP server running on host host, listening at port port. NNTP_SSL objects have the same methods as NNTP objects. If port is omitted, port 563 (NNTPS) is used. ssl_context is also optional, and is a SSLContext object. All other parameters behave the same as for NNTP.", 
        "name": "nntplib.NNTP_SSL", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.NNTP_SSL", 
        "syntax": "class nntplib.NNTP_SSL(host, port=563, user=None, password=None, ssl_context=None, readermode=None, usenetrc=False[, timeout])", 
        "type": "Internet"
    }, 
    "nntplib.decode_header": {
        "descr": "Decode a header value, un-escaping any escaped non-ASCII characters. header_str must be a str object. The unescaped value is returned. Using this function is recommended to display some headers in a human readable form:", 
        "name": "nntplib.decode_header", 
        "params": [], 
        "path": "python/library/nntplib#nntplib.decode_header", 
        "syntax": "nntplib.decode_header(header_str)", 
        "type": "Internet"
    }, 
    "numbers.Complex": {
        "descr": "Subclasses of this type describe complex numbers and include the operations that work on the built-in complex type. These are: conversions to complex and bool, real, imag, +, -, *, /, abs(), conjugate(), ==, and !=. All except - and != are abstract.", 
        "name": "numbers.Complex", 
        "params": [], 
        "path": "python/library/numbers#numbers.Complex", 
        "syntax": "class numbers.Complex", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Complex.conjugate": {
        "descr": "Abstract. Returns the complex conjugate. For example, (1+3j).conjugate() == (1-3j).", 
        "name": "numbers.Complex.conjugate", 
        "params": [], 
        "path": "python/library/numbers#numbers.Complex.conjugate", 
        "syntax": "conjugate()", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Complex.imag": {
        "descr": "Abstract. Retrieves the imaginary component of this number.", 
        "name": "numbers.Complex.imag", 
        "params": [], 
        "path": "python/library/numbers#numbers.Complex.imag", 
        "syntax": "imag", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Complex.real": {
        "descr": "Abstract. Retrieves the real component of this number.", 
        "name": "numbers.Complex.real", 
        "params": [], 
        "path": "python/library/numbers#numbers.Complex.real", 
        "syntax": "real", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Integral": {
        "descr": "Subtypes Rational and adds a conversion to int. Provides defaults for float(), numerator, and denominator. Adds abstract methods for ** and bit-string operations: <<, >>, &, ^, |, ~.", 
        "name": "numbers.Integral", 
        "params": [], 
        "path": "python/library/numbers#numbers.Integral", 
        "syntax": "class numbers.Integral", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Number": {
        "descr": "The root of the numeric hierarchy. If you just want to check if an argument x is a number, without caring what kind, use isinstance(x, Number).", 
        "name": "numbers.Number", 
        "params": [], 
        "path": "python/library/numbers#numbers.Number", 
        "syntax": "class numbers.Number", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Rational": {
        "descr": "Subtypes Real and adds numerator and denominator properties, which should be in lowest terms. With these, it provides a default for float().", 
        "name": "numbers.Rational", 
        "params": [], 
        "path": "python/library/numbers#numbers.Rational", 
        "syntax": "class numbers.Rational", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Rational.denominator": {
        "descr": "Abstract.", 
        "name": "numbers.Rational.denominator", 
        "params": [], 
        "path": "python/library/numbers#numbers.Rational.denominator", 
        "syntax": "denominator", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Rational.numerator": {
        "descr": "Abstract.", 
        "name": "numbers.Rational.numerator", 
        "params": [], 
        "path": "python/library/numbers#numbers.Rational.numerator", 
        "syntax": "numerator", 
        "type": "Numeric & Mathematical"
    }, 
    "numbers.Real": {
        "descr": "To Complex, Real adds the operations that work on real numbers.", 
        "name": "numbers.Real", 
        "params": [], 
        "path": "python/library/numbers#numbers.Real", 
        "syntax": "class numbers.Real", 
        "type": "Numeric & Mathematical"
    }, 
    "object": {
        "descr": "Return a new featureless object. object is a base for all classes. It has the methods that are common to all instances of Python classes. This function does not accept any arguments.", 
        "name": "object", 
        "params": [], 
        "path": "python/library/functions#object", 
        "syntax": "object()", 
        "type": "Built-in Functions"
    }, 
    "object.__dict__": {
        "descr": "A dictionary or other mapping object used to store an object\u2019s (writable) attributes.", 
        "name": "object.__dict__", 
        "params": [], 
        "path": "python/library/stdtypes#object.__dict__", 
        "syntax": "object.__dict__", 
        "type": "Built-in Types"
    }, 
    "object.__getnewargs__": {
        "descr": "In protocol 2 and newer, classes that implements the __getnewargs__() method can dictate the values passed to the __new__() method upon unpickling. This is often needed for classes whose __new__() method requires arguments.", 
        "name": "object.__getnewargs__", 
        "params": [], 
        "path": "python/library/pickle#object.__getnewargs__", 
        "syntax": "object.__getnewargs__()", 
        "type": "Data Persistence"
    }, 
    "object.__getstate__": {
        "descr": "Classes can further influence how their instances are pickled; if the class defines the method __getstate__(), it is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary. If the __getstate__() method is absent, the instance\u2019s __dict__ is pickled as usual.", 
        "name": "object.__getstate__", 
        "params": [], 
        "path": "python/library/pickle#object.__getstate__", 
        "syntax": "object.__getstate__()", 
        "type": "Data Persistence"
    }, 
    "object.__reduce__": {
        "descr": "The interface is currently defined as follows. The __reduce__() method takes no argument and shall return either a string or preferably a tuple (the returned object is often referred to as the \u201creduce value\u201d).", 
        "name": "object.__reduce__", 
        "params": [], 
        "path": "python/library/pickle#object.__reduce__", 
        "syntax": "object.__reduce__()", 
        "type": "Data Persistence"
    }, 
    "object.__reduce_ex__": {
        "descr": "Alternatively, a __reduce_ex__() method may be defined. The only difference is this method should take a single integer argument, the protocol version. When defined, pickle will prefer it over the __reduce__() method. In addition, __reduce__() automatically becomes a synonym for the extended version. The main use for this method is to provide backwards-compatible reduce values for older Python releases.", 
        "name": "object.__reduce_ex__", 
        "params": [], 
        "path": "python/library/pickle#object.__reduce_ex__", 
        "syntax": "object.__reduce_ex__(protocol)", 
        "type": "Data Persistence"
    }, 
    "object.__setstate__": {
        "descr": "Upon unpickling, if the class defines __setstate__(), it is called with the unpickled state. In that case, there is no requirement for the state object to be a dictionary. Otherwise, the pickled state must be a dictionary and its items are assigned to the new instance\u2019s dictionary.", 
        "name": "object.__setstate__", 
        "params": [], 
        "path": "python/library/pickle#object.__setstate__", 
        "syntax": "object.__setstate__(state)", 
        "type": "Data Persistence"
    }, 
    "oct": {
        "descr": "Convert an integer number to an octal string. The result is a valid Python expression. If x is not a Python int object, it has to define an __index__() method that returns an integer.", 
        "name": "oct", 
        "params": [], 
        "path": "python/library/functions#oct", 
        "syntax": "oct(x)", 
        "type": "Built-in Functions"
    }, 
    "open": {
        "descr": "Open file and return a corresponding file object. If the file cannot be opened, an OSError is raised.", 
        "name": "open", 
        "params": [], 
        "path": "python/library/functions#open", 
        "syntax": "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)", 
        "type": "Built-in Functions"
    }, 
    "operator.__abs__": {
        "descr": "Return the absolute value of obj.", 
        "name": "operator.__abs__", 
        "params": [], 
        "path": "python/library/operator#operator.__abs__", 
        "syntax": "operator.__abs__(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.__add__": {
        "descr": "Return a + b, for a and b numbers.", 
        "name": "operator.__add__", 
        "params": [], 
        "path": "python/library/operator#operator.__add__", 
        "syntax": "operator.__add__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__and__": {
        "descr": "Return the bitwise and of a and b.", 
        "name": "operator.__and__", 
        "params": [], 
        "path": "python/library/operator#operator.__and__", 
        "syntax": "operator.__and__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__concat__": {
        "descr": "Return a + b for a and b sequences.", 
        "name": "operator.__concat__", 
        "params": [], 
        "path": "python/library/operator#operator.__concat__", 
        "syntax": "operator.__concat__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__contains__": {
        "descr": "Return the outcome of the test b in a. Note the reversed operands.", 
        "name": "operator.__contains__", 
        "params": [], 
        "path": "python/library/operator#operator.__contains__", 
        "syntax": "operator.__contains__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__delitem__": {
        "descr": "Remove the value of a at index b.", 
        "name": "operator.__delitem__", 
        "params": [], 
        "path": "python/library/operator#operator.__delitem__", 
        "syntax": "operator.__delitem__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__eq__": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.__eq__", 
        "params": [], 
        "path": "python/library/operator#operator.__eq__", 
        "syntax": "operator.__eq__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__floordiv__": {
        "descr": "Return a // b.", 
        "name": "operator.__floordiv__", 
        "params": [], 
        "path": "python/library/operator#operator.__floordiv__", 
        "syntax": "operator.__floordiv__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__ge__": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.__ge__", 
        "params": [], 
        "path": "python/library/operator#operator.__ge__", 
        "syntax": "operator.__ge__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__getitem__": {
        "descr": "Return the value of a at index b.", 
        "name": "operator.__getitem__", 
        "params": [], 
        "path": "python/library/operator#operator.__getitem__", 
        "syntax": "operator.__getitem__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__gt__": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.__gt__", 
        "params": [], 
        "path": "python/library/operator#operator.__gt__", 
        "syntax": "operator.__gt__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__iadd__": {
        "descr": "a = iadd(a, b) is equivalent to a += b.", 
        "name": "operator.__iadd__", 
        "params": [], 
        "path": "python/library/operator#operator.__iadd__", 
        "syntax": "operator.__iadd__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__iand__": {
        "descr": "a = iand(a, b) is equivalent to a &= b.", 
        "name": "operator.__iand__", 
        "params": [], 
        "path": "python/library/operator#operator.__iand__", 
        "syntax": "operator.__iand__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__iconcat__": {
        "descr": "a = iconcat(a, b) is equivalent to a += b for a and b sequences.", 
        "name": "operator.__iconcat__", 
        "params": [], 
        "path": "python/library/operator#operator.__iconcat__", 
        "syntax": "operator.__iconcat__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__ifloordiv__": {
        "descr": "a = ifloordiv(a, b) is equivalent to a //= b.", 
        "name": "operator.__ifloordiv__", 
        "params": [], 
        "path": "python/library/operator#operator.__ifloordiv__", 
        "syntax": "operator.__ifloordiv__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__ilshift__": {
        "descr": "a = ilshift(a, b) is equivalent to a <<= b.", 
        "name": "operator.__ilshift__", 
        "params": [], 
        "path": "python/library/operator#operator.__ilshift__", 
        "syntax": "operator.__ilshift__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__imod__": {
        "descr": "a = imod(a, b) is equivalent to a %= b.", 
        "name": "operator.__imod__", 
        "params": [], 
        "path": "python/library/operator#operator.__imod__", 
        "syntax": "operator.__imod__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__imul__": {
        "descr": "a = imul(a, b) is equivalent to a *= b.", 
        "name": "operator.__imul__", 
        "params": [], 
        "path": "python/library/operator#operator.__imul__", 
        "syntax": "operator.__imul__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__index__": {
        "descr": "Return a converted to an integer. Equivalent to a.__index__().", 
        "name": "operator.__index__", 
        "params": [], 
        "path": "python/library/operator#operator.__index__", 
        "syntax": "operator.__index__(a)", 
        "type": "Functional Programming"
    }, 
    "operator.__inv__": {
        "descr": "Return the bitwise inverse of the number obj. This is equivalent to ~obj.", 
        "name": "operator.__inv__", 
        "params": [], 
        "path": "python/library/operator#operator.__inv__", 
        "syntax": "operator.__inv__(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.__invert__": {
        "descr": "Return the bitwise inverse of the number obj. This is equivalent to ~obj.", 
        "name": "operator.__invert__", 
        "params": [], 
        "path": "python/library/operator#operator.__invert__", 
        "syntax": "operator.__invert__(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.__ior__": {
        "descr": "a = ior(a, b) is equivalent to a |= b.", 
        "name": "operator.__ior__", 
        "params": [], 
        "path": "python/library/operator#operator.__ior__", 
        "syntax": "operator.__ior__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__ipow__": {
        "descr": "a = ipow(a, b) is equivalent to a **= b.", 
        "name": "operator.__ipow__", 
        "params": [], 
        "path": "python/library/operator#operator.__ipow__", 
        "syntax": "operator.__ipow__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__irshift__": {
        "descr": "a = irshift(a, b) is equivalent to a >>= b.", 
        "name": "operator.__irshift__", 
        "params": [], 
        "path": "python/library/operator#operator.__irshift__", 
        "syntax": "operator.__irshift__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__isub__": {
        "descr": "a = isub(a, b) is equivalent to a -= b.", 
        "name": "operator.__isub__", 
        "params": [], 
        "path": "python/library/operator#operator.__isub__", 
        "syntax": "operator.__isub__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__itruediv__": {
        "descr": "a = itruediv(a, b) is equivalent to a /= b.", 
        "name": "operator.__itruediv__", 
        "params": [], 
        "path": "python/library/operator#operator.__itruediv__", 
        "syntax": "operator.__itruediv__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__ixor__": {
        "descr": "a = ixor(a, b) is equivalent to a ^= b.", 
        "name": "operator.__ixor__", 
        "params": [], 
        "path": "python/library/operator#operator.__ixor__", 
        "syntax": "operator.__ixor__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__le__": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.__le__", 
        "params": [], 
        "path": "python/library/operator#operator.__le__", 
        "syntax": "operator.__le__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__lshift__": {
        "descr": "Return a shifted left by b.", 
        "name": "operator.__lshift__", 
        "params": [], 
        "path": "python/library/operator#operator.__lshift__", 
        "syntax": "operator.__lshift__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__lt__": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.__lt__", 
        "params": [], 
        "path": "python/library/operator#operator.__lt__", 
        "syntax": "operator.__lt__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__mod__": {
        "descr": "Return a % b.", 
        "name": "operator.__mod__", 
        "params": [], 
        "path": "python/library/operator#operator.__mod__", 
        "syntax": "operator.__mod__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__mul__": {
        "descr": "Return a * b, for a and b numbers.", 
        "name": "operator.__mul__", 
        "params": [], 
        "path": "python/library/operator#operator.__mul__", 
        "syntax": "operator.__mul__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__ne__": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.__ne__", 
        "params": [], 
        "path": "python/library/operator#operator.__ne__", 
        "syntax": "operator.__ne__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__neg__": {
        "descr": "Return obj negated (-obj).", 
        "name": "operator.__neg__", 
        "params": [], 
        "path": "python/library/operator#operator.__neg__", 
        "syntax": "operator.__neg__(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.__not__": {
        "descr": "Return the outcome of not obj. (Note that there is no __not__() method for object instances; only the interpreter core defines this operation. The result is affected by the __bool__() and __len__() methods.)", 
        "name": "operator.__not__", 
        "params": [], 
        "path": "python/library/operator#operator.__not__", 
        "syntax": "operator.__not__(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.__or__": {
        "descr": "Return the bitwise or of a and b.", 
        "name": "operator.__or__", 
        "params": [], 
        "path": "python/library/operator#operator.__or__", 
        "syntax": "operator.__or__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__pos__": {
        "descr": "Return obj positive (+obj).", 
        "name": "operator.__pos__", 
        "params": [], 
        "path": "python/library/operator#operator.__pos__", 
        "syntax": "operator.__pos__(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.__pow__": {
        "descr": "Return a ** b, for a and b numbers.", 
        "name": "operator.__pow__", 
        "params": [], 
        "path": "python/library/operator#operator.__pow__", 
        "syntax": "operator.__pow__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__rshift__": {
        "descr": "Return a shifted right by b.", 
        "name": "operator.__rshift__", 
        "params": [], 
        "path": "python/library/operator#operator.__rshift__", 
        "syntax": "operator.__rshift__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__setitem__": {
        "descr": "Set the value of a at index b to c.", 
        "name": "operator.__setitem__", 
        "params": [], 
        "path": "python/library/operator#operator.__setitem__", 
        "syntax": "operator.__setitem__(a, b, c)", 
        "type": "Functional Programming"
    }, 
    "operator.__sub__": {
        "descr": "Return a - b.", 
        "name": "operator.__sub__", 
        "params": [], 
        "path": "python/library/operator#operator.__sub__", 
        "syntax": "operator.__sub__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__truediv__": {
        "descr": "Return a / b where 2/3 is .66 rather than 0. This is also known as \u201ctrue\u201d division.", 
        "name": "operator.__truediv__", 
        "params": [], 
        "path": "python/library/operator#operator.__truediv__", 
        "syntax": "operator.__truediv__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.__xor__": {
        "descr": "Return the bitwise exclusive or of a and b.", 
        "name": "operator.__xor__", 
        "params": [], 
        "path": "python/library/operator#operator.__xor__", 
        "syntax": "operator.__xor__(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.abs": {
        "descr": "Return the absolute value of obj.", 
        "name": "operator.abs", 
        "params": [], 
        "path": "python/library/operator#operator.abs", 
        "syntax": "operator.abs(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.add": {
        "descr": "Return a + b, for a and b numbers.", 
        "name": "operator.add", 
        "params": [], 
        "path": "python/library/operator#operator.add", 
        "syntax": "operator.add(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.and_": {
        "descr": "Return the bitwise and of a and b.", 
        "name": "operator.and_", 
        "params": [], 
        "path": "python/library/operator#operator.and_", 
        "syntax": "operator.and_(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.attrgetter": {
        "descr": "Return a callable object that fetches attr from its operand. If more than one attribute is requested, returns a tuple of attributes. The attribute names can also contain dots. For example:", 
        "name": "operator.attrgetter", 
        "params": [], 
        "path": "python/library/operator#operator.attrgetter", 
        "syntax": "operator.attrgetter(attr)", 
        "type": "Functional Programming"
    }, 
    "operator.concat": {
        "descr": "Return a + b for a and b sequences.", 
        "name": "operator.concat", 
        "params": [], 
        "path": "python/library/operator#operator.concat", 
        "syntax": "operator.concat(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.contains": {
        "descr": "Return the outcome of the test b in a. Note the reversed operands.", 
        "name": "operator.contains", 
        "params": [], 
        "path": "python/library/operator#operator.contains", 
        "syntax": "operator.contains(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.countOf": {
        "descr": "Return the number of occurrences of b in a.", 
        "name": "operator.countOf", 
        "params": [], 
        "path": "python/library/operator#operator.countOf", 
        "syntax": "operator.countOf(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.delitem": {
        "descr": "Remove the value of a at index b.", 
        "name": "operator.delitem", 
        "params": [], 
        "path": "python/library/operator#operator.delitem", 
        "syntax": "operator.delitem(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.eq": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.eq", 
        "params": [], 
        "path": "python/library/operator#operator.eq", 
        "syntax": "operator.eq(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.floordiv": {
        "descr": "Return a // b.", 
        "name": "operator.floordiv", 
        "params": [], 
        "path": "python/library/operator#operator.floordiv", 
        "syntax": "operator.floordiv(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.ge": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.ge", 
        "params": [], 
        "path": "python/library/operator#operator.ge", 
        "syntax": "operator.ge(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.getitem": {
        "descr": "Return the value of a at index b.", 
        "name": "operator.getitem", 
        "params": [], 
        "path": "python/library/operator#operator.getitem", 
        "syntax": "operator.getitem(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.gt": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.gt", 
        "params": [], 
        "path": "python/library/operator#operator.gt", 
        "syntax": "operator.gt(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.iadd": {
        "descr": "a = iadd(a, b) is equivalent to a += b.", 
        "name": "operator.iadd", 
        "params": [], 
        "path": "python/library/operator#operator.iadd", 
        "syntax": "operator.iadd(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.iand": {
        "descr": "a = iand(a, b) is equivalent to a &= b.", 
        "name": "operator.iand", 
        "params": [], 
        "path": "python/library/operator#operator.iand", 
        "syntax": "operator.iand(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.iconcat": {
        "descr": "a = iconcat(a, b) is equivalent to a += b for a and b sequences.", 
        "name": "operator.iconcat", 
        "params": [], 
        "path": "python/library/operator#operator.iconcat", 
        "syntax": "operator.iconcat(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.ifloordiv": {
        "descr": "a = ifloordiv(a, b) is equivalent to a //= b.", 
        "name": "operator.ifloordiv", 
        "params": [], 
        "path": "python/library/operator#operator.ifloordiv", 
        "syntax": "operator.ifloordiv(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.ilshift": {
        "descr": "a = ilshift(a, b) is equivalent to a <<= b.", 
        "name": "operator.ilshift", 
        "params": [], 
        "path": "python/library/operator#operator.ilshift", 
        "syntax": "operator.ilshift(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.imod": {
        "descr": "a = imod(a, b) is equivalent to a %= b.", 
        "name": "operator.imod", 
        "params": [], 
        "path": "python/library/operator#operator.imod", 
        "syntax": "operator.imod(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.imul": {
        "descr": "a = imul(a, b) is equivalent to a *= b.", 
        "name": "operator.imul", 
        "params": [], 
        "path": "python/library/operator#operator.imul", 
        "syntax": "operator.imul(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.index": {
        "descr": "Return a converted to an integer. Equivalent to a.__index__().", 
        "name": "operator.index", 
        "params": [], 
        "path": "python/library/operator#operator.index", 
        "syntax": "operator.index(a)", 
        "type": "Functional Programming"
    }, 
    "operator.indexOf": {
        "descr": "Return the index of the first of occurrence of b in a.", 
        "name": "operator.indexOf", 
        "params": [], 
        "path": "python/library/operator#operator.indexOf", 
        "syntax": "operator.indexOf(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.inv": {
        "descr": "Return the bitwise inverse of the number obj. This is equivalent to ~obj.", 
        "name": "operator.inv", 
        "params": [], 
        "path": "python/library/operator#operator.inv", 
        "syntax": "operator.inv(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.invert": {
        "descr": "Return the bitwise inverse of the number obj. This is equivalent to ~obj.", 
        "name": "operator.invert", 
        "params": [], 
        "path": "python/library/operator#operator.invert", 
        "syntax": "operator.invert(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.ior": {
        "descr": "a = ior(a, b) is equivalent to a |= b.", 
        "name": "operator.ior", 
        "params": [], 
        "path": "python/library/operator#operator.ior", 
        "syntax": "operator.ior(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.ipow": {
        "descr": "a = ipow(a, b) is equivalent to a **= b.", 
        "name": "operator.ipow", 
        "params": [], 
        "path": "python/library/operator#operator.ipow", 
        "syntax": "operator.ipow(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.irshift": {
        "descr": "a = irshift(a, b) is equivalent to a >>= b.", 
        "name": "operator.irshift", 
        "params": [], 
        "path": "python/library/operator#operator.irshift", 
        "syntax": "operator.irshift(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.is_": {
        "descr": "Return a is b. Tests object identity.", 
        "name": "operator.is_", 
        "params": [], 
        "path": "python/library/operator#operator.is_", 
        "syntax": "operator.is_(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.is_not": {
        "descr": "Return a is not b. Tests object identity.", 
        "name": "operator.is_not", 
        "params": [], 
        "path": "python/library/operator#operator.is_not", 
        "syntax": "operator.is_not(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.isub": {
        "descr": "a = isub(a, b) is equivalent to a -= b.", 
        "name": "operator.isub", 
        "params": [], 
        "path": "python/library/operator#operator.isub", 
        "syntax": "operator.isub(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.itemgetter": {
        "descr": "Return a callable object that fetches item from its operand using the operand\u2019s __getitem__() method. If multiple items are specified, returns a tuple of lookup values. For example:", 
        "name": "operator.itemgetter", 
        "params": [], 
        "path": "python/library/operator#operator.itemgetter", 
        "syntax": "operator.itemgetter(item)", 
        "type": "Functional Programming"
    }, 
    "operator.itruediv": {
        "descr": "a = itruediv(a, b) is equivalent to a /= b.", 
        "name": "operator.itruediv", 
        "params": [], 
        "path": "python/library/operator#operator.itruediv", 
        "syntax": "operator.itruediv(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.ixor": {
        "descr": "a = ixor(a, b) is equivalent to a ^= b.", 
        "name": "operator.ixor", 
        "params": [], 
        "path": "python/library/operator#operator.ixor", 
        "syntax": "operator.ixor(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.le": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.le", 
        "params": [], 
        "path": "python/library/operator#operator.le", 
        "syntax": "operator.le(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.lshift": {
        "descr": "Return a shifted left by b.", 
        "name": "operator.lshift", 
        "params": [], 
        "path": "python/library/operator#operator.lshift", 
        "syntax": "operator.lshift(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.lt": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.lt", 
        "params": [], 
        "path": "python/library/operator#operator.lt", 
        "syntax": "operator.lt(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.methodcaller": {
        "descr": "Return a callable object that calls the method name on its operand. If additional arguments and/or keyword arguments are given, they will be given to the method as well. For example:", 
        "name": "operator.methodcaller", 
        "params": [], 
        "path": "python/library/operator#operator.methodcaller", 
        "syntax": "operator.methodcaller(name[, args...])", 
        "type": "Functional Programming"
    }, 
    "operator.mod": {
        "descr": "Return a % b.", 
        "name": "operator.mod", 
        "params": [], 
        "path": "python/library/operator#operator.mod", 
        "syntax": "operator.mod(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.mul": {
        "descr": "Return a * b, for a and b numbers.", 
        "name": "operator.mul", 
        "params": [], 
        "path": "python/library/operator#operator.mul", 
        "syntax": "operator.mul(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.ne": {
        "descr": "Perform \u201crich comparisons\u201d between a and b. Specifically, lt(a, b) is equivalent to a < b, le(a, b) is equivalent to a <= b, eq(a, b) is equivalent to a == b, ne(a, b) is equivalent to a != b, gt(a, b) is equivalent to a > b and ge(a, b) is equivalent to a >= b. Note that these functions can return any value, which may or may not be interpretable as a Boolean value. See Comparisons for more information about rich comparisons.", 
        "name": "operator.ne", 
        "params": [], 
        "path": "python/library/operator#operator.ne", 
        "syntax": "operator.ne(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.neg": {
        "descr": "Return obj negated (-obj).", 
        "name": "operator.neg", 
        "params": [], 
        "path": "python/library/operator#operator.neg", 
        "syntax": "operator.neg(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.not_": {
        "descr": "Return the outcome of not obj. (Note that there is no __not__() method for object instances; only the interpreter core defines this operation. The result is affected by the __bool__() and __len__() methods.)", 
        "name": "operator.not_", 
        "params": [], 
        "path": "python/library/operator#operator.not_", 
        "syntax": "operator.not_(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.or_": {
        "descr": "Return the bitwise or of a and b.", 
        "name": "operator.or_", 
        "params": [], 
        "path": "python/library/operator#operator.or_", 
        "syntax": "operator.or_(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.pos": {
        "descr": "Return obj positive (+obj).", 
        "name": "operator.pos", 
        "params": [], 
        "path": "python/library/operator#operator.pos", 
        "syntax": "operator.pos(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.pow": {
        "descr": "Return a ** b, for a and b numbers.", 
        "name": "operator.pow", 
        "params": [], 
        "path": "python/library/operator#operator.pow", 
        "syntax": "operator.pow(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.rshift": {
        "descr": "Return a shifted right by b.", 
        "name": "operator.rshift", 
        "params": [], 
        "path": "python/library/operator#operator.rshift", 
        "syntax": "operator.rshift(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.setitem": {
        "descr": "Set the value of a at index b to c.", 
        "name": "operator.setitem", 
        "params": [], 
        "path": "python/library/operator#operator.setitem", 
        "syntax": "operator.setitem(a, b, c)", 
        "type": "Functional Programming"
    }, 
    "operator.sub": {
        "descr": "Return a - b.", 
        "name": "operator.sub", 
        "params": [], 
        "path": "python/library/operator#operator.sub", 
        "syntax": "operator.sub(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.truediv": {
        "descr": "Return a / b where 2/3 is .66 rather than 0. This is also known as \u201ctrue\u201d division.", 
        "name": "operator.truediv", 
        "params": [], 
        "path": "python/library/operator#operator.truediv", 
        "syntax": "operator.truediv(a, b)", 
        "type": "Functional Programming"
    }, 
    "operator.truth": {
        "descr": "Return True if obj is true, and False otherwise. This is equivalent to using the bool constructor.", 
        "name": "operator.truth", 
        "params": [], 
        "path": "python/library/operator#operator.truth", 
        "syntax": "operator.truth(obj)", 
        "type": "Functional Programming"
    }, 
    "operator.xor": {
        "descr": "Return the bitwise exclusive or of a and b.", 
        "name": "operator.xor", 
        "params": [], 
        "path": "python/library/operator#operator.xor", 
        "syntax": "operator.xor(a, b)", 
        "type": "Functional Programming"
    }, 
    "optparse.Option.ACTIONS": {
        "descr": "All actions must be listed in ACTIONS.", 
        "name": "optparse.Option.ACTIONS", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.ACTIONS", 
        "syntax": "Option.ACTIONS", 
        "type": "Operating System"
    }, 
    "optparse.Option.ALWAYS_TYPED_ACTIONS": {
        "descr": "Actions that always take a type (i.e. whose options always take a value) are additionally listed here. The only effect of this is that optparse assigns the default type, \"string\", to options with no explicit type whose action is listed in ALWAYS_TYPED_ACTIONS.", 
        "name": "optparse.Option.ALWAYS_TYPED_ACTIONS", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.ALWAYS_TYPED_ACTIONS", 
        "syntax": "Option.ALWAYS_TYPED_ACTIONS", 
        "type": "Operating System"
    }, 
    "optparse.Option.STORE_ACTIONS": {
        "descr": "\u201cstore\u201d actions are additionally listed here.", 
        "name": "optparse.Option.STORE_ACTIONS", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.STORE_ACTIONS", 
        "syntax": "Option.STORE_ACTIONS", 
        "type": "Operating System"
    }, 
    "optparse.Option.TYPED_ACTIONS": {
        "descr": "\u201ctyped\u201d actions are additionally listed here.", 
        "name": "optparse.Option.TYPED_ACTIONS", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.TYPED_ACTIONS", 
        "syntax": "Option.TYPED_ACTIONS", 
        "type": "Operating System"
    }, 
    "optparse.Option.TYPES": {
        "descr": "A tuple of type names; in your subclass, simply define a new tuple TYPES that builds on the standard one.", 
        "name": "optparse.Option.TYPES", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.TYPES", 
        "syntax": "Option.TYPES", 
        "type": "Operating System"
    }, 
    "optparse.Option.TYPE_CHECKER": {
        "descr": "A dictionary mapping type names to type-checking functions. A type-checking function has the following signature:", 
        "name": "optparse.Option.TYPE_CHECKER", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.TYPE_CHECKER", 
        "syntax": "Option.TYPE_CHECKER", 
        "type": "Operating System"
    }, 
    "optparse.Option.action": {
        "descr": "(default: \"store\")", 
        "name": "optparse.Option.action", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.action", 
        "syntax": "Option.action", 
        "type": "Operating System"
    }, 
    "optparse.Option.callback": {
        "descr": "For options with action \"callback\", the callable to call when this option is seen. See section Option Callbacks for detail on the arguments passed to the callable.", 
        "name": "optparse.Option.callback", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.callback", 
        "syntax": "Option.callback", 
        "type": "Operating System"
    }, 
    "optparse.Option.callback_args": {
        "descr": "Additional positional and keyword arguments to pass to callback after the four standard callback arguments.", 
        "name": "optparse.Option.callback_args", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.callback_args", 
        "syntax": "Option.callback_args", 
        "type": "Operating System"
    }, 
    "optparse.Option.callback_kwargs": {
        "descr": "Additional positional and keyword arguments to pass to callback after the four standard callback arguments.", 
        "name": "optparse.Option.callback_kwargs", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.callback_kwargs", 
        "syntax": "Option.callback_kwargs", 
        "type": "Operating System"
    }, 
    "optparse.Option.choices": {
        "descr": "For options of type \"choice\", the list of strings the user may choose from.", 
        "name": "optparse.Option.choices", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.choices", 
        "syntax": "Option.choices", 
        "type": "Operating System"
    }, 
    "optparse.Option.const": {
        "descr": "For actions that store a constant value, the constant value to store.", 
        "name": "optparse.Option.const", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.const", 
        "syntax": "Option.const", 
        "type": "Operating System"
    }, 
    "optparse.Option.default": {
        "descr": "The value to use for this option\u2019s destination if the option is not seen on the command line. See also OptionParser.set_defaults().", 
        "name": "optparse.Option.default", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.default", 
        "syntax": "Option.default", 
        "type": "Operating System"
    }, 
    "optparse.Option.dest": {
        "descr": "(default: derived from option strings)", 
        "name": "optparse.Option.dest", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.dest", 
        "syntax": "Option.dest", 
        "type": "Operating System"
    }, 
    "optparse.Option.help": {
        "descr": "Help text to print for this option when listing all available options after the user supplies a help option (such as --help). If no help text is supplied, the option will be listed without help text. To hide this option, use the special value optparse.SUPPRESS_HELP.", 
        "name": "optparse.Option.help", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.help", 
        "syntax": "Option.help", 
        "type": "Operating System"
    }, 
    "optparse.Option.metavar": {
        "descr": "(default: derived from option strings)", 
        "name": "optparse.Option.metavar", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.metavar", 
        "syntax": "Option.metavar", 
        "type": "Operating System"
    }, 
    "optparse.Option.nargs": {
        "descr": "(default: 1)", 
        "name": "optparse.Option.nargs", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.nargs", 
        "syntax": "Option.nargs", 
        "type": "Operating System"
    }, 
    "optparse.Option.type": {
        "descr": "(default: \"string\")", 
        "name": "optparse.Option.type", 
        "params": [], 
        "path": "python/library/optparse#optparse.Option.type", 
        "syntax": "Option.type", 
        "type": "Operating System"
    }, 
    "optparse.OptionGroup": {
        "descr": "where", 
        "name": "optparse.OptionGroup", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionGroup", 
        "syntax": "class optparse.OptionGroup(parser, title, description=None)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser": {
        "descr": "The OptionParser constructor has no required arguments, but a number of optional keyword arguments. You should always pass them as keyword arguments, i.e. do not rely on the order in which the arguments are declared.", 
        "name": "optparse.OptionParser", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser", 
        "syntax": "class optparse.OptionParser(...)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.add_option": {
        "descr": "To define an option with only a short option string:", 
        "name": "optparse.OptionParser.add_option", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.add_option", 
        "syntax": "OptionParser.add_option(option)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.disable_interspersed_args": {
        "descr": "Set parsing to stop on the first non-option. For example, if -a and -b are both simple options that take no arguments, optparse normally accepts this syntax:", 
        "name": "optparse.OptionParser.disable_interspersed_args", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.disable_interspersed_args", 
        "syntax": "OptionParser.disable_interspersed_args()", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.enable_interspersed_args": {
        "descr": "Set parsing to not stop on the first non-option, allowing interspersing switches with command arguments. This is the default behavior.", 
        "name": "optparse.OptionParser.enable_interspersed_args", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.enable_interspersed_args", 
        "syntax": "OptionParser.enable_interspersed_args()", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.get_option": {
        "descr": "Returns the Option instance with the option string opt_str, or None if no options have that option string.", 
        "name": "optparse.OptionParser.get_option", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.get_option", 
        "syntax": "OptionParser.get_option(opt_str)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.get_option_group": {
        "descr": "Return the OptionGroup to which the short or long option string opt_str (e.g. '-o' or '--option') belongs. If there\u2019s no such OptionGroup, return None.", 
        "name": "optparse.OptionParser.get_option_group", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.get_option_group", 
        "syntax": "OptionParser.get_option_group(opt_str)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.get_usage": {
        "descr": "Same as print_usage() but returns the usage string instead of printing it.", 
        "name": "optparse.OptionParser.get_usage", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.get_usage", 
        "syntax": "OptionParser.get_usage()", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.get_version": {
        "descr": "Same as print_version() but returns the version string instead of printing it.", 
        "name": "optparse.OptionParser.get_version", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.get_version", 
        "syntax": "OptionParser.get_version()", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.has_option": {
        "descr": "Return true if the OptionParser has an option with option string opt_str (e.g., -q or --verbose).", 
        "name": "optparse.OptionParser.has_option", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.has_option", 
        "syntax": "OptionParser.has_option(opt_str)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.print_usage": {
        "descr": "Print the usage message for the current program (self.usage) to file (default stdout). Any occurrence of the string %prog in self.usage is replaced with the name of the current program. Does nothing if self.usage is empty or not defined.", 
        "name": "optparse.OptionParser.print_usage", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.print_usage", 
        "syntax": "OptionParser.print_usage(file=None)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.print_version": {
        "descr": "Print the version message for the current program (self.version) to file (default stdout). As with print_usage(), any occurrence of %prog in self.version is replaced with the name of the current program. Does nothing if self.version is empty or undefined.", 
        "name": "optparse.OptionParser.print_version", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.print_version", 
        "syntax": "OptionParser.print_version(file=None)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.remove_option": {
        "descr": "If the OptionParser has an option corresponding to opt_str, that option is removed. If that option provided any other option strings, all of those option strings become invalid. If opt_str does not occur in any option belonging to this OptionParser, raises ValueError.", 
        "name": "optparse.OptionParser.remove_option", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.remove_option", 
        "syntax": "OptionParser.remove_option(opt_str)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.set_defaults": {
        "descr": "Set default values for several option destinations at once. Using set_defaults() is the preferred way to set default values for options, since multiple options can share the same destination. For example, if several \u201cmode\u201d options all set the same destination, any one of them can set the default, and the last one wins:", 
        "name": "optparse.OptionParser.set_defaults", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.set_defaults", 
        "syntax": "OptionParser.set_defaults(dest=value, ...)", 
        "type": "Operating System"
    }, 
    "optparse.OptionParser.set_usage": {
        "descr": "Set the usage string according to the rules described above for the usage constructor keyword argument. Passing None sets the default usage string; use optparse.SUPPRESS_USAGE to suppress a usage message.", 
        "name": "optparse.OptionParser.set_usage", 
        "params": [], 
        "path": "python/library/optparse#optparse.OptionParser.set_usage", 
        "syntax": "OptionParser.set_usage(usage)", 
        "type": "Operating System"
    }, 
    "ord": {
        "descr": "Given a string representing one Unicode character, return an integer representing the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('\\u2020') returns 8224. This is the inverse of chr().", 
        "name": "ord", 
        "params": [], 
        "path": "python/library/functions#ord", 
        "syntax": "ord(c)", 
        "type": "Built-in Functions"
    }, 
    "os.WCOREDUMP": {
        "descr": "Return True if a core dump was generated for the process, otherwise return False.", 
        "name": "os.WCOREDUMP", 
        "params": [], 
        "path": "python/library/os#os.WCOREDUMP", 
        "syntax": "os.WCOREDUMP(status)", 
        "type": "Operating System"
    }, 
    "os.WEXITSTATUS": {
        "descr": "If WIFEXITED(status) is true, return the integer parameter to the exit(2) system call. Otherwise, the return value is meaningless.", 
        "name": "os.WEXITSTATUS", 
        "params": [], 
        "path": "python/library/os#os.WEXITSTATUS", 
        "syntax": "os.WEXITSTATUS(status)", 
        "type": "Operating System"
    }, 
    "os.WIFCONTINUED": {
        "descr": "Return True if the process has been continued from a job control stop, otherwise return False.", 
        "name": "os.WIFCONTINUED", 
        "params": [], 
        "path": "python/library/os#os.WIFCONTINUED", 
        "syntax": "os.WIFCONTINUED(status)", 
        "type": "Operating System"
    }, 
    "os.WIFEXITED": {
        "descr": "Return True if the process exited using the exit(2) system call, otherwise return False.", 
        "name": "os.WIFEXITED", 
        "params": [], 
        "path": "python/library/os#os.WIFEXITED", 
        "syntax": "os.WIFEXITED(status)", 
        "type": "Operating System"
    }, 
    "os.WIFSIGNALED": {
        "descr": "Return True if the process exited due to a signal, otherwise return False.", 
        "name": "os.WIFSIGNALED", 
        "params": [], 
        "path": "python/library/os#os.WIFSIGNALED", 
        "syntax": "os.WIFSIGNALED(status)", 
        "type": "Operating System"
    }, 
    "os.WIFSTOPPED": {
        "descr": "Return True if the process has been stopped, otherwise return False.", 
        "name": "os.WIFSTOPPED", 
        "params": [], 
        "path": "python/library/os#os.WIFSTOPPED", 
        "syntax": "os.WIFSTOPPED(status)", 
        "type": "Operating System"
    }, 
    "os.WSTOPSIG": {
        "descr": "Return the signal which caused the process to stop.", 
        "name": "os.WSTOPSIG", 
        "params": [], 
        "path": "python/library/os#os.WSTOPSIG", 
        "syntax": "os.WSTOPSIG(status)", 
        "type": "Operating System"
    }, 
    "os.WTERMSIG": {
        "descr": "Return the signal which caused the process to exit.", 
        "name": "os.WTERMSIG", 
        "params": [], 
        "path": "python/library/os#os.WTERMSIG", 
        "syntax": "os.WTERMSIG(status)", 
        "type": "Operating System"
    }, 
    "os._exit": {
        "descr": "Exit the process with status n, without calling cleanup handlers, flushing stdio buffers, etc.", 
        "name": "os._exit", 
        "params": [], 
        "path": "python/library/os#os._exit", 
        "syntax": "os._exit(n)", 
        "type": "Operating System"
    }, 
    "os.abort": {
        "descr": "Generate a SIGABRT signal to the current process. On Unix, the default behavior is to produce a core dump; on Windows, the process immediately returns an exit code of 3. Be aware that calling this function will not call the Python signal handler registered for SIGABRT with signal.signal().", 
        "name": "os.abort", 
        "params": [], 
        "path": "python/library/os#os.abort", 
        "syntax": "os.abort()", 
        "type": "Operating System"
    }, 
    "os.access": {
        "descr": "Use the real uid/gid to test for access to path. Note that most operations will use the effective uid/gid, therefore this routine can be used in a suid/sgid environment to test if the invoking user has the specified access to path. mode should be F_OK to test the existence of path, or it can be the inclusive OR of one or more of R_OK, W_OK, and X_OK to test permissions. Return True if access is allowed, False if not. See the Unix man page access(2) for more information.", 
        "name": "os.access", 
        "params": [], 
        "path": "python/library/os#os.access", 
        "syntax": "os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.altsep": {
        "descr": "An alternative character used by the operating system to separate pathname components, or None if only one separator character exists. This is set to '/' on Windows systems where sep is a backslash. Also available via os.path.", 
        "name": "os.altsep", 
        "params": [], 
        "path": "python/library/os#os.altsep", 
        "syntax": "os.altsep", 
        "type": "Operating System"
    }, 
    "os.chdir": {
        "descr": "This function can support specifying a file descriptor. The descriptor must refer to an opened directory, not an open file.", 
        "name": "os.chdir", 
        "params": [], 
        "path": "python/library/os#os.chdir", 
        "syntax": "os.chdir(path)", 
        "type": "Operating System"
    }, 
    "os.chflags": {
        "descr": "Set the flags of path to the numeric flags. flags may take a combination (bitwise OR) of the following values (as defined in the stat module):", 
        "name": "os.chflags", 
        "params": [], 
        "path": "python/library/os#os.chflags", 
        "syntax": "os.chflags(path, flags, *, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.chmod": {
        "descr": "Change the mode of path to the numeric mode. mode may take one of the following values (as defined in the stat module) or bitwise ORed combinations of them:", 
        "name": "os.chmod", 
        "params": [], 
        "path": "python/library/os#os.chmod", 
        "syntax": "os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.chown": {
        "descr": "Change the owner and group id of path to the numeric uid and gid. To leave one of the ids unchanged, set it to -1.", 
        "name": "os.chown", 
        "params": [], 
        "path": "python/library/os#os.chown", 
        "syntax": "os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.chroot": {
        "descr": "Change the root directory of the current process to path.", 
        "name": "os.chroot", 
        "params": [], 
        "path": "python/library/os#os.chroot", 
        "syntax": "os.chroot(path)", 
        "type": "Operating System"
    }, 
    "os.close": {
        "descr": "Close file descriptor fd.", 
        "name": "os.close", 
        "params": [], 
        "path": "python/library/os#os.close", 
        "syntax": "os.close(fd)", 
        "type": "Operating System"
    }, 
    "os.closerange": {
        "descr": "Close all file descriptors from fd_low (inclusive) to fd_high (exclusive), ignoring errors. Equivalent to (but much faster than):", 
        "name": "os.closerange", 
        "params": [], 
        "path": "python/library/os#os.closerange", 
        "syntax": "os.closerange(fd_low, fd_high)", 
        "type": "Operating System"
    }, 
    "os.confstr": {
        "descr": "Return string-valued system configuration values. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given as the keys of the confstr_names dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted.", 
        "name": "os.confstr", 
        "params": [], 
        "path": "python/library/os#os.confstr", 
        "syntax": "os.confstr(name)", 
        "type": "Operating System"
    }, 
    "os.confstr_names": {
        "descr": "Dictionary mapping names accepted by confstr() to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system.", 
        "name": "os.confstr_names", 
        "params": [], 
        "path": "python/library/os#os.confstr_names", 
        "syntax": "os.confstr_names", 
        "type": "Operating System"
    }, 
    "os.ctermid": {
        "descr": "Return the filename corresponding to the controlling terminal of the process.", 
        "name": "os.ctermid", 
        "params": [], 
        "path": "python/library/os#os.ctermid", 
        "syntax": "os.ctermid()", 
        "type": "Operating System"
    }, 
    "os.curdir": {
        "descr": "The constant string used by the operating system to refer to the current directory. This is '.' for Windows and POSIX. Also available via os.path.", 
        "name": "os.curdir", 
        "params": [], 
        "path": "python/library/os#os.curdir", 
        "syntax": "os.curdir", 
        "type": "Operating System"
    }, 
    "os.defpath": {
        "descr": "The default search path used by exec*p* and spawn*p* if the environment doesn\u2019t have a 'PATH' key. Also available via os.path.", 
        "name": "os.defpath", 
        "params": [], 
        "path": "python/library/os#os.defpath", 
        "syntax": "os.defpath", 
        "type": "Operating System"
    }, 
    "os.device_encoding": {
        "descr": "Return a string describing the encoding of the device associated with fd if it is connected to a terminal; else return None.", 
        "name": "os.device_encoding", 
        "params": [], 
        "path": "python/library/os#os.device_encoding", 
        "syntax": "os.device_encoding(fd)", 
        "type": "Operating System"
    }, 
    "os.devnull": {
        "descr": "The file path of the null device. For example: '/dev/null' for POSIX, 'nul' for Windows. Also available via os.path.", 
        "name": "os.devnull", 
        "params": [], 
        "path": "python/library/os#os.devnull", 
        "syntax": "os.devnull", 
        "type": "Operating System"
    }, 
    "os.dup": {
        "descr": "Duplicate file descriptor fd to fd2, closing the latter first if necessary.", 
        "name": "os.dup", 
        "params": [], 
        "path": "python/library/os#os.dup", 
        "syntax": "os.dup2(fd, fd2)", 
        "type": "Operating System"
    }, 
    "os.dup2": {
        "descr": "Duplicate file descriptor fd to fd2, closing the latter first if necessary.", 
        "name": "os.dup2", 
        "params": [], 
        "path": "python/library/os#os.dup2", 
        "syntax": "os.dup2(fd, fd2)", 
        "type": "Operating System"
    }, 
    "os.environ": {
        "descr": "A mapping object representing the string environment. For example, environ['HOME'] is the pathname of your home directory (on some platforms), and is equivalent to getenv(\"HOME\") in C.", 
        "name": "os.environ", 
        "params": [], 
        "path": "python/library/os#os.environ", 
        "syntax": "os.environ", 
        "type": "Operating System"
    }, 
    "os.environb": {
        "descr": "Bytes version of environ: a mapping object representing the environment as byte strings. environ and environb are synchronized (modify environb updates environ, and vice versa).", 
        "name": "os.environb", 
        "params": [], 
        "path": "python/library/os#os.environb", 
        "syntax": "os.environb", 
        "type": "Operating System"
    }, 
    "os.error": {
        "descr": "An alias for the built-in OSError exception.", 
        "name": "os.error", 
        "params": [], 
        "path": "python/library/os#os.error", 
        "syntax": "exception os.error", 
        "type": "Operating System"
    }, 
    "os.execl": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execl", 
        "params": [], 
        "path": "python/library/os#os.execl", 
        "syntax": "os.execl(path, arg0, arg1, ...)", 
        "type": "Operating System"
    }, 
    "os.execle": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execle", 
        "params": [], 
        "path": "python/library/os#os.execle", 
        "syntax": "os.execle(path, arg0, arg1, ..., env)", 
        "type": "Operating System"
    }, 
    "os.execlp": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execlp", 
        "params": [], 
        "path": "python/library/os#os.execlp", 
        "syntax": "os.execlp(file, arg0, arg1, ...)", 
        "type": "Operating System"
    }, 
    "os.execlpe": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execlpe", 
        "params": [], 
        "path": "python/library/os#os.execlpe", 
        "syntax": "os.execlpe(file, arg0, arg1, ..., env)", 
        "type": "Operating System"
    }, 
    "os.execv": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execv", 
        "params": [], 
        "path": "python/library/os#os.execv", 
        "syntax": "os.execv(path, args)", 
        "type": "Operating System"
    }, 
    "os.execve": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execve", 
        "params": [], 
        "path": "python/library/os#os.execve", 
        "syntax": "os.execve(path, args, env)", 
        "type": "Operating System"
    }, 
    "os.execvp": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execvp", 
        "params": [], 
        "path": "python/library/os#os.execvp", 
        "syntax": "os.execvp(file, args)", 
        "type": "Operating System"
    }, 
    "os.execvpe": {
        "descr": "These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.", 
        "name": "os.execvpe", 
        "params": [], 
        "path": "python/library/os#os.execvpe", 
        "syntax": "os.execvpe(file, args, env)", 
        "type": "Operating System"
    }, 
    "os.extsep": {
        "descr": "The character which separates the base filename from the extension; for example, the '.' in os.py. Also available via os.path.", 
        "name": "os.extsep", 
        "params": [], 
        "path": "python/library/os#os.extsep", 
        "syntax": "os.extsep", 
        "type": "Operating System"
    }, 
    "os.fchdir": {
        "descr": "Change the current working directory to the directory represented by the file descriptor fd. The descriptor must refer to an opened directory, not an open file. As of Python 3.3, this is equivalent to os.chdir(fd).", 
        "name": "os.fchdir", 
        "params": [], 
        "path": "python/library/os#os.fchdir", 
        "syntax": "os.fchdir(fd)", 
        "type": "Operating System"
    }, 
    "os.fchmod": {
        "descr": "Change the mode of the file given by fd to the numeric mode. See the docs for chmod() for possible values of mode. As of Python 3.3, this is equivalent to os.chmod(fd, mode).", 
        "name": "os.fchmod", 
        "params": [], 
        "path": "python/library/os#os.fchmod", 
        "syntax": "os.fchmod(fd, mode)", 
        "type": "Operating System"
    }, 
    "os.fchown": {
        "descr": "Change the owner and group id of the file given by fd to the numeric uid and gid. To leave one of the ids unchanged, set it to -1. See chown(). As of Python 3.3, this is equivalent to os.chown(fd, uid, gid).", 
        "name": "os.fchown", 
        "params": [], 
        "path": "python/library/os#os.fchown", 
        "syntax": "os.fchown(fd, uid, gid)", 
        "type": "Operating System"
    }, 
    "os.fdatasync": {
        "descr": "Force write of file with filedescriptor fd to disk. Does not force update of metadata.", 
        "name": "os.fdatasync", 
        "params": [], 
        "path": "python/library/os#os.fdatasync", 
        "syntax": "os.fdatasync(fd)", 
        "type": "Operating System"
    }, 
    "os.fdopen": {
        "descr": "Return an open file object connected to the file descriptor fd. This is an alias of the open() built-in function and accepts the same arguments. The only difference is that the first argument of fdopen() must always be an integer.", 
        "name": "os.fdopen", 
        "params": [], 
        "path": "python/library/os#os.fdopen", 
        "syntax": "os.fdopen(fd, *args, **kwargs)", 
        "type": "Operating System"
    }, 
    "os.fork": {
        "descr": "Fork a child process. Return 0 in the child and the child\u2019s process id in the parent. If an error occurs OSError is raised.", 
        "name": "os.fork", 
        "params": [], 
        "path": "python/library/os#os.fork", 
        "syntax": "os.fork()", 
        "type": "Operating System"
    }, 
    "os.forkpty": {
        "descr": "Fork a child process, using a new pseudo-terminal as the child\u2019s controlling terminal. Return a pair of (pid, fd), where pid is 0 in the child, the new child\u2019s process id in the parent, and fd is the file descriptor of the master end of the pseudo-terminal. For a more portable approach, use the pty module. If an error occurs OSError is raised.", 
        "name": "os.forkpty", 
        "params": [], 
        "path": "python/library/os#os.forkpty", 
        "syntax": "os.forkpty()", 
        "type": "Operating System"
    }, 
    "os.fpathconf": {
        "descr": "Return system configuration information relevant to an open file. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given in the pathconf_names dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted.", 
        "name": "os.fpathconf", 
        "params": [], 
        "path": "python/library/os#os.fpathconf", 
        "syntax": "os.fpathconf(fd, name)", 
        "type": "Operating System"
    }, 
    "os.fsdecode": {
        "descr": "Decode filename from the filesystem encoding with 'surrogateescape' error handler, or 'strict' on Windows; return str unchanged.", 
        "name": "os.fsdecode", 
        "params": [], 
        "path": "python/library/os#os.fsdecode", 
        "syntax": "os.fsdecode(filename)", 
        "type": "Operating System"
    }, 
    "os.fsencode": {
        "descr": "Encode filename to the filesystem encoding with 'surrogateescape' error handler, or 'strict' on Windows; return bytes unchanged.", 
        "name": "os.fsencode", 
        "params": [], 
        "path": "python/library/os#os.fsencode", 
        "syntax": "os.fsencode(filename)", 
        "type": "Operating System"
    }, 
    "os.fstat": {
        "descr": "Return status for file descriptor fd, like stat(). As of Python 3.3, this is equivalent to os.stat(fd).", 
        "name": "os.fstat", 
        "params": [], 
        "path": "python/library/os#os.fstat", 
        "syntax": "os.fstat(fd)", 
        "type": "Operating System"
    }, 
    "os.fstatvfs": {
        "descr": "Return information about the filesystem containing the file associated with file descriptor fd, like statvfs(). As of Python 3.3, this is equivalent to os.statvfs(fd).", 
        "name": "os.fstatvfs", 
        "params": [], 
        "path": "python/library/os#os.fstatvfs", 
        "syntax": "os.fstatvfs(fd)", 
        "type": "Operating System"
    }, 
    "os.fsync": {
        "descr": "Force write of file with filedescriptor fd to disk. On Unix, this calls the native fsync() function; on Windows, the MS _commit() function.", 
        "name": "os.fsync", 
        "params": [], 
        "path": "python/library/os#os.fsync", 
        "syntax": "os.fsync(fd)", 
        "type": "Operating System"
    }, 
    "os.ftruncate": {
        "descr": "Truncate the file corresponding to file descriptor fd, so that it is at most length bytes in size. As of Python 3.3, this is equivalent to os.truncate(fd, length).", 
        "name": "os.ftruncate", 
        "params": [], 
        "path": "python/library/os#os.ftruncate", 
        "syntax": "os.ftruncate(fd, length)", 
        "type": "Operating System"
    }, 
    "os.fwalk": {
        "descr": "dirpath, dirnames and filenames are identical to walk() output, and dirfd is a file descriptor referring to the directory dirpath.", 
        "name": "os.fwalk", 
        "params": [], 
        "path": "python/library/os#os.fwalk", 
        "syntax": "os.fwalk(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.get_exec_path": {
        "descr": "Returns the list of directories that will be searched for a named executable, similar to a shell, when launching a process. env, when specified, should be an environment variable dictionary to lookup the PATH in. By default, when env is None, environ is used.", 
        "name": "os.get_exec_path", 
        "params": [], 
        "path": "python/library/os#os.get_exec_path", 
        "syntax": "os.get_exec_path(env=None)", 
        "type": "Operating System"
    }, 
    "os.get_terminal_size": {
        "descr": "Return the size of the terminal window as (columns, lines), tuple of type terminal_size.", 
        "name": "os.get_terminal_size", 
        "params": [], 
        "path": "python/library/os#os.get_terminal_size", 
        "syntax": "os.get_terminal_size(fd=STDOUT_FILENO)", 
        "type": "Operating System"
    }, 
    "os.getcwd": {
        "descr": "Return a string representing the current working directory.", 
        "name": "os.getcwd", 
        "params": [], 
        "path": "python/library/os#os.getcwd", 
        "syntax": "os.getcwd()", 
        "type": "Operating System"
    }, 
    "os.getcwdb": {
        "descr": "Return a bytestring representing the current working directory.", 
        "name": "os.getcwdb", 
        "params": [], 
        "path": "python/library/os#os.getcwdb", 
        "syntax": "os.getcwdb()", 
        "type": "Operating System"
    }, 
    "os.getegid": {
        "descr": "Return the effective group id of the current process. This corresponds to the \u201cset id\u201d bit on the file being executed in the current process.", 
        "name": "os.getegid", 
        "params": [], 
        "path": "python/library/os#os.getegid", 
        "syntax": "os.getegid()", 
        "type": "Operating System"
    }, 
    "os.getenv": {
        "descr": "Return the value of the environment variable key if it exists, or default if it doesn\u2019t. key, default and the result are str.", 
        "name": "os.getenv", 
        "params": [], 
        "path": "python/library/os#os.getenv", 
        "syntax": "os.getenv(key, default=None)", 
        "type": "Operating System"
    }, 
    "os.getenvb": {
        "descr": "Return the value of the environment variable key if it exists, or default if it doesn\u2019t. key, default and the result are bytes.", 
        "name": "os.getenvb", 
        "params": [], 
        "path": "python/library/os#os.getenvb", 
        "syntax": "os.getenvb(key, default=None)", 
        "type": "Operating System"
    }, 
    "os.geteuid": {
        "descr": "Availability: Unix.", 
        "name": "os.geteuid", 
        "params": [], 
        "path": "python/library/os#os.geteuid", 
        "syntax": "os.geteuid()", 
        "type": "Operating System"
    }, 
    "os.getgid": {
        "descr": "Availability: Unix.", 
        "name": "os.getgid", 
        "params": [], 
        "path": "python/library/os#os.getgid", 
        "syntax": "os.getgid()", 
        "type": "Operating System"
    }, 
    "os.getgrouplist": {
        "descr": "Return list of group ids that user belongs to. If group is not in the list, it is included; typically, group is specified as the group ID field from the password record for user.", 
        "name": "os.getgrouplist", 
        "params": [], 
        "path": "python/library/os#os.getgrouplist", 
        "syntax": "os.getgrouplist(user, group)", 
        "type": "Operating System"
    }, 
    "os.getgroups": {
        "descr": "Return list of supplemental group ids associated with the current process.", 
        "name": "os.getgroups", 
        "params": [], 
        "path": "python/library/os#os.getgroups", 
        "syntax": "os.getgroups()", 
        "type": "Operating System"
    }, 
    "os.getloadavg": {
        "descr": "Return the number of processes in the system run queue averaged over the last 1, 5, and 15 minutes or raises OSError if the load average was unobtainable.", 
        "name": "os.getloadavg", 
        "params": [], 
        "path": "python/library/os#os.getloadavg", 
        "syntax": "os.getloadavg()", 
        "type": "Operating System"
    }, 
    "os.getlogin": {
        "descr": "Return the name of the user logged in on the controlling terminal of the process. For most purposes, it is more useful to use the environment variables LOGNAME or USERNAME to find out who the user is, or pwd.getpwuid(os.getuid())[0] to get the login name of the currently effective user id.", 
        "name": "os.getlogin", 
        "params": [], 
        "path": "python/library/os#os.getlogin", 
        "syntax": "os.getlogin()", 
        "type": "Operating System"
    }, 
    "os.getpgid": {
        "descr": "Return the process group id of the process with process id pid. If pid is 0, the process group id of the current process is returned.", 
        "name": "os.getpgid", 
        "params": [], 
        "path": "python/library/os#os.getpgid", 
        "syntax": "os.getpgid(pid)", 
        "type": "Operating System"
    }, 
    "os.getpgrp": {
        "descr": "Availability: Unix.", 
        "name": "os.getpgrp", 
        "params": [], 
        "path": "python/library/os#os.getpgrp", 
        "syntax": "os.getpgrp()", 
        "type": "Operating System"
    }, 
    "os.getpid": {
        "descr": "Availability: Unix, Windows.", 
        "name": "os.getpid", 
        "params": [], 
        "path": "python/library/os#os.getpid", 
        "syntax": "os.getpid()", 
        "type": "Operating System"
    }, 
    "os.getppid": {
        "descr": "Availability: Unix, Windows.", 
        "name": "os.getppid", 
        "params": [], 
        "path": "python/library/os#os.getppid", 
        "syntax": "os.getppid()", 
        "type": "Operating System"
    }, 
    "os.getpriority": {
        "descr": "Availability: Unix.", 
        "name": "os.getpriority", 
        "params": [], 
        "path": "python/library/os#os.getpriority", 
        "syntax": "os.getpriority(which, who)", 
        "type": "Operating System"
    }, 
    "os.getresgid": {
        "descr": "Return a tuple (rgid, egid, sgid) denoting the current process\u2019s real, effective, and saved group ids.", 
        "name": "os.getresgid", 
        "params": [], 
        "path": "python/library/os#os.getresgid", 
        "syntax": "os.getresgid()", 
        "type": "Operating System"
    }, 
    "os.getresuid": {
        "descr": "Return a tuple (ruid, euid, suid) denoting the current process\u2019s real, effective, and saved user ids.", 
        "name": "os.getresuid", 
        "params": [], 
        "path": "python/library/os#os.getresuid", 
        "syntax": "os.getresuid()", 
        "type": "Operating System"
    }, 
    "os.getsid": {
        "descr": "Call the system call getsid(). See the Unix manual for the semantics.", 
        "name": "os.getsid", 
        "params": [], 
        "path": "python/library/os#os.getsid", 
        "syntax": "os.getsid(pid)", 
        "type": "Operating System"
    }, 
    "os.getuid": {
        "descr": "Availability: Unix.", 
        "name": "os.getuid", 
        "params": [], 
        "path": "python/library/os#os.getuid", 
        "syntax": "os.getuid()", 
        "type": "Operating System"
    }, 
    "os.getxattr": {
        "descr": "Return the value of the extended filesystem attribute attribute for path. attribute can be bytes or str. If it is str, it is encoded with the filesystem encoding.", 
        "name": "os.getxattr", 
        "params": [], 
        "path": "python/library/os#os.getxattr", 
        "syntax": "os.getxattr(path, attribute, *, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.initgroups": {
        "descr": "Call the system initgroups() to initialize the group access list with all of the groups of which the specified username is a member, plus the specified group id.", 
        "name": "os.initgroups", 
        "params": [], 
        "path": "python/library/os#os.initgroups", 
        "syntax": "os.initgroups(username, gid)", 
        "type": "Operating System"
    }, 
    "os.isatty": {
        "descr": "Return True if the file descriptor fd is open and connected to a tty(-like) device, else False.", 
        "name": "os.isatty", 
        "params": [], 
        "path": "python/library/os#os.isatty", 
        "syntax": "os.isatty(fd)", 
        "type": "Operating System"
    }, 
    "os.kill": {
        "descr": "Windows: The signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT signals are special signals which can only be sent to console processes which share a common console window, e.g., some subprocesses. Any other value for sig will cause the process to be unconditionally killed by the TerminateProcess API, and the exit code will be set to sig. The Windows version of kill() additionally takes process handles to be killed.", 
        "name": "os.kill", 
        "params": [], 
        "path": "python/library/os#os.kill", 
        "syntax": "os.kill(pid, sig)", 
        "type": "Operating System"
    }, 
    "os.killpg": {
        "descr": "Availability: Unix.", 
        "name": "os.killpg", 
        "params": [], 
        "path": "python/library/os#os.killpg", 
        "syntax": "os.killpg(pgid, sig)", 
        "type": "Operating System"
    }, 
    "os.lchflags": {
        "descr": "Set the flags of path to the numeric flags, like chflags(), but do not follow symbolic links. As of Python 3.3, this is equivalent to os.chflags(path, flags, follow_symlinks=False).", 
        "name": "os.lchflags", 
        "params": [], 
        "path": "python/library/os#os.lchflags", 
        "syntax": "os.lchflags(path, flags)", 
        "type": "Operating System"
    }, 
    "os.lchmod": {
        "descr": "Change the mode of path to the numeric mode. If path is a symlink, this affects the symlink rather than the target. See the docs for chmod() for possible values of mode. As of Python 3.3, this is equivalent to os.chmod(path, mode, follow_symlinks=False).", 
        "name": "os.lchmod", 
        "params": [], 
        "path": "python/library/os#os.lchmod", 
        "syntax": "os.lchmod(path, mode)", 
        "type": "Operating System"
    }, 
    "os.lchown": {
        "descr": "Change the owner and group id of path to the numeric uid and gid. This function will not follow symbolic links. As of Python 3.3, this is equivalent to os.chown(path, uid, gid, follow_symlinks=False).", 
        "name": "os.lchown", 
        "params": [], 
        "path": "python/library/os#os.lchown", 
        "syntax": "os.lchown(path, uid, gid)", 
        "type": "Operating System"
    }, 
    "os.linesep": {
        "descr": "The string used to separate (or, rather, terminate) lines on the current platform. This may be a single character, such as '\\n' for POSIX, or multiple characters, for example, '\\r\\n' for Windows. Do not use os.linesep as a line terminator when writing files opened in text mode (the default); use a single '\\n' instead, on all platforms.", 
        "name": "os.linesep", 
        "params": [], 
        "path": "python/library/os#os.linesep", 
        "syntax": "os.linesep", 
        "type": "Operating System"
    }, 
    "os.link": {
        "descr": "Create a hard link pointing to src named dst.", 
        "name": "os.link", 
        "params": [], 
        "path": "python/library/os#os.link", 
        "syntax": "os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.listdir": {
        "descr": "Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order, and does not include the special entries '.' and '..' even if they are present in the directory.", 
        "name": "os.listdir", 
        "params": [], 
        "path": "python/library/os#os.listdir", 
        "syntax": "os.listdir(path='.')", 
        "type": "Operating System"
    }, 
    "os.listxattr": {
        "descr": "Return a list of the extended filesystem attributes on path. The attributes in the list are represented as strings decoded with the filesystem encoding. If path is None, listxattr() will examine the current directory.", 
        "name": "os.listxattr", 
        "params": [], 
        "path": "python/library/os#os.listxattr", 
        "syntax": "os.listxattr(path=None, *, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.lockf": {
        "descr": "Apply, test or remove a POSIX lock on an open file descriptor. fd is an open file descriptor. cmd specifies the command to use - one of F_LOCK, F_TLOCK, F_ULOCK or F_TEST. len specifies the section of the file to lock.", 
        "name": "os.lockf", 
        "params": [], 
        "path": "python/library/os#os.lockf", 
        "syntax": "os.lockf(fd, cmd, len)", 
        "type": "Operating System"
    }, 
    "os.lseek": {
        "descr": "Set the current position of file descriptor fd to position pos, modified by how: SEEK_SET or 0 to set the position relative to the beginning of the file; SEEK_CUR or 1 to set it relative to the current position; SEEK_END or 2 to set it relative to the end of the file. Return the new cursor position in bytes, starting from the beginning.", 
        "name": "os.lseek", 
        "params": [], 
        "path": "python/library/os#os.lseek", 
        "syntax": "os.lseek(fd, pos, how)", 
        "type": "Operating System"
    }, 
    "os.lstat": {
        "descr": "Perform the equivalent of an lstat() system call on the given path. Similar to stat(), but does not follow symbolic links. On platforms that do not support symbolic links, this is an alias for stat(). As of Python 3.3, this is equivalent to os.stat(path, dir_fd=dir_fd, follow_symlinks=False).", 
        "name": "os.lstat", 
        "params": [], 
        "path": "python/library/os#os.lstat", 
        "syntax": "os.lstat(path, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.major": {
        "descr": "Extract the device major number from a raw device number (usually the st_dev or st_rdev field from stat).", 
        "name": "os.major", 
        "params": [], 
        "path": "python/library/os#os.major", 
        "syntax": "os.major(device)", 
        "type": "Operating System"
    }, 
    "os.makedev": {
        "descr": "Compose a raw device number from the major and minor device numbers.", 
        "name": "os.makedev", 
        "params": [], 
        "path": "python/library/os#os.makedev", 
        "syntax": "os.makedev(major, minor)", 
        "type": "Operating System"
    }, 
    "os.makedirs": {
        "descr": "The default mode is 0o777 (octal). On some systems, mode is ignored. Where it is used, the current umask value is first masked out.", 
        "name": "os.makedirs", 
        "params": [], 
        "path": "python/library/os#os.makedirs", 
        "syntax": "os.makedirs(path, mode=0o777, exist_ok=False)", 
        "type": "Operating System"
    }, 
    "os.minor": {
        "descr": "Extract the device minor number from a raw device number (usually the st_dev or st_rdev field from stat).", 
        "name": "os.minor", 
        "params": [], 
        "path": "python/library/os#os.minor", 
        "syntax": "os.minor(device)", 
        "type": "Operating System"
    }, 
    "os.mkdir": {
        "descr": "Create a directory named path with numeric mode mode.", 
        "name": "os.mkdir", 
        "params": [], 
        "path": "python/library/os#os.mkdir", 
        "syntax": "os.mkdir(path, mode=0o777, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.mkfifo": {
        "descr": "Create a FIFO (a named pipe) named path with numeric mode mode. The current umask value is first masked out from the mode.", 
        "name": "os.mkfifo", 
        "params": [], 
        "path": "python/library/os#os.mkfifo", 
        "syntax": "os.mkfifo(path, mode=0o666, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.mknod": {
        "descr": "Create a filesystem node (file, device special file or named pipe) named filename. mode specifies both the permissions to use and the type of node to be created, being combined (bitwise OR) with one of stat.S_IFREG, stat.S_IFCHR, stat.S_IFBLK, and stat.S_IFIFO (those constants are available in stat). For stat.S_IFCHR and stat.S_IFBLK, device defines the newly created device special file (probably using os.makedev()), otherwise it is ignored.", 
        "name": "os.mknod", 
        "params": [], 
        "path": "python/library/os#os.mknod", 
        "syntax": "os.mknod(filename, mode=0o600, device=0, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.name": {
        "descr": "The name of the operating system dependent module imported. The following names have currently been registered: 'posix', 'nt', 'mac', 'os2', 'ce', 'java'.", 
        "name": "os.name", 
        "params": [], 
        "path": "python/library/os#os.name", 
        "syntax": "os.name", 
        "type": "Operating System"
    }, 
    "os.nice": {
        "descr": "Add increment to the process\u2019s \u201cniceness\u201d. Return the new niceness.", 
        "name": "os.nice", 
        "params": [], 
        "path": "python/library/os#os.nice", 
        "syntax": "os.nice(increment)", 
        "type": "Operating System"
    }, 
    "os.open": {
        "descr": "Open the file file and set various flags according to flags and possibly its mode according to mode. When computing mode, the current umask value is first masked out. Return the file descriptor for the newly opened file.", 
        "name": "os.open", 
        "params": [], 
        "path": "python/library/os#os.open", 
        "syntax": "os.open(file, flags, mode=0o777, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.openpty": {
        "descr": "Availability: some flavors of Unix.", 
        "name": "os.openpty", 
        "params": [], 
        "path": "python/library/os#os.openpty", 
        "syntax": "os.openpty()", 
        "type": "Operating System"
    }, 
    "os.pardir": {
        "descr": "The constant string used by the operating system to refer to the parent directory. This is '..' for Windows and POSIX. Also available via os.path.", 
        "name": "os.pardir", 
        "params": [], 
        "path": "python/library/os#os.pardir", 
        "syntax": "os.pardir", 
        "type": "Operating System"
    }, 
    "os.path.abspath": {
        "descr": "Return a normalized absolutized version of the pathname path. On most platforms, this is equivalent to calling the function normpath() as follows: normpath(join(os.getcwd(), path)).", 
        "name": "os.path.abspath", 
        "params": [], 
        "path": "python/library/os.path#os.path.abspath", 
        "syntax": "os.path.abspath(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.basename": {
        "descr": "Return the base name of pathname path. This is the second element of the pair returned by passing path to the function split(). Note that the result of this function is different from the Unix basename program; where basename for '/foo/bar/' returns 'bar', the basename() function returns an empty string ('').", 
        "name": "os.path.basename", 
        "params": [], 
        "path": "python/library/os.path#os.path.basename", 
        "syntax": "os.path.basename(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.commonprefix": {
        "descr": "Return the longest path prefix (taken character-by-character) that is a prefix of all paths in list. If list is empty, return the empty string (''). Note that this may return invalid paths because it works a character at a time.", 
        "name": "os.path.commonprefix", 
        "params": [], 
        "path": "python/library/os.path#os.path.commonprefix", 
        "syntax": "os.path.commonprefix(list)", 
        "type": "File & Directory Access"
    }, 
    "os.path.dirname": {
        "descr": "Return the directory name of pathname path. This is the first element of the pair returned by passing path to the function split().", 
        "name": "os.path.dirname", 
        "params": [], 
        "path": "python/library/os.path#os.path.dirname", 
        "syntax": "os.path.dirname(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.exists": {
        "descr": "Return True if path refers to an existing path or an open file descriptor. Returns False for broken symbolic links. On some platforms, this function may return False if permission is not granted to execute os.stat() on the requested file, even if the path physically exists.", 
        "name": "os.path.exists", 
        "params": [], 
        "path": "python/library/os.path#os.path.exists", 
        "syntax": "os.path.exists(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.expanduser": {
        "descr": "On Unix and Windows, return the argument with an initial component of ~ or ~user replaced by that user\u2018s home directory.", 
        "name": "os.path.expanduser", 
        "params": [], 
        "path": "python/library/os.path#os.path.expanduser", 
        "syntax": "os.path.expanduser(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.expandvars": {
        "descr": "Return the argument with environment variables expanded. Substrings of the form $name or ${name} are replaced by the value of environment variable name. Malformed variable names and references to non-existing variables are left unchanged.", 
        "name": "os.path.expandvars", 
        "params": [], 
        "path": "python/library/os.path#os.path.expandvars", 
        "syntax": "os.path.expandvars(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.getatime": {
        "descr": "Return the time of last access of path. The return value is a number giving the number of seconds since the epoch (see the time module). Raise OSError if the file does not exist or is inaccessible.", 
        "name": "os.path.getatime", 
        "params": [], 
        "path": "python/library/os.path#os.path.getatime", 
        "syntax": "os.path.getatime(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.getctime": {
        "descr": "Return the system\u2019s ctime which, on some systems (like Unix) is the time of the last metadata change, and, on others (like Windows), is the creation time for path. The return value is a number giving the number of seconds since the epoch (see the time module). Raise OSError if the file does not exist or is inaccessible.", 
        "name": "os.path.getctime", 
        "params": [], 
        "path": "python/library/os.path#os.path.getctime", 
        "syntax": "os.path.getctime(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.getmtime": {
        "descr": "Return the time of last modification of path. The return value is a number giving the number of seconds since the epoch (see the time module). Raise OSError if the file does not exist or is inaccessible.", 
        "name": "os.path.getmtime", 
        "params": [], 
        "path": "python/library/os.path#os.path.getmtime", 
        "syntax": "os.path.getmtime(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.getsize": {
        "descr": "Return the size, in bytes, of path. Raise OSError if the file does not exist or is inaccessible.", 
        "name": "os.path.getsize", 
        "params": [], 
        "path": "python/library/os.path#os.path.getsize", 
        "syntax": "os.path.getsize(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.isabs": {
        "descr": "Return True if path is an absolute pathname. On Unix, that means it begins with a slash, on Windows that it begins with a (back)slash after chopping off a potential drive letter.", 
        "name": "os.path.isabs", 
        "params": [], 
        "path": "python/library/os.path#os.path.isabs", 
        "syntax": "os.path.isabs(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.isdir": {
        "descr": "Return True if path is an existing directory. This follows symbolic links, so both islink() and isdir() can be true for the same path.", 
        "name": "os.path.isdir", 
        "params": [], 
        "path": "python/library/os.path#os.path.isdir", 
        "syntax": "os.path.isdir(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.isfile": {
        "descr": "Return True if path is an existing regular file. This follows symbolic links, so both islink() and isfile() can be true for the same path.", 
        "name": "os.path.isfile", 
        "params": [], 
        "path": "python/library/os.path#os.path.isfile", 
        "syntax": "os.path.isfile(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.islink": {
        "descr": "Return True if path refers to a directory entry that is a symbolic link. Always False if symbolic links are not supported.", 
        "name": "os.path.islink", 
        "params": [], 
        "path": "python/library/os.path#os.path.islink", 
        "syntax": "os.path.islink(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.ismount": {
        "descr": "Return True if pathname path is a mount point: a point in a file system where a different file system has been mounted. The function checks whether path\u2018s parent, path/.., is on a different device than path, or whether path/.. and path point to the same i-node on the same device \u2014 this should detect mount points for all Unix and POSIX variants.", 
        "name": "os.path.ismount", 
        "params": [], 
        "path": "python/library/os.path#os.path.ismount", 
        "syntax": "os.path.ismount(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.join": {
        "descr": "Join one or more path components intelligently. If any component is an absolute path, all previous components (on Windows, including the previous drive letter, if there was one) are thrown away, and joining continues. The return value is the concatenation of path1, and optionally path2, etc., with exactly one directory separator (os.sep) following each non-empty part except the last. (This means that an empty last part will result in a path that ends with a separator.) Note that on Windows, since there is a current directory for each drive, os.path.join(\"c:\", \"foo\") represents a path relative to the current directory on drive C: (c:foo), not c:\\foo.", 
        "name": "os.path.join", 
        "params": [], 
        "path": "python/library/os.path#os.path.join", 
        "syntax": "os.path.join(path1[, path2[, ...]])", 
        "type": "File & Directory Access"
    }, 
    "os.path.lexists": {
        "descr": "Return True if path refers to an existing path. Returns True for broken symbolic links. Equivalent to exists() on platforms lacking os.lstat().", 
        "name": "os.path.lexists", 
        "params": [], 
        "path": "python/library/os.path#os.path.lexists", 
        "syntax": "os.path.lexists(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.normcase": {
        "descr": "Normalize the case of a pathname. On Unix and Mac OS X, this returns the path unchanged; on case-insensitive filesystems, it converts the path to lowercase. On Windows, it also converts forward slashes to backward slashes. Raise a TypeError if the type of path is not str or bytes.", 
        "name": "os.path.normcase", 
        "params": [], 
        "path": "python/library/os.path#os.path.normcase", 
        "syntax": "os.path.normcase(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.normpath": {
        "descr": "Normalize a pathname by collapsing redundant separators and up-level references so that A//B, A/B/, A/./B and A/foo/../B all become A/B. This string manipulation may change the meaning of a path that contains symbolic links. On Windows, it converts forward slashes to backward slashes. To normalize case, use normcase().", 
        "name": "os.path.normpath", 
        "params": [], 
        "path": "python/library/os.path#os.path.normpath", 
        "syntax": "os.path.normpath(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.realpath": {
        "descr": "Return the canonical path of the specified filename, eliminating any symbolic links encountered in the path (if they are supported by the operating system).", 
        "name": "os.path.realpath", 
        "params": [], 
        "path": "python/library/os.path#os.path.realpath", 
        "syntax": "os.path.realpath(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.relpath": {
        "descr": "Return a relative filepath to path either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or start.", 
        "name": "os.path.relpath", 
        "params": [], 
        "path": "python/library/os.path#os.path.relpath", 
        "syntax": "os.path.relpath(path, start=None)", 
        "type": "File & Directory Access"
    }, 
    "os.path.samefile": {
        "descr": "Return True if both pathname arguments refer to the same file or directory. On Unix, this is determined by the device number and i-node number and raises an exception if a os.stat() call on either pathname fails.", 
        "name": "os.path.samefile", 
        "params": [], 
        "path": "python/library/os.path#os.path.samefile", 
        "syntax": "os.path.samefile(path1, path2)", 
        "type": "File & Directory Access"
    }, 
    "os.path.sameopenfile": {
        "descr": "Return True if the file descriptors fp1 and fp2 refer to the same file.", 
        "name": "os.path.sameopenfile", 
        "params": [], 
        "path": "python/library/os.path#os.path.sameopenfile", 
        "syntax": "os.path.sameopenfile(fp1, fp2)", 
        "type": "File & Directory Access"
    }, 
    "os.path.samestat": {
        "descr": "Return True if the stat tuples stat1 and stat2 refer to the same file. These structures may have been returned by os.fstat(), os.lstat(), or os.stat(). This function implements the underlying comparison used by samefile() and sameopenfile().", 
        "name": "os.path.samestat", 
        "params": [], 
        "path": "python/library/os.path#os.path.samestat", 
        "syntax": "os.path.samestat(stat1, stat2)", 
        "type": "File & Directory Access"
    }, 
    "os.path.split": {
        "descr": "Split the pathname path into a pair, (head, tail) where tail is the last pathname component and head is everything leading up to that. The tail part will never contain a slash; if path ends in a slash, tail will be empty. If there is no slash in path, head will be empty. If path is empty, both head and tail are empty. Trailing slashes are stripped from head unless it is the root (one or more slashes only). In all cases, join(head, tail) returns a path to the same location as path (but the strings may differ). Also see the functions dirname() and basename().", 
        "name": "os.path.split", 
        "params": [], 
        "path": "python/library/os.path#os.path.split", 
        "syntax": "os.path.split(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.splitdrive": {
        "descr": "Split the pathname path into a pair (drive, tail) where drive is either a mount point or the empty string. On systems which do not use drive specifications, drive will always be the empty string. In all cases, drive + tail will be the same as path.", 
        "name": "os.path.splitdrive", 
        "params": [], 
        "path": "python/library/os.path#os.path.splitdrive", 
        "syntax": "os.path.splitdrive(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.splitext": {
        "descr": "Split the pathname path into a pair (root, ext) such that root + ext == path, and ext is empty or begins with a period and contains at most one period. Leading periods on the basename are ignored; splitext('.cshrc') returns ('.cshrc', '').", 
        "name": "os.path.splitext", 
        "params": [], 
        "path": "python/library/os.path#os.path.splitext", 
        "syntax": "os.path.splitext(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.splitunc": {
        "descr": "Deprecated since version 3.1: Use splitdrive instead.", 
        "name": "os.path.splitunc", 
        "params": [], 
        "path": "python/library/os.path#os.path.splitunc", 
        "syntax": "os.path.splitunc(path)", 
        "type": "File & Directory Access"
    }, 
    "os.path.supports_unicode_filenames": {
        "descr": "True if arbitrary Unicode strings can be used as file names (within limitations imposed by the file system).", 
        "name": "os.path.supports_unicode_filenames", 
        "params": [], 
        "path": "python/library/os.path#os.path.supports_unicode_filenames", 
        "syntax": "os.path.supports_unicode_filenames", 
        "type": "File & Directory Access"
    }, 
    "os.pathconf": {
        "descr": "Return system configuration information relevant to a named file. name specifies the configuration value to retrieve; it may be a string which is the name of a defined system value; these names are specified in a number of standards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define additional names as well. The names known to the host operating system are given in the pathconf_names dictionary. For configuration variables not included in that mapping, passing an integer for name is also accepted.", 
        "name": "os.pathconf", 
        "params": [], 
        "path": "python/library/os#os.pathconf", 
        "syntax": "os.pathconf(path, name)", 
        "type": "Operating System"
    }, 
    "os.pathconf_names": {
        "descr": "Dictionary mapping names accepted by pathconf() and fpathconf() to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system.", 
        "name": "os.pathconf_names", 
        "params": [], 
        "path": "python/library/os#os.pathconf_names", 
        "syntax": "os.pathconf_names", 
        "type": "Operating System"
    }, 
    "os.pathsep": {
        "descr": "The character conventionally used by the operating system to separate search path components (as in PATH), such as ':' for POSIX or ';' for Windows. Also available via os.path.", 
        "name": "os.pathsep", 
        "params": [], 
        "path": "python/library/os#os.pathsep", 
        "syntax": "os.pathsep", 
        "type": "Operating System"
    }, 
    "os.pipe": {
        "descr": "Create a pipe with flags set atomically. flags can be constructed by ORing together one or more of these values: O_NONBLOCK, O_CLOEXEC. Return a pair of file descriptors (r, w) usable for reading and writing, respectively.", 
        "name": "os.pipe", 
        "params": [], 
        "path": "python/library/os#os.pipe", 
        "syntax": "os.pipe2(flags)", 
        "type": "Operating System"
    }, 
    "os.pipe2": {
        "descr": "Create a pipe with flags set atomically. flags can be constructed by ORing together one or more of these values: O_NONBLOCK, O_CLOEXEC. Return a pair of file descriptors (r, w) usable for reading and writing, respectively.", 
        "name": "os.pipe2", 
        "params": [], 
        "path": "python/library/os#os.pipe2", 
        "syntax": "os.pipe2(flags)", 
        "type": "Operating System"
    }, 
    "os.plock": {
        "descr": "Lock program segments into memory. The value of op (defined in <sys/lock.h>) determines which segments are locked.", 
        "name": "os.plock", 
        "params": [], 
        "path": "python/library/os#os.plock", 
        "syntax": "os.plock(op)", 
        "type": "Operating System"
    }, 
    "os.popen": {
        "descr": "Run child processes, returning opened pipes for communications. These functions are described in section File Object Creation.", 
        "name": "os.popen", 
        "params": [], 
        "path": "python/library/os#os.popen", 
        "syntax": "os.popen(...)", 
        "type": "Operating System"
    }, 
    "os.posix_fadvise": {
        "descr": "Announces an intention to access data in a specific pattern thus allowing the kernel to make optimizations. The advice applies to the region of the file specified by fd starting at offset and continuing for len bytes. advice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL, POSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED or POSIX_FADV_DONTNEED.", 
        "name": "os.posix_fadvise", 
        "params": [], 
        "path": "python/library/os#os.posix_fadvise", 
        "syntax": "os.posix_fadvise(fd, offset, len, advice)", 
        "type": "Operating System"
    }, 
    "os.posix_fallocate": {
        "descr": "Ensures that enough disk space is allocated for the file specified by fd starting from offset and continuing for len bytes.", 
        "name": "os.posix_fallocate", 
        "params": [], 
        "path": "python/library/os#os.posix_fallocate", 
        "syntax": "os.posix_fallocate(fd, offset, len)", 
        "type": "Operating System"
    }, 
    "os.pread": {
        "descr": "Read from a file descriptor, fd, at a position of offset. It will read up to buffersize number of bytes. The file offset remains unchanged.", 
        "name": "os.pread", 
        "params": [], 
        "path": "python/library/os#os.pread", 
        "syntax": "os.pread(fd, buffersize, offset)", 
        "type": "Operating System"
    }, 
    "os.putenv": {
        "descr": "Availability: most flavors of Unix, Windows.", 
        "name": "os.putenv", 
        "params": [], 
        "path": "python/library/os#os.putenv", 
        "syntax": "os.putenv(key, value)", 
        "type": "Operating System"
    }, 
    "os.pwrite": {
        "descr": "Write string to a file descriptor, fd, from offset, leaving the file offset unchanged.", 
        "name": "os.pwrite", 
        "params": [], 
        "path": "python/library/os#os.pwrite", 
        "syntax": "os.pwrite(fd, string, offset)", 
        "type": "Operating System"
    }, 
    "os.read": {
        "descr": "Read at most n bytes from file descriptor fd. Return a bytestring containing the bytes read. If the end of the file referred to by fd has been reached, an empty bytes object is returned.", 
        "name": "os.read", 
        "params": [], 
        "path": "python/library/os#os.read", 
        "syntax": "os.read(fd, n)", 
        "type": "Operating System"
    }, 
    "os.readlink": {
        "descr": "Return a string representing the path to which the symbolic link points. The result may be either an absolute or relative pathname; if it is relative, it may be converted to an absolute pathname using os.path.join(os.path.dirname(path), result).", 
        "name": "os.readlink", 
        "params": [], 
        "path": "python/library/os#os.readlink", 
        "syntax": "os.readlink(path, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.readv": {
        "descr": "Read from a file descriptor fd into a number of mutable bytes-like objects buffers. readv() will transfer data into each buffer until it is full and then move on to the next buffer in the sequence to hold the rest of the data. readv() returns the total number of bytes read (which may be less than the total capacity of all the objects).", 
        "name": "os.readv", 
        "params": [], 
        "path": "python/library/os#os.readv", 
        "syntax": "os.readv(fd, buffers)", 
        "type": "Operating System"
    }, 
    "os.remove": {
        "descr": "Remove (delete) the file path. If path is a directory, OSError is raised. Use rmdir() to remove directories.", 
        "name": "os.remove", 
        "params": [], 
        "path": "python/library/os#os.remove", 
        "syntax": "os.remove(path, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.removedirs": {
        "descr": "", 
        "name": "os.removedirs", 
        "params": [], 
        "path": "python/library/os#os.removedirs", 
        "syntax": "os.removedirs(path)", 
        "type": "Operating System"
    }, 
    "os.removexattr": {
        "descr": "Removes the extended filesystem attribute attribute from path. attribute should be bytes or str. If it is a string, it is encoded with the filesystem encoding.", 
        "name": "os.removexattr", 
        "params": [], 
        "path": "python/library/os#os.removexattr", 
        "syntax": "os.removexattr(path, attribute, *, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.rename": {
        "descr": "Rename the file or directory src to dst. If dst is a directory, OSError will be raised. On Unix, if dst exists and is a file, it will be replaced silently if the user has permission. The operation may fail on some Unix flavors if src and dst are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement). On Windows, if dst already exists, OSError will be raised even if it is a file.", 
        "name": "os.rename", 
        "params": [], 
        "path": "python/library/os#os.rename", 
        "syntax": "os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.renames": {
        "descr": "Recursive directory or file renaming function. Works like rename(), except creation of any intermediate directories needed to make the new pathname good is attempted first. After the rename, directories corresponding to rightmost path segments of the old name will be pruned away using removedirs().", 
        "name": "os.renames", 
        "params": [], 
        "path": "python/library/os#os.renames", 
        "syntax": "os.renames(old, new)", 
        "type": "Operating System"
    }, 
    "os.replace": {
        "descr": "Rename the file or directory src to dst. If dst is a directory, OSError will be raised. If dst exists and is a file, it will be replaced silently if the user has permission. The operation may fail if src and dst are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement).", 
        "name": "os.replace", 
        "params": [], 
        "path": "python/library/os#os.replace", 
        "syntax": "os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.rmdir": {
        "descr": "Remove (delete) the directory path. Only works when the directory is empty, otherwise, OSError is raised. In order to remove whole directory trees, shutil.rmtree() can be used.", 
        "name": "os.rmdir", 
        "params": [], 
        "path": "python/library/os#os.rmdir", 
        "syntax": "os.rmdir(path, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.sched_get_priority_max": {
        "descr": "Get the maximum priority value for policy. policy is one of the scheduling policy constants above.", 
        "name": "os.sched_get_priority_max", 
        "params": [], 
        "path": "python/library/os#os.sched_get_priority_max", 
        "syntax": "os.sched_get_priority_max(policy)", 
        "type": "Operating System"
    }, 
    "os.sched_get_priority_min": {
        "descr": "Get the minimum priority value for policy. policy is one of the scheduling policy constants above.", 
        "name": "os.sched_get_priority_min", 
        "params": [], 
        "path": "python/library/os#os.sched_get_priority_min", 
        "syntax": "os.sched_get_priority_min(policy)", 
        "type": "Operating System"
    }, 
    "os.sched_getaffinity": {
        "descr": "Return the set of CPUs the process with PID pid (or the current process if zero) is restricted to.", 
        "name": "os.sched_getaffinity", 
        "params": [], 
        "path": "python/library/os#os.sched_getaffinity", 
        "syntax": "os.sched_getaffinity(pid)", 
        "type": "Operating System"
    }, 
    "os.sched_getparam": {
        "descr": "Return the scheduling parameters as a sched_param instance for the process with PID pid. A pid of 0 means the calling process.", 
        "name": "os.sched_getparam", 
        "params": [], 
        "path": "python/library/os#os.sched_getparam", 
        "syntax": "os.sched_getparam(pid)", 
        "type": "Operating System"
    }, 
    "os.sched_getscheduler": {
        "descr": "Return the scheduling policy for the process with PID pid. A pid of 0 means the calling process. The result is one of the scheduling policy constants above.", 
        "name": "os.sched_getscheduler", 
        "params": [], 
        "path": "python/library/os#os.sched_getscheduler", 
        "syntax": "os.sched_getscheduler(pid)", 
        "type": "Operating System"
    }, 
    "os.sched_param": {
        "descr": "This class represents tunable scheduling parameters used in sched_setparam(), sched_setscheduler(), and sched_getparam(). It is immutable.", 
        "name": "os.sched_param", 
        "params": [], 
        "path": "python/library/os#os.sched_param", 
        "syntax": "class os.sched_param(sched_priority)", 
        "type": "Operating System"
    }, 
    "os.sched_param.sched_priority": {
        "descr": "The scheduling priority for a scheduling policy.", 
        "name": "os.sched_param.sched_priority", 
        "params": [], 
        "path": "python/library/os#os.sched_param.sched_priority", 
        "syntax": "sched_priority", 
        "type": "Operating System"
    }, 
    "os.sched_rr_get_interval": {
        "descr": "Return the round-robin quantum in seconds for the process with PID pid. A pid of 0 means the calling process.", 
        "name": "os.sched_rr_get_interval", 
        "params": [], 
        "path": "python/library/os#os.sched_rr_get_interval", 
        "syntax": "os.sched_rr_get_interval(pid)", 
        "type": "Operating System"
    }, 
    "os.sched_setaffinity": {
        "descr": "Restrict the process with PID pid (or the current process if zero) to a set of CPUs. mask is an iterable of integers representing the set of CPUs to which the process should be restricted.", 
        "name": "os.sched_setaffinity", 
        "params": [], 
        "path": "python/library/os#os.sched_setaffinity", 
        "syntax": "os.sched_setaffinity(pid, mask)", 
        "type": "Operating System"
    }, 
    "os.sched_setparam": {
        "descr": "Set a scheduling parameters for the process with PID pid. A pid of 0 means the calling process. param is a sched_param instance.", 
        "name": "os.sched_setparam", 
        "params": [], 
        "path": "python/library/os#os.sched_setparam", 
        "syntax": "os.sched_setparam(pid, param)", 
        "type": "Operating System"
    }, 
    "os.sched_setscheduler": {
        "descr": "Set the scheduling policy for the process with PID pid. A pid of 0 means the calling process. policy is one of the scheduling policy constants above. param is a sched_param instance.", 
        "name": "os.sched_setscheduler", 
        "params": [], 
        "path": "python/library/os#os.sched_setscheduler", 
        "syntax": "os.sched_setscheduler(pid, policy, param)", 
        "type": "Operating System"
    }, 
    "os.sched_yield": {
        "descr": "Voluntarily relinquish the CPU.", 
        "name": "os.sched_yield", 
        "params": [], 
        "path": "python/library/os#os.sched_yield", 
        "syntax": "os.sched_yield()", 
        "type": "Operating System"
    }, 
    "os.sendfile": {
        "descr": "Copy nbytes bytes from file descriptor in to file descriptor out starting at offset. Return the number of bytes sent. When EOF is reached return 0.", 
        "name": "os.sendfile", 
        "params": [], 
        "path": "python/library/os#os.sendfile", 
        "syntax": "os.sendfile(out, in, offset, nbytes)", 
        "type": "Operating System"
    }, 
    "os.sep": {
        "descr": "The character used by the operating system to separate pathname components. This is '/' for POSIX and '\\\\' for Windows. Note that knowing this is not sufficient to be able to parse or concatenate pathnames \u2014 use os.path.split() and os.path.join() \u2014 but it is occasionally useful. Also available via os.path.", 
        "name": "os.sep", 
        "params": [], 
        "path": "python/library/os#os.sep", 
        "syntax": "os.sep", 
        "type": "Operating System"
    }, 
    "os.setegid": {
        "descr": "Set the current process\u2019s effective group id.", 
        "name": "os.setegid", 
        "params": [], 
        "path": "python/library/os#os.setegid", 
        "syntax": "os.setegid(egid)", 
        "type": "Operating System"
    }, 
    "os.seteuid": {
        "descr": "Set the current process\u2019s effective user id.", 
        "name": "os.seteuid", 
        "params": [], 
        "path": "python/library/os#os.seteuid", 
        "syntax": "os.seteuid(euid)", 
        "type": "Operating System"
    }, 
    "os.setgid": {
        "descr": "Set the current process\u2019 group id.", 
        "name": "os.setgid", 
        "params": [], 
        "path": "python/library/os#os.setgid", 
        "syntax": "os.setgid(gid)", 
        "type": "Operating System"
    }, 
    "os.setgroups": {
        "descr": "Set the list of supplemental group ids associated with the current process to groups. groups must be a sequence, and each element must be an integer identifying a group. This operation is typically available only to the superuser.", 
        "name": "os.setgroups", 
        "params": [], 
        "path": "python/library/os#os.setgroups", 
        "syntax": "os.setgroups(groups)", 
        "type": "Operating System"
    }, 
    "os.setpgid": {
        "descr": "Call the system call setpgid() to set the process group id of the process with id pid to the process group with id pgrp. See the Unix manual for the semantics.", 
        "name": "os.setpgid", 
        "params": [], 
        "path": "python/library/os#os.setpgid", 
        "syntax": "os.setpgid(pid, pgrp)", 
        "type": "Operating System"
    }, 
    "os.setpgrp": {
        "descr": "Call the system call setpgrp() or setpgrp(0, 0) depending on which version is implemented (if any). See the Unix manual for the semantics.", 
        "name": "os.setpgrp", 
        "params": [], 
        "path": "python/library/os#os.setpgrp", 
        "syntax": "os.setpgrp()", 
        "type": "Operating System"
    }, 
    "os.setpriority": {
        "descr": "Availability: Unix", 
        "name": "os.setpriority", 
        "params": [], 
        "path": "python/library/os#os.setpriority", 
        "syntax": "os.setpriority(which, who, priority)", 
        "type": "Operating System"
    }, 
    "os.setregid": {
        "descr": "Set the current process\u2019s real and effective group ids.", 
        "name": "os.setregid", 
        "params": [], 
        "path": "python/library/os#os.setregid", 
        "syntax": "os.setregid(rgid, egid)", 
        "type": "Operating System"
    }, 
    "os.setresgid": {
        "descr": "Set the current process\u2019s real, effective, and saved group ids.", 
        "name": "os.setresgid", 
        "params": [], 
        "path": "python/library/os#os.setresgid", 
        "syntax": "os.setresgid(rgid, egid, sgid)", 
        "type": "Operating System"
    }, 
    "os.setresuid": {
        "descr": "Set the current process\u2019s real, effective, and saved user ids.", 
        "name": "os.setresuid", 
        "params": [], 
        "path": "python/library/os#os.setresuid", 
        "syntax": "os.setresuid(ruid, euid, suid)", 
        "type": "Operating System"
    }, 
    "os.setreuid": {
        "descr": "Set the current process\u2019s real and effective user ids.", 
        "name": "os.setreuid", 
        "params": [], 
        "path": "python/library/os#os.setreuid", 
        "syntax": "os.setreuid(ruid, euid)", 
        "type": "Operating System"
    }, 
    "os.setsid": {
        "descr": "Call the system call setsid(). See the Unix manual for the semantics.", 
        "name": "os.setsid", 
        "params": [], 
        "path": "python/library/os#os.setsid", 
        "syntax": "os.setsid()", 
        "type": "Operating System"
    }, 
    "os.setuid": {
        "descr": "Availability: Unix.", 
        "name": "os.setuid", 
        "params": [], 
        "path": "python/library/os#os.setuid", 
        "syntax": "os.setuid(uid)", 
        "type": "Operating System"
    }, 
    "os.setxattr": {
        "descr": "Set the extended filesystem attribute attribute on path to value. attribute must be a bytes or str with no embedded NULs. If it is a str, it is encoded with the filesystem encoding. flags may be XATTR_REPLACE or XATTR_CREATE. If XATTR_REPLACE is given and the attribute does not exist, EEXISTS will be raised. If XATTR_CREATE is given and the attribute already exists, the attribute will not be created and ENODATA will be raised.", 
        "name": "os.setxattr", 
        "params": [], 
        "path": "python/library/os#os.setxattr", 
        "syntax": "os.setxattr(path, attribute, value, flags=0, *, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.spawnl": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnl", 
        "params": [], 
        "path": "python/library/os#os.spawnl", 
        "syntax": "os.spawnl(mode, path, ...)", 
        "type": "Operating System"
    }, 
    "os.spawnle": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnle", 
        "params": [], 
        "path": "python/library/os#os.spawnle", 
        "syntax": "os.spawnle(mode, path, ..., env)", 
        "type": "Operating System"
    }, 
    "os.spawnlp": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnlp", 
        "params": [], 
        "path": "python/library/os#os.spawnlp", 
        "syntax": "os.spawnlp(mode, file, ...)", 
        "type": "Operating System"
    }, 
    "os.spawnlpe": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnlpe", 
        "params": [], 
        "path": "python/library/os#os.spawnlpe", 
        "syntax": "os.spawnlpe(mode, file, ..., env)", 
        "type": "Operating System"
    }, 
    "os.spawnv": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnv", 
        "params": [], 
        "path": "python/library/os#os.spawnv", 
        "syntax": "os.spawnv(mode, path, args)", 
        "type": "Operating System"
    }, 
    "os.spawnve": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnve", 
        "params": [], 
        "path": "python/library/os#os.spawnve", 
        "syntax": "os.spawnve(mode, path, args, env)", 
        "type": "Operating System"
    }, 
    "os.spawnvp": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnvp", 
        "params": [], 
        "path": "python/library/os#os.spawnvp", 
        "syntax": "os.spawnvp(mode, file, args)", 
        "type": "Operating System"
    }, 
    "os.spawnvpe": {
        "descr": "Execute the program path in a new process.", 
        "name": "os.spawnvpe", 
        "params": [], 
        "path": "python/library/os#os.spawnvpe", 
        "syntax": "os.spawnvpe(mode, file, args, env)", 
        "type": "Operating System"
    }, 
    "os.startfile": {
        "descr": "Start a file with its associated application.", 
        "name": "os.startfile", 
        "params": [], 
        "path": "python/library/os#os.startfile", 
        "syntax": "os.startfile(path[, operation])", 
        "type": "Operating System"
    }, 
    "os.stat": {
        "descr": "Perform the equivalent of a stat() system call on the given path. path may be specified as either a string or as an open file descriptor. (This function normally follows symlinks; to stat a symlink add the argument follow_symlinks=False, or use lstat().)", 
        "name": "os.stat", 
        "params": [], 
        "path": "python/library/os#os.stat", 
        "syntax": "os.stat(path, *, dir_fd=None, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.stat_float_times": {
        "descr": "Determine whether stat_result represents time stamps as float objects. If newvalue is True, future calls to stat() return floats, if it is False, future calls return ints. If newvalue is omitted, return the current setting.", 
        "name": "os.stat_float_times", 
        "params": [], 
        "path": "python/library/os#os.stat_float_times", 
        "syntax": "os.stat_float_times([newvalue])", 
        "type": "Operating System"
    }, 
    "os.statvfs": {
        "descr": "Perform a statvfs() system call on the given path. The return value is an object whose attributes describe the filesystem on the given path, and correspond to the members of the statvfs structure, namely: f_bsize, f_frsize, f_blocks, f_bfree, f_bavail, f_files, f_ffree, f_favail, f_flag, f_namemax.", 
        "name": "os.statvfs", 
        "params": [], 
        "path": "python/library/os#os.statvfs", 
        "syntax": "os.statvfs(path)", 
        "type": "Operating System"
    }, 
    "os.strerror": {
        "descr": "Return the error message corresponding to the error code in code. On platforms where strerror() returns NULL when given an unknown error number, ValueError is raised.", 
        "name": "os.strerror", 
        "params": [], 
        "path": "python/library/os#os.strerror", 
        "syntax": "os.strerror(code)", 
        "type": "Operating System"
    }, 
    "os.supports_bytes_environ": {
        "descr": "True if the native OS type of the environment is bytes (eg. False on Windows).", 
        "name": "os.supports_bytes_environ", 
        "params": [], 
        "path": "python/library/os#os.supports_bytes_environ", 
        "syntax": "os.supports_bytes_environ", 
        "type": "Operating System"
    }, 
    "os.supports_dir_fd": {
        "descr": "A Set object indicating which functions in the os module permit use of their dir_fd parameter. Different platforms provide different functionality, and an option that might work on one might be unsupported on another. For consistency\u2019s sakes, functions that support dir_fd always allow specifying the parameter, but will raise an exception if the functionality is not actually available.", 
        "name": "os.supports_dir_fd", 
        "params": [], 
        "path": "python/library/os#os.supports_dir_fd", 
        "syntax": "os.supports_dir_fd", 
        "type": "Operating System"
    }, 
    "os.supports_effective_ids": {
        "descr": "A Set object indicating which functions in the os module permit use of the effective_ids parameter for os.access(). If the local platform supports it, the collection will contain os.access(), otherwise it will be empty.", 
        "name": "os.supports_effective_ids", 
        "params": [], 
        "path": "python/library/os#os.supports_effective_ids", 
        "syntax": "os.supports_effective_ids", 
        "type": "Operating System"
    }, 
    "os.supports_fd": {
        "descr": "A Set object indicating which functions in the os module permit specifying their path parameter as an open file descriptor. Different platforms provide different functionality, and an option that might work on one might be unsupported on another. For consistency\u2019s sakes, functions that support fd always allow specifying the parameter, but will raise an exception if the functionality is not actually available.", 
        "name": "os.supports_fd", 
        "params": [], 
        "path": "python/library/os#os.supports_fd", 
        "syntax": "os.supports_fd", 
        "type": "Operating System"
    }, 
    "os.supports_follow_symlinks": {
        "descr": "A Set object indicating which functions in the os module permit use of their follow_symlinks parameter. Different platforms provide different functionality, and an option that might work on one might be unsupported on another. For consistency\u2019s sakes, functions that support follow_symlinks always allow specifying the parameter, but will raise an exception if the functionality is not actually available.", 
        "name": "os.supports_follow_symlinks", 
        "params": [], 
        "path": "python/library/os#os.supports_follow_symlinks", 
        "syntax": "os.supports_follow_symlinks", 
        "type": "Operating System"
    }, 
    "os.symlink": {
        "descr": "Create a symbolic link pointing to source named link_name.", 
        "name": "os.symlink", 
        "params": [], 
        "path": "python/library/os#os.symlink", 
        "syntax": "os.symlink(source, link_name, target_is_directory=False, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.sync": {
        "descr": "Force write of everything to disk.", 
        "name": "os.sync", 
        "params": [], 
        "path": "python/library/os#os.sync", 
        "syntax": "os.sync()", 
        "type": "Operating System"
    }, 
    "os.sysconf": {
        "descr": "Return integer-valued system configuration values. If the configuration value specified by name isn\u2019t defined, -1 is returned. The comments regarding the name parameter for confstr() apply here as well; the dictionary that provides information on the known names is given by sysconf_names.", 
        "name": "os.sysconf", 
        "params": [], 
        "path": "python/library/os#os.sysconf", 
        "syntax": "os.sysconf(name)", 
        "type": "Operating System"
    }, 
    "os.sysconf_names": {
        "descr": "Dictionary mapping names accepted by sysconf() to the integer values defined for those names by the host operating system. This can be used to determine the set of names known to the system.", 
        "name": "os.sysconf_names", 
        "params": [], 
        "path": "python/library/os#os.sysconf_names", 
        "syntax": "os.sysconf_names", 
        "type": "Operating System"
    }, 
    "os.system": {
        "descr": "Execute the command (a string) in a subshell. This is implemented by calling the Standard C function system(), and has the same limitations. Changes to sys.stdin, etc. are not reflected in the environment of the executed command. If command generates any output, it will be sent to the interpreter standard output stream.", 
        "name": "os.system", 
        "params": [], 
        "path": "python/library/os#os.system", 
        "syntax": "os.system(command)", 
        "type": "Operating System"
    }, 
    "os.tcgetpgrp": {
        "descr": "Return the process group associated with the terminal given by fd (an open file descriptor as returned by os.open()).", 
        "name": "os.tcgetpgrp", 
        "params": [], 
        "path": "python/library/os#os.tcgetpgrp", 
        "syntax": "os.tcgetpgrp(fd)", 
        "type": "Operating System"
    }, 
    "os.tcsetpgrp": {
        "descr": "Set the process group associated with the terminal given by fd (an open file descriptor as returned by os.open()) to pg.", 
        "name": "os.tcsetpgrp", 
        "params": [], 
        "path": "python/library/os#os.tcsetpgrp", 
        "syntax": "os.tcsetpgrp(fd, pg)", 
        "type": "Operating System"
    }, 
    "os.terminal_size": {
        "descr": "A subclass of tuple, holding (columns, lines) of the terminal window size.", 
        "name": "os.terminal_size", 
        "params": [], 
        "path": "python/library/os#os.terminal_size", 
        "syntax": "class os.terminal_size", 
        "type": "Operating System"
    }, 
    "os.terminal_size.columns": {
        "descr": "Width of the terminal window in characters.", 
        "name": "os.terminal_size.columns", 
        "params": [], 
        "path": "python/library/os#os.terminal_size.columns", 
        "syntax": "columns", 
        "type": "Operating System"
    }, 
    "os.terminal_size.lines": {
        "descr": "Height of the terminal window in characters.", 
        "name": "os.terminal_size.lines", 
        "params": [], 
        "path": "python/library/os#os.terminal_size.lines", 
        "syntax": "lines", 
        "type": "Operating System"
    }, 
    "os.times": {
        "descr": "Returns the current global process times. The return value is an object with five attributes:", 
        "name": "os.times", 
        "params": [], 
        "path": "python/library/os#os.times", 
        "syntax": "os.times()", 
        "type": "Operating System"
    }, 
    "os.truncate": {
        "descr": "Truncate the file corresponding to path, so that it is at most length bytes in size.", 
        "name": "os.truncate", 
        "params": [], 
        "path": "python/library/os#os.truncate", 
        "syntax": "os.truncate(path, length)", 
        "type": "Operating System"
    }, 
    "os.ttyname": {
        "descr": "Return a string which specifies the terminal device associated with file descriptor fd. If fd is not associated with a terminal device, an exception is raised.", 
        "name": "os.ttyname", 
        "params": [], 
        "path": "python/library/os#os.ttyname", 
        "syntax": "os.ttyname(fd)", 
        "type": "Operating System"
    }, 
    "os.umask": {
        "descr": "Set the current numeric umask and return the previous umask.", 
        "name": "os.umask", 
        "params": [], 
        "path": "python/library/os#os.umask", 
        "syntax": "os.umask(mask)", 
        "type": "Operating System"
    }, 
    "os.uname": {
        "descr": "For backwards compatibility, this object is also iterable, behaving like a five-tuple containing sysname, nodename, release, version, and machine in that order.", 
        "name": "os.uname", 
        "params": [], 
        "path": "python/library/os#os.uname", 
        "syntax": "os.uname()", 
        "type": "Operating System"
    }, 
    "os.unlink": {
        "descr": "Remove (delete) the file path. This function is identical to remove(); the unlink name is its traditional Unix name. Please see the documentation for remove() for further information.", 
        "name": "os.unlink", 
        "params": [], 
        "path": "python/library/os#os.unlink", 
        "syntax": "os.unlink(path, *, dir_fd=None)", 
        "type": "Operating System"
    }, 
    "os.unsetenv": {
        "descr": "When unsetenv() is supported, deletion of items in os.environ is automatically translated into a corresponding call to unsetenv(); however, calls to unsetenv() don\u2019t update os.environ, so it is actually preferable to delete items of os.environ.", 
        "name": "os.unsetenv", 
        "params": [], 
        "path": "python/library/os#os.unsetenv", 
        "syntax": "os.unsetenv(key)", 
        "type": "Operating System"
    }, 
    "os.urandom": {
        "descr": "Return a string of n random bytes suitable for cryptographic use.", 
        "name": "os.urandom", 
        "params": [], 
        "path": "python/library/os#os.urandom", 
        "syntax": "os.urandom(n)", 
        "type": "Operating System"
    }, 
    "os.utime": {
        "descr": "Set the access and modified times of the file specified by path.", 
        "name": "os.utime", 
        "params": [], 
        "path": "python/library/os#os.utime", 
        "syntax": "os.utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True)", 
        "type": "Operating System"
    }, 
    "os.wait": {
        "descr": "Similar to waitpid(), except a 3-element tuple, containing the child\u2019s process id, exit status indication, and resource usage information is returned. Refer to resource.getrusage() for details on resource usage information. The arguments to wait4() are the same as those provided to waitpid().", 
        "name": "os.wait", 
        "params": [], 
        "path": "python/library/os#os.wait", 
        "syntax": "os.wait4(pid, options)", 
        "type": "Operating System"
    }, 
    "os.wait3": {
        "descr": "Similar to waitpid(), except no process id argument is given and a 3-element tuple containing the child\u2019s process id, exit status indication, and resource usage information is returned. Refer to resource.getrusage() for details on resource usage information. The option argument is the same as that provided to waitpid() and wait4().", 
        "name": "os.wait3", 
        "params": [], 
        "path": "python/library/os#os.wait3", 
        "syntax": "os.wait3(options)", 
        "type": "Operating System"
    }, 
    "os.wait4": {
        "descr": "Similar to waitpid(), except a 3-element tuple, containing the child\u2019s process id, exit status indication, and resource usage information is returned. Refer to resource.getrusage() for details on resource usage information. The arguments to wait4() are the same as those provided to waitpid().", 
        "name": "os.wait4", 
        "params": [], 
        "path": "python/library/os#os.wait4", 
        "syntax": "os.wait4(pid, options)", 
        "type": "Operating System"
    }, 
    "os.waitid": {
        "descr": "Wait for the completion of one or more child processes. idtype can be P_PID, P_PGID or P_ALL. id specifies the pid to wait on. options is constructed from the ORing of one or more of WEXITED, WSTOPPED or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT. The return value is an object representing the data contained in the siginfo_t structure, namely: si_pid, si_uid, si_signo, si_status, si_code or None if WNOHANG is specified and there are no children in a waitable state.", 
        "name": "os.waitid", 
        "params": [], 
        "path": "python/library/os#os.waitid", 
        "syntax": "os.waitid(idtype, id, options)", 
        "type": "Operating System"
    }, 
    "os.waitpid": {
        "descr": "The details of this function differ on Unix and Windows.", 
        "name": "os.waitpid", 
        "params": [], 
        "path": "python/library/os#os.waitpid", 
        "syntax": "os.waitpid(pid, options)", 
        "type": "Operating System"
    }, 
    "os.walk": {
        "descr": "dirpath is a string, the path to the directory. dirnames is a list of the names of the subdirectories in dirpath (excluding '.' and '..'). filenames is a list of the names of the non-directory files in dirpath. Note that the names in the lists contain no path components. To get a full path (which begins with top) to a file or directory in dirpath, do os.path.join(dirpath, name).", 
        "name": "os.walk", 
        "params": [], 
        "path": "python/library/os#os.walk", 
        "syntax": "os.walk(top, topdown=True, onerror=None, followlinks=False)", 
        "type": "Operating System"
    }, 
    "os.write": {
        "descr": "Write the bytestring in str to file descriptor fd. Return the number of bytes actually written.", 
        "name": "os.write", 
        "params": [], 
        "path": "python/library/os#os.write", 
        "syntax": "os.write(fd, str)", 
        "type": "Operating System"
    }, 
    "os.writev": {
        "descr": "Write the contents of buffers to file descriptor fd. buffers must be a sequence of bytes-like objects. writev() writes the contents of each object to the file descriptor and returns the total number of bytes written.", 
        "name": "os.writev", 
        "params": [], 
        "path": "python/library/os#os.writev", 
        "syntax": "os.writev(fd, buffers)", 
        "type": "Operating System"
    }, 
    "ossaudiodev.OSSAudioError": {
        "descr": "This exception is raised on certain errors. The argument is a string describing what went wrong.", 
        "name": "ossaudiodev.OSSAudioError", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.OSSAudioError", 
        "syntax": "exception ossaudiodev.OSSAudioError", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.open": {
        "descr": "Open an audio device and return an OSS audio device object. This object supports many file-like methods, such as read(), write(), and fileno() (although there are subtle differences between conventional Unix read/write semantics and those of OSS audio devices). It also supports a number of audio-specific methods; see below for the complete list of methods.", 
        "name": "ossaudiodev.open", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.open", 
        "syntax": "ossaudiodev.open(mode)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.openmixer": {
        "descr": "Open a mixer device and return an OSS mixer device object. device is the mixer device filename to use. If it is not specified, this module first looks in the environment variable MIXERDEV for a device to use. If not found, it falls back to /dev/mixer.", 
        "name": "ossaudiodev.openmixer", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.openmixer", 
        "syntax": "ossaudiodev.openmixer([device])", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.bufsize": {
        "descr": "Returns the size of the hardware buffer, in samples.", 
        "name": "ossaudiodev.oss_audio_device.bufsize", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.bufsize", 
        "syntax": "oss_audio_device.bufsize()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.channels": {
        "descr": "Set the number of output channels to nchannels. A value of 1 indicates monophonic sound, 2 stereophonic. Some devices may have more than 2 channels, and some high-end devices may not support mono. Returns the number of channels the device was set to.", 
        "name": "ossaudiodev.oss_audio_device.channels", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.channels", 
        "syntax": "oss_audio_device.channels(nchannels)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.close": {
        "descr": "Explicitly close the audio device. When you are done writing to or reading from an audio device, you should explicitly close it. A closed device cannot be used again.", 
        "name": "ossaudiodev.oss_audio_device.close", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.close", 
        "syntax": "oss_audio_device.close()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.closed": {
        "descr": "Boolean indicating whether the device has been closed.", 
        "name": "ossaudiodev.oss_audio_device.closed", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.closed", 
        "syntax": "oss_audio_device.closed", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.fileno": {
        "descr": "Return the file descriptor associated with the device.", 
        "name": "ossaudiodev.oss_audio_device.fileno", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.fileno", 
        "syntax": "oss_audio_device.fileno()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.getfmts": {
        "descr": "Return a bitmask of the audio output formats supported by the soundcard. Some of the formats supported by OSS are:", 
        "name": "ossaudiodev.oss_audio_device.getfmts", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.getfmts", 
        "syntax": "oss_audio_device.getfmts()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.mode": {
        "descr": "The I/O mode for the file, either \"r\", \"rw\", or \"w\".", 
        "name": "ossaudiodev.oss_audio_device.mode", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.mode", 
        "syntax": "oss_audio_device.mode", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.name": {
        "descr": "String containing the name of the device file.", 
        "name": "ossaudiodev.oss_audio_device.name", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.name", 
        "syntax": "oss_audio_device.name", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.nonblock": {
        "descr": "Put the device into non-blocking mode. Once in non-blocking mode, there is no way to return it to blocking mode.", 
        "name": "ossaudiodev.oss_audio_device.nonblock", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.nonblock", 
        "syntax": "oss_audio_device.nonblock()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.obufcount": {
        "descr": "Returns the number of samples that are in the hardware buffer yet to be played.", 
        "name": "ossaudiodev.oss_audio_device.obufcount", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.obufcount", 
        "syntax": "oss_audio_device.obufcount()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.obuffree": {
        "descr": "Returns the number of samples that could be queued into the hardware buffer to be played without blocking.", 
        "name": "ossaudiodev.oss_audio_device.obuffree", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.obuffree", 
        "syntax": "oss_audio_device.obuffree()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.post": {
        "descr": "Tell the driver that there is likely to be a pause in the output, making it possible for the device to handle the pause more intelligently. You might use this after playing a spot sound effect, before waiting for user input, or before doing disk I/O.", 
        "name": "ossaudiodev.oss_audio_device.post", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.post", 
        "syntax": "oss_audio_device.post()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.read": {
        "descr": "Read size bytes from the audio input and return them as a Python string. Unlike most Unix device drivers, OSS audio devices in blocking mode (the default) will block read() until the entire requested amount of data is available.", 
        "name": "ossaudiodev.oss_audio_device.read", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.read", 
        "syntax": "oss_audio_device.read(size)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.reset": {
        "descr": "Immediately stop playing or recording and return the device to a state where it can accept commands. The OSS documentation recommends closing and re-opening the device after calling reset().", 
        "name": "ossaudiodev.oss_audio_device.reset", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.reset", 
        "syntax": "oss_audio_device.reset()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.setfmt": {
        "descr": "Try to set the current audio format to format\u2014see getfmts() for a list. Returns the audio format that the device was set to, which may not be the requested format. May also be used to return the current audio format\u2014do this by passing an \u201caudio format\u201d of AFMT_QUERY.", 
        "name": "ossaudiodev.oss_audio_device.setfmt", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.setfmt", 
        "syntax": "oss_audio_device.setfmt(format)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.setparameters": {
        "descr": "Set the key audio sampling parameters\u2014sample format, number of channels, and sampling rate\u2014in one method call. format, nchannels, and samplerate should be as specified in the setfmt(), channels(), and speed() methods. If strict is true, setparameters() checks to see if each parameter was actually set to the requested value, and raises OSSAudioError if not. Returns a tuple (format, nchannels, samplerate) indicating the parameter values that were actually set by the device driver (i.e., the same as the return values of setfmt(), channels(), and speed()).", 
        "name": "ossaudiodev.oss_audio_device.setparameters", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.setparameters", 
        "syntax": "oss_audio_device.setparameters(format, nchannels, samplerate[, strict=False])", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.speed": {
        "descr": "Try to set the audio sampling rate to samplerate samples per second. Returns the rate actually set. Most sound devices don\u2019t support arbitrary sampling rates. Common rates are:", 
        "name": "ossaudiodev.oss_audio_device.speed", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.speed", 
        "syntax": "oss_audio_device.speed(samplerate)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.sync": {
        "descr": "Wait until the sound device has played every byte in its buffer. (This happens implicitly when the device is closed.) The OSS documentation recommends closing and re-opening the device rather than using sync().", 
        "name": "ossaudiodev.oss_audio_device.sync", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.sync", 
        "syntax": "oss_audio_device.sync()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.write": {
        "descr": "Write the Python string data to the audio device and return the number of bytes written. If the audio device is in blocking mode (the default), the entire string is always written (again, this is different from usual Unix device semantics). If the device is in non-blocking mode, some data may not be written \u2014see writeall().", 
        "name": "ossaudiodev.oss_audio_device.write", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.write", 
        "syntax": "oss_audio_device.write(data)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_audio_device.writeall": {
        "descr": "Write the entire Python string data to the audio device: waits until the audio device is able to accept data, writes as much data as it will accept, and repeats until data has been completely written. If the device is in blocking mode (the default), this has the same effect as write(); writeall() is only useful in non-blocking mode. Has no return value, since the amount of data written is always equal to the amount of data supplied.", 
        "name": "ossaudiodev.oss_audio_device.writeall", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_audio_device.writeall", 
        "syntax": "oss_audio_device.writeall(data)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.close": {
        "descr": "This method closes the open mixer device file. Any further attempts to use the mixer after this file is closed will raise an OSError.", 
        "name": "ossaudiodev.oss_mixer_device.close", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.close", 
        "syntax": "oss_mixer_device.close()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.controls": {
        "descr": "This method returns a bitmask specifying the available mixer controls (\u201cControl\u201d being a specific mixable \u201cchannel\u201d, such as SOUND_MIXER_PCM or SOUND_MIXER_SYNTH). This bitmask indicates a subset of all available mixer controls\u2014the SOUND_MIXER_* constants defined at module level. To determine if, for example, the current mixer object supports a PCM mixer, use the following Python code:", 
        "name": "ossaudiodev.oss_mixer_device.controls", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.controls", 
        "syntax": "oss_mixer_device.controls()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.fileno": {
        "descr": "Returns the file handle number of the open mixer device file.", 
        "name": "ossaudiodev.oss_mixer_device.fileno", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.fileno", 
        "syntax": "oss_mixer_device.fileno()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.get": {
        "descr": "Returns the volume of a given mixer control. The returned volume is a 2-tuple (left_volume,right_volume). Volumes are specified as numbers from 0 (silent) to 100 (full volume). If the control is monophonic, a 2-tuple is still returned, but both volumes are the same.", 
        "name": "ossaudiodev.oss_mixer_device.get", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.get", 
        "syntax": "oss_mixer_device.get(control)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.get_recsrc": {
        "descr": "This method returns a bitmask indicating which control(s) are currently being used as a recording source.", 
        "name": "ossaudiodev.oss_mixer_device.get_recsrc", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.get_recsrc", 
        "syntax": "oss_mixer_device.get_recsrc()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.reccontrols": {
        "descr": "Returns a bitmask specifying the mixer controls that may be used to record. See the code example for controls() for an example of reading from a bitmask.", 
        "name": "ossaudiodev.oss_mixer_device.reccontrols", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.reccontrols", 
        "syntax": "oss_mixer_device.reccontrols()", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.set": {
        "descr": "Sets the volume for a given mixer control to (left,right). left and right must be ints and between 0 (silent) and 100 (full volume). On success, the new volume is returned as a 2-tuple. Note that this may not be exactly the same as the volume specified, because of the limited resolution of some soundcard\u2019s mixers.", 
        "name": "ossaudiodev.oss_mixer_device.set", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.set", 
        "syntax": "oss_mixer_device.set(control, (left, right))", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.set_recsrc": {
        "descr": "Call this function to specify a recording source. Returns a bitmask indicating the new recording source (or sources) if successful; raises OSError if an invalid source was specified. To set the current recording source to the microphone input:", 
        "name": "ossaudiodev.oss_mixer_device.set_recsrc", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.set_recsrc", 
        "syntax": "oss_mixer_device.set_recsrc(bitmask)", 
        "type": "Multimedia"
    }, 
    "ossaudiodev.oss_mixer_device.stereocontrols": {
        "descr": "Returns a bitmask indicating stereo mixer controls. If a bit is set, the corresponding control is stereo; if it is unset, the control is either monophonic or not supported by the mixer (use in combination with controls() to determine which).", 
        "name": "ossaudiodev.oss_mixer_device.stereocontrols", 
        "params": [], 
        "path": "python/library/ossaudiodev#ossaudiodev.oss_mixer_device.stereocontrols", 
        "syntax": "oss_mixer_device.stereocontrols()", 
        "type": "Multimedia"
    }, 
    "partition": {
        "descr": "Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.", 
        "name": "str.partition", 
        "params": [], 
        "path": "python/library/stdtypes#str.partition", 
        "syntax": "str.partition(sep)", 
        "type": "Built-in Types"
    }, 
    "pdb.Pdb": {
        "descr": "Pdb is the debugger class.", 
        "name": "pdb.Pdb", 
        "params": [], 
        "path": "python/library/pdb#pdb.Pdb", 
        "syntax": "class pdb.Pdb(completekey='tab', stdin=None, stdout=None, skip=None, nosigint=False)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.Pdb.run": {
        "descr": "See the documentation for the functions explained above.", 
        "name": "pdb.Pdb.run", 
        "params": [], 
        "path": "python/library/pdb#pdb.Pdb.run", 
        "syntax": "run(statement, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.Pdb.runcall": {
        "descr": "See the documentation for the functions explained above.", 
        "name": "pdb.Pdb.runcall", 
        "params": [], 
        "path": "python/library/pdb#pdb.Pdb.runcall", 
        "syntax": "runcall(function, *args, **kwds)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.Pdb.runeval": {
        "descr": "See the documentation for the functions explained above.", 
        "name": "pdb.Pdb.runeval", 
        "params": [], 
        "path": "python/library/pdb#pdb.Pdb.runeval", 
        "syntax": "runeval(expression, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.Pdb.set_trace": {
        "descr": "See the documentation for the functions explained above.", 
        "name": "pdb.Pdb.set_trace", 
        "params": [], 
        "path": "python/library/pdb#pdb.Pdb.set_trace", 
        "syntax": "set_trace()", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.pm": {
        "descr": "Enter post-mortem debugging of the traceback found in sys.last_traceback.", 
        "name": "pdb.pm", 
        "params": [], 
        "path": "python/library/pdb#pdb.pm", 
        "syntax": "pdb.pm()", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.post_mortem": {
        "descr": "Enter post-mortem debugging of the given traceback object. If no traceback is given, it uses the one of the exception that is currently being handled (an exception must be being handled if the default is to be used).", 
        "name": "pdb.post_mortem", 
        "params": [], 
        "path": "python/library/pdb#pdb.post_mortem", 
        "syntax": "pdb.post_mortem(traceback=None)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.run": {
        "descr": "Execute the statement (given as a string or a code object) under debugger control. The debugger prompt appears before any code is executed; you can set breakpoints and type continue, or you can step through the statement using step or next (all these commands are explained below). The optional globals and locals arguments specify the environment in which the code is executed; by default the dictionary of the module __main__ is used. (See the explanation of the built-in exec() or eval() functions.)", 
        "name": "pdb.run", 
        "params": [], 
        "path": "python/library/pdb#pdb.run", 
        "syntax": "pdb.run(statement, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.runcall": {
        "descr": "Call the function (a function or method object, not a string) with the given arguments. When runcall() returns, it returns whatever the function call returned. The debugger prompt appears as soon as the function is entered.", 
        "name": "pdb.runcall", 
        "params": [], 
        "path": "python/library/pdb#pdb.runcall", 
        "syntax": "pdb.runcall(function, *args, **kwds)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.runeval": {
        "descr": "Evaluate the expression (given as a string or a code object) under debugger control. When runeval() returns, it returns the value of the expression. Otherwise this function is similar to run().", 
        "name": "pdb.runeval", 
        "params": [], 
        "path": "python/library/pdb#pdb.runeval", 
        "syntax": "pdb.runeval(expression, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "pdb.set_trace": {
        "descr": "Enter the debugger at the calling stack frame. This is useful to hard-code a breakpoint at a given point in a program, even if the code is not otherwise being debugged (e.g. when an assertion fails).", 
        "name": "pdb.set_trace", 
        "params": [], 
        "path": "python/library/pdb#pdb.set_trace", 
        "syntax": "pdb.set_trace()", 
        "type": "Debugging & Profiling"
    }, 
    "pickle.PickleError": {
        "descr": "Common base class for the other pickling exceptions. It inherits Exception.", 
        "name": "pickle.PickleError", 
        "params": [], 
        "path": "python/library/pickle#pickle.PickleError", 
        "syntax": "exception pickle.PickleError", 
        "type": "Data Persistence"
    }, 
    "pickle.Pickler": {
        "descr": "This takes a binary file for writing a pickle data stream.", 
        "name": "pickle.Pickler", 
        "params": [], 
        "path": "python/library/pickle#pickle.Pickler", 
        "syntax": "class pickle.Pickler(file, protocol=None, *, fix_imports=True)", 
        "type": "Data Persistence"
    }, 
    "pickle.Pickler.dispatch_table": {
        "descr": "A pickler object\u2019s dispatch table is a registry of reduction functions of the kind which can be declared using copyreg.pickle(). It is a mapping whose keys are classes and whose values are reduction functions. A reduction function takes a single argument of the associated class and should conform to the same interface as a __reduce__() method.", 
        "name": "pickle.Pickler.dispatch_table", 
        "params": [], 
        "path": "python/library/pickle#pickle.Pickler.dispatch_table", 
        "syntax": "dispatch_table", 
        "type": "Data Persistence"
    }, 
    "pickle.Pickler.dump": {
        "descr": "Write a pickled representation of obj to the open file object given in the constructor.", 
        "name": "pickle.Pickler.dump", 
        "params": [], 
        "path": "python/library/pickle#pickle.Pickler.dump", 
        "syntax": "dump(obj)", 
        "type": "Data Persistence"
    }, 
    "pickle.Pickler.fast": {
        "descr": "Deprecated. Enable fast mode if set to a true value. The fast mode disables the usage of memo, therefore speeding the pickling process by not generating superfluous PUT opcodes. It should not be used with self-referential objects, doing otherwise will cause Pickler to recurse infinitely.", 
        "name": "pickle.Pickler.fast", 
        "params": [], 
        "path": "python/library/pickle#pickle.Pickler.fast", 
        "syntax": "fast", 
        "type": "Data Persistence"
    }, 
    "pickle.Pickler.persistent_id": {
        "descr": "Do nothing by default. This exists so a subclass can override it.", 
        "name": "pickle.Pickler.persistent_id", 
        "params": [], 
        "path": "python/library/pickle#pickle.Pickler.persistent_id", 
        "syntax": "persistent_id(obj)", 
        "type": "Data Persistence"
    }, 
    "pickle.PicklingError": {
        "descr": "Error raised when an unpicklable object is encountered by Pickler. It inherits PickleError.", 
        "name": "pickle.PicklingError", 
        "params": [], 
        "path": "python/library/pickle#pickle.PicklingError", 
        "syntax": "exception pickle.PicklingError", 
        "type": "Data Persistence"
    }, 
    "pickle.Unpickler": {
        "descr": "This takes a binary file for reading a pickle data stream.", 
        "name": "pickle.Unpickler", 
        "params": [], 
        "path": "python/library/pickle#pickle.Unpickler", 
        "syntax": "class pickle.Unpickler(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\")", 
        "type": "Data Persistence"
    }, 
    "pickle.Unpickler.find_class": {
        "descr": "Import module if necessary and return the object called name from it, where the module and name arguments are str objects. Note, unlike its name suggests, find_class() is also used for finding functions.", 
        "name": "pickle.Unpickler.find_class", 
        "params": [], 
        "path": "python/library/pickle#pickle.Unpickler.find_class", 
        "syntax": "find_class(module, name)", 
        "type": "Data Persistence"
    }, 
    "pickle.Unpickler.load": {
        "descr": "Read a pickled object representation from the open file object given in the constructor, and return the reconstituted object hierarchy specified therein. Bytes past the pickled object\u2019s representation are ignored.", 
        "name": "pickle.Unpickler.load", 
        "params": [], 
        "path": "python/library/pickle#pickle.Unpickler.load", 
        "syntax": "load()", 
        "type": "Data Persistence"
    }, 
    "pickle.Unpickler.persistent_load": {
        "descr": "Raise an UnpicklingError by default.", 
        "name": "pickle.Unpickler.persistent_load", 
        "params": [], 
        "path": "python/library/pickle#pickle.Unpickler.persistent_load", 
        "syntax": "persistent_load(pid)", 
        "type": "Data Persistence"
    }, 
    "pickle.UnpicklingError": {
        "descr": "Error raised when there is a problem unpickling an object, such as a data corruption or a security violation. It inherits PickleError.", 
        "name": "pickle.UnpicklingError", 
        "params": [], 
        "path": "python/library/pickle#pickle.UnpicklingError", 
        "syntax": "exception pickle.UnpicklingError", 
        "type": "Data Persistence"
    }, 
    "pickle.dump": {
        "descr": "Write a pickled representation of obj to the open file object file. This is equivalent to Pickler(file, protocol).dump(obj).", 
        "name": "pickle.dump", 
        "params": [], 
        "path": "python/library/pickle#pickle.dump", 
        "syntax": "pickle.dump(obj, file, protocol=None, *, fix_imports=True)", 
        "type": "Data Persistence"
    }, 
    "pickle.dumps": {
        "descr": "Return the pickled representation of the object as a bytes object, instead of writing it to a file.", 
        "name": "pickle.dumps", 
        "params": [], 
        "path": "python/library/pickle#pickle.dumps", 
        "syntax": "pickle.dumps(obj, protocol=None, *, fix_imports=True)", 
        "type": "Data Persistence"
    }, 
    "pickle.load": {
        "descr": "Read a pickled object representation from the open file object file and return the reconstituted object hierarchy specified therein. This is equivalent to Unpickler(file).load().", 
        "name": "pickle.load", 
        "params": [], 
        "path": "python/library/pickle#pickle.load", 
        "syntax": "pickle.load(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\")", 
        "type": "Data Persistence"
    }, 
    "pickle.loads": {
        "descr": "Read a pickled object hierarchy from a bytes object and return the reconstituted object hierarchy specified therein", 
        "name": "pickle.loads", 
        "params": [], 
        "path": "python/library/pickle#pickle.loads", 
        "syntax": "pickle.loads(bytes_object, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\")", 
        "type": "Data Persistence"
    }, 
    "pipes.Template": {
        "descr": "An abstraction of a pipeline.", 
        "name": "pipes.Template", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template", 
        "syntax": "class pipes.Template", 
        "type": "Unix"
    }, 
    "pipes.Template.append": {
        "descr": "Append a new action at the end. The cmd variable must be a valid bourne shell command. The kind variable consists of two letters.", 
        "name": "pipes.Template.append", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.append", 
        "syntax": "Template.append(cmd, kind)", 
        "type": "Unix"
    }, 
    "pipes.Template.clone": {
        "descr": "Return a new, equivalent, pipeline template.", 
        "name": "pipes.Template.clone", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.clone", 
        "syntax": "Template.clone()", 
        "type": "Unix"
    }, 
    "pipes.Template.copy": {
        "descr": "Copy infile to outfile through the pipe.", 
        "name": "pipes.Template.copy", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.copy", 
        "syntax": "Template.copy(infile, outfile)", 
        "type": "Unix"
    }, 
    "pipes.Template.debug": {
        "descr": "If flag is true, turn debugging on. Otherwise, turn debugging off. When debugging is on, commands to be executed are printed, and the shell is given set -x command to be more verbose.", 
        "name": "pipes.Template.debug", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.debug", 
        "syntax": "Template.debug(flag)", 
        "type": "Unix"
    }, 
    "pipes.Template.open": {
        "descr": "Return a file-like object, open to file, but read from or written to by the pipeline. Note that only one of 'r', 'w' may be given.", 
        "name": "pipes.Template.open", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.open", 
        "syntax": "Template.open(file, mode)", 
        "type": "Unix"
    }, 
    "pipes.Template.prepend": {
        "descr": "Add a new action at the beginning. See append() for explanations of the arguments.", 
        "name": "pipes.Template.prepend", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.prepend", 
        "syntax": "Template.prepend(cmd, kind)", 
        "type": "Unix"
    }, 
    "pipes.Template.reset": {
        "descr": "Restore a pipeline template to its initial state.", 
        "name": "pipes.Template.reset", 
        "params": [], 
        "path": "python/library/pipes#pipes.Template.reset", 
        "syntax": "Template.reset()", 
        "type": "Unix"
    }, 
    "pkgutil.ImpImporter": {
        "descr": "PEP 302 Importer that wraps Python\u2019s \u201cclassic\u201d import algorithm.", 
        "name": "pkgutil.ImpImporter", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.ImpImporter", 
        "syntax": "class pkgutil.ImpImporter(dirname=None)", 
        "type": "Importing"
    }, 
    "pkgutil.ImpLoader": {
        "descr": "PEP 302 Loader that wraps Python\u2019s \u201cclassic\u201d import algorithm.", 
        "name": "pkgutil.ImpLoader", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.ImpLoader", 
        "syntax": "class pkgutil.ImpLoader(fullname, file, filename, etc)", 
        "type": "Importing"
    }, 
    "pkgutil.extend_path": {
        "descr": "Extend the search path for the modules which comprise a package. Intended use is to place the following code in a package\u2019s __init__.py:", 
        "name": "pkgutil.extend_path", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.extend_path", 
        "syntax": "pkgutil.extend_path(path, name)", 
        "type": "Importing"
    }, 
    "pkgutil.find_loader": {
        "descr": "Retrieve a PEP 302 module loader for the given fullname.", 
        "name": "pkgutil.find_loader", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.find_loader", 
        "syntax": "pkgutil.find_loader(fullname)", 
        "type": "Importing"
    }, 
    "pkgutil.get_data": {
        "descr": "Get a resource from a package.", 
        "name": "pkgutil.get_data", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.get_data", 
        "syntax": "pkgutil.get_data(package, resource)", 
        "type": "Importing"
    }, 
    "pkgutil.get_importer": {
        "descr": "Retrieve a PEP 302 importer for the given path_item.", 
        "name": "pkgutil.get_importer", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.get_importer", 
        "syntax": "pkgutil.get_importer(path_item)", 
        "type": "Importing"
    }, 
    "pkgutil.get_loader": {
        "descr": "Get a PEP 302 \u201cloader\u201d object for module_or_name.", 
        "name": "pkgutil.get_loader", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.get_loader", 
        "syntax": "pkgutil.get_loader(module_or_name)", 
        "type": "Importing"
    }, 
    "pkgutil.iter_importers": {
        "descr": "Yield PEP 302 importers for the given module name.", 
        "name": "pkgutil.iter_importers", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.iter_importers", 
        "syntax": "pkgutil.iter_importers(fullname='')", 
        "type": "Importing"
    }, 
    "pkgutil.iter_modules": {
        "descr": "Yields (module_finder, name, ispkg) for all submodules on path, or, if path is None, all top-level modules on sys.path.", 
        "name": "pkgutil.iter_modules", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.iter_modules", 
        "syntax": "pkgutil.iter_modules(path=None, prefix='')", 
        "type": "Importing"
    }, 
    "pkgutil.walk_packages": {
        "descr": "Yields (module_finder, name, ispkg) for all modules recursively on path, or, if path is None, all accessible modules.", 
        "name": "pkgutil.walk_packages", 
        "params": [], 
        "path": "python/library/pkgutil#pkgutil.walk_packages", 
        "syntax": "pkgutil.walk_packages(path=None, prefix='', onerror=None)", 
        "type": "Importing"
    }, 
    "platform.architecture": {
        "descr": "Queries the given executable (defaults to the Python interpreter binary) for various architecture information.", 
        "name": "platform.architecture", 
        "params": [], 
        "path": "python/library/platform#platform.architecture", 
        "syntax": "platform.architecture(executable=sys.executable, bits='', linkage='')", 
        "type": "Operating System"
    }, 
    "platform.dist": {
        "descr": "This is another name for linux_distribution().", 
        "name": "platform.dist", 
        "params": [], 
        "path": "python/library/platform#platform.dist", 
        "syntax": "platform.dist(distname='', version='', id='', supported_dists=('SuSE', 'debian', 'redhat', 'mandrake', ...))", 
        "type": "Operating System"
    }, 
    "platform.java_ver": {
        "descr": "Version interface for Jython.", 
        "name": "platform.java_ver", 
        "params": [], 
        "path": "python/library/platform#platform.java_ver", 
        "syntax": "platform.java_ver(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))", 
        "type": "Operating System"
    }, 
    "platform.libc_ver": {
        "descr": "Tries to determine the libc version against which the file executable (defaults to the Python interpreter) is linked. Returns a tuple of strings (lib, version) which default to the given parameters in case the lookup fails.", 
        "name": "platform.libc_ver", 
        "params": [], 
        "path": "python/library/platform#platform.libc_ver", 
        "syntax": "platform.libc_ver(executable=sys.executable, lib='', version='', chunksize=2048)", 
        "type": "Operating System"
    }, 
    "platform.linux_distribution": {
        "descr": "Tries to determine the name of the Linux OS distribution name.", 
        "name": "platform.linux_distribution", 
        "params": [], 
        "path": "python/library/platform#platform.linux_distribution", 
        "syntax": "platform.linux_distribution(distname='', version='', id='', supported_dists=('SuSE', 'debian', 'redhat', 'mandrake', ...), full_distribution_name=1)", 
        "type": "Operating System"
    }, 
    "platform.mac_ver": {
        "descr": "Get Mac OS version information and return it as tuple (release, versioninfo, machine) with versioninfo being a tuple (version, dev_stage, non_release_version).", 
        "name": "platform.mac_ver", 
        "params": [], 
        "path": "python/library/platform#platform.mac_ver", 
        "syntax": "platform.mac_ver(release='', versioninfo=('', '', ''), machine='')", 
        "type": "Operating System"
    }, 
    "platform.machine": {
        "descr": "Returns the machine type, e.g. 'i386'. An empty string is returned if the value cannot be determined.", 
        "name": "platform.machine", 
        "params": [], 
        "path": "python/library/platform#platform.machine", 
        "syntax": "platform.machine()", 
        "type": "Operating System"
    }, 
    "platform.node": {
        "descr": "Returns the computer\u2019s network name (may not be fully qualified!). An empty string is returned if the value cannot be determined.", 
        "name": "platform.node", 
        "params": [], 
        "path": "python/library/platform#platform.node", 
        "syntax": "platform.node()", 
        "type": "Operating System"
    }, 
    "platform.platform": {
        "descr": "Returns a single string identifying the underlying platform with as much useful information as possible.", 
        "name": "platform.platform", 
        "params": [], 
        "path": "python/library/platform#platform.platform", 
        "syntax": "platform.platform(aliased=0, terse=0)", 
        "type": "Operating System"
    }, 
    "platform.popen": {
        "descr": "Portable popen() interface. Find a working popen implementation preferring win32pipe.popen(). On Windows NT, win32pipe.popen() should work; on Windows 9x it hangs due to bugs in the MS C library.", 
        "name": "platform.popen", 
        "params": [], 
        "path": "python/library/platform#platform.popen", 
        "syntax": "platform.popen(cmd, mode='r', bufsize=-1)", 
        "type": "Operating System"
    }, 
    "platform.processor": {
        "descr": "Returns the (real) processor name, e.g. 'amdk6'.", 
        "name": "platform.processor", 
        "params": [], 
        "path": "python/library/platform#platform.processor", 
        "syntax": "platform.processor()", 
        "type": "Operating System"
    }, 
    "platform.python_branch": {
        "descr": "Returns a string identifying the Python implementation SCM branch.", 
        "name": "platform.python_branch", 
        "params": [], 
        "path": "python/library/platform#platform.python_branch", 
        "syntax": "platform.python_branch()", 
        "type": "Operating System"
    }, 
    "platform.python_build": {
        "descr": "Returns a tuple (buildno, builddate) stating the Python build number and date as strings.", 
        "name": "platform.python_build", 
        "params": [], 
        "path": "python/library/platform#platform.python_build", 
        "syntax": "platform.python_build()", 
        "type": "Operating System"
    }, 
    "platform.python_compiler": {
        "descr": "Returns a string identifying the compiler used for compiling Python.", 
        "name": "platform.python_compiler", 
        "params": [], 
        "path": "python/library/platform#platform.python_compiler", 
        "syntax": "platform.python_compiler()", 
        "type": "Operating System"
    }, 
    "platform.python_implementation": {
        "descr": "Returns a string identifying the Python implementation. Possible return values are: \u2018CPython\u2019, \u2018IronPython\u2019, \u2018Jython\u2019, \u2018PyPy\u2019.", 
        "name": "platform.python_implementation", 
        "params": [], 
        "path": "python/library/platform#platform.python_implementation", 
        "syntax": "platform.python_implementation()", 
        "type": "Operating System"
    }, 
    "platform.python_revision": {
        "descr": "Returns a string identifying the Python implementation SCM revision.", 
        "name": "platform.python_revision", 
        "params": [], 
        "path": "python/library/platform#platform.python_revision", 
        "syntax": "platform.python_revision()", 
        "type": "Operating System"
    }, 
    "platform.python_version": {
        "descr": "Returns the Python version as string 'major.minor.patchlevel'", 
        "name": "platform.python_version", 
        "params": [], 
        "path": "python/library/platform#platform.python_version", 
        "syntax": "platform.python_version()", 
        "type": "Operating System"
    }, 
    "platform.python_version_tuple": {
        "descr": "Returns the Python version as tuple (major, minor, patchlevel) of strings.", 
        "name": "platform.python_version_tuple", 
        "params": [], 
        "path": "python/library/platform#platform.python_version_tuple", 
        "syntax": "platform.python_version_tuple()", 
        "type": "Operating System"
    }, 
    "platform.release": {
        "descr": "Returns the system\u2019s release, e.g. '2.2.0' or 'NT' An empty string is returned if the value cannot be determined.", 
        "name": "platform.release", 
        "params": [], 
        "path": "python/library/platform#platform.release", 
        "syntax": "platform.release()", 
        "type": "Operating System"
    }, 
    "platform.system": {
        "descr": "Returns the system/OS name, e.g. 'Linux', 'Windows', or 'Java'. An empty string is returned if the value cannot be determined.", 
        "name": "platform.system", 
        "params": [], 
        "path": "python/library/platform#platform.system", 
        "syntax": "platform.system()", 
        "type": "Operating System"
    }, 
    "platform.system_alias": {
        "descr": "Returns (system, release, version) aliased to common marketing names used for some systems. It also does some reordering of the information in some cases where it would otherwise cause confusion.", 
        "name": "platform.system_alias", 
        "params": [], 
        "path": "python/library/platform#platform.system_alias", 
        "syntax": "platform.system_alias(system, release, version)", 
        "type": "Operating System"
    }, 
    "platform.uname": {
        "descr": "Fairly portable uname interface. Returns a namedtuple() containing six attributes: system, node, release, version, machine, and processor.", 
        "name": "platform.uname", 
        "params": [], 
        "path": "python/library/platform#platform.uname", 
        "syntax": "platform.uname()", 
        "type": "Operating System"
    }, 
    "platform.version": {
        "descr": "Returns the system\u2019s release version, e.g. '#3 on degas'. An empty string is returned if the value cannot be determined.", 
        "name": "platform.version", 
        "params": [], 
        "path": "python/library/platform#platform.version", 
        "syntax": "platform.version()", 
        "type": "Operating System"
    }, 
    "platform.win32_ver": {
        "descr": "Get additional version information from the Windows Registry and return a tuple (release, version, csd, ptype) referring to OS release, version number, CSD level (service pack) and OS type (multi/single processor).", 
        "name": "platform.win32_ver", 
        "params": [], 
        "path": "python/library/platform#platform.win32_ver", 
        "syntax": "platform.win32_ver(release='', version='', csd='', ptype='')", 
        "type": "Operating System"
    }, 
    "plistlib.Data": {
        "descr": "Return a \u201cdata\u201d wrapper object around the bytes object data. This is used in functions converting from/to plists to represent the <data> type available in plists.", 
        "name": "plistlib.Data", 
        "params": [], 
        "path": "python/library/plistlib#plistlib.Data", 
        "syntax": "class plistlib.Data(data)", 
        "type": "File Formats"
    }, 
    "plistlib.readPlist": {
        "descr": "Read a plist file. pathOrFile may either be a file name or a (readable and binary) file object. Return the unpacked root object (which usually is a dictionary).", 
        "name": "plistlib.readPlist", 
        "params": [], 
        "path": "python/library/plistlib#plistlib.readPlist", 
        "syntax": "plistlib.readPlist(pathOrFile)", 
        "type": "File Formats"
    }, 
    "plistlib.readPlistFromBytes": {
        "descr": "Read a plist data from a bytes object. Return the root object.", 
        "name": "plistlib.readPlistFromBytes", 
        "params": [], 
        "path": "python/library/plistlib#plistlib.readPlistFromBytes", 
        "syntax": "plistlib.readPlistFromBytes(data)", 
        "type": "File Formats"
    }, 
    "plistlib.writePlist": {
        "descr": "Write rootObject to a plist file. pathOrFile may either be a file name or a (writable and binary) file object.", 
        "name": "plistlib.writePlist", 
        "params": [], 
        "path": "python/library/plistlib#plistlib.writePlist", 
        "syntax": "plistlib.writePlist(rootObject, pathOrFile)", 
        "type": "File Formats"
    }, 
    "plistlib.writePlistToBytes": {
        "descr": "Return rootObject as a plist-formatted bytes object.", 
        "name": "plistlib.writePlistToBytes", 
        "params": [], 
        "path": "python/library/plistlib#plistlib.writePlistToBytes", 
        "syntax": "plistlib.writePlistToBytes(rootObject)", 
        "type": "File Formats"
    }, 
    "pop": {
        "descr": "If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised.", 
        "name": "dict.pop", 
        "params": [], 
        "path": "python/library/stdtypes#dict.pop", 
        "syntax": "pop(key[, default])", 
        "type": "Built-in Types"
    }, 
    "popitem": {
        "descr": "Remove and return an arbitrary (key, value) pair from the dictionary.", 
        "name": "dict.popitem", 
        "params": [], 
        "path": "python/library/stdtypes#dict.popitem", 
        "syntax": "popitem()", 
        "type": "Built-in Types"
    }, 
    "poplib.POP3": {
        "descr": "This class implements the actual POP3 protocol. The connection is created when the instance is initialized. If port is omitted, the standard POP3 port (110) is used. The optional timeout parameter specifies a timeout in seconds for the connection attempt (if not specified, the global default timeout setting will be used).", 
        "name": "poplib.POP3", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3", 
        "syntax": "class poplib.POP3(host, port=POP3_PORT[, timeout])", 
        "type": "Internet"
    }, 
    "poplib.POP3.apop": {
        "descr": "Use the more secure APOP authentication to log into the POP3 server.", 
        "name": "poplib.POP3.apop", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.apop", 
        "syntax": "POP3.apop(user, secret)", 
        "type": "Internet"
    }, 
    "poplib.POP3.dele": {
        "descr": "Flag message number which for deletion. On most servers deletions are not actually performed until QUIT (the major exception is Eudora QPOP, which deliberately violates the RFCs by doing pending deletes on any disconnect).", 
        "name": "poplib.POP3.dele", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.dele", 
        "syntax": "POP3.dele(which)", 
        "type": "Internet"
    }, 
    "poplib.POP3.getwelcome": {
        "descr": "Returns the greeting string sent by the POP3 server.", 
        "name": "poplib.POP3.getwelcome", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.getwelcome", 
        "syntax": "POP3.getwelcome()", 
        "type": "Internet"
    }, 
    "poplib.POP3.list": {
        "descr": "Request message list, result is in the form (response, ['mesg_num octets', ...], octets). If which is set, it is the message to list.", 
        "name": "poplib.POP3.list", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.list", 
        "syntax": "POP3.list([which])", 
        "type": "Internet"
    }, 
    "poplib.POP3.noop": {
        "descr": "Do nothing. Might be used as a keep-alive.", 
        "name": "poplib.POP3.noop", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.noop", 
        "syntax": "POP3.noop()", 
        "type": "Internet"
    }, 
    "poplib.POP3.pass_": {
        "descr": "Send password, response includes message count and mailbox size. Note: the mailbox on the server is locked until quit() is called.", 
        "name": "poplib.POP3.pass_", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.pass_", 
        "syntax": "POP3.pass_(password)", 
        "type": "Internet"
    }, 
    "poplib.POP3.quit": {
        "descr": "Signoff: commit changes, unlock mailbox, drop connection.", 
        "name": "poplib.POP3.quit", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.quit", 
        "syntax": "POP3.quit()", 
        "type": "Internet"
    }, 
    "poplib.POP3.retr": {
        "descr": "Retrieve whole message number which, and set its seen flag. Result is in form (response, ['line', ...], octets).", 
        "name": "poplib.POP3.retr", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.retr", 
        "syntax": "POP3.retr(which)", 
        "type": "Internet"
    }, 
    "poplib.POP3.rpop": {
        "descr": "Use RPOP authentication (similar to UNIX r-commands) to log into POP3 server.", 
        "name": "poplib.POP3.rpop", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.rpop", 
        "syntax": "POP3.rpop(user)", 
        "type": "Internet"
    }, 
    "poplib.POP3.rset": {
        "descr": "Remove any deletion marks for the mailbox.", 
        "name": "poplib.POP3.rset", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.rset", 
        "syntax": "POP3.rset()", 
        "type": "Internet"
    }, 
    "poplib.POP3.set_debuglevel": {
        "descr": "Set the instance\u2019s debugging level. This controls the amount of debugging output printed. The default, 0, produces no debugging output. A value of 1 produces a moderate amount of debugging output, generally a single line per request. A value of 2 or higher produces the maximum amount of debugging output, logging each line sent and received on the control connection.", 
        "name": "poplib.POP3.set_debuglevel", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.set_debuglevel", 
        "syntax": "POP3.set_debuglevel(level)", 
        "type": "Internet"
    }, 
    "poplib.POP3.stat": {
        "descr": "Get mailbox status. The result is a tuple of 2 integers: (message count, mailbox size).", 
        "name": "poplib.POP3.stat", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.stat", 
        "syntax": "POP3.stat()", 
        "type": "Internet"
    }, 
    "poplib.POP3.top": {
        "descr": "Retrieves the message header plus howmuch lines of the message after the header of message number which. Result is in form (response, ['line', ...], octets).", 
        "name": "poplib.POP3.top", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.top", 
        "syntax": "POP3.top(which, howmuch)", 
        "type": "Internet"
    }, 
    "poplib.POP3.uidl": {
        "descr": "Return message digest (unique id) list. If which is specified, result contains the unique id for that message in the form 'response mesgnum uid, otherwise result is list (response, ['mesgnum uid', ...], octets).", 
        "name": "poplib.POP3.uidl", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.uidl", 
        "syntax": "POP3.uidl(which=None)", 
        "type": "Internet"
    }, 
    "poplib.POP3.user": {
        "descr": "Send user command, response should indicate that a password is required.", 
        "name": "poplib.POP3.user", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3.user", 
        "syntax": "POP3.user(username)", 
        "type": "Internet"
    }, 
    "poplib.POP3_SSL": {
        "descr": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket. If port is not specified, 995, the standard POP3-over-SSL port is used. keyfile and certfile are also optional - they can contain a PEM formatted private key and certificate chain file for the SSL connection. timeout works as in the POP3 constructor. context parameter is a ssl.SSLContext object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure.", 
        "name": "poplib.POP3_SSL", 
        "params": [], 
        "path": "python/library/poplib#poplib.POP3_SSL", 
        "syntax": "class poplib.POP3_SSL(host, port=POP3_SSL_PORT, keyfile=None, certfile=None, timeout=None, context=None)", 
        "type": "Internet"
    }, 
    "poplib.error_proto": {
        "descr": "Exception raised on any errors from this module (errors from socket module are not caught). The reason for the exception is passed to the constructor as a string.", 
        "name": "poplib.error_proto", 
        "params": [], 
        "path": "python/library/poplib#poplib.error_proto", 
        "syntax": "exception poplib.error_proto", 
        "type": "Internet"
    }, 
    "pos": {
        "descr": "The value of pos which was passed to the search() or match() method of a regex object. This is the index into the string at which the RE engine started looking for a match.", 
        "name": "re.match.pos", 
        "params": [], 
        "path": "python/library/re#re.match.pos", 
        "syntax": "match.pos", 
        "type": "Text Processing"
    }, 
    "posix.environ": {
        "descr": "A dictionary representing the string environment at the time the interpreter was started. Keys and values are bytes on Unix and str on Windows. For example, environ[b'HOME'] (environ['HOME'] on Windows) is the pathname of your home directory, equivalent to getenv(\"HOME\") in C.", 
        "name": "posix.environ", 
        "params": [], 
        "path": "python/library/posix#posix.environ", 
        "syntax": "posix.environ", 
        "type": "Unix"
    }, 
    "pow": {
        "descr": "Return x to the power y; if z is present, return x to the power y, modulo z (computed more efficiently than pow(x, y) % z). The two-argument form pow(x, y) is equivalent to using the power operator: x**y.", 
        "name": "pow", 
        "params": [], 
        "path": "python/library/functions#pow", 
        "syntax": "pow(x, y[, z])", 
        "type": "Built-in Functions"
    }, 
    "pprint.PrettyPrinter": {
        "descr": "Construct a PrettyPrinter instance. This constructor understands several keyword parameters. An output stream may be set using the stream keyword; the only method used on the stream object is the file protocol\u2019s write() method. If not specified, the PrettyPrinter adopts sys.stdout. Three additional parameters may be used to control the formatted representation. The keywords are indent, depth, and width. The amount of indentation added for each recursive level is specified by indent; the default is one. Other values can cause output to look a little odd, but can make nesting easier to spot. The number of levels which may be printed is controlled by depth; if the data structure being printed is too deep, the next contained level is replaced by .... By default, there is no constraint on the depth of the objects being formatted. The desired output width is constrained using the width parameter; the default is 80 characters. If a structure cannot be formatted within the constrained width, a best effort will be made.", 
        "name": "pprint.PrettyPrinter", 
        "params": [], 
        "path": "python/library/pprint#pprint.PrettyPrinter", 
        "syntax": "class pprint.PrettyPrinter(indent=1, width=80, depth=None, stream=None)", 
        "type": "Data Types"
    }, 
    "pprint.PrettyPrinter.format": {
        "descr": "Returns three values: the formatted version of object as a string, a flag indicating whether the result is readable, and a flag indicating whether recursion was detected. The first argument is the object to be presented. The second is a dictionary which contains the id() of objects that are part of the current presentation context (direct and indirect containers for object that are affecting the presentation) as the keys; if an object needs to be presented which is already represented in context, the third return value should be True. Recursive calls to the format() method should add additional entries for containers to this dictionary. The third argument, maxlevels, gives the requested limit to recursion; this will be 0 if there is no requested limit. This argument should be passed unmodified to recursive calls. The fourth argument, level, gives the current level; recursive calls should be passed a value less than that of the current call.", 
        "name": "pprint.PrettyPrinter.format", 
        "params": [], 
        "path": "python/library/pprint#pprint.PrettyPrinter.format", 
        "syntax": "PrettyPrinter.format(object, context, maxlevels, level)", 
        "type": "Data Types"
    }, 
    "pprint.PrettyPrinter.isreadable": {
        "descr": "", 
        "name": "pprint.PrettyPrinter.isreadable", 
        "params": [], 
        "path": "python/library/pprint#pprint.PrettyPrinter.isreadable", 
        "syntax": "PrettyPrinter.isreadable(object)", 
        "type": "Data Types"
    }, 
    "pprint.PrettyPrinter.isrecursive": {
        "descr": "Determine if the object requires a recursive representation.", 
        "name": "pprint.PrettyPrinter.isrecursive", 
        "params": [], 
        "path": "python/library/pprint#pprint.PrettyPrinter.isrecursive", 
        "syntax": "PrettyPrinter.isrecursive(object)", 
        "type": "Data Types"
    }, 
    "pprint.PrettyPrinter.pformat": {
        "descr": "Return the formatted representation of object. This takes into account the options passed to the PrettyPrinter constructor.", 
        "name": "pprint.PrettyPrinter.pformat", 
        "params": [], 
        "path": "python/library/pprint#pprint.PrettyPrinter.pformat", 
        "syntax": "PrettyPrinter.pformat(object)", 
        "type": "Data Types"
    }, 
    "pprint.PrettyPrinter.pprint": {
        "descr": "Print the formatted representation of object on the configured stream, followed by a newline.", 
        "name": "pprint.PrettyPrinter.pprint", 
        "params": [], 
        "path": "python/library/pprint#pprint.PrettyPrinter.pprint", 
        "syntax": "PrettyPrinter.pprint(object)", 
        "type": "Data Types"
    }, 
    "pprint.isreadable": {
        "descr": "", 
        "name": "pprint.isreadable", 
        "params": [], 
        "path": "python/library/pprint#pprint.isreadable", 
        "syntax": "pprint.isreadable(object)", 
        "type": "Data Types"
    }, 
    "pprint.isrecursive": {
        "descr": "Determine if object requires a recursive representation.", 
        "name": "pprint.isrecursive", 
        "params": [], 
        "path": "python/library/pprint#pprint.isrecursive", 
        "syntax": "pprint.isrecursive(object)", 
        "type": "Data Types"
    }, 
    "pprint.pformat": {
        "descr": "Return the formatted representation of object as a string. indent, width and depth will be passed to the PrettyPrinter constructor as formatting parameters.", 
        "name": "pprint.pformat", 
        "params": [], 
        "path": "python/library/pprint#pprint.pformat", 
        "syntax": "pprint.pformat(object, indent=1, width=80, depth=None)", 
        "type": "Data Types"
    }, 
    "pprint.pprint": {
        "descr": "Prints the formatted representation of object on stream, followed by a newline. If stream is None, sys.stdout is used. This may be used in the interactive interpreter instead of the print() function for inspecting values (you can even reassign print = pprint.pprint for use within a scope). indent, width and depth will be passed to the PrettyPrinter constructor as formatting parameters.", 
        "name": "pprint.pprint", 
        "params": [], 
        "path": "python/library/pprint#pprint.pprint", 
        "syntax": "pprint.pprint(object, stream=None, indent=1, width=80, depth=None)", 
        "type": "Data Types"
    }, 
    "pprint.saferepr": {
        "descr": "Return a string representation of object, protected against recursive data structures. If the representation of object exposes a recursive entry, the recursive reference will be represented as <Recursion on typename with id=number>. The representation is not otherwise formatted.", 
        "name": "pprint.saferepr", 
        "params": [], 
        "path": "python/library/pprint#pprint.saferepr", 
        "syntax": "pprint.saferepr(object)", 
        "type": "Data Types"
    }, 
    "print": {
        "descr": "Print objects to the stream file, separated by sep and followed by end. sep, end and file, if present, must be given as keyword arguments.", 
        "name": "print", 
        "params": [], 
        "path": "python/library/functions#print", 
        "syntax": "print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False)", 
        "type": "Built-in Functions"
    }, 
    "profile.Profile": {
        "descr": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run() function provides.", 
        "name": "profile.Profile", 
        "params": [], 
        "path": "python/library/profile#profile.Profile", 
        "syntax": "class profile.Profile(timer=None, timeunit=0.0, subcalls=True, builtins=True)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.create_stats": {
        "descr": "Stop collecting profiling data and record the results internally as the current profile.", 
        "name": "profile.Profile.create_stats", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.create_stats", 
        "syntax": "create_stats()", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.disable": {
        "descr": "Stop collecting profiling data.", 
        "name": "profile.Profile.disable", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.disable", 
        "syntax": "disable()", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.dump_stats": {
        "descr": "Write the results of the current profile to filename.", 
        "name": "profile.Profile.dump_stats", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.dump_stats", 
        "syntax": "dump_stats(filename)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.enable": {
        "descr": "Start collecting profiling data.", 
        "name": "profile.Profile.enable", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.enable", 
        "syntax": "enable()", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.print_stats": {
        "descr": "Create a Stats object based on the current profile and print the results to stdout.", 
        "name": "profile.Profile.print_stats", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.print_stats", 
        "syntax": "print_stats(sort=-1)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.run": {
        "descr": "Profile the cmd via exec().", 
        "name": "profile.Profile.run", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.run", 
        "syntax": "run(cmd)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.runcall": {
        "descr": "Profile func(*args, **kwargs)", 
        "name": "profile.Profile.runcall", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.runcall", 
        "syntax": "runcall(func, *args, **kwargs)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.Profile.runctx": {
        "descr": "Profile the cmd via exec() with the specified global and local environment.", 
        "name": "profile.Profile.runctx", 
        "params": [], 
        "path": "python/library/profile#profile.Profile.runctx", 
        "syntax": "runctx(cmd, globals, locals)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.run": {
        "descr": "This function takes a single argument that can be passed to the exec() function, and an optional file name. In all cases this routine executes:", 
        "name": "profile.run", 
        "params": [], 
        "path": "python/library/profile#profile.run", 
        "syntax": "profile.run(command, filename=None, sort=-1)", 
        "type": "Debugging & Profiling"
    }, 
    "profile.runctx": {
        "descr": "This function is similar to run(), with added arguments to supply the globals and locals dictionaries for the command string. This routine executes:", 
        "name": "profile.runctx", 
        "params": [], 
        "path": "python/library/profile#profile.runctx", 
        "syntax": "profile.runctx(command, globals, locals, filename=None)", 
        "type": "Debugging & Profiling"
    }, 
    "property": {
        "descr": "Return a property attribute.", 
        "name": "property", 
        "params": [], 
        "path": "python/library/functions#property", 
        "syntax": "property(fget=None, fset=None, fdel=None, doc=None)", 
        "type": "Built-in Functions"
    }, 
    "pstats.Stats": {
        "descr": "This class constructor creates an instance of a \u201cstatistics object\u201d from a filename (or list of filenames) or from a Profile instance. Output will be printed to the stream specified by stream.", 
        "name": "pstats.Stats", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats", 
        "syntax": "class pstats.Stats(*filenames or profile, stream=sys.stdout)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.add": {
        "descr": "This method of the Stats class accumulates additional profiling information into the current profiling object. Its arguments should refer to filenames created by the corresponding version of profile.run() or cProfile.run(). Statistics for identically named (re: file, line, name) functions are automatically accumulated into single function statistics.", 
        "name": "pstats.Stats.add", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.add", 
        "syntax": "add(*filenames)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.dump_stats": {
        "descr": "Save the data loaded into the Stats object to a file named filename. The file is created if it does not exist, and is overwritten if it already exists. This is equivalent to the method of the same name on the profile.Profile and cProfile.Profile classes.", 
        "name": "pstats.Stats.dump_stats", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.dump_stats", 
        "syntax": "dump_stats(filename)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.print_callees": {
        "descr": "This method for the Stats class prints a list of all function that were called by the indicated function. Aside from this reversal of direction of calls (re: called vs was called by), the arguments and ordering are identical to the print_callers() method.", 
        "name": "pstats.Stats.print_callees", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.print_callees", 
        "syntax": "print_callees(*restrictions)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.print_callers": {
        "descr": "This method for the Stats class prints a list of all functions that called each function in the profiled database. The ordering is identical to that provided by print_stats(), and the definition of the restricting argument is also identical. Each caller is reported on its own line. The format differs slightly depending on the profiler that produced the stats:", 
        "name": "pstats.Stats.print_callers", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.print_callers", 
        "syntax": "print_callers(*restrictions)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.print_stats": {
        "descr": "This method for the Stats class prints out a report as described in the profile.run() definition.", 
        "name": "pstats.Stats.print_stats", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.print_stats", 
        "syntax": "print_stats(*restrictions)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.reverse_order": {
        "descr": "This method for the Stats class reverses the ordering of the basic list within the object. Note that by default ascending vs descending order is properly selected based on the sort key of choice.", 
        "name": "pstats.Stats.reverse_order", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.reverse_order", 
        "syntax": "reverse_order()", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.sort_stats": {
        "descr": "This method modifies the Stats object by sorting it according to the supplied criteria. The argument is typically a string identifying the basis of a sort (example: 'time' or 'name').", 
        "name": "pstats.Stats.sort_stats", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.sort_stats", 
        "syntax": "sort_stats(*keys)", 
        "type": "Debugging & Profiling"
    }, 
    "pstats.Stats.strip_dirs": {
        "descr": "This method for the Stats class removes all leading path information from file names. It is very useful in reducing the size of the printout to fit within (close to) 80 columns. This method modifies the object, and the stripped information is lost. After performing a strip operation, the object is considered to have its entries in a \u201crandom\u201d order, as it was just after object initialization and loading. If strip_dirs() causes two function names to be indistinguishable (they are on the same line of the same filename, and have the same function name), then the statistics for these two entries are accumulated into a single entry.", 
        "name": "pstats.Stats.strip_dirs", 
        "params": [], 
        "path": "python/library/profile#pstats.Stats.strip_dirs", 
        "syntax": "strip_dirs()", 
        "type": "Debugging & Profiling"
    }, 
    "pty.fork": {
        "descr": "Fork. Connect the child\u2019s controlling terminal to a pseudo-terminal. Return value is (pid, fd). Note that the child gets pid 0, and the fd is invalid. The parent\u2019s return value is the pid of the child, and fd is a file descriptor connected to the child\u2019s controlling terminal (and also to the child\u2019s standard input and output).", 
        "name": "pty.fork", 
        "params": [], 
        "path": "python/library/pty#pty.fork", 
        "syntax": "pty.fork()", 
        "type": "Unix"
    }, 
    "pty.openpty": {
        "descr": "Open a new pseudo-terminal pair, using os.openpty() if possible, or emulation code for generic Unix systems. Return a pair of file descriptors (master, slave), for the master and the slave end, respectively.", 
        "name": "pty.openpty", 
        "params": [], 
        "path": "python/library/pty#pty.openpty", 
        "syntax": "pty.openpty()", 
        "type": "Unix"
    }, 
    "pty.spawn": {
        "descr": "Spawn a process, and connect its controlling terminal with the current process\u2019s standard io. This is often used to baffle programs which insist on reading from the controlling terminal.", 
        "name": "pty.spawn", 
        "params": [], 
        "path": "python/library/pty#pty.spawn", 
        "syntax": "pty.spawn(argv[, master_read[, stdin_read]])", 
        "type": "Unix"
    }, 
    "pwd.getpwall": {
        "descr": "Return a list of all available password database entries, in arbitrary order.", 
        "name": "pwd.getpwall", 
        "params": [], 
        "path": "python/library/pwd#pwd.getpwall", 
        "syntax": "pwd.getpwall()", 
        "type": "Unix"
    }, 
    "pwd.getpwnam": {
        "descr": "Return the password database entry for the given user name.", 
        "name": "pwd.getpwnam", 
        "params": [], 
        "path": "python/library/pwd#pwd.getpwnam", 
        "syntax": "pwd.getpwnam(name)", 
        "type": "Unix"
    }, 
    "pwd.getpwuid": {
        "descr": "Return the password database entry for the given numeric user ID.", 
        "name": "pwd.getpwuid", 
        "params": [], 
        "path": "python/library/pwd#pwd.getpwuid", 
        "syntax": "pwd.getpwuid(uid)", 
        "type": "Unix"
    }, 
    "queue.Empty": {
        "descr": "Exception raised when non-blocking get() (or get_nowait()) is called on a Queue object which is empty.", 
        "name": "queue.Empty", 
        "params": [], 
        "path": "python/library/queue#queue.Empty", 
        "syntax": "exception queue.Empty", 
        "type": "Concurrent Execution"
    }, 
    "queue.Full": {
        "descr": "Exception raised when non-blocking put() (or put_nowait()) is called on a Queue object which is full.", 
        "name": "queue.Full", 
        "params": [], 
        "path": "python/library/queue#queue.Full", 
        "syntax": "exception queue.Full", 
        "type": "Concurrent Execution"
    }, 
    "queue.LifoQueue": {
        "descr": "Constructor for a LIFO queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.", 
        "name": "queue.LifoQueue", 
        "params": [], 
        "path": "python/library/queue#queue.LifoQueue", 
        "syntax": "class queue.LifoQueue(maxsize=0)", 
        "type": "Concurrent Execution"
    }, 
    "queue.PriorityQueue": {
        "descr": "Constructor for a priority queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.", 
        "name": "queue.PriorityQueue", 
        "params": [], 
        "path": "python/library/queue#queue.PriorityQueue", 
        "syntax": "class queue.PriorityQueue(maxsize=0)", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue": {
        "descr": "Constructor for a FIFO queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.", 
        "name": "queue.Queue", 
        "params": [], 
        "path": "python/library/queue#queue.Queue", 
        "syntax": "class queue.Queue(maxsize=0)", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.empty": {
        "descr": "Return True if the queue is empty, False otherwise. If empty() returns True it doesn\u2019t guarantee that a subsequent call to put() will not block. Similarly, if empty() returns False it doesn\u2019t guarantee that a subsequent call to get() will not block.", 
        "name": "queue.Queue.empty", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.empty", 
        "syntax": "Queue.empty()", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.full": {
        "descr": "Return True if the queue is full, False otherwise. If full() returns True it doesn\u2019t guarantee that a subsequent call to get() will not block. Similarly, if full() returns False it doesn\u2019t guarantee that a subsequent call to put() will not block.", 
        "name": "queue.Queue.full", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.full", 
        "syntax": "Queue.full()", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.get": {
        "descr": "Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).", 
        "name": "queue.Queue.get", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.get", 
        "syntax": "Queue.get(block=True, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.get_nowait": {
        "descr": "Equivalent to get(False).", 
        "name": "queue.Queue.get_nowait", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.get_nowait", 
        "syntax": "Queue.get_nowait()", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.join": {
        "descr": "Blocks until all items in the queue have been gotten and processed.", 
        "name": "queue.Queue.join", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.join", 
        "syntax": "Queue.join()", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.put": {
        "descr": "Put item into the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case).", 
        "name": "queue.Queue.put", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.put", 
        "syntax": "Queue.put(item, block=True, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.put_nowait": {
        "descr": "Equivalent to put(item, False).", 
        "name": "queue.Queue.put_nowait", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.put_nowait", 
        "syntax": "Queue.put_nowait(item)", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.qsize": {
        "descr": "Return the approximate size of the queue. Note, qsize() > 0 doesn\u2019t guarantee that a subsequent get() will not block, nor will qsize() < maxsize guarantee that put() will not block.", 
        "name": "queue.Queue.qsize", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.qsize", 
        "syntax": "Queue.qsize()", 
        "type": "Concurrent Execution"
    }, 
    "queue.Queue.task_done": {
        "descr": "Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.", 
        "name": "queue.Queue.task_done", 
        "params": [], 
        "path": "python/library/queue#queue.Queue.task_done", 
        "syntax": "Queue.task_done()", 
        "type": "Concurrent Execution"
    }, 
    "quit": {
        "descr": "Objects that when printed, print a message like \u201cUse quit() or Ctrl-D (i.e. EOF) to exit\u201d, and when called, raise SystemExit with the specified exit code.", 
        "name": "quit", 
        "params": [], 
        "path": "python/library/constants#quit", 
        "syntax": "quit(code=None)", 
        "type": "Built-in Constants"
    }, 
    "quopri.decode": {
        "descr": "Decode the contents of the input file and write the resulting decoded binary data to the output file. input and output must be file objects. input will be read until input.readline() returns an empty string. If the optional argument header is present and true, underscore will be decoded as space. This is used to decode \u201cQ\u201d-encoded headers as described in RFC 1522: \u201cMIME (Multipurpose Internet Mail Extensions) Part Two: Message Header Extensions for Non-ASCII Text\u201d.", 
        "name": "quopri.decode", 
        "params": [], 
        "path": "python/library/quopri#quopri.decode", 
        "syntax": "quopri.decode(input, output, header=False)", 
        "type": "Internet Data"
    }, 
    "quopri.decodestring": {
        "descr": "Like decode(), except that it accepts a source string and returns the corresponding decoded string.", 
        "name": "quopri.decodestring", 
        "params": [], 
        "path": "python/library/quopri#quopri.decodestring", 
        "syntax": "quopri.decodestring(s, header=False)", 
        "type": "Internet Data"
    }, 
    "quopri.encode": {
        "descr": "Encode the contents of the input file and write the resulting quoted-printable data to the output file. input and output must be file objects. input will be read until input.readline() returns an empty string. quotetabs is a flag which controls whether to encode embedded spaces and tabs; when true it encodes such embedded whitespace, and when false it leaves them unencoded. Note that spaces and tabs appearing at the end of lines are always encoded, as per RFC 1521. header is a flag which controls if spaces are encoded as underscores as per RFC 1522.", 
        "name": "quopri.encode", 
        "params": [], 
        "path": "python/library/quopri#quopri.encode", 
        "syntax": "quopri.encode(input, output, quotetabs, header=False)", 
        "type": "Internet Data"
    }, 
    "quopri.encodestring": {
        "descr": "Like encode(), except that it accepts a source string and returns the corresponding encoded string. quotetabs and header are optional (defaulting to False), and are passed straight through to encode().", 
        "name": "quopri.encodestring", 
        "params": [], 
        "path": "python/library/quopri#quopri.encodestring", 
        "syntax": "quopri.encodestring(s, quotetabs=False, header=False)", 
        "type": "Internet Data"
    }, 
    "random.SystemRandom": {
        "descr": "Class that uses the os.urandom() function for generating random numbers from sources provided by the operating system. Not available on all systems. Does not rely on software state, and sequences are not reproducible. Accordingly, the seed() method has no effect and is ignored. The getstate() and setstate() methods raise NotImplementedError if called.", 
        "name": "random.SystemRandom", 
        "params": [], 
        "path": "python/library/random#random.SystemRandom", 
        "syntax": "class random.SystemRandom([seed])", 
        "type": "Numeric & Mathematical"
    }, 
    "random.betavariate": {
        "descr": "Beta distribution. Conditions on the parameters are alpha > 0 and beta > 0. Returned values range between 0 and 1.", 
        "name": "random.betavariate", 
        "params": [], 
        "path": "python/library/random#random.betavariate", 
        "syntax": "random.betavariate(alpha, beta)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.choice": {
        "descr": "Return a random element from the non-empty sequence seq. If seq is empty, raises IndexError.", 
        "name": "random.choice", 
        "params": [], 
        "path": "python/library/random#random.choice", 
        "syntax": "random.choice(seq)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.expovariate": {
        "descr": "Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called \u201clambda\u201d, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative.", 
        "name": "random.expovariate", 
        "params": [], 
        "path": "python/library/random#random.expovariate", 
        "syntax": "random.expovariate(lambd)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.gammavariate": {
        "descr": "Gamma distribution. (Not the gamma function!) Conditions on the parameters are alpha > 0 and beta > 0.", 
        "name": "random.gammavariate", 
        "params": [], 
        "path": "python/library/random#random.gammavariate", 
        "syntax": "random.gammavariate(alpha, beta)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.gauss": {
        "descr": "Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the normalvariate() function defined below.", 
        "name": "random.gauss", 
        "params": [], 
        "path": "python/library/random#random.gauss", 
        "syntax": "random.gauss(mu, sigma)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.getrandbits": {
        "descr": "Returns a Python integer with k random bits. This method is supplied with the MersenneTwister generator and some other generators may also provide it as an optional part of the API. When available, getrandbits() enables randrange() to handle arbitrarily large ranges.", 
        "name": "random.getrandbits", 
        "params": [], 
        "path": "python/library/random#random.getrandbits", 
        "syntax": "random.getrandbits(k)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.getstate": {
        "descr": "Return an object capturing the current internal state of the generator. This object can be passed to setstate() to restore the state.", 
        "name": "random.getstate", 
        "params": [], 
        "path": "python/library/random#random.getstate", 
        "syntax": "random.getstate()", 
        "type": "Numeric & Mathematical"
    }, 
    "random.lognormvariate": {
        "descr": "Log normal distribution. If you take the natural logarithm of this distribution, you\u2019ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero.", 
        "name": "random.lognormvariate", 
        "params": [], 
        "path": "python/library/random#random.lognormvariate", 
        "syntax": "random.lognormvariate(mu, sigma)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.normalvariate": {
        "descr": "Normal distribution. mu is the mean, and sigma is the standard deviation.", 
        "name": "random.normalvariate", 
        "params": [], 
        "path": "python/library/random#random.normalvariate", 
        "syntax": "random.normalvariate(mu, sigma)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.paretovariate": {
        "descr": "Pareto distribution. alpha is the shape parameter.", 
        "name": "random.paretovariate", 
        "params": [], 
        "path": "python/library/random#random.paretovariate", 
        "syntax": "random.paretovariate(alpha)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.randint": {
        "descr": "Return a random integer N such that a <= N <= b. Alias for randrange(a, b+1).", 
        "name": "random.randint", 
        "params": [], 
        "path": "python/library/random#random.randint", 
        "syntax": "random.randint(a, b)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.random": {
        "descr": "Return the next random floating point number in the range [0.0, 1.0).", 
        "name": "random.random", 
        "params": [], 
        "path": "python/library/random#random.random", 
        "syntax": "random.random()", 
        "type": "Numeric & Mathematical"
    }, 
    "random.randrange": {
        "descr": "Return a randomly selected element from range(start, stop, step). This is equivalent to choice(range(start, stop, step)), but doesn\u2019t actually build a range object.", 
        "name": "random.randrange", 
        "params": [], 
        "path": "python/library/random#random.randrange", 
        "syntax": "random.randrange(stop)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.sample": {
        "descr": "Return a k length list of unique elements chosen from the population sequence or set. Used for random sampling without replacement.", 
        "name": "random.sample", 
        "params": [], 
        "path": "python/library/random#random.sample", 
        "syntax": "random.sample(population, k)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.seed": {
        "descr": "Initialize the random number generator.", 
        "name": "random.seed", 
        "params": [], 
        "path": "python/library/random#random.seed", 
        "syntax": "random.seed(a=None, version=2)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.setstate": {
        "descr": "state should have been obtained from a previous call to getstate(), and setstate() restores the internal state of the generator to what it was at the time getstate() was called.", 
        "name": "random.setstate", 
        "params": [], 
        "path": "python/library/random#random.setstate", 
        "syntax": "random.setstate(state)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.shuffle": {
        "descr": "Shuffle the sequence x in place. The optional argument random is a 0-argument function returning a random float in [0.0, 1.0); by default, this is the function random().", 
        "name": "random.shuffle", 
        "params": [], 
        "path": "python/library/random#random.shuffle", 
        "syntax": "random.shuffle(x[, random])", 
        "type": "Numeric & Mathematical"
    }, 
    "random.triangular": {
        "descr": "Return a random floating point number N such that low <= N <= high and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution.", 
        "name": "random.triangular", 
        "params": [], 
        "path": "python/library/random#random.triangular", 
        "syntax": "random.triangular(low, high, mode)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.uniform": {
        "descr": "Return a random floating point number N such that a <= N <= b for a <= b and b <= N <= a for b < a.", 
        "name": "random.uniform", 
        "params": [], 
        "path": "python/library/random#random.uniform", 
        "syntax": "random.uniform(a, b)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.vonmisesvariate": {
        "descr": "mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi.", 
        "name": "random.vonmisesvariate", 
        "params": [], 
        "path": "python/library/random#random.vonmisesvariate", 
        "syntax": "random.vonmisesvariate(mu, kappa)", 
        "type": "Numeric & Mathematical"
    }, 
    "random.weibullvariate": {
        "descr": "Weibull distribution. alpha is the scale parameter and beta is the shape parameter.", 
        "name": "random.weibullvariate", 
        "params": [], 
        "path": "python/library/random#random.weibullvariate", 
        "syntax": "random.weibullvariate(alpha, beta)", 
        "type": "Numeric & Mathematical"
    }, 
    "range": {
        "descr": "Rather than being a function, range is actually an immutable sequence type, as documented in Ranges and Sequence Types \u2014 list, tuple, range.", 
        "name": "range", 
        "params": [], 
        "path": "python/library/functions#range", 
        "syntax": "range(stop)", 
        "type": "Built-in Functions"
    }, 
    "re": {
        "descr": "The regular expression object whose match() or search() method produced this match instance.", 
        "name": "re.match.re", 
        "params": [], 
        "path": "python/library/re#re.match.re", 
        "syntax": "match.re", 
        "type": "Text Processing"
    }, 
    "re.compile": {
        "descr": "Compile a regular expression pattern into a regular expression object, which can be used for matching using its match() and search() methods, described below.", 
        "name": "re.compile", 
        "params": [], 
        "path": "python/library/re#re.compile", 
        "syntax": "re.compile(pattern, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.error": {
        "descr": "Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern.", 
        "name": "re.error", 
        "params": [], 
        "path": "python/library/re#re.error", 
        "syntax": "exception re.error", 
        "type": "Text Processing"
    }, 
    "re.escape": {
        "descr": "Escape all the characters in pattern except ASCII letters, numbers and '_'. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it.", 
        "name": "re.escape", 
        "params": [], 
        "path": "python/library/re#re.escape", 
        "syntax": "re.escape(string)", 
        "type": "Text Processing"
    }, 
    "re.findall": {
        "descr": "Return all non-overlapping matches of pattern in string, as a list of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result unless they touch the beginning of another match.", 
        "name": "re.findall", 
        "params": [], 
        "path": "python/library/re#re.findall", 
        "syntax": "re.findall(pattern, string, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.finditer": {
        "descr": "Return an iterator yielding match objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result unless they touch the beginning of another match.", 
        "name": "re.finditer", 
        "params": [], 
        "path": "python/library/re#re.finditer", 
        "syntax": "re.finditer(pattern, string, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.match": {
        "descr": "If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match.", 
        "name": "re.match", 
        "params": [], 
        "path": "python/library/re#re.match", 
        "syntax": "re.match(pattern, string, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.match.end": {
        "descr": "Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return -1 if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to m.group(g)) is", 
        "name": "re.match.end", 
        "params": [], 
        "path": "python/library/re#re.match.end", 
        "syntax": "match.end([group])", 
        "type": "Text Processing"
    }, 
    "re.match.endpos": {
        "descr": "The value of endpos which was passed to the search() or match() method of a regex object. This is the index into the string beyond which the RE engine will not go.", 
        "name": "re.match.endpos", 
        "params": [], 
        "path": "python/library/re#re.match.endpos", 
        "syntax": "match.endpos", 
        "type": "Text Processing"
    }, 
    "re.match.expand": {
        "descr": "Return the string obtained by doing backslash substitution on the template string template, as done by the sub() method. Escapes such as \\n are converted to the appropriate characters, and numeric backreferences (\\1, \\2) and named backreferences (\\g<1>, \\g<name>) are replaced by the contents of the corresponding group.", 
        "name": "re.match.expand", 
        "params": [], 
        "path": "python/library/re#re.match.expand", 
        "syntax": "match.expand(template)", 
        "type": "Text Processing"
    }, 
    "re.match.group": {
        "descr": "Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an IndexError exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is None. If a group is contained in a part of the pattern that matched multiple times, the last match is returned.", 
        "name": "re.match.group", 
        "params": [], 
        "path": "python/library/re#re.match.group", 
        "syntax": "match.group([group1, ...])", 
        "type": "Text Processing"
    }, 
    "re.match.groupdict": {
        "descr": "Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name. The default argument is used for groups that did not participate in the match; it defaults to None. For example:", 
        "name": "re.match.groupdict", 
        "params": [], 
        "path": "python/library/re#re.match.groupdict", 
        "syntax": "match.groupdict(default=None)", 
        "type": "Text Processing"
    }, 
    "re.match.groups": {
        "descr": "Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to None.", 
        "name": "re.match.groups", 
        "params": [], 
        "path": "python/library/re#re.match.groups", 
        "syntax": "match.groups(default=None)", 
        "type": "Text Processing"
    }, 
    "re.match.lastgroup": {
        "descr": "The name of the last matched capturing group, or None if the group didn\u2019t have a name, or if no group was matched at all.", 
        "name": "re.match.lastgroup", 
        "params": [], 
        "path": "python/library/re#re.match.lastgroup", 
        "syntax": "match.lastgroup", 
        "type": "Text Processing"
    }, 
    "re.match.lastindex": {
        "descr": "The integer index of the last matched capturing group, or None if no group was matched at all. For example, the expressions (a)b, ((a)(b)), and ((ab)) will have lastindex == 1 if applied to the string 'ab', while the expression (a)(b) will have lastindex == 2, if applied to the same string.", 
        "name": "re.match.lastindex", 
        "params": [], 
        "path": "python/library/re#re.match.lastindex", 
        "syntax": "match.lastindex", 
        "type": "Text Processing"
    }, 
    "re.match.pos": {
        "descr": "The value of pos which was passed to the search() or match() method of a regex object. This is the index into the string at which the RE engine started looking for a match.", 
        "name": "re.match.pos", 
        "params": [], 
        "path": "python/library/re#re.match.pos", 
        "syntax": "match.pos", 
        "type": "Text Processing"
    }, 
    "re.match.re": {
        "descr": "The regular expression object whose match() or search() method produced this match instance.", 
        "name": "re.match.re", 
        "params": [], 
        "path": "python/library/re#re.match.re", 
        "syntax": "match.re", 
        "type": "Text Processing"
    }, 
    "re.match.span": {
        "descr": "For a match m, return the 2-tuple (m.start(group), m.end(group)). Note that if group did not contribute to the match, this is (-1, -1). group defaults to zero, the entire match.", 
        "name": "re.match.span", 
        "params": [], 
        "path": "python/library/re#re.match.span", 
        "syntax": "match.span([group])", 
        "type": "Text Processing"
    }, 
    "re.match.start": {
        "descr": "Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return -1 if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to m.group(g)) is", 
        "name": "re.match.start", 
        "params": [], 
        "path": "python/library/re#re.match.start", 
        "syntax": "match.start([group])", 
        "type": "Text Processing"
    }, 
    "re.match.string": {
        "descr": "The string passed to match() or search().", 
        "name": "re.match.string", 
        "params": [], 
        "path": "python/library/re#re.match.string", 
        "syntax": "match.string", 
        "type": "Text Processing"
    }, 
    "re.purge": {
        "descr": "Clear the regular expression cache.", 
        "name": "re.purge", 
        "params": [], 
        "path": "python/library/re#re.purge", 
        "syntax": "re.purge()", 
        "type": "Text Processing"
    }, 
    "re.regex.findall": {
        "descr": "Similar to the findall() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for match().", 
        "name": "re.regex.findall", 
        "params": [], 
        "path": "python/library/re#re.regex.findall", 
        "syntax": "regex.findall(string[, pos[, endpos]])", 
        "type": "Text Processing"
    }, 
    "re.regex.finditer": {
        "descr": "Similar to the finditer() function, using the compiled pattern, but also accepts optional pos and endpos parameters that limit the search region like for match().", 
        "name": "re.regex.finditer", 
        "params": [], 
        "path": "python/library/re#re.regex.finditer", 
        "syntax": "regex.finditer(string[, pos[, endpos]])", 
        "type": "Text Processing"
    }, 
    "re.regex.flags": {
        "descr": "The regex matching flags. This is a combination of the flags given to compile(), any (?...) inline flags in the pattern, and implicit flags such as UNICODE if the pattern is a Unicode string.", 
        "name": "re.regex.flags", 
        "params": [], 
        "path": "python/library/re#re.regex.flags", 
        "syntax": "regex.flags", 
        "type": "Text Processing"
    }, 
    "re.regex.groupindex": {
        "descr": "A dictionary mapping any symbolic group names defined by (?P<id>) to group numbers. The dictionary is empty if no symbolic groups were used in the pattern.", 
        "name": "re.regex.groupindex", 
        "params": [], 
        "path": "python/library/re#re.regex.groupindex", 
        "syntax": "regex.groupindex", 
        "type": "Text Processing"
    }, 
    "re.regex.groups": {
        "descr": "The number of capturing groups in the pattern.", 
        "name": "re.regex.groups", 
        "params": [], 
        "path": "python/library/re#re.regex.groups", 
        "syntax": "regex.groups", 
        "type": "Text Processing"
    }, 
    "re.regex.match": {
        "descr": "If zero or more characters at the beginning of string match this regular expression, return a corresponding match object. Return None if the string does not match the pattern; note that this is different from a zero-length match.", 
        "name": "re.regex.match", 
        "params": [], 
        "path": "python/library/re#re.regex.match", 
        "syntax": "regex.match(string[, pos[, endpos]])", 
        "type": "Text Processing"
    }, 
    "re.regex.pattern": {
        "descr": "The pattern string from which the RE object was compiled.", 
        "name": "re.regex.pattern", 
        "params": [], 
        "path": "python/library/re#re.regex.pattern", 
        "syntax": "regex.pattern", 
        "type": "Text Processing"
    }, 
    "re.regex.search": {
        "descr": "Scan through string looking for a location where this regular expression produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string.", 
        "name": "re.regex.search", 
        "params": [], 
        "path": "python/library/re#re.regex.search", 
        "syntax": "regex.search(string[, pos[, endpos]])", 
        "type": "Text Processing"
    }, 
    "re.regex.split": {
        "descr": "Identical to the split() function, using the compiled pattern.", 
        "name": "re.regex.split", 
        "params": [], 
        "path": "python/library/re#re.regex.split", 
        "syntax": "regex.split(string, maxsplit=0)", 
        "type": "Text Processing"
    }, 
    "re.regex.sub": {
        "descr": "Identical to the sub() function, using the compiled pattern.", 
        "name": "re.regex.sub", 
        "params": [], 
        "path": "python/library/re#re.regex.sub", 
        "syntax": "regex.sub(repl, string, count=0)", 
        "type": "Text Processing"
    }, 
    "re.regex.subn": {
        "descr": "Identical to the subn() function, using the compiled pattern.", 
        "name": "re.regex.subn", 
        "params": [], 
        "path": "python/library/re#re.regex.subn", 
        "syntax": "regex.subn(repl, string, count=0)", 
        "type": "Text Processing"
    }, 
    "re.search": {
        "descr": "Scan through string looking for a location where the regular expression pattern produces a match, and return a corresponding match object. Return None if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string.", 
        "name": "re.search", 
        "params": [], 
        "path": "python/library/re#re.search", 
        "syntax": "re.search(pattern, string, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.split": {
        "descr": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list.", 
        "name": "re.split", 
        "params": [], 
        "path": "python/library/re#re.split", 
        "syntax": "re.split(pattern, string, maxsplit=0, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.sub": {
        "descr": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn\u2019t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, \\n is converted to a single newline character, \\r is converted to a carriage return, and so forth. Unknown escapes such as \\j are left alone. Backreferences, such as \\6, are replaced with the substring matched by group 6 in the pattern. For example:", 
        "name": "re.sub", 
        "params": [], 
        "path": "python/library/re#re.sub", 
        "syntax": "re.sub(pattern, repl, string, count=0, flags=0)", 
        "type": "Text Processing"
    }, 
    "re.subn": {
        "descr": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made).", 
        "name": "re.subn", 
        "params": [], 
        "path": "python/library/re#re.subn", 
        "syntax": "re.subn(pattern, repl, string, count=0, flags=0)", 
        "type": "Text Processing"
    }, 
    "readline.add_history": {
        "descr": "Append a line to the history buffer, as if it was the last line typed.", 
        "name": "readline.add_history", 
        "params": [], 
        "path": "python/library/readline#readline.add_history", 
        "syntax": "readline.add_history(line)", 
        "type": "Text Processing"
    }, 
    "readline.clear_history": {
        "descr": "Clear the current history. (Note: this function is not available if the installed version of GNU readline doesn\u2019t support it.)", 
        "name": "readline.clear_history", 
        "params": [], 
        "path": "python/library/readline#readline.clear_history", 
        "syntax": "readline.clear_history()", 
        "type": "Text Processing"
    }, 
    "readline.get_begidx": {
        "descr": "Get the beginning index of the readline tab-completion scope.", 
        "name": "readline.get_begidx", 
        "params": [], 
        "path": "python/library/readline#readline.get_begidx", 
        "syntax": "readline.get_begidx()", 
        "type": "Text Processing"
    }, 
    "readline.get_completer": {
        "descr": "Get the completer function, or None if no completer function has been set.", 
        "name": "readline.get_completer", 
        "params": [], 
        "path": "python/library/readline#readline.get_completer", 
        "syntax": "readline.get_completer()", 
        "type": "Text Processing"
    }, 
    "readline.get_completer_delims": {
        "descr": "Get the readline word delimiters for tab-completion.", 
        "name": "readline.get_completer_delims", 
        "params": [], 
        "path": "python/library/readline#readline.get_completer_delims", 
        "syntax": "readline.get_completer_delims()", 
        "type": "Text Processing"
    }, 
    "readline.get_completion_type": {
        "descr": "Get the type of completion being attempted.", 
        "name": "readline.get_completion_type", 
        "params": [], 
        "path": "python/library/readline#readline.get_completion_type", 
        "syntax": "readline.get_completion_type()", 
        "type": "Text Processing"
    }, 
    "readline.get_current_history_length": {
        "descr": "Return the number of lines currently in the history. (This is different from get_history_length(), which returns the maximum number of lines that will be written to a history file.)", 
        "name": "readline.get_current_history_length", 
        "params": [], 
        "path": "python/library/readline#readline.get_current_history_length", 
        "syntax": "readline.get_current_history_length()", 
        "type": "Text Processing"
    }, 
    "readline.get_endidx": {
        "descr": "Get the ending index of the readline tab-completion scope.", 
        "name": "readline.get_endidx", 
        "params": [], 
        "path": "python/library/readline#readline.get_endidx", 
        "syntax": "readline.get_endidx()", 
        "type": "Text Processing"
    }, 
    "readline.get_history_item": {
        "descr": "Return the current contents of history item at index.", 
        "name": "readline.get_history_item", 
        "params": [], 
        "path": "python/library/readline#readline.get_history_item", 
        "syntax": "readline.get_history_item(index)", 
        "type": "Text Processing"
    }, 
    "readline.get_history_length": {
        "descr": "Return the desired length of the history file. Negative values imply unlimited history file size.", 
        "name": "readline.get_history_length", 
        "params": [], 
        "path": "python/library/readline#readline.get_history_length", 
        "syntax": "readline.get_history_length()", 
        "type": "Text Processing"
    }, 
    "readline.get_line_buffer": {
        "descr": "Return the current contents of the line buffer.", 
        "name": "readline.get_line_buffer", 
        "params": [], 
        "path": "python/library/readline#readline.get_line_buffer", 
        "syntax": "readline.get_line_buffer()", 
        "type": "Text Processing"
    }, 
    "readline.insert_text": {
        "descr": "Insert text into the command line.", 
        "name": "readline.insert_text", 
        "params": [], 
        "path": "python/library/readline#readline.insert_text", 
        "syntax": "readline.insert_text(string)", 
        "type": "Text Processing"
    }, 
    "readline.parse_and_bind": {
        "descr": "Parse and execute single line of a readline init file.", 
        "name": "readline.parse_and_bind", 
        "params": [], 
        "path": "python/library/readline#readline.parse_and_bind", 
        "syntax": "readline.parse_and_bind(string)", 
        "type": "Text Processing"
    }, 
    "readline.read_history_file": {
        "descr": "Load a readline history file. The default filename is ~/.history.", 
        "name": "readline.read_history_file", 
        "params": [], 
        "path": "python/library/readline#readline.read_history_file", 
        "syntax": "readline.read_history_file([filename])", 
        "type": "Text Processing"
    }, 
    "readline.read_init_file": {
        "descr": "Parse a readline initialization file. The default filename is the last filename used.", 
        "name": "readline.read_init_file", 
        "params": [], 
        "path": "python/library/readline#readline.read_init_file", 
        "syntax": "readline.read_init_file([filename])", 
        "type": "Text Processing"
    }, 
    "readline.redisplay": {
        "descr": "Change what\u2019s displayed on the screen to reflect the current contents of the line buffer.", 
        "name": "readline.redisplay", 
        "params": [], 
        "path": "python/library/readline#readline.redisplay", 
        "syntax": "readline.redisplay()", 
        "type": "Text Processing"
    }, 
    "readline.remove_history_item": {
        "descr": "Remove history item specified by its position from the history.", 
        "name": "readline.remove_history_item", 
        "params": [], 
        "path": "python/library/readline#readline.remove_history_item", 
        "syntax": "readline.remove_history_item(pos)", 
        "type": "Text Processing"
    }, 
    "readline.replace_history_item": {
        "descr": "Replace history item specified by its position with the given line.", 
        "name": "readline.replace_history_item", 
        "params": [], 
        "path": "python/library/readline#readline.replace_history_item", 
        "syntax": "readline.replace_history_item(pos, line)", 
        "type": "Text Processing"
    }, 
    "readline.set_completer": {
        "descr": "Set or remove the completer function. If function is specified, it will be used as the new completer function; if omitted or None, any completer function already installed is removed. The completer function is called as function(text, state), for state in 0, 1, 2, ..., until it returns a non-string value. It should return the next possible completion starting with text.", 
        "name": "readline.set_completer", 
        "params": [], 
        "path": "python/library/readline#readline.set_completer", 
        "syntax": "readline.set_completer([function])", 
        "type": "Text Processing"
    }, 
    "readline.set_completer_delims": {
        "descr": "Set the readline word delimiters for tab-completion.", 
        "name": "readline.set_completer_delims", 
        "params": [], 
        "path": "python/library/readline#readline.set_completer_delims", 
        "syntax": "readline.set_completer_delims(string)", 
        "type": "Text Processing"
    }, 
    "readline.set_completion_display_matches_hook": {
        "descr": "Set or remove the completion display function. If function is specified, it will be used as the new completion display function; if omitted or None, any completion display function already installed is removed. The completion display function is called as function(substitution, [matches], longest_match_length) once each time matches need to be displayed.", 
        "name": "readline.set_completion_display_matches_hook", 
        "params": [], 
        "path": "python/library/readline#readline.set_completion_display_matches_hook", 
        "syntax": "readline.set_completion_display_matches_hook([function])", 
        "type": "Text Processing"
    }, 
    "readline.set_history_length": {
        "descr": "Set the number of lines to save in the history file. write_history_file() uses this value to truncate the history file when saving. Negative values imply unlimited history file size.", 
        "name": "readline.set_history_length", 
        "params": [], 
        "path": "python/library/readline#readline.set_history_length", 
        "syntax": "readline.set_history_length(length)", 
        "type": "Text Processing"
    }, 
    "readline.set_pre_input_hook": {
        "descr": "Set or remove the pre_input_hook function. If function is specified, it will be used as the new pre_input_hook function; if omitted or None, any hook function already installed is removed. The pre_input_hook function is called with no arguments after the first prompt has been printed and just before readline starts reading input characters.", 
        "name": "readline.set_pre_input_hook", 
        "params": [], 
        "path": "python/library/readline#readline.set_pre_input_hook", 
        "syntax": "readline.set_pre_input_hook([function])", 
        "type": "Text Processing"
    }, 
    "readline.set_startup_hook": {
        "descr": "Set or remove the startup_hook function. If function is specified, it will be used as the new startup_hook function; if omitted or None, any hook function already installed is removed. The startup_hook function is called with no arguments just before readline prints the first prompt.", 
        "name": "readline.set_startup_hook", 
        "params": [], 
        "path": "python/library/readline#readline.set_startup_hook", 
        "syntax": "readline.set_startup_hook([function])", 
        "type": "Text Processing"
    }, 
    "readline.write_history_file": {
        "descr": "Save a readline history file. The default filename is ~/.history.", 
        "name": "readline.write_history_file", 
        "params": [], 
        "path": "python/library/readline#readline.write_history_file", 
        "syntax": "readline.write_history_file([filename])", 
        "type": "Text Processing"
    }, 
    "remove": {
        "descr": "Remove the first occurrence of x from the array.", 
        "name": "array.array.remove", 
        "params": [], 
        "path": "python/library/array#array.array.remove", 
        "syntax": "array.remove(x)", 
        "type": "Data Types"
    }, 
    "replace": {
        "descr": "Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.", 
        "name": "str.replace", 
        "params": [], 
        "path": "python/library/stdtypes#str.replace", 
        "syntax": "str.replace(old, new[, count])", 
        "type": "Built-in Types"
    }, 
    "repr": {
        "descr": "Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a __repr__() method.", 
        "name": "repr", 
        "params": [], 
        "path": "python/library/functions#repr", 
        "syntax": "repr(object)", 
        "type": "Built-in Functions"
    }, 
    "reprlib.Repr": {
        "descr": "Class which provides formatting services useful in implementing functions similar to the built-in repr(); size limits for different object types are added to avoid the generation of representations which are excessively long.", 
        "name": "reprlib.Repr", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr", 
        "syntax": "class reprlib.Repr", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxarray": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxarray", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxarray", 
        "syntax": "Repr.maxarray", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxdeque": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxdeque", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxdeque", 
        "syntax": "Repr.maxdeque", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxdict": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxdict", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxdict", 
        "syntax": "Repr.maxdict", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxfrozenset": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxfrozenset", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxfrozenset", 
        "syntax": "Repr.maxfrozenset", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxlevel": {
        "descr": "Depth limit on the creation of recursive representations. The default is 6.", 
        "name": "reprlib.Repr.maxlevel", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxlevel", 
        "syntax": "Repr.maxlevel", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxlist": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxlist", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxlist", 
        "syntax": "Repr.maxlist", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxlong": {
        "descr": "Maximum number of characters in the representation for an integer. Digits are dropped from the middle. The default is 40.", 
        "name": "reprlib.Repr.maxlong", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxlong", 
        "syntax": "Repr.maxlong", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxother": {
        "descr": "This limit is used to control the size of object types for which no specific formatting method is available on the Repr object. It is applied in a similar manner as maxstring. The default is 20.", 
        "name": "reprlib.Repr.maxother", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxother", 
        "syntax": "Repr.maxother", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxset": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxset", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxset", 
        "syntax": "Repr.maxset", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxstring": {
        "descr": "Limit on the number of characters in the representation of the string. Note that the \u201cnormal\u201d representation of the string is used as the character source: if escape sequences are needed in the representation, these may be mangled when the representation is shortened. The default is 30.", 
        "name": "reprlib.Repr.maxstring", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxstring", 
        "syntax": "Repr.maxstring", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.maxtuple": {
        "descr": "Limits on the number of entries represented for the named object type. The default is 4 for maxdict, 5 for maxarray, and 6 for the others.", 
        "name": "reprlib.Repr.maxtuple", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.maxtuple", 
        "syntax": "Repr.maxtuple", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.repr": {
        "descr": "Recursive implementation used by repr(). This uses the type of obj to determine which formatting method to call, passing it obj and level. The type-specific methods should call repr1() to perform recursive formatting, with level - 1 for the value of level in the recursive call.", 
        "name": "reprlib.Repr.repr", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.repr", 
        "syntax": "Repr.repr1(obj, level)", 
        "type": "Data Types"
    }, 
    "reprlib.Repr.repr1": {
        "descr": "Recursive implementation used by repr(). This uses the type of obj to determine which formatting method to call, passing it obj and level. The type-specific methods should call repr1() to perform recursive formatting, with level - 1 for the value of level in the recursive call.", 
        "name": "reprlib.Repr.repr1", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.Repr.repr1", 
        "syntax": "Repr.repr1(obj, level)", 
        "type": "Data Types"
    }, 
    "reprlib.aRepr": {
        "descr": "This is an instance of Repr which is used to provide the repr() function described below. Changing the attributes of this object will affect the size limits used by repr() and the Python debugger.", 
        "name": "reprlib.aRepr", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.aRepr", 
        "syntax": "reprlib.aRepr", 
        "type": "Data Types"
    }, 
    "reprlib.recursive_repr": {
        "descr": "Decorator for __repr__() methods to detect recursive calls within the same thread. If a recursive call is made, the fillvalue is returned, otherwise, the usual __repr__() call is made. For example:", 
        "name": "reprlib.recursive_repr", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.recursive_repr", 
        "syntax": "@reprlib.recursive_repr(fillvalue=\"...\")", 
        "type": "Data Types"
    }, 
    "reprlib.repr": {
        "descr": "This is the repr() method of aRepr. It returns a string similar to that returned by the built-in function of the same name, but with limits on most sizes.", 
        "name": "reprlib.repr", 
        "params": [], 
        "path": "python/library/reprlib#reprlib.repr", 
        "syntax": "reprlib.repr(obj)", 
        "type": "Data Types"
    }, 
    "resource.error": {
        "descr": "A deprecated alias of OSError.", 
        "name": "resource.error", 
        "params": [], 
        "path": "python/library/resource#resource.error", 
        "syntax": "exception resource.error", 
        "type": "Unix"
    }, 
    "resource.getpagesize": {
        "descr": "Returns the number of bytes in a system page. (This need not be the same as the hardware page size.) This function is useful for determining the number of bytes of memory a process is using. The third element of the tuple returned by getrusage() describes memory usage in pages; multiplying by page size produces number of bytes.", 
        "name": "resource.getpagesize", 
        "params": [], 
        "path": "python/library/resource#resource.getpagesize", 
        "syntax": "resource.getpagesize()", 
        "type": "Unix"
    }, 
    "resource.getrlimit": {
        "descr": "Returns a tuple (soft, hard) with the current soft and hard limits of resource. Raises ValueError if an invalid resource is specified, or error if the underlying system call fails unexpectedly.", 
        "name": "resource.getrlimit", 
        "params": [], 
        "path": "python/library/resource#resource.getrlimit", 
        "syntax": "resource.getrlimit(resource)", 
        "type": "Unix"
    }, 
    "resource.getrusage": {
        "descr": "This function returns an object that describes the resources consumed by either the current process or its children, as specified by the who parameter. The who parameter should be specified using one of the RUSAGE_* constants described below.", 
        "name": "resource.getrusage", 
        "params": [], 
        "path": "python/library/resource#resource.getrusage", 
        "syntax": "resource.getrusage(who)", 
        "type": "Unix"
    }, 
    "resource.setrlimit": {
        "descr": "Sets new limits of consumption of resource. The limits argument must be a tuple (soft, hard) of two integers describing the new limits. A value of RLIM_INFINITY can be used to request a limit that is unlimited.", 
        "name": "resource.setrlimit", 
        "params": [], 
        "path": "python/library/resource#resource.setrlimit", 
        "syntax": "resource.setrlimit(resource, limits)", 
        "type": "Unix"
    }, 
    "reverse": {
        "descr": "Reverse the order of the items in the array.", 
        "name": "array.array.reverse", 
        "params": [], 
        "path": "python/library/array#array.array.reverse", 
        "syntax": "array.reverse()", 
        "type": "Data Types"
    }, 
    "reversed": {
        "descr": "Return a reverse iterator. seq must be an object which has a __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method with integer arguments starting at 0).", 
        "name": "reversed", 
        "params": [], 
        "path": "python/library/functions#reversed", 
        "syntax": "reversed(seq)", 
        "type": "Built-in Functions"
    }, 
    "rfind": {
        "descr": "Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.", 
        "name": "str.rfind", 
        "params": [], 
        "path": "python/library/stdtypes#str.rfind", 
        "syntax": "str.rfind(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "rindex": {
        "descr": "Like rfind() but raises ValueError when the substring sub is not found.", 
        "name": "str.rindex", 
        "params": [], 
        "path": "python/library/stdtypes#str.rindex", 
        "syntax": "str.rindex(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "rjust": {
        "descr": "Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is a space). The original string is returned if width is less than or equal to len(s).", 
        "name": "str.rjust", 
        "params": [], 
        "path": "python/library/stdtypes#str.rjust", 
        "syntax": "str.rjust(width[, fillchar])", 
        "type": "Built-in Types"
    }, 
    "rlcompleter.Completer.complete": {
        "descr": "Return the stateth completion for text.", 
        "name": "rlcompleter.Completer.complete", 
        "params": [], 
        "path": "python/library/rlcompleter#rlcompleter.Completer.complete", 
        "syntax": "Completer.complete(text, state)", 
        "type": "Text Processing"
    }, 
    "round": {
        "descr": "Return the floating point value number rounded to ndigits digits after the decimal point. If ndigits is omitted, it defaults to zero. Delegates to number.__round__(ndigits).", 
        "name": "round", 
        "params": [], 
        "path": "python/library/functions#round", 
        "syntax": "round(number[, ndigits])", 
        "type": "Built-in Functions"
    }, 
    "rpartition": {
        "descr": "Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself.", 
        "name": "str.rpartition", 
        "params": [], 
        "path": "python/library/stdtypes#str.rpartition", 
        "syntax": "str.rpartition(sep)", 
        "type": "Built-in Types"
    }, 
    "rsplit": {
        "descr": "Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below.", 
        "name": "str.rsplit", 
        "params": [], 
        "path": "python/library/stdtypes#str.rsplit", 
        "syntax": "str.rsplit(sep=None, maxsplit=-1)", 
        "type": "Built-in Types"
    }, 
    "rstrip": {
        "descr": "Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped:", 
        "name": "str.rstrip", 
        "params": [], 
        "path": "python/library/stdtypes#str.rstrip", 
        "syntax": "str.rstrip([chars])", 
        "type": "Built-in Types"
    }, 
    "runpy.run_module": {
        "descr": "Execute the code of the specified module and return the resulting module globals dictionary. The module\u2019s code is first located using the standard import mechanism (refer to PEP 302 for details) and then executed in a fresh module namespace.", 
        "name": "runpy.run_module", 
        "params": [], 
        "path": "python/library/runpy#runpy.run_module", 
        "syntax": "runpy.run_module(mod_name, init_globals=None, run_name=None, alter_sys=False)", 
        "type": "Importing"
    }, 
    "runpy.run_path": {
        "descr": "Execute the code at the named filesystem location and return the resulting module globals dictionary. As with a script name supplied to the CPython command line, the supplied path may refer to a Python source file, a compiled bytecode file or a valid sys.path entry containing a __main__ module (e.g. a zipfile containing a top-level __main__.py file).", 
        "name": "runpy.run_path", 
        "params": [], 
        "path": "python/library/runpy#runpy.run_path", 
        "syntax": "runpy.run_path(file_path, init_globals=None, run_name=None)", 
        "type": "Importing"
    }, 
    "sched.scheduler": {
        "descr": "The scheduler class defines a generic interface to scheduling events. It needs two functions to actually deal with the \u201coutside world\u201d \u2014 timefunc should be callable without arguments, and return a number (the \u201ctime\u201d, in any units whatsoever). If time.monotonic is not available, the timefunc default is time.time instead. The delayfunc function should be callable with one argument, compatible with the output of timefunc, and should delay that many time units. delayfunc will also be called with the argument 0 after each event is run to allow other threads an opportunity to run in multi-threaded applications.", 
        "name": "sched.scheduler", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler", 
        "syntax": "class sched.scheduler(timefunc=time.monotonic, delayfunc=time.sleep)", 
        "type": "Concurrent Execution"
    }, 
    "sched.scheduler.cancel": {
        "descr": "Remove the event from the queue. If event is not an event currently in the queue, this method will raise a ValueError.", 
        "name": "sched.scheduler.cancel", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler.cancel", 
        "syntax": "scheduler.cancel(event)", 
        "type": "Concurrent Execution"
    }, 
    "sched.scheduler.empty": {
        "descr": "Return true if the event queue is empty.", 
        "name": "sched.scheduler.empty", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler.empty", 
        "syntax": "scheduler.empty()", 
        "type": "Concurrent Execution"
    }, 
    "sched.scheduler.enter": {
        "descr": "Schedule an event for delay more time units. Other than the relative time, the other arguments, the effect and the return value are the same as those for enterabs().", 
        "name": "sched.scheduler.enter", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler.enter", 
        "syntax": "scheduler.enter(delay, priority, action, argument=(), kwargs={})", 
        "type": "Concurrent Execution"
    }, 
    "sched.scheduler.enterabs": {
        "descr": "Schedule a new event. The time argument should be a numeric type compatible with the return value of the timefunc function passed to the constructor. Events scheduled for the same time will be executed in the order of their priority.", 
        "name": "sched.scheduler.enterabs", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler.enterabs", 
        "syntax": "scheduler.enterabs(time, priority, action, argument=(), kwargs={})", 
        "type": "Concurrent Execution"
    }, 
    "sched.scheduler.queue": {
        "descr": "Read-only attribute returning a list of upcoming events in the order they will be run. Each event is shown as a named tuple with the following fields: time, priority, action, argument, kwargs.", 
        "name": "sched.scheduler.queue", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler.queue", 
        "syntax": "scheduler.queue", 
        "type": "Concurrent Execution"
    }, 
    "sched.scheduler.run": {
        "descr": "Run all scheduled events. This method will wait (using the delayfunc() function passed to the constructor) for the next event, then execute it and so on until there are no more scheduled events.", 
        "name": "sched.scheduler.run", 
        "params": [], 
        "path": "python/library/sched#sched.scheduler.run", 
        "syntax": "scheduler.run(blocking=True)", 
        "type": "Concurrent Execution"
    }, 
    "select.PIPE_BUF": {
        "descr": "The minimum number of bytes which can be written without blocking to a pipe when the pipe has been reported as ready for writing by select(), poll() or another interface in this module. This doesn\u2019t apply to other kind of file-like objects such as sockets.", 
        "name": "select.PIPE_BUF", 
        "params": [], 
        "path": "python/library/select#select.PIPE_BUF", 
        "syntax": "select.PIPE_BUF", 
        "type": "Concurrent Execution"
    }, 
    "select.devpoll": {
        "descr": "(Only supported on Solaris and derivatives.) Returns a /dev/poll polling object; see section /dev/poll Polling Objects below for the methods supported by devpoll objects.", 
        "name": "select.devpoll", 
        "params": [], 
        "path": "python/library/select#select.devpoll", 
        "syntax": "select.devpoll()", 
        "type": "Concurrent Execution"
    }, 
    "select.devpoll.modify": {
        "descr": "This method does an unregister() followed by a register(). It is (a bit) more efficient that doing the same explicitly.", 
        "name": "select.devpoll.modify", 
        "params": [], 
        "path": "python/library/select#select.devpoll.modify", 
        "syntax": "devpoll.modify(fd[, eventmask])", 
        "type": "Concurrent Execution"
    }, 
    "select.devpoll.poll": {
        "descr": "Polls the set of registered file descriptors, and returns a possibly-empty list containing (fd, event) 2-tuples for the descriptors that have events or errors to report. fd is the file descriptor, and event is a bitmask with bits set for the reported events for that descriptor \u2014 POLLIN for waiting input, POLLOUT to indicate that the descriptor can be written to, and so forth. An empty list indicates that the call timed out and no file descriptors had any events to report. If timeout is given, it specifies the length of time in milliseconds which the system will wait for events before returning. If timeout is omitted, -1, or None, the call will block until there is an event for this poll object.", 
        "name": "select.devpoll.poll", 
        "params": [], 
        "path": "python/library/select#select.devpoll.poll", 
        "syntax": "devpoll.poll([timeout])", 
        "type": "Concurrent Execution"
    }, 
    "select.devpoll.register": {
        "descr": "Register a file descriptor with the polling object. Future calls to the poll() method will then check whether the file descriptor has any pending I/O events. fd can be either an integer, or an object with a fileno() method that returns an integer. File objects implement fileno(), so they can also be used as the argument.", 
        "name": "select.devpoll.register", 
        "params": [], 
        "path": "python/library/select#select.devpoll.register", 
        "syntax": "devpoll.register(fd[, eventmask])", 
        "type": "Concurrent Execution"
    }, 
    "select.devpoll.unregister": {
        "descr": "Remove a file descriptor being tracked by a polling object. Just like the register() method, fd can be an integer or an object with a fileno() method that returns an integer.", 
        "name": "select.devpoll.unregister", 
        "params": [], 
        "path": "python/library/select#select.devpoll.unregister", 
        "syntax": "devpoll.unregister(fd)", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll": {
        "descr": "(Only supported on Linux 2.5.44 and newer.) Return an edge polling object, which can be used as Edge or Level Triggered interface for I/O events. sizehint is deprecated and completely ignored. flags can be set to EPOLL_CLOEXEC, which causes the epoll descriptor to be closed automatically when os.execve() is called. See section Edge and Level Trigger Polling (epoll) Objects below for the methods supported by epolling objects.", 
        "name": "select.epoll", 
        "params": [], 
        "path": "python/library/select#select.epoll", 
        "syntax": "select.epoll(sizehint=-1, flags=0)", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.close": {
        "descr": "Close the control file descriptor of the epoll object.", 
        "name": "select.epoll.close", 
        "params": [], 
        "path": "python/library/select#select.epoll.close", 
        "syntax": "epoll.close()", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.fileno": {
        "descr": "Return the file descriptor number of the control fd.", 
        "name": "select.epoll.fileno", 
        "params": [], 
        "path": "python/library/select#select.epoll.fileno", 
        "syntax": "epoll.fileno()", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.fromfd": {
        "descr": "Create an epoll object from a given file descriptor.", 
        "name": "select.epoll.fromfd", 
        "params": [], 
        "path": "python/library/select#select.epoll.fromfd", 
        "syntax": "epoll.fromfd(fd)", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.modify": {
        "descr": "Modify a register file descriptor.", 
        "name": "select.epoll.modify", 
        "params": [], 
        "path": "python/library/select#select.epoll.modify", 
        "syntax": "epoll.modify(fd, eventmask)", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.poll": {
        "descr": "Wait for events. timeout in seconds (float)", 
        "name": "select.epoll.poll", 
        "params": [], 
        "path": "python/library/select#select.epoll.poll", 
        "syntax": "epoll.poll(timeout=-1, maxevents=-1)", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.register": {
        "descr": "Register a fd descriptor with the epoll object.", 
        "name": "select.epoll.register", 
        "params": [], 
        "path": "python/library/select#select.epoll.register", 
        "syntax": "epoll.register(fd[, eventmask])", 
        "type": "Concurrent Execution"
    }, 
    "select.epoll.unregister": {
        "descr": "Remove a registered file descriptor from the epoll object.", 
        "name": "select.epoll.unregister", 
        "params": [], 
        "path": "python/library/select#select.epoll.unregister", 
        "syntax": "epoll.unregister(fd)", 
        "type": "Concurrent Execution"
    }, 
    "select.error": {
        "descr": "A deprecated alias of OSError.", 
        "name": "select.error", 
        "params": [], 
        "path": "python/library/select#select.error", 
        "syntax": "exception select.error", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent": {
        "descr": "(Only supported on BSD.) Returns a kernel event object; see section Kevent Objects below for the methods supported by kevent objects.", 
        "name": "select.kevent", 
        "params": [], 
        "path": "python/library/select#select.kevent", 
        "syntax": "select.kevent(ident, filter=KQ_FILTER_READ, flags=KQ_EV_ADD, fflags=0, data=0, udata=0)", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent.data": {
        "descr": "Filter specific data.", 
        "name": "select.kevent.data", 
        "params": [], 
        "path": "python/library/select#select.kevent.data", 
        "syntax": "kevent.data", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent.fflags": {
        "descr": "Filter specific flags.", 
        "name": "select.kevent.fflags", 
        "params": [], 
        "path": "python/library/select#select.kevent.fflags", 
        "syntax": "kevent.fflags", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent.filter": {
        "descr": "Name of the kernel filter.", 
        "name": "select.kevent.filter", 
        "params": [], 
        "path": "python/library/select#select.kevent.filter", 
        "syntax": "kevent.filter", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent.flags": {
        "descr": "Filter action.", 
        "name": "select.kevent.flags", 
        "params": [], 
        "path": "python/library/select#select.kevent.flags", 
        "syntax": "kevent.flags", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent.ident": {
        "descr": "Value used to identify the event. The interpretation depends on the filter but it\u2019s usually the file descriptor. In the constructor ident can either be an int or an object with a fileno() method. kevent stores the integer internally.", 
        "name": "select.kevent.ident", 
        "params": [], 
        "path": "python/library/select#select.kevent.ident", 
        "syntax": "kevent.ident", 
        "type": "Concurrent Execution"
    }, 
    "select.kevent.udata": {
        "descr": "User defined value.", 
        "name": "select.kevent.udata", 
        "params": [], 
        "path": "python/library/select#select.kevent.udata", 
        "syntax": "kevent.udata", 
        "type": "Concurrent Execution"
    }, 
    "select.kqueue": {
        "descr": "(Only supported on BSD.) Returns a kernel queue object; see section Kqueue Objects below for the methods supported by kqueue objects.", 
        "name": "select.kqueue", 
        "params": [], 
        "path": "python/library/select#select.kqueue", 
        "syntax": "select.kqueue()", 
        "type": "Concurrent Execution"
    }, 
    "select.kqueue.close": {
        "descr": "Close the control file descriptor of the kqueue object.", 
        "name": "select.kqueue.close", 
        "params": [], 
        "path": "python/library/select#select.kqueue.close", 
        "syntax": "kqueue.close()", 
        "type": "Concurrent Execution"
    }, 
    "select.kqueue.control": {
        "descr": "Low level interface to kevent", 
        "name": "select.kqueue.control", 
        "params": [], 
        "path": "python/library/select#select.kqueue.control", 
        "syntax": "kqueue.control(changelist, max_events[, timeout=None]) \u2192 eventlist", 
        "type": "Concurrent Execution"
    }, 
    "select.kqueue.fileno": {
        "descr": "Return the file descriptor number of the control fd.", 
        "name": "select.kqueue.fileno", 
        "params": [], 
        "path": "python/library/select#select.kqueue.fileno", 
        "syntax": "kqueue.fileno()", 
        "type": "Concurrent Execution"
    }, 
    "select.kqueue.fromfd": {
        "descr": "Create a kqueue object from a given file descriptor.", 
        "name": "select.kqueue.fromfd", 
        "params": [], 
        "path": "python/library/select#select.kqueue.fromfd", 
        "syntax": "kqueue.fromfd(fd)", 
        "type": "Concurrent Execution"
    }, 
    "select.poll": {
        "descr": "(Not supported by all operating systems.) Returns a polling object, which supports registering and unregistering file descriptors, and then polling them for I/O events; see section Polling Objects below for the methods supported by polling objects.", 
        "name": "select.poll", 
        "params": [], 
        "path": "python/library/select#select.poll", 
        "syntax": "select.poll()", 
        "type": "Concurrent Execution"
    }, 
    "select.poll.modify": {
        "descr": "Modifies an already registered fd. This has the same effect as register(fd, eventmask). Attempting to modify a file descriptor that was never registered causes an IOError exception with errno ENOENT to be raised.", 
        "name": "select.poll.modify", 
        "params": [], 
        "path": "python/library/select#select.poll.modify", 
        "syntax": "poll.modify(fd, eventmask)", 
        "type": "Concurrent Execution"
    }, 
    "select.poll.poll": {
        "descr": "Polls the set of registered file descriptors, and returns a possibly-empty list containing (fd, event) 2-tuples for the descriptors that have events or errors to report. fd is the file descriptor, and event is a bitmask with bits set for the reported events for that descriptor \u2014 POLLIN for waiting input, POLLOUT to indicate that the descriptor can be written to, and so forth. An empty list indicates that the call timed out and no file descriptors had any events to report. If timeout is given, it specifies the length of time in milliseconds which the system will wait for events before returning. If timeout is omitted, negative, or None, the call will block until there is an event for this poll object.", 
        "name": "select.poll.poll", 
        "params": [], 
        "path": "python/library/select#select.poll.poll", 
        "syntax": "poll.poll([timeout])", 
        "type": "Concurrent Execution"
    }, 
    "select.poll.register": {
        "descr": "Register a file descriptor with the polling object. Future calls to the poll() method will then check whether the file descriptor has any pending I/O events. fd can be either an integer, or an object with a fileno() method that returns an integer. File objects implement fileno(), so they can also be used as the argument.", 
        "name": "select.poll.register", 
        "params": [], 
        "path": "python/library/select#select.poll.register", 
        "syntax": "poll.register(fd[, eventmask])", 
        "type": "Concurrent Execution"
    }, 
    "select.poll.unregister": {
        "descr": "Remove a file descriptor being tracked by a polling object. Just like the register() method, fd can be an integer or an object with a fileno() method that returns an integer.", 
        "name": "select.poll.unregister", 
        "params": [], 
        "path": "python/library/select#select.poll.unregister", 
        "syntax": "poll.unregister(fd)", 
        "type": "Concurrent Execution"
    }, 
    "select.select": {
        "descr": "This is a straightforward interface to the Unix select() system call. The first three arguments are sequences of \u2018waitable objects\u2019: either integers representing file descriptors or objects with a parameterless method named fileno() returning such an integer:", 
        "name": "select.select", 
        "params": [], 
        "path": "python/library/select#select.select", 
        "syntax": "select.select(rlist, wlist, xlist[, timeout])", 
        "type": "Concurrent Execution"
    }, 
    "set": {
        "descr": "Return a new set object, optionally with elements taken from iterable. set is a built-in class. See set and Set Types \u2014 set, frozenset for documentation about this class.", 
        "name": "set", 
        "params": [], 
        "path": "python/library/functions#set", 
        "syntax": "set([iterable])", 
        "type": "Built-in Functions"
    }, 
    "set.add": {
        "descr": "Add element elem to the set.", 
        "name": "set.add", 
        "params": [], 
        "path": "python/library/stdtypes#set.add", 
        "syntax": "add(elem)", 
        "type": "Built-in Types"
    }, 
    "set.clear": {
        "descr": "Remove all elements from the set.", 
        "name": "set.clear", 
        "params": [], 
        "path": "python/library/stdtypes#set.clear", 
        "syntax": "clear()", 
        "type": "Built-in Types"
    }, 
    "set.copy": {
        "descr": "Return a new set with a shallow copy of s.", 
        "name": "set.copy", 
        "params": [], 
        "path": "python/library/stdtypes#set.copy", 
        "syntax": "copy()", 
        "type": "Built-in Types"
    }, 
    "set.difference": {
        "descr": "Return a new set with elements in the set that are not in the others.", 
        "name": "set.difference", 
        "params": [], 
        "path": "python/library/stdtypes#set.difference", 
        "syntax": "difference(other, ...)", 
        "type": "Built-in Types"
    }, 
    "set.difference_update": {
        "descr": "Update the set, removing elements found in others.", 
        "name": "set.difference_update", 
        "params": [], 
        "path": "python/library/stdtypes#set.difference_update", 
        "syntax": "difference_update(other, ...)", 
        "type": "Built-in Types"
    }, 
    "set.discard": {
        "descr": "Remove element elem from the set if it is present.", 
        "name": "set.discard", 
        "params": [], 
        "path": "python/library/stdtypes#set.discard", 
        "syntax": "discard(elem)", 
        "type": "Built-in Types"
    }, 
    "set.intersection": {
        "descr": "Return a new set with elements common to the set and all others.", 
        "name": "set.intersection", 
        "params": [], 
        "path": "python/library/stdtypes#set.intersection", 
        "syntax": "intersection(other, ...)", 
        "type": "Built-in Types"
    }, 
    "set.intersection_update": {
        "descr": "Update the set, keeping only elements found in it and all others.", 
        "name": "set.intersection_update", 
        "params": [], 
        "path": "python/library/stdtypes#set.intersection_update", 
        "syntax": "intersection_update(other, ...)", 
        "type": "Built-in Types"
    }, 
    "set.isdisjoint": {
        "descr": "Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set.", 
        "name": "set.isdisjoint", 
        "params": [], 
        "path": "python/library/stdtypes#set.isdisjoint", 
        "syntax": "isdisjoint(other)", 
        "type": "Built-in Types"
    }, 
    "set.issubset": {
        "descr": "Test whether every element in the set is in other.", 
        "name": "set.issubset", 
        "params": [], 
        "path": "python/library/stdtypes#set.issubset", 
        "syntax": "issubset(other)", 
        "type": "Built-in Types"
    }, 
    "set.issuperset": {
        "descr": "Test whether every element in other is in the set.", 
        "name": "set.issuperset", 
        "params": [], 
        "path": "python/library/stdtypes#set.issuperset", 
        "syntax": "issuperset(other)", 
        "type": "Built-in Types"
    }, 
    "set.pop": {
        "descr": "Remove and return an arbitrary element from the set. Raises KeyError if the set is empty.", 
        "name": "set.pop", 
        "params": [], 
        "path": "python/library/stdtypes#set.pop", 
        "syntax": "pop()", 
        "type": "Built-in Types"
    }, 
    "set.remove": {
        "descr": "Remove element elem from the set. Raises KeyError if elem is not contained in the set.", 
        "name": "set.remove", 
        "params": [], 
        "path": "python/library/stdtypes#set.remove", 
        "syntax": "remove(elem)", 
        "type": "Built-in Types"
    }, 
    "set.symmetric_difference": {
        "descr": "Return a new set with elements in either the set or other but not both.", 
        "name": "set.symmetric_difference", 
        "params": [], 
        "path": "python/library/stdtypes#set.symmetric_difference", 
        "syntax": "symmetric_difference(other)", 
        "type": "Built-in Types"
    }, 
    "set.symmetric_difference_update": {
        "descr": "Update the set, keeping only elements found in either set, but not in both.", 
        "name": "set.symmetric_difference_update", 
        "params": [], 
        "path": "python/library/stdtypes#set.symmetric_difference_update", 
        "syntax": "symmetric_difference_update(other)", 
        "type": "Built-in Types"
    }, 
    "set.union": {
        "descr": "Return a new set with elements from the set and all others.", 
        "name": "set.union", 
        "params": [], 
        "path": "python/library/stdtypes#set.union", 
        "syntax": "union(other, ...)", 
        "type": "Built-in Types"
    }, 
    "set.update": {
        "descr": "Update the set, adding elements from all others.", 
        "name": "set.update", 
        "params": [], 
        "path": "python/library/stdtypes#set.update", 
        "syntax": "update(other, ...)", 
        "type": "Built-in Types"
    }, 
    "setattr": {
        "descr": "This is the counterpart of getattr(). The arguments are an object, a string and an arbitrary value. The string may name an existing attribute or a new attribute. The function assigns the value to the attribute, provided the object allows it. For example, setattr(x, 'foobar', 123) is equivalent to x.foobar = 123.", 
        "name": "setattr", 
        "params": [], 
        "path": "python/library/functions#setattr", 
        "syntax": "setattr(object, name, value)", 
        "type": "Built-in Functions"
    }, 
    "setdefault": {
        "descr": "If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None.", 
        "name": "dict.setdefault", 
        "params": [], 
        "path": "python/library/stdtypes#dict.setdefault", 
        "syntax": "setdefault(key[, default])", 
        "type": "Built-in Types"
    }, 
    "shelve.BsdDbShelf": {
        "descr": "A subclass of Shelf which exposes first(), next(), previous(), last() and set_location() which are available in the third-party bsddb module from pybsddb but not in other database modules. The dict object passed to the constructor must support those methods. This is generally accomplished by calling one of bsddb.hashopen(), bsddb.btopen() or bsddb.rnopen(). The optional protocol, writeback, and keyencoding parameters have the same interpretation as for the Shelf class.", 
        "name": "shelve.BsdDbShelf", 
        "params": [], 
        "path": "python/library/shelve#shelve.BsdDbShelf", 
        "syntax": "class shelve.BsdDbShelf(dict, protocol=None, writeback=False, keyencoding='utf-8')", 
        "type": "Data Persistence"
    }, 
    "shelve.DbfilenameShelf": {
        "descr": "A subclass of Shelf which accepts a filename instead of a dict-like object. The underlying file will be opened using dbm.open(). By default, the file will be created and opened for both read and write. The optional flag parameter has the same interpretation as for the open() function. The optional protocol and writeback parameters have the same interpretation as for the Shelf class.", 
        "name": "shelve.DbfilenameShelf", 
        "params": [], 
        "path": "python/library/shelve#shelve.DbfilenameShelf", 
        "syntax": "class shelve.DbfilenameShelf(filename, flag='c', protocol=None, writeback=False)", 
        "type": "Data Persistence"
    }, 
    "shelve.Shelf": {
        "descr": "A subclass of collections.abc.MutableMapping which stores pickled values in the dict object.", 
        "name": "shelve.Shelf", 
        "params": [], 
        "path": "python/library/shelve#shelve.Shelf", 
        "syntax": "class shelve.Shelf(dict, protocol=None, writeback=False, keyencoding='utf-8')", 
        "type": "Data Persistence"
    }, 
    "shelve.Shelf.close": {
        "descr": "Synchronize and close the persistent dict object. Operations on a closed shelf will fail with a ValueError.", 
        "name": "shelve.Shelf.close", 
        "params": [], 
        "path": "python/library/shelve#shelve.Shelf.close", 
        "syntax": "Shelf.close()", 
        "type": "Data Persistence"
    }, 
    "shelve.Shelf.sync": {
        "descr": "Write back all entries in the cache if the shelf was opened with writeback set to True. Also empty the cache and synchronize the persistent dictionary on disk, if feasible. This is called automatically when the shelf is closed with close().", 
        "name": "shelve.Shelf.sync", 
        "params": [], 
        "path": "python/library/shelve#shelve.Shelf.sync", 
        "syntax": "Shelf.sync()", 
        "type": "Data Persistence"
    }, 
    "shelve.open": {
        "descr": "Open a persistent dictionary. The filename specified is the base filename for the underlying database. As a side-effect, an extension may be added to the filename and more than one file may be created. By default, the underlying database file is opened for reading and writing. The optional flag parameter has the same interpretation as the flag parameter of dbm.open().", 
        "name": "shelve.open", 
        "params": [], 
        "path": "python/library/shelve#shelve.open", 
        "syntax": "shelve.open(filename, flag='c', protocol=None, writeback=False)", 
        "type": "Data Persistence"
    }, 
    "shlex.quote": {
        "descr": "Return a shell-escaped version of the string s. The returned value is a string that can safely be used as one token in a shell command line, for cases where you cannot use a list.", 
        "name": "shlex.quote", 
        "params": [], 
        "path": "python/library/shlex#shlex.quote", 
        "syntax": "shlex.quote(s)", 
        "type": "Frameworks"
    }, 
    "shlex.shlex": {
        "descr": "A shlex instance or subclass instance is a lexical analyzer object. The initialization argument, if present, specifies where to read characters from. It must be a file-/stream-like object with read() and readline() methods, or a string. If no argument is given, input will be taken from sys.stdin. The second optional argument is a filename string, which sets the initial value of the infile attribute. If the instream argument is omitted or equal to sys.stdin, this second argument defaults to \u201cstdin\u201d. The posix argument defines the operational mode: when posix is not true (default), the shlex instance will operate in compatibility mode. When operating in POSIX mode, shlex will try to be as close as possible to the POSIX shell parsing rules.", 
        "name": "shlex.shlex", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex", 
        "syntax": "class shlex.shlex(instream=None, infile=None, posix=False)", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.commenters": {
        "descr": "The string of characters that are recognized as comment beginners. All characters from the comment beginner to end of line are ignored. Includes just '#' by default.", 
        "name": "shlex.shlex.commenters", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.commenters", 
        "syntax": "shlex.commenters", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.debug": {
        "descr": "If this attribute is numeric and 1 or more, a shlex instance will print verbose progress output on its behavior. If you need to use this, you can read the module source code to learn the details.", 
        "name": "shlex.shlex.debug", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.debug", 
        "syntax": "shlex.debug", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.eof": {
        "descr": "Token used to determine end of file. This will be set to the empty string (''), in non-POSIX mode, and to None in POSIX mode.", 
        "name": "shlex.shlex.eof", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.eof", 
        "syntax": "shlex.eof", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.error_leader": {
        "descr": "This method generates an error message leader in the format of a Unix C compiler error label; the format is '\"%s\", line %d: ', where the %s is replaced with the name of the current source file and the %d with the current input line number (the optional arguments can be used to override these).", 
        "name": "shlex.shlex.error_leader", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.error_leader", 
        "syntax": "shlex.error_leader(infile=None, lineno=None)", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.escape": {
        "descr": "Characters that will be considered as escape. This will be only used in POSIX mode, and includes just '\\' by default.", 
        "name": "shlex.shlex.escape", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.escape", 
        "syntax": "shlex.escape", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.escapedquotes": {
        "descr": "Characters in quotes that will interpret escape characters defined in escape. This is only used in POSIX mode, and includes just '\"' by default.", 
        "name": "shlex.shlex.escapedquotes", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.escapedquotes", 
        "syntax": "shlex.escapedquotes", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.get_token": {
        "descr": "Return a token. If tokens have been stacked using push_token(), pop a token off the stack. Otherwise, read one from the input stream. If reading encounters an immediate end-of-file, eof is returned (the empty string ('') in non-POSIX mode, and None in POSIX mode).", 
        "name": "shlex.shlex.get_token", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.get_token", 
        "syntax": "shlex.get_token()", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.infile": {
        "descr": "The name of the current input file, as initially set at class instantiation time or stacked by later source requests. It may be useful to examine this when constructing error messages.", 
        "name": "shlex.shlex.infile", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.infile", 
        "syntax": "shlex.infile", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.instream": {
        "descr": "The input stream from which this shlex instance is reading characters.", 
        "name": "shlex.shlex.instream", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.instream", 
        "syntax": "shlex.instream", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.lineno": {
        "descr": "Source line number (count of newlines seen so far plus one).", 
        "name": "shlex.shlex.lineno", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.lineno", 
        "syntax": "shlex.lineno", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.pop_source": {
        "descr": "Pop the last-pushed input source from the input stack. This is the same method used internally when the lexer reaches EOF on a stacked input stream.", 
        "name": "shlex.shlex.pop_source", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.pop_source", 
        "syntax": "shlex.pop_source()", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.push_source": {
        "descr": "Push an input source stream onto the input stack. If the filename argument is specified it will later be available for use in error messages. This is the same method used internally by the sourcehook() method.", 
        "name": "shlex.shlex.push_source", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.push_source", 
        "syntax": "shlex.push_source(newstream, newfile=None)", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.push_token": {
        "descr": "Push the argument onto the token stack.", 
        "name": "shlex.shlex.push_token", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.push_token", 
        "syntax": "shlex.push_token(str)", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.quotes": {
        "descr": "Characters that will be considered string quotes. The token accumulates until the same quote is encountered again (thus, different quote types protect each other as in the shell.) By default, includes ASCII single and double quotes.", 
        "name": "shlex.shlex.quotes", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.quotes", 
        "syntax": "shlex.quotes", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.read_token": {
        "descr": "Read a raw token. Ignore the pushback stack, and do not interpret source requests. (This is not ordinarily a useful entry point, and is documented here only for the sake of completeness.)", 
        "name": "shlex.shlex.read_token", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.read_token", 
        "syntax": "shlex.read_token()", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.source": {
        "descr": "This attribute is None by default. If you assign a string to it, that string will be recognized as a lexical-level inclusion request similar to the source keyword in various shells. That is, the immediately following token will opened as a filename and input taken from that stream until EOF, at which point the close() method of that stream will be called and the input source will again become the original input stream. Source requests may be stacked any number of levels deep.", 
        "name": "shlex.shlex.source", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.source", 
        "syntax": "shlex.source", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.sourcehook": {
        "descr": "When shlex detects a source request (see source below) this method is given the following token as argument, and expected to return a tuple consisting of a filename and an open file-like object.", 
        "name": "shlex.shlex.sourcehook", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.sourcehook", 
        "syntax": "shlex.sourcehook(filename)", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.token": {
        "descr": "The token buffer. It may be useful to examine this when catching exceptions.", 
        "name": "shlex.shlex.token", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.token", 
        "syntax": "shlex.token", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.whitespace": {
        "descr": "Characters that will be considered whitespace and skipped. Whitespace bounds tokens. By default, includes space, tab, linefeed and carriage-return.", 
        "name": "shlex.shlex.whitespace", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.whitespace", 
        "syntax": "shlex.whitespace", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.whitespace_split": {
        "descr": "If True, tokens will only be split in whitespaces. This is useful, for example, for parsing command lines with shlex, getting tokens in a similar way to shell arguments.", 
        "name": "shlex.shlex.whitespace_split", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.whitespace_split", 
        "syntax": "shlex.whitespace_split", 
        "type": "Frameworks"
    }, 
    "shlex.shlex.wordchars": {
        "descr": "The string of characters that will accumulate into multi-character tokens. By default, includes all ASCII alphanumerics and underscore.", 
        "name": "shlex.shlex.wordchars", 
        "params": [], 
        "path": "python/library/shlex#shlex.shlex.wordchars", 
        "syntax": "shlex.wordchars", 
        "type": "Frameworks"
    }, 
    "shlex.split": {
        "descr": "Split the string s using shell-like syntax. If comments is False (the default), the parsing of comments in the given string will be disabled (setting the commenters attribute of the shlex instance to the empty string). This function operates in POSIX mode by default, but uses non-POSIX mode if the posix argument is false.", 
        "name": "shlex.split", 
        "params": [], 
        "path": "python/library/shlex#shlex.split", 
        "syntax": "shlex.split(s, comments=False, posix=True)", 
        "type": "Frameworks"
    }, 
    "shutil.Error": {
        "descr": "This exception collects exceptions that are raised during a multi-file operation. For copytree(), the exception argument is a list of 3-tuples (srcname, dstname, exception).", 
        "name": "shutil.Error", 
        "params": [], 
        "path": "python/library/shutil#shutil.Error", 
        "syntax": "exception shutil.Error", 
        "type": "File & Directory Access"
    }, 
    "shutil.chown": {
        "descr": "Change owner user and/or group of the given path.", 
        "name": "shutil.chown", 
        "params": [], 
        "path": "python/library/shutil#shutil.chown", 
        "syntax": "shutil.chown(path, user=None, group=None)", 
        "type": "File & Directory Access"
    }, 
    "shutil.copy": {
        "descr": "Identical to copy() except that copy2() also attempts to preserve all file metadata.", 
        "name": "shutil.copy", 
        "params": [], 
        "path": "python/library/shutil#shutil.copy", 
        "syntax": "shutil.copy2(src, dst, *, follow_symlinks=True)", 
        "type": "File & Directory Access"
    }, 
    "shutil.copy2": {
        "descr": "Identical to copy() except that copy2() also attempts to preserve all file metadata.", 
        "name": "shutil.copy2", 
        "params": [], 
        "path": "python/library/shutil#shutil.copy2", 
        "syntax": "shutil.copy2(src, dst, *, follow_symlinks=True)", 
        "type": "File & Directory Access"
    }, 
    "shutil.copyfile": {
        "descr": "Copy the contents (no metadata) of the file named src to a file named dst and return dst. src and dst are path names given as strings. dst must be the complete target file name; look at shutil.copy() for a copy that accepts a target directory path. If src and dst specify the same file, Error is raised.", 
        "name": "shutil.copyfile", 
        "params": [], 
        "path": "python/library/shutil#shutil.copyfile", 
        "syntax": "shutil.copyfile(src, dst, *, follow_symlinks=True)", 
        "type": "File & Directory Access"
    }, 
    "shutil.copyfileobj": {
        "descr": "Copy the contents of the file-like object fsrc to the file-like object fdst. The integer length, if given, is the buffer size. In particular, a negative length value means to copy the data without looping over the source data in chunks; by default the data is read in chunks to avoid uncontrolled memory consumption. Note that if the current file position of the fsrc object is not 0, only the contents from the current file position to the end of the file will be copied.", 
        "name": "shutil.copyfileobj", 
        "params": [], 
        "path": "python/library/shutil#shutil.copyfileobj", 
        "syntax": "shutil.copyfileobj(fsrc, fdst[, length])", 
        "type": "File & Directory Access"
    }, 
    "shutil.copymode": {
        "descr": "Copy the permission bits from src to dst. The file contents, owner, and group are unaffected. src and dst are path names given as strings. If follow_symlinks is false, and both src and dst are symbolic links, copymode() will attempt to modify the mode of dst itself (rather than the file it points to). This functionality is not available on every platform; please see copystat() for more information. If copymode() cannot modify symbolic links on the local platform, and it is asked to do so, it will do nothing and return.", 
        "name": "shutil.copymode", 
        "params": [], 
        "path": "python/library/shutil#shutil.copymode", 
        "syntax": "shutil.copymode(src, dst, *, follow_symlinks=True)", 
        "type": "File & Directory Access"
    }, 
    "shutil.copystat": {
        "descr": "Copy the permission bits, last access time, last modification time, and flags from src to dst. On Linux, copystat() also copies the \u201cextended attributes\u201d where possible. The file contents, owner, and group are unaffected. src and dst are path names given as strings.", 
        "name": "shutil.copystat", 
        "params": [], 
        "path": "python/library/shutil#shutil.copystat", 
        "syntax": "shutil.copystat(src, dst, *, follow_symlinks=True)", 
        "type": "File & Directory Access"
    }, 
    "shutil.copytree": {
        "descr": "Recursively copy an entire directory tree rooted at src, returning the destination directory. The destination directory, named by dst, must not already exist; it will be created as well as missing parent directories. Permissions and times of directories are copied with copystat(), individual files are copied using shutil.copy2().", 
        "name": "shutil.copytree", 
        "params": [], 
        "path": "python/library/shutil#shutil.copytree", 
        "syntax": "shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)", 
        "type": "File & Directory Access"
    }, 
    "shutil.disk_usage": {
        "descr": "Return disk usage statistics about the given path as a named tuple with the attributes total, used and free, which are the amount of total, used and free space, in bytes.", 
        "name": "shutil.disk_usage", 
        "params": [], 
        "path": "python/library/shutil#shutil.disk_usage", 
        "syntax": "shutil.disk_usage(path)", 
        "type": "File & Directory Access"
    }, 
    "shutil.get_archive_formats": {
        "descr": "Return a list of supported formats for archiving. Each element of the returned sequence is a tuple (name, description)", 
        "name": "shutil.get_archive_formats", 
        "params": [], 
        "path": "python/library/shutil#shutil.get_archive_formats", 
        "syntax": "shutil.get_archive_formats()", 
        "type": "File & Directory Access"
    }, 
    "shutil.get_terminal_size": {
        "descr": "Get the size of the terminal window.", 
        "name": "shutil.get_terminal_size", 
        "params": [], 
        "path": "python/library/shutil#shutil.get_terminal_size", 
        "syntax": "shutil.get_terminal_size(fallback=(columns, lines))", 
        "type": "File & Directory Access"
    }, 
    "shutil.get_unpack_formats": {
        "descr": "Return a list of all registered formats for unpacking. Each element of the returned sequence is a tuple (name, extensions, description).", 
        "name": "shutil.get_unpack_formats", 
        "params": [], 
        "path": "python/library/shutil#shutil.get_unpack_formats", 
        "syntax": "shutil.get_unpack_formats()", 
        "type": "File & Directory Access"
    }, 
    "shutil.ignore_patterns": {
        "descr": "This factory function creates a function that can be used as a callable for copytree()\u2018s ignore argument, ignoring files and directories that match one of the glob-style patterns provided. See the example below.", 
        "name": "shutil.ignore_patterns", 
        "params": [], 
        "path": "python/library/shutil#shutil.ignore_patterns", 
        "syntax": "shutil.ignore_patterns(*patterns)", 
        "type": "File & Directory Access"
    }, 
    "shutil.make_archive": {
        "descr": "Create an archive file (such as zip or tar) and return its name.", 
        "name": "shutil.make_archive", 
        "params": [], 
        "path": "python/library/shutil#shutil.make_archive", 
        "syntax": "shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])", 
        "type": "File & Directory Access"
    }, 
    "shutil.move": {
        "descr": "Recursively move a file or directory (src) to another location (dst) and return the destination.", 
        "name": "shutil.move", 
        "params": [], 
        "path": "python/library/shutil#shutil.move", 
        "syntax": "shutil.move(src, dst)", 
        "type": "File & Directory Access"
    }, 
    "shutil.register_archive_format": {
        "descr": "Register an archiver for the format name. function is a callable that will be used to invoke the archiver.", 
        "name": "shutil.register_archive_format", 
        "params": [], 
        "path": "python/library/shutil#shutil.register_archive_format", 
        "syntax": "shutil.register_archive_format(name, function[, extra_args[, description]])", 
        "type": "File & Directory Access"
    }, 
    "shutil.register_unpack_format": {
        "descr": "Registers an unpack format. name is the name of the format and extensions is a list of extensions corresponding to the format, like .zip for Zip files.", 
        "name": "shutil.register_unpack_format", 
        "params": [], 
        "path": "python/library/shutil#shutil.register_unpack_format", 
        "syntax": "shutil.register_unpack_format(name, extensions, function[, extra_args[, description]])", 
        "type": "File & Directory Access"
    }, 
    "shutil.rmtree": {
        "descr": "If onerror is provided, it must be a callable that accepts three parameters: function, path, and excinfo.", 
        "name": "shutil.rmtree", 
        "params": [], 
        "path": "python/library/shutil#shutil.rmtree", 
        "syntax": "shutil.rmtree(path, ignore_errors=False, onerror=None)", 
        "type": "File & Directory Access"
    }, 
    "shutil.rmtree.avoids_symlink_attacks": {
        "descr": "Indicates whether the current platform and implementation provides a symlink attack resistant version of rmtree(). Currently this is only true for platforms supporting fd-based directory access functions.", 
        "name": "shutil.rmtree.avoids_symlink_attacks", 
        "params": [], 
        "path": "python/library/shutil#shutil.rmtree.avoids_symlink_attacks", 
        "syntax": "rmtree.avoids_symlink_attacks", 
        "type": "File & Directory Access"
    }, 
    "shutil.unpack_archive": {
        "descr": "Unpack an archive. filename is the full path of the archive.", 
        "name": "shutil.unpack_archive", 
        "params": [], 
        "path": "python/library/shutil#shutil.unpack_archive", 
        "syntax": "shutil.unpack_archive(filename[, extract_dir[, format]])", 
        "type": "File & Directory Access"
    }, 
    "shutil.unregister_archive_format": {
        "descr": "Remove the archive format name from the list of supported formats.", 
        "name": "shutil.unregister_archive_format", 
        "params": [], 
        "path": "python/library/shutil#shutil.unregister_archive_format", 
        "syntax": "shutil.unregister_archive_format(name)", 
        "type": "File & Directory Access"
    }, 
    "shutil.unregister_unpack_format": {
        "descr": "Unregister an unpack format. name is the name of the format.", 
        "name": "shutil.unregister_unpack_format", 
        "params": [], 
        "path": "python/library/shutil#shutil.unregister_unpack_format", 
        "syntax": "shutil.unregister_unpack_format(name)", 
        "type": "File & Directory Access"
    }, 
    "shutil.which": {
        "descr": "Return the path to an executable which would be run if the given cmd was called. If no cmd would be called, return None.", 
        "name": "shutil.which", 
        "params": [], 
        "path": "python/library/shutil#shutil.which", 
        "syntax": "shutil.which(cmd, mode=os.F_OK | os.X_OK, path=None)", 
        "type": "File & Directory Access"
    }, 
    "signal.ItimerError": {
        "descr": "Raised to signal an error from the underlying setitimer() or getitimer() implementation. Expect this error if an invalid interval timer or a negative time is passed to setitimer(). This error is a subtype of OSError.", 
        "name": "signal.ItimerError", 
        "params": [], 
        "path": "python/library/signal#signal.ItimerError", 
        "syntax": "exception signal.ItimerError", 
        "type": "Networking"
    }, 
    "signal.alarm": {
        "descr": "If time is non-zero, this function requests that a SIGALRM signal be sent to the process in time seconds. Any previously scheduled alarm is canceled (only one alarm can be scheduled at any time). The returned value is then the number of seconds before any previously set alarm was to have been delivered. If time is zero, no alarm is scheduled, and any scheduled alarm is canceled. If the return value is zero, no alarm is currently scheduled. (See the Unix man page alarm(2).) Availability: Unix.", 
        "name": "signal.alarm", 
        "params": [], 
        "path": "python/library/signal#signal.alarm", 
        "syntax": "signal.alarm(time)", 
        "type": "Networking"
    }, 
    "signal.getitimer": {
        "descr": "Returns current value of a given interval timer specified by which. Availability: Unix.", 
        "name": "signal.getitimer", 
        "params": [], 
        "path": "python/library/signal#signal.getitimer", 
        "syntax": "signal.getitimer(which)", 
        "type": "Networking"
    }, 
    "signal.getsignal": {
        "descr": "Return the current signal handler for the signal signalnum. The returned value may be a callable Python object, or one of the special values signal.SIG_IGN, signal.SIG_DFL or None. Here, signal.SIG_IGN means that the signal was previously ignored, signal.SIG_DFL means that the default way of handling the signal was previously in use, and None means that the previous signal handler was not installed from Python.", 
        "name": "signal.getsignal", 
        "params": [], 
        "path": "python/library/signal#signal.getsignal", 
        "syntax": "signal.getsignal(signalnum)", 
        "type": "Networking"
    }, 
    "signal.pause": {
        "descr": "Cause the process to sleep until a signal is received; the appropriate handler will then be called. Returns nothing. Not on Windows. (See the Unix man page signal(2).)", 
        "name": "signal.pause", 
        "params": [], 
        "path": "python/library/signal#signal.pause", 
        "syntax": "signal.pause()", 
        "type": "Networking"
    }, 
    "signal.pthread_kill": {
        "descr": "Send the signal signum to the thread thread_id, another thread in the same process as the caller. The target thread can be executing any code (Python or not). However, if the target thread is executing the Python interpreter, the Python signal handlers will be executed by the main thread. Therefore, the only point of sending a signal to a particular Python thread would be to force a running system call to fail with InterruptedError.", 
        "name": "signal.pthread_kill", 
        "params": [], 
        "path": "python/library/signal#signal.pthread_kill", 
        "syntax": "signal.pthread_kill(thread_id, signum)", 
        "type": "Networking"
    }, 
    "signal.pthread_sigmask": {
        "descr": "Fetch and/or change the signal mask of the calling thread. The signal mask is the set of signals whose delivery is currently blocked for the caller. Return the old signal mask as a set of signals.", 
        "name": "signal.pthread_sigmask", 
        "params": [], 
        "path": "python/library/signal#signal.pthread_sigmask", 
        "syntax": "signal.pthread_sigmask(how, mask)", 
        "type": "Networking"
    }, 
    "signal.set_wakeup_fd": {
        "descr": "Set the wakeup file descriptor to fd. When a signal is received, the signal number is written as a single byte into the fd. This can be used by a library to wakeup a poll or select call, allowing the signal to be fully processed.", 
        "name": "signal.set_wakeup_fd", 
        "params": [], 
        "path": "python/library/signal#signal.set_wakeup_fd", 
        "syntax": "signal.set_wakeup_fd(fd)", 
        "type": "Networking"
    }, 
    "signal.setitimer": {
        "descr": "Sets given interval timer (one of signal.ITIMER_REAL, signal.ITIMER_VIRTUAL or signal.ITIMER_PROF) specified by which to fire after seconds (float is accepted, different from alarm()) and after that every interval seconds. The interval timer specified by which can be cleared by setting seconds to zero.", 
        "name": "signal.setitimer", 
        "params": [], 
        "path": "python/library/signal#signal.setitimer", 
        "syntax": "signal.setitimer(which, seconds[, interval])", 
        "type": "Networking"
    }, 
    "signal.siginterrupt": {
        "descr": "Change system call restart behaviour: if flag is False, system calls will be restarted when interrupted by signal signalnum, otherwise system calls will be interrupted. Returns nothing. Availability: Unix (see the man page siginterrupt(3) for further information).", 
        "name": "signal.siginterrupt", 
        "params": [], 
        "path": "python/library/signal#signal.siginterrupt", 
        "syntax": "signal.siginterrupt(signalnum, flag)", 
        "type": "Networking"
    }, 
    "signal.signal": {
        "descr": "Set the handler for signal signalnum to the function handler. handler can be a callable Python object taking two arguments (see below), or one of the special values signal.SIG_IGN or signal.SIG_DFL. The previous signal handler will be returned (see the description of getsignal() above). (See the Unix man page signal(2).)", 
        "name": "signal.signal", 
        "params": [], 
        "path": "python/library/signal#signal.signal", 
        "syntax": "signal.signal(signalnum, handler)", 
        "type": "Networking"
    }, 
    "signal.sigpending": {
        "descr": "Examine the set of signals that are pending for delivery to the calling thread (i.e., the signals which have been raised while blocked). Return the set of the pending signals.", 
        "name": "signal.sigpending", 
        "params": [], 
        "path": "python/library/signal#signal.sigpending", 
        "syntax": "signal.sigpending()", 
        "type": "Networking"
    }, 
    "signal.sigtimedwait": {
        "descr": "Like sigwaitinfo(), but takes an additional timeout argument specifying a timeout. If timeout is specified as 0, a poll is performed. Returns None if a timeout occurs.", 
        "name": "signal.sigtimedwait", 
        "params": [], 
        "path": "python/library/signal#signal.sigtimedwait", 
        "syntax": "signal.sigtimedwait(sigset, timeout)", 
        "type": "Networking"
    }, 
    "signal.sigwait": {
        "descr": "Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set sigset. The function accepts the signal (removes it from the pending list of signals), and returns the signal number.", 
        "name": "signal.sigwait", 
        "params": [], 
        "path": "python/library/signal#signal.sigwait", 
        "syntax": "signal.sigwait(sigset)", 
        "type": "Networking"
    }, 
    "signal.sigwaitinfo": {
        "descr": "Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set sigset. The function accepts the signal and removes it from the pending list of signals. If one of the signals in sigset is already pending for the calling thread, the function will return immediately with information about that signal. The signal handler is not called for the delivered signal. The function raises an InterruptedError if it is interrupted by a signal that is not in sigset.", 
        "name": "signal.sigwaitinfo", 
        "params": [], 
        "path": "python/library/signal#signal.sigwaitinfo", 
        "syntax": "signal.sigwaitinfo(sigset)", 
        "type": "Networking"
    }, 
    "site.addsitedir": {
        "descr": "Add a directory to sys.path and process its .pth files. Typically used in sitecustomize or usercustomize (see above).", 
        "name": "site.addsitedir", 
        "params": [], 
        "path": "python/library/site#site.addsitedir", 
        "syntax": "site.addsitedir(sitedir, known_paths=None)", 
        "type": "Runtime"
    }, 
    "site.getsitepackages": {
        "descr": "Return a list containing all global site-packages directories (and possibly site-python).", 
        "name": "site.getsitepackages", 
        "params": [], 
        "path": "python/library/site#site.getsitepackages", 
        "syntax": "site.getsitepackages()", 
        "type": "Runtime"
    }, 
    "site.getuserbase": {
        "descr": "Return the path of the user base directory, USER_BASE. If it is not initialized yet, this function will also set it, respecting PYTHONUSERBASE.", 
        "name": "site.getuserbase", 
        "params": [], 
        "path": "python/library/site#site.getuserbase", 
        "syntax": "site.getuserbase()", 
        "type": "Runtime"
    }, 
    "site.getusersitepackages": {
        "descr": "Return the path of the user-specific site-packages directory, USER_SITE. If it is not initialized yet, this function will also set it, respecting PYTHONNOUSERSITE and USER_BASE.", 
        "name": "site.getusersitepackages", 
        "params": [], 
        "path": "python/library/site#site.getusersitepackages", 
        "syntax": "site.getusersitepackages()", 
        "type": "Runtime"
    }, 
    "site.main": {
        "descr": "Adds all the standard site-specific directories to the module search path. This function is called automatically when this module is imported, unless the python interpreter was started with the -S flag.", 
        "name": "site.main", 
        "params": [], 
        "path": "python/library/site#site.main", 
        "syntax": "site.main()", 
        "type": "Runtime"
    }, 
    "slice": {
        "descr": "", 
        "name": "slice", 
        "params": [], 
        "path": "python/library/functions#slice", 
        "syntax": "slice(stop)", 
        "type": "Built-in Functions"
    }, 
    "smtpd.DebuggingServer": {
        "descr": "Create a new debugging server. Arguments are as per SMTPServer. Messages will be discarded, and printed on stdout.", 
        "name": "smtpd.DebuggingServer", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.DebuggingServer", 
        "syntax": "class smtpd.DebuggingServer(localaddr, remoteaddr)", 
        "type": "Internet"
    }, 
    "smtpd.MailmanProxy": {
        "descr": "Create a new pure proxy server. Arguments are as per SMTPServer. Everything will be relayed to remoteaddr, unless local mailman configurations knows about an address, in which case it will be handled via mailman. Note that running this has a good chance to make you into an open relay, so please be careful.", 
        "name": "smtpd.MailmanProxy", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.MailmanProxy", 
        "syntax": "class smtpd.MailmanProxy(localaddr, remoteaddr)", 
        "type": "Internet"
    }, 
    "smtpd.PureProxy": {
        "descr": "Create a new pure proxy server. Arguments are as per SMTPServer. Everything will be relayed to remoteaddr. Note that running this has a good chance to make you into an open relay, so please be careful.", 
        "name": "smtpd.PureProxy", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.PureProxy", 
        "syntax": "class smtpd.PureProxy(localaddr, remoteaddr)", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel": {
        "descr": "Create a new SMTPChannel object which manages the communication between the server and a single SMTP client.", 
        "name": "smtpd.SMTPChannel", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel", 
        "syntax": "class smtpd.SMTPChannel(server, conn, addr)", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.addr": {
        "descr": "Holds the address of the client, the second value returned by socket.accept", 
        "name": "smtpd.SMTPChannel.addr", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.addr", 
        "syntax": "addr", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.conn": {
        "descr": "Holds the socket object connecting to the client.", 
        "name": "smtpd.SMTPChannel.conn", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.conn", 
        "syntax": "conn", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.fqdn": {
        "descr": "Holds the fully-qualified domain name of the server as returned by socket.getfqdn().", 
        "name": "smtpd.SMTPChannel.fqdn", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.fqdn", 
        "syntax": "fqdn", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.mailfrom": {
        "descr": "Holds a string containing the address identified in the \u201cMAIL FROM:\u201d line from the client.", 
        "name": "smtpd.SMTPChannel.mailfrom", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.mailfrom", 
        "syntax": "mailfrom", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.peer": {
        "descr": "Holds the name of the client peer as returned by conn.getpeername() where conn is conn.", 
        "name": "smtpd.SMTPChannel.peer", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.peer", 
        "syntax": "peer", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.rcpttos": {
        "descr": "Holds a list of strings containing the addresses identified in the \u201cRCPT TO:\u201d lines from the client.", 
        "name": "smtpd.SMTPChannel.rcpttos", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.rcpttos", 
        "syntax": "rcpttos", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.received_data": {
        "descr": "Holds a string containing all of the data sent by the client during the DATA state, up to but not including the terminating \"\\r\\n.\\r\\n\".", 
        "name": "smtpd.SMTPChannel.received_data", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.received_data", 
        "syntax": "received_data", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.received_lines": {
        "descr": "Holds a list of the line strings (decoded using UTF-8) received from the client. The lines have their \"\\r\\n\" line ending translated to \"\\n\".", 
        "name": "smtpd.SMTPChannel.received_lines", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.received_lines", 
        "syntax": "received_lines", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.seen_greeting": {
        "descr": "Holds a string containing the greeting sent by the client in its \u201cHELO\u201d.", 
        "name": "smtpd.SMTPChannel.seen_greeting", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.seen_greeting", 
        "syntax": "seen_greeting", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.smtp_server": {
        "descr": "Holds the SMTPServer that spawned this channel.", 
        "name": "smtpd.SMTPChannel.smtp_server", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.smtp_server", 
        "syntax": "smtp_server", 
        "type": "Internet"
    }, 
    "smtpd.SMTPChannel.smtp_state": {
        "descr": "Holds the current state of the channel. This will be either COMMAND initially and then DATA after the client sends a \u201cDATA\u201d line.", 
        "name": "smtpd.SMTPChannel.smtp_state", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPChannel.smtp_state", 
        "syntax": "smtp_state", 
        "type": "Internet"
    }, 
    "smtpd.SMTPServer": {
        "descr": "Create a new SMTPServer object, which binds to local address localaddr. It will treat remoteaddr as an upstream SMTP relayer. It inherits from asyncore.dispatcher, and so will insert itself into asyncore\u2018s event loop on instantiation.", 
        "name": "smtpd.SMTPServer", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPServer", 
        "syntax": "class smtpd.SMTPServer(localaddr, remoteaddr, data_size_limit=33554432)", 
        "type": "Internet"
    }, 
    "smtpd.SMTPServer.channel_class": {
        "descr": "Override this in subclasses to use a custom SMTPChannel for managing SMTP clients.", 
        "name": "smtpd.SMTPServer.channel_class", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPServer.channel_class", 
        "syntax": "channel_class", 
        "type": "Internet"
    }, 
    "smtpd.SMTPServer.process_message": {
        "descr": "Raise NotImplementedError exception. Override this in subclasses to do something useful with this message. Whatever was passed in the constructor as remoteaddr will be available as the _remoteaddr attribute. peer is the remote host\u2019s address, mailfrom is the envelope originator, rcpttos are the envelope recipients and data is a string containing the contents of the e-mail (which should be in RFC 2822 format).", 
        "name": "smtpd.SMTPServer.process_message", 
        "params": [], 
        "path": "python/library/smtpd#smtpd.SMTPServer.process_message", 
        "syntax": "process_message(peer, mailfrom, rcpttos, data)", 
        "type": "Internet"
    }, 
    "smtplib.LMTP": {
        "descr": "The LMTP protocol, which is very similar to ESMTP, is heavily based on the standard SMTP client. It\u2019s common to use Unix sockets for LMTP, so our connect() method must support that as well as a regular host:port server. The optional arguments local_hostname and source_address have the same meaning as they do in the SMTP class. To specify a Unix socket, you must use an absolute path for host, starting with a \u2018/\u2019.", 
        "name": "smtplib.LMTP", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.LMTP", 
        "syntax": "class smtplib.LMTP(host='', port=LMTP_PORT, local_hostname=None, source_address=None)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP": {
        "descr": "A SMTP instance encapsulates an SMTP connection. It has methods that support a full repertoire of SMTP and ESMTP operations. If the optional host and port parameters are given, the SMTP connect() method is called with those parameters during initialization. If specified, local_hostname is used as the FQDN of the local host in the HELO/EHLO command. Otherwise, the local hostname is found using socket.getfqdn(). If the connect() call returns anything other than a success code, an SMTPConnectError is raised. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). The optional source_address parameter allows to bind to some specific source address in a machine with multiple network interfaces, and/or to some specific source TCP port. It takes a 2-tuple (host, port), for the socket to bind to as its source address before connecting. If omitted (or if host or port are '' and/or 0 respectively) the OS default behavior will be used.", 
        "name": "smtplib.SMTP", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP", 
        "syntax": "class smtplib.SMTP(host='', port=0, local_hostname=None[, timeout], source_address=None)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.connect": {
        "descr": "Connect to a host on a given port. The defaults are to connect to the local host at the standard SMTP port (25). If the hostname ends with a colon (':') followed by a number, that suffix will be stripped off and the number interpreted as the port number to use. This method is automatically invoked by the constructor if a host is specified during instantiation. Returns a 2-tuple of the response code and message sent by the server in its connection response.", 
        "name": "smtplib.SMTP.connect", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.connect", 
        "syntax": "SMTP.connect(host='localhost', port=0)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.docmd": {
        "descr": "Send a command cmd to the server. The optional argument args is simply concatenated to the command, separated by a space.", 
        "name": "smtplib.SMTP.docmd", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.docmd", 
        "syntax": "SMTP.docmd(cmd, args='')", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.ehlo": {
        "descr": "Identify yourself to an ESMTP server using EHLO. The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by has_extn(). Also sets several informational attributes: the message returned by the server is stored as the ehlo_resp attribute, does_esmtp is set to true or false depending on whether the server supports ESMTP, and esmtp_features will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any).", 
        "name": "smtplib.SMTP.ehlo", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.ehlo", 
        "syntax": "SMTP.ehlo(name='')", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.ehlo_or_helo_if_needed": {
        "descr": "This method call ehlo() and or helo() if there has been no previous EHLO or HELO command this session. It tries ESMTP EHLO first.", 
        "name": "smtplib.SMTP.ehlo_or_helo_if_needed", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.ehlo_or_helo_if_needed", 
        "syntax": "SMTP.ehlo_or_helo_if_needed()", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.has_extn": {
        "descr": "Return True if name is in the set of SMTP service extensions returned by the server, False otherwise. Case is ignored.", 
        "name": "smtplib.SMTP.has_extn", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.has_extn", 
        "syntax": "SMTP.has_extn(name)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.helo": {
        "descr": "Identify yourself to the SMTP server using HELO. The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the helo_resp attribute of the object.", 
        "name": "smtplib.SMTP.helo", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.helo", 
        "syntax": "SMTP.helo(name='')", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.login": {
        "descr": "Log in on an SMTP server that requires authentication. The arguments are the username and the password to authenticate with. If there has been no previous EHLO or HELO command this session, this method tries ESMTP EHLO first. This method will return normally if the authentication was successful, or may raise the following exceptions:", 
        "name": "smtplib.SMTP.login", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.login", 
        "syntax": "SMTP.login(user, password)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.quit": {
        "descr": "Terminate the SMTP session and close the connection. Return the result of the SMTP QUIT command.", 
        "name": "smtplib.SMTP.quit", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.quit", 
        "syntax": "SMTP.quit()", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.send_message": {
        "descr": "This is a convenience method for calling sendmail() with the message represented by an email.message.Message object. The arguments have the same meaning as for sendmail(), except that msg is a Message object.", 
        "name": "smtplib.SMTP.send_message", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.send_message", 
        "syntax": "SMTP.send_message(msg, from_addr=None, to_addrs=None, mail_options=[], rcpt_options=[])", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.sendmail": {
        "descr": "Send mail. The required arguments are an RFC 822 from-address string, a list of RFC 822 to-address strings (a bare string will be treated as a list with 1 address), and a message string. The caller may pass a list of ESMTP options (such as 8bitmime) to be used in MAIL FROM commands as mail_options. ESMTP options (such as DSN commands) that should be used with all RCPT commands can be passed as rcpt_options. (If you need to use different ESMTP options to different recipients you have to use the low-level methods such as mail(), rcpt() and data() to send the message.)", 
        "name": "smtplib.SMTP.sendmail", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.sendmail", 
        "syntax": "SMTP.sendmail(from_addr, to_addrs, msg, mail_options=[], rcpt_options=[])", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.set_debuglevel": {
        "descr": "Set the debug output level. A true value for level results in debug messages for connection and for all messages sent to and received from the server.", 
        "name": "smtplib.SMTP.set_debuglevel", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.set_debuglevel", 
        "syntax": "SMTP.set_debuglevel(level)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.starttls": {
        "descr": "Put the SMTP connection in TLS (Transport Layer Security) mode. All SMTP commands that follow will be encrypted. You should then call ehlo() again.", 
        "name": "smtplib.SMTP.starttls", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.starttls", 
        "syntax": "SMTP.starttls(keyfile=None, certfile=None, context=None)", 
        "type": "Internet"
    }, 
    "smtplib.SMTP.verify": {
        "descr": "Check the validity of an address on this server using SMTP VRFY. Returns a tuple consisting of code 250 and a full RFC 822 address (including human name) if the user address is valid. Otherwise returns an SMTP error code of 400 or greater and an error string.", 
        "name": "smtplib.SMTP.verify", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP.verify", 
        "syntax": "SMTP.verify(address)", 
        "type": "Internet"
    }, 
    "smtplib.SMTPAuthenticationError": {
        "descr": "SMTP authentication went wrong. Most probably the server didn\u2019t accept the username/password combination provided.", 
        "name": "smtplib.SMTPAuthenticationError", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPAuthenticationError", 
        "syntax": "exception smtplib.SMTPAuthenticationError", 
        "type": "Internet"
    }, 
    "smtplib.SMTPConnectError": {
        "descr": "Error occurred during establishment of a connection with the server.", 
        "name": "smtplib.SMTPConnectError", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPConnectError", 
        "syntax": "exception smtplib.SMTPConnectError", 
        "type": "Internet"
    }, 
    "smtplib.SMTPDataError": {
        "descr": "The SMTP server refused to accept the message data.", 
        "name": "smtplib.SMTPDataError", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPDataError", 
        "syntax": "exception smtplib.SMTPDataError", 
        "type": "Internet"
    }, 
    "smtplib.SMTPException": {
        "descr": "The base exception class for all the other exceptions provided by this module.", 
        "name": "smtplib.SMTPException", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPException", 
        "syntax": "exception smtplib.SMTPException", 
        "type": "Internet"
    }, 
    "smtplib.SMTPHeloError": {
        "descr": "The server refused our HELO message.", 
        "name": "smtplib.SMTPHeloError", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPHeloError", 
        "syntax": "exception smtplib.SMTPHeloError", 
        "type": "Internet"
    }, 
    "smtplib.SMTPRecipientsRefused": {
        "descr": "All recipient addresses refused. The errors for each recipient are accessible through the attribute recipients, which is a dictionary of exactly the same sort as SMTP.sendmail() returns.", 
        "name": "smtplib.SMTPRecipientsRefused", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPRecipientsRefused", 
        "syntax": "exception smtplib.SMTPRecipientsRefused", 
        "type": "Internet"
    }, 
    "smtplib.SMTPResponseException": {
        "descr": "Base class for all exceptions that include an SMTP error code. These exceptions are generated in some instances when the SMTP server returns an error code. The error code is stored in the smtp_code attribute of the error, and the smtp_error attribute is set to the error message.", 
        "name": "smtplib.SMTPResponseException", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPResponseException", 
        "syntax": "exception smtplib.SMTPResponseException", 
        "type": "Internet"
    }, 
    "smtplib.SMTPSenderRefused": {
        "descr": "Sender address refused. In addition to the attributes set by on all SMTPResponseException exceptions, this sets \u2018sender\u2019 to the string that the SMTP server refused.", 
        "name": "smtplib.SMTPSenderRefused", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPSenderRefused", 
        "syntax": "exception smtplib.SMTPSenderRefused", 
        "type": "Internet"
    }, 
    "smtplib.SMTPServerDisconnected": {
        "descr": "This exception is raised when the server unexpectedly disconnects, or when an attempt is made to use the SMTP instance before connecting it to a server.", 
        "name": "smtplib.SMTPServerDisconnected", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTPServerDisconnected", 
        "syntax": "exception smtplib.SMTPServerDisconnected", 
        "type": "Internet"
    }, 
    "smtplib.SMTP_SSL": {
        "descr": "A SMTP_SSL instance behaves exactly the same as instances of SMTP. SMTP_SSL should be used for situations where SSL is required from the beginning of the connection and using starttls() is not appropriate. If host is not specified, the local host is used. If port is zero, the standard SMTP-over-SSL port (465) is used. The optional arguments local_hostname and source_address have the same meaning as they do in the SMTP class. keyfile and certfile are also optional, and can contain a PEM formatted private key and certificate chain file for the SSL connection. context also optional, can contain a SSLContext, and is an alternative to keyfile and certfile; If it is specified both keyfile and certfile must be None. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). The optional source_address parameter allows to bind to some specific source address in a machine with multiple network interfaces, and/or to some specific source tcp port. It takes a 2-tuple (host, port), for the socket to bind to as its source address before connecting. If omitted (or if host or port are '' and/or 0 respectively) the OS default behavior will be used.", 
        "name": "smtplib.SMTP_SSL", 
        "params": [], 
        "path": "python/library/smtplib#smtplib.SMTP_SSL", 
        "syntax": "class smtplib.SMTP_SSL(host='', port=0, local_hostname=None, keyfile=None, certfile=None[, timeout], context=None, source_address=None)", 
        "type": "Internet"
    }, 
    "sndhdr.what": {
        "descr": "Determines the type of sound data stored in the file filename using whathdr(). If it succeeds, returns a tuple as described above, otherwise None is returned.", 
        "name": "sndhdr.what", 
        "params": [], 
        "path": "python/library/sndhdr#sndhdr.what", 
        "syntax": "sndhdr.what(filename)", 
        "type": "Multimedia"
    }, 
    "sndhdr.whathdr": {
        "descr": "Determines the type of sound data stored in a file based on the file header. The name of the file is given by filename. This function returns a tuple as described above on success, or None.", 
        "name": "sndhdr.whathdr", 
        "params": [], 
        "path": "python/library/sndhdr#sndhdr.whathdr", 
        "syntax": "sndhdr.whathdr(filename)", 
        "type": "Multimedia"
    }, 
    "socket.CMSG_LEN": {
        "descr": "Return the total length, without trailing padding, of an ancillary data item with associated data of the given length. This value can often be used as the buffer size for recvmsg() to receive a single item of ancillary data, but RFC 3542 requires portable applications to use CMSG_SPACE() and thus include space for padding, even when the item will be the last in the buffer. Raises OverflowError if length is outside the permissible range of values.", 
        "name": "socket.CMSG_LEN", 
        "params": [], 
        "path": "python/library/socket#socket.CMSG_LEN", 
        "syntax": "socket.CMSG_LEN(length)", 
        "type": "Networking"
    }, 
    "socket.CMSG_SPACE": {
        "descr": "Return the buffer size needed for recvmsg() to receive an ancillary data item with associated data of the given length, along with any trailing padding. The buffer space needed to receive multiple items is the sum of the CMSG_SPACE() values for their associated data lengths. Raises OverflowError if length is outside the permissible range of values.", 
        "name": "socket.CMSG_SPACE", 
        "params": [], 
        "path": "python/library/socket#socket.CMSG_SPACE", 
        "syntax": "socket.CMSG_SPACE(length)", 
        "type": "Networking"
    }, 
    "socket.SocketType": {
        "descr": "This is a Python type object that represents the socket object type. It is the same as type(socket(...)).", 
        "name": "socket.SocketType", 
        "params": [], 
        "path": "python/library/socket#socket.SocketType", 
        "syntax": "socket.SocketType", 
        "type": "Networking"
    }, 
    "socket.create_connection": {
        "descr": "Connect to a TCP service listening on the Internet address (a 2-tuple (host, port)), and return the socket object. This is a higher-level function than socket.connect(): if host is a non-numeric hostname, it will try to resolve it for both AF_INET and AF_INET6, and then try to connect to all possible addresses in turn until a connection succeeds. This makes it easy to write clients that are compatible to both IPv4 and IPv6.", 
        "name": "socket.create_connection", 
        "params": [], 
        "path": "python/library/socket#socket.create_connection", 
        "syntax": "socket.create_connection(address[, timeout[, source_address]])", 
        "type": "Networking"
    }, 
    "socket.error": {
        "descr": "A deprecated alias of OSError.", 
        "name": "socket.error", 
        "params": [], 
        "path": "python/library/socket#socket.error", 
        "syntax": "exception socket.error", 
        "type": "Networking"
    }, 
    "socket.fromfd": {
        "descr": "Duplicate the file descriptor fd (an integer as returned by a file object\u2019s fileno() method) and build a socket object from the result. Address family, socket type and protocol number are as for the socket() function above. The file descriptor should refer to a socket, but this is not checked \u2014 subsequent operations on the object may fail if the file descriptor is invalid. This function is rarely needed, but can be used to get or set socket options on a socket passed to a program as standard input or output (such as a server started by the Unix inet daemon). The socket is assumed to be in blocking mode.", 
        "name": "socket.fromfd", 
        "params": [], 
        "path": "python/library/socket#socket.fromfd", 
        "syntax": "socket.fromfd(fd, family, type[, proto])", 
        "type": "Networking"
    }, 
    "socket.fromshare": {
        "descr": "Instantiate a socket from data obtained from the socket.share() method. The socket is assumed to be in blocking mode.", 
        "name": "socket.fromshare", 
        "params": [], 
        "path": "python/library/socket#socket.fromshare", 
        "syntax": "socket.fromshare(data)", 
        "type": "Networking"
    }, 
    "socket.gaierror": {
        "descr": "A subclass of OSError, this exception is raised for address-related errors by getaddrinfo() and getnameinfo(). The accompanying value is a pair (error, string) representing an error returned by a library call. string represents the description of error, as returned by the gai_strerror() C function. The numeric error value will match one of the EAI_* constants defined in this module.", 
        "name": "socket.gaierror", 
        "params": [], 
        "path": "python/library/socket#socket.gaierror", 
        "syntax": "exception socket.gaierror", 
        "type": "Networking"
    }, 
    "socket.getaddrinfo": {
        "descr": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. host is a domain name, a string representation of an IPv4/v6 address or None. port is a string service name such as 'http', a numeric port number or None. By passing None as the value of host and port, you can pass NULL to the underlying C API.", 
        "name": "socket.getaddrinfo", 
        "params": [], 
        "path": "python/library/socket#socket.getaddrinfo", 
        "syntax": "socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)", 
        "type": "Networking"
    }, 
    "socket.getdefaulttimeout": {
        "descr": "Return the default timeout in seconds (float) for new socket objects. A value of None indicates that new socket objects have no timeout. When the socket module is first imported, the default is None.", 
        "name": "socket.getdefaulttimeout", 
        "params": [], 
        "path": "python/library/socket#socket.getdefaulttimeout", 
        "syntax": "socket.getdefaulttimeout()", 
        "type": "Networking"
    }, 
    "socket.getfqdn": {
        "descr": "Return a fully qualified domain name for name. If name is omitted or empty, it is interpreted as the local host. To find the fully qualified name, the hostname returned by gethostbyaddr() is checked, followed by aliases for the host, if available. The first name which includes a period is selected. In case no fully qualified domain name is available, the hostname as returned by gethostname() is returned.", 
        "name": "socket.getfqdn", 
        "params": [], 
        "path": "python/library/socket#socket.getfqdn", 
        "syntax": "socket.getfqdn([name])", 
        "type": "Networking"
    }, 
    "socket.gethostbyaddr": {
        "descr": "Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4/v6 addresses for the same interface on the same host (most likely containing only a single address). To find the fully qualified domain name, use the function getfqdn(). gethostbyaddr() supports both IPv4 and IPv6.", 
        "name": "socket.gethostbyaddr", 
        "params": [], 
        "path": "python/library/socket#socket.gethostbyaddr", 
        "syntax": "socket.gethostbyaddr(ip_address)", 
        "type": "Networking"
    }, 
    "socket.gethostbyname": {
        "descr": "Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as '100.50.200.5'. If the host name is an IPv4 address itself it is returned unchanged. See gethostbyname_ex() for a more complete interface. gethostbyname() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support.", 
        "name": "socket.gethostbyname", 
        "params": [], 
        "path": "python/library/socket#socket.gethostbyname", 
        "syntax": "socket.gethostbyname(hostname)", 
        "type": "Networking"
    }, 
    "socket.gethostbyname_ex": {
        "descr": "Translate a host name to IPv4 address format, extended interface. Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4 addresses for the same interface on the same host (often but not always a single address). gethostbyname_ex() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support.", 
        "name": "socket.gethostbyname_ex", 
        "params": [], 
        "path": "python/library/socket#socket.gethostbyname_ex", 
        "syntax": "socket.gethostbyname_ex(hostname)", 
        "type": "Networking"
    }, 
    "socket.gethostname": {
        "descr": "Return a string containing the hostname of the machine where the Python interpreter is currently executing.", 
        "name": "socket.gethostname", 
        "params": [], 
        "path": "python/library/socket#socket.gethostname", 
        "syntax": "socket.gethostname()", 
        "type": "Networking"
    }, 
    "socket.getnameinfo": {
        "descr": "Translate a socket address sockaddr into a 2-tuple (host, port). Depending on the settings of flags, the result can contain a fully-qualified domain name or numeric address representation in host. Similarly, port can contain a string port name or a numeric port number.", 
        "name": "socket.getnameinfo", 
        "params": [], 
        "path": "python/library/socket#socket.getnameinfo", 
        "syntax": "socket.getnameinfo(sockaddr, flags)", 
        "type": "Networking"
    }, 
    "socket.getprotobyname": {
        "descr": "Translate an Internet protocol name (for example, 'icmp') to a constant suitable for passing as the (optional) third argument to the socket() function. This is usually only needed for sockets opened in \u201craw\u201d mode (SOCK_RAW); for the normal socket modes, the correct protocol is chosen automatically if the protocol is omitted or zero.", 
        "name": "socket.getprotobyname", 
        "params": [], 
        "path": "python/library/socket#socket.getprotobyname", 
        "syntax": "socket.getprotobyname(protocolname)", 
        "type": "Networking"
    }, 
    "socket.getservbyname": {
        "descr": "Translate an Internet service name and protocol name to a port number for that service. The optional protocol name, if given, should be 'tcp' or 'udp', otherwise any protocol will match.", 
        "name": "socket.getservbyname", 
        "params": [], 
        "path": "python/library/socket#socket.getservbyname", 
        "syntax": "socket.getservbyname(servicename[, protocolname])", 
        "type": "Networking"
    }, 
    "socket.getservbyport": {
        "descr": "Translate an Internet port number and protocol name to a service name for that service. The optional protocol name, if given, should be 'tcp' or 'udp', otherwise any protocol will match.", 
        "name": "socket.getservbyport", 
        "params": [], 
        "path": "python/library/socket#socket.getservbyport", 
        "syntax": "socket.getservbyport(port[, protocolname])", 
        "type": "Networking"
    }, 
    "socket.has_ipv6": {
        "descr": "This constant contains a boolean value which indicates if IPv6 is supported on this platform.", 
        "name": "socket.has_ipv6", 
        "params": [], 
        "path": "python/library/socket#socket.has_ipv6", 
        "syntax": "socket.has_ipv6", 
        "type": "Networking"
    }, 
    "socket.herror": {
        "descr": "A subclass of OSError, this exception is raised for address-related errors, i.e. for functions that use h_errno in the POSIX C API, including gethostbyname_ex() and gethostbyaddr(). The accompanying value is a pair (h_errno, string) representing an error returned by a library call. h_errno is a numeric value, while string represents the description of h_errno, as returned by the hstrerror() C function.", 
        "name": "socket.herror", 
        "params": [], 
        "path": "python/library/socket#socket.herror", 
        "syntax": "exception socket.herror", 
        "type": "Networking"
    }, 
    "socket.htonl": {
        "descr": "Convert 32-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.", 
        "name": "socket.htonl", 
        "params": [], 
        "path": "python/library/socket#socket.htonl", 
        "syntax": "socket.htonl(x)", 
        "type": "Networking"
    }, 
    "socket.htons": {
        "descr": "Convert 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.", 
        "name": "socket.htons", 
        "params": [], 
        "path": "python/library/socket#socket.htons", 
        "syntax": "socket.htons(x)", 
        "type": "Networking"
    }, 
    "socket.if_indextoname": {
        "descr": "Return a network interface name corresponding to a interface index number. OSError if no interface with the given index exists.", 
        "name": "socket.if_indextoname", 
        "params": [], 
        "path": "python/library/socket#socket.if_indextoname", 
        "syntax": "socket.if_indextoname(if_index)", 
        "type": "Networking"
    }, 
    "socket.if_nameindex": {
        "descr": "Return a list of network interface information (index int, name string) tuples. OSError if the system call fails.", 
        "name": "socket.if_nameindex", 
        "params": [], 
        "path": "python/library/socket#socket.if_nameindex", 
        "syntax": "socket.if_nameindex()", 
        "type": "Networking"
    }, 
    "socket.if_nametoindex": {
        "descr": "Return a network interface index number corresponding to an interface name. OSError if no interface with the given name exists.", 
        "name": "socket.if_nametoindex", 
        "params": [], 
        "path": "python/library/socket#socket.if_nametoindex", 
        "syntax": "socket.if_nametoindex(if_name)", 
        "type": "Networking"
    }, 
    "socket.inet_aton": {
        "descr": "Convert an IPv4 address from dotted-quad string format (for example, \u2018123.45.67.89\u2019) to 32-bit packed binary format, as a bytes object four characters in length. This is useful when conversing with a program that uses the standard C library and needs objects of type struct in_addr, which is the C type for the 32-bit packed binary this function returns.", 
        "name": "socket.inet_aton", 
        "params": [], 
        "path": "python/library/socket#socket.inet_aton", 
        "syntax": "socket.inet_aton(ip_string)", 
        "type": "Networking"
    }, 
    "socket.inet_ntoa": {
        "descr": "Convert a 32-bit packed IPv4 address (a bytes object four characters in length) to its standard dotted-quad string representation (for example, \u2018123.45.67.89\u2019). This is useful when conversing with a program that uses the standard C library and needs objects of type struct in_addr, which is the C type for the 32-bit packed binary data this function takes as an argument.", 
        "name": "socket.inet_ntoa", 
        "params": [], 
        "path": "python/library/socket#socket.inet_ntoa", 
        "syntax": "socket.inet_ntoa(packed_ip)", 
        "type": "Networking"
    }, 
    "socket.inet_ntop": {
        "descr": "Convert a packed IP address (a bytes object of some number of characters) to its standard, family-specific string representation (for example, '7.10.0.5' or '5aef:2b::8'). inet_ntop() is useful when a library or network protocol returns an object of type struct in_addr (similar to inet_ntoa()) or struct in6_addr.", 
        "name": "socket.inet_ntop", 
        "params": [], 
        "path": "python/library/socket#socket.inet_ntop", 
        "syntax": "socket.inet_ntop(address_family, packed_ip)", 
        "type": "Networking"
    }, 
    "socket.inet_pton": {
        "descr": "Convert an IP address from its family-specific string format to a packed, binary format. inet_pton() is useful when a library or network protocol calls for an object of type struct in_addr (similar to inet_aton()) or struct in6_addr.", 
        "name": "socket.inet_pton", 
        "params": [], 
        "path": "python/library/socket#socket.inet_pton", 
        "syntax": "socket.inet_pton(address_family, ip_string)", 
        "type": "Networking"
    }, 
    "socket.ntohl": {
        "descr": "Convert 32-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.", 
        "name": "socket.ntohl", 
        "params": [], 
        "path": "python/library/socket#socket.ntohl", 
        "syntax": "socket.ntohl(x)", 
        "type": "Networking"
    }, 
    "socket.ntohs": {
        "descr": "Convert 16-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.", 
        "name": "socket.ntohs", 
        "params": [], 
        "path": "python/library/socket#socket.ntohs", 
        "syntax": "socket.ntohs(x)", 
        "type": "Networking"
    }, 
    "socket.setdefaulttimeout": {
        "descr": "Set the default timeout in seconds (float) for new socket objects. When the socket module is first imported, the default is None. See settimeout() for possible values and their respective meanings.", 
        "name": "socket.setdefaulttimeout", 
        "params": [], 
        "path": "python/library/socket#socket.setdefaulttimeout", 
        "syntax": "socket.setdefaulttimeout(timeout)", 
        "type": "Networking"
    }, 
    "socket.sethostname": {
        "descr": "Set the machine\u2019s hostname to name. This will raise a OSError if you don\u2019t have enough rights.", 
        "name": "socket.sethostname", 
        "params": [], 
        "path": "python/library/socket#socket.sethostname", 
        "syntax": "socket.sethostname(name)", 
        "type": "Networking"
    }, 
    "socket.socket": {
        "descr": "Create a new socket using the given address family, socket type and protocol number. The address family should be AF_INET (the default), AF_INET6, AF_UNIX, AF_CAN or AF_RDS. The socket type should be SOCK_STREAM (the default), SOCK_DGRAM, SOCK_RAW or perhaps one of the other SOCK_ constants. The protocol number is usually zero and may be omitted in that case or CAN_RAW in case the address family is AF_CAN.", 
        "name": "socket.socket", 
        "params": [], 
        "path": "python/library/socket#socket.socket", 
        "syntax": "socket.socket([family[, type[, proto]]])", 
        "type": "Networking"
    }, 
    "socket.socket.accept": {
        "descr": "Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.", 
        "name": "socket.socket.accept", 
        "params": [], 
        "path": "python/library/socket#socket.socket.accept", 
        "syntax": "socket.accept()", 
        "type": "Networking"
    }, 
    "socket.socket.bind": {
        "descr": "Bind the socket to address. The socket must not already be bound. (The format of address depends on the address family \u2014 see above.)", 
        "name": "socket.socket.bind", 
        "params": [], 
        "path": "python/library/socket#socket.socket.bind", 
        "syntax": "socket.bind(address)", 
        "type": "Networking"
    }, 
    "socket.socket.close": {
        "descr": "Mark the socket closed. The underlying system resource (e.g. a file descriptor) is also closed when all file objects from makefile() are closed. Once that happens, all future operations on the socket object will fail. The remote end will receive no more data (after queued data is flushed).", 
        "name": "socket.socket.close", 
        "params": [], 
        "path": "python/library/socket#socket.socket.close", 
        "syntax": "socket.close()", 
        "type": "Networking"
    }, 
    "socket.socket.connect": {
        "descr": "Connect to a remote socket at address. (The format of address depends on the address family \u2014 see above.)", 
        "name": "socket.socket.connect", 
        "params": [], 
        "path": "python/library/socket#socket.socket.connect", 
        "syntax": "socket.connect(address)", 
        "type": "Networking"
    }, 
    "socket.socket.connect_ex": {
        "descr": "Like connect(address), but return an error indicator instead of raising an exception for errors returned by the C-level connect() call (other problems, such as \u201chost not found,\u201d can still raise exceptions). The error indicator is 0 if the operation succeeded, otherwise the value of the errno variable. This is useful to support, for example, asynchronous connects.", 
        "name": "socket.socket.connect_ex", 
        "params": [], 
        "path": "python/library/socket#socket.socket.connect_ex", 
        "syntax": "socket.connect_ex(address)", 
        "type": "Networking"
    }, 
    "socket.socket.detach": {
        "descr": "Put the socket object into closed state without actually closing the underlying file descriptor. The file descriptor is returned, and can be reused for other purposes.", 
        "name": "socket.socket.detach", 
        "params": [], 
        "path": "python/library/socket#socket.socket.detach", 
        "syntax": "socket.detach()", 
        "type": "Networking"
    }, 
    "socket.socket.family": {
        "descr": "The socket family.", 
        "name": "socket.socket.family", 
        "params": [], 
        "path": "python/library/socket#socket.socket.family", 
        "syntax": "socket.family", 
        "type": "Networking"
    }, 
    "socket.socket.fileno": {
        "descr": "Return the socket\u2019s file descriptor (a small integer). This is useful with select.select().", 
        "name": "socket.socket.fileno", 
        "params": [], 
        "path": "python/library/socket#socket.socket.fileno", 
        "syntax": "socket.fileno()", 
        "type": "Networking"
    }, 
    "socket.socket.getpeername": {
        "descr": "Return the remote address to which the socket is connected. This is useful to find out the port number of a remote IPv4/v6 socket, for instance. (The format of the address returned depends on the address family \u2014 see above.) On some systems this function is not supported.", 
        "name": "socket.socket.getpeername", 
        "params": [], 
        "path": "python/library/socket#socket.socket.getpeername", 
        "syntax": "socket.getpeername()", 
        "type": "Networking"
    }, 
    "socket.socket.getsockname": {
        "descr": "Return the socket\u2019s own address. This is useful to find out the port number of an IPv4/v6 socket, for instance. (The format of the address returned depends on the address family \u2014 see above.)", 
        "name": "socket.socket.getsockname", 
        "params": [], 
        "path": "python/library/socket#socket.socket.getsockname", 
        "syntax": "socket.getsockname()", 
        "type": "Networking"
    }, 
    "socket.socket.getsockopt": {
        "descr": "Return the value of the given socket option (see the Unix man page getsockopt(2)). The needed symbolic constants (SO_* etc.) are defined in this module. If buflen is absent, an integer option is assumed and its integer value is returned by the function. If buflen is present, it specifies the maximum length of the buffer used to receive the option in, and this buffer is returned as a bytes object. It is up to the caller to decode the contents of the buffer (see the optional built-in module struct for a way to decode C structures encoded as byte strings).", 
        "name": "socket.socket.getsockopt", 
        "params": [], 
        "path": "python/library/socket#socket.socket.getsockopt", 
        "syntax": "socket.getsockopt(level, optname[, buflen])", 
        "type": "Networking"
    }, 
    "socket.socket.gettimeout": {
        "descr": "Return the timeout in seconds (float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking() or settimeout().", 
        "name": "socket.socket.gettimeout", 
        "params": [], 
        "path": "python/library/socket#socket.socket.gettimeout", 
        "syntax": "socket.gettimeout()", 
        "type": "Networking"
    }, 
    "socket.socket.ioctl": {
        "descr": "The ioctl() method is a limited interface to the WSAIoctl system interface. Please refer to the Win32 documentation for more information.", 
        "name": "socket.socket.ioctl", 
        "params": [], 
        "path": "python/library/socket#socket.socket.ioctl", 
        "syntax": "socket.ioctl(control, option)", 
        "type": "Networking"
    }, 
    "socket.socket.listen": {
        "descr": "Listen for connections made to the socket. The backlog argument specifies the maximum number of queued connections and should be at least 0; the maximum value is system-dependent (usually 5), the minimum value is forced to 0.", 
        "name": "socket.socket.listen", 
        "params": [], 
        "path": "python/library/socket#socket.socket.listen", 
        "syntax": "socket.listen(backlog)", 
        "type": "Networking"
    }, 
    "socket.socket.makefile": {
        "descr": "The socket must be in blocking mode; it can have a timeout, but the file object\u2019s internal buffer may end up in a inconsistent state if a timeout occurs.", 
        "name": "socket.socket.makefile", 
        "params": [], 
        "path": "python/library/socket#socket.socket.makefile", 
        "syntax": "socket.makefile(mode='r', buffering=None, *, encoding=None, errors=None, newline=None)", 
        "type": "Networking"
    }, 
    "socket.socket.proto": {
        "descr": "The socket protocol.", 
        "name": "socket.socket.proto", 
        "params": [], 
        "path": "python/library/socket#socket.socket.proto", 
        "syntax": "socket.proto", 
        "type": "Networking"
    }, 
    "socket.socket.recv": {
        "descr": "Receive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by bufsize. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.", 
        "name": "socket.socket.recv", 
        "params": [], 
        "path": "python/library/socket#socket.socket.recv", 
        "syntax": "socket.recv(bufsize[, flags])", 
        "type": "Networking"
    }, 
    "socket.socket.recv_into": {
        "descr": "Receive up to nbytes bytes from the socket, storing the data into a buffer rather than creating a new bytestring. If nbytes is not specified (or 0), receive up to the size available in the given buffer. Returns the number of bytes received. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.", 
        "name": "socket.socket.recv_into", 
        "params": [], 
        "path": "python/library/socket#socket.socket.recv_into", 
        "syntax": "socket.recv_into(buffer[, nbytes[, flags]])", 
        "type": "Networking"
    }, 
    "socket.socket.recvfrom": {
        "descr": "Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family \u2014 see above.)", 
        "name": "socket.socket.recvfrom", 
        "params": [], 
        "path": "python/library/socket#socket.socket.recvfrom", 
        "syntax": "socket.recvfrom(bufsize[, flags])", 
        "type": "Networking"
    }, 
    "socket.socket.recvfrom_into": {
        "descr": "Receive data from the socket, writing it into buffer instead of creating a new bytestring. The return value is a pair (nbytes, address) where nbytes is the number of bytes received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family \u2014 see above.)", 
        "name": "socket.socket.recvfrom_into", 
        "params": [], 
        "path": "python/library/socket#socket.socket.recvfrom_into", 
        "syntax": "socket.recvfrom_into(buffer[, nbytes[, flags]])", 
        "type": "Networking"
    }, 
    "socket.socket.recvmsg": {
        "descr": "Receive normal data (up to bufsize bytes) and ancillary data from the socket. The ancbufsize argument sets the size in bytes of the internal buffer used to receive the ancillary data; it defaults to 0, meaning that no ancillary data will be received. Appropriate buffer sizes for ancillary data can be calculated using CMSG_SPACE() or CMSG_LEN(), and items which do not fit into the buffer might be truncated or discarded. The flags argument defaults to 0 and has the same meaning as for recv().", 
        "name": "socket.socket.recvmsg", 
        "params": [], 
        "path": "python/library/socket#socket.socket.recvmsg", 
        "syntax": "socket.recvmsg(bufsize[, ancbufsize[, flags]])", 
        "type": "Networking"
    }, 
    "socket.socket.recvmsg_into": {
        "descr": "Receive normal data and ancillary data from the socket, behaving as recvmsg() would, but scatter the non-ancillary data into a series of buffers instead of returning a new bytes object. The buffers argument must be an iterable of objects that export writable buffers (e.g. bytearray objects); these will be filled with successive chunks of the non-ancillary data until it has all been written or there are no more buffers. The operating system may set a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used. The ancbufsize and flags arguments have the same meaning as for recvmsg().", 
        "name": "socket.socket.recvmsg_into", 
        "params": [], 
        "path": "python/library/socket#socket.socket.recvmsg_into", 
        "syntax": "socket.recvmsg_into(buffers[, ancbufsize[, flags]])", 
        "type": "Networking"
    }, 
    "socket.socket.send": {
        "descr": "Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. For further information on this topic, consult the Socket Programming HOWTO.", 
        "name": "socket.socket.send", 
        "params": [], 
        "path": "python/library/socket#socket.socket.send", 
        "syntax": "socket.send(bytes[, flags])", 
        "type": "Networking"
    }, 
    "socket.socket.sendall": {
        "descr": "Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Unlike send(), this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.", 
        "name": "socket.socket.sendall", 
        "params": [], 
        "path": "python/library/socket#socket.socket.sendall", 
        "syntax": "socket.sendall(bytes[, flags])", 
        "type": "Networking"
    }, 
    "socket.socket.sendmsg": {
        "descr": "Send normal and ancillary data to the socket, gathering the non-ancillary data from a series of buffers and concatenating it into a single message. The buffers argument specifies the non-ancillary data as an iterable of buffer-compatible objects (e.g. bytes objects); the operating system may set a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used. The ancdata argument specifies the ancillary data (control messages) as an iterable of zero or more tuples (cmsg_level, cmsg_type, cmsg_data), where cmsg_level and cmsg_type are integers specifying the protocol level and protocol-specific type respectively, and cmsg_data is a buffer-compatible object holding the associated data. Note that some systems (in particular, systems without CMSG_SPACE()) might support sending only one control message per call. The flags argument defaults to 0 and has the same meaning as for send(). If address is supplied and not None, it sets a destination address for the message. The return value is the number of bytes of non-ancillary data sent.", 
        "name": "socket.socket.sendmsg", 
        "params": [], 
        "path": "python/library/socket#socket.socket.sendmsg", 
        "syntax": "socket.sendmsg(buffers[, ancdata[, flags[, address]]])", 
        "type": "Networking"
    }, 
    "socket.socket.sendto": {
        "descr": "Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. The optional flags argument has the same meaning as for recv() above. Return the number of bytes sent. (The format of address depends on the address family \u2014 see above.)", 
        "name": "socket.socket.sendto", 
        "params": [], 
        "path": "python/library/socket#socket.socket.sendto", 
        "syntax": "socket.sendto(bytes, address)", 
        "type": "Networking"
    }, 
    "socket.socket.setblocking": {
        "descr": "Set blocking or non-blocking mode of the socket: if flag is false, the socket is set to non-blocking, else to blocking mode.", 
        "name": "socket.socket.setblocking", 
        "params": [], 
        "path": "python/library/socket#socket.socket.setblocking", 
        "syntax": "socket.setblocking(flag)", 
        "type": "Networking"
    }, 
    "socket.socket.setsockopt": {
        "descr": "", 
        "name": "socket.socket.setsockopt", 
        "params": [], 
        "path": "python/library/socket#socket.socket.setsockopt", 
        "syntax": "socket.setsockopt(level, optname, value)", 
        "type": "Networking"
    }, 
    "socket.socket.settimeout": {
        "descr": "Set a timeout on blocking socket operations. The value argument can be a nonnegative floating point number expressing seconds, or None. If a non-zero value is given, subsequent socket operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If None is given, the socket is put in blocking mode.", 
        "name": "socket.socket.settimeout", 
        "params": [], 
        "path": "python/library/socket#socket.socket.settimeout", 
        "syntax": "socket.settimeout(value)", 
        "type": "Networking"
    }, 
    "socket.socket.share": {
        "descr": "Duplicate a socket and prepare it for sharing with a target process. The target process must be provided with process_id. The resulting bytes object can then be passed to the target process using some form of interprocess communication and the socket can be recreated there using fromshare(). Once this method has been called, it is safe to close the socket since the operating system has already duplicated it for the target process.", 
        "name": "socket.socket.share", 
        "params": [], 
        "path": "python/library/socket#socket.socket.share", 
        "syntax": "socket.share(process_id)", 
        "type": "Networking"
    }, 
    "socket.socket.shutdown": {
        "descr": "Shut down one or both halves of the connection. If how is SHUT_RD, further receives are disallowed. If how is SHUT_WR, further sends are disallowed. If how is SHUT_RDWR, further sends and receives are disallowed.", 
        "name": "socket.socket.shutdown", 
        "params": [], 
        "path": "python/library/socket#socket.socket.shutdown", 
        "syntax": "socket.shutdown(how)", 
        "type": "Networking"
    }, 
    "socket.socket.type": {
        "descr": "The socket type.", 
        "name": "socket.socket.type", 
        "params": [], 
        "path": "python/library/socket#socket.socket.type", 
        "syntax": "socket.type", 
        "type": "Networking"
    }, 
    "socket.socketpair": {
        "descr": "Build a pair of connected socket objects using the given address family, socket type, and protocol number. Address family, socket type, and protocol number are as for the socket() function above. The default family is AF_UNIX if defined on the platform; otherwise, the default is AF_INET. Availability: Unix.", 
        "name": "socket.socketpair", 
        "params": [], 
        "path": "python/library/socket#socket.socketpair", 
        "syntax": "socket.socketpair([family[, type[, proto]]])", 
        "type": "Networking"
    }, 
    "socket.timeout": {
        "descr": "A subclass of OSError, this exception is raised when a timeout occurs on a socket which has had timeouts enabled via a prior call to settimeout() (or implicitly through setdefaulttimeout()). The accompanying value is a string whose value is currently always \u201ctimed out\u201d.", 
        "name": "socket.timeout", 
        "params": [], 
        "path": "python/library/socket#socket.timeout", 
        "syntax": "exception socket.timeout", 
        "type": "Networking"
    }, 
    "socketserver.BaseServer": {
        "descr": "This is the superclass of all Server objects in the module. It defines the interface, given below, but does not implement most of the methods, which is done in subclasses.", 
        "name": "socketserver.BaseServer", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer", 
        "syntax": "class socketserver.BaseServer", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.RequestHandlerClass": {
        "descr": "The user-provided request handler class; an instance of this class is created for each request.", 
        "name": "socketserver.BaseServer.RequestHandlerClass", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.RequestHandlerClass", 
        "syntax": "BaseServer.RequestHandlerClass", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.address_family": {
        "descr": "The family of protocols to which the server\u2019s socket belongs. Common examples are socket.AF_INET and socket.AF_UNIX.", 
        "name": "socketserver.BaseServer.address_family", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.address_family", 
        "syntax": "BaseServer.address_family", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.allow_reuse_address": {
        "descr": "Whether the server will allow the reuse of an address. This defaults to False, and can be set in subclasses to change the policy.", 
        "name": "socketserver.BaseServer.allow_reuse_address", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.allow_reuse_address", 
        "syntax": "BaseServer.allow_reuse_address", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.fileno": {
        "descr": "Return an integer file descriptor for the socket on which the server is listening. This function is most commonly passed to select.select(), to allow monitoring multiple servers in the same process.", 
        "name": "socketserver.BaseServer.fileno", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.fileno", 
        "syntax": "BaseServer.fileno()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.finish_request": {
        "descr": "Actually processes the request by instantiating RequestHandlerClass and calling its handle() method.", 
        "name": "socketserver.BaseServer.finish_request", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.finish_request", 
        "syntax": "BaseServer.finish_request()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.get_request": {
        "descr": "Must accept a request from the socket, and return a 2-tuple containing the new socket object to be used to communicate with the client, and the client\u2019s address.", 
        "name": "socketserver.BaseServer.get_request", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.get_request", 
        "syntax": "BaseServer.get_request()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.handle_error": {
        "descr": "This function is called if the RequestHandlerClass\u2018s handle() method raises an exception. The default action is to print the traceback to standard output and continue handling further requests.", 
        "name": "socketserver.BaseServer.handle_error", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.handle_error", 
        "syntax": "BaseServer.handle_error(request, client_address)", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.handle_request": {
        "descr": "Process a single request. This function calls the following methods in order: get_request(), verify_request(), and process_request(). If the user-provided handle() method of the handler class raises an exception, the server\u2019s handle_error() method will be called. If no request is received within self.timeout seconds, handle_timeout() will be called and handle_request() will return.", 
        "name": "socketserver.BaseServer.handle_request", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.handle_request", 
        "syntax": "BaseServer.handle_request()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.handle_timeout": {
        "descr": "This function is called when the timeout attribute has been set to a value other than None and the timeout period has passed with no requests being received. The default action for forking servers is to collect the status of any child processes that have exited, while in threading servers this method does nothing.", 
        "name": "socketserver.BaseServer.handle_timeout", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.handle_timeout", 
        "syntax": "BaseServer.handle_timeout()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.process_request": {
        "descr": "Calls finish_request() to create an instance of the RequestHandlerClass. If desired, this function can create a new process or thread to handle the request; the ForkingMixIn and ThreadingMixIn classes do this.", 
        "name": "socketserver.BaseServer.process_request", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.process_request", 
        "syntax": "BaseServer.process_request(request, client_address)", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.request_queue_size": {
        "descr": "The size of the request queue. If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to request_queue_size requests. Once the queue is full, further requests from clients will get a \u201cConnection denied\u201d error. The default value is usually 5, but this can be overridden by subclasses.", 
        "name": "socketserver.BaseServer.request_queue_size", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.request_queue_size", 
        "syntax": "BaseServer.request_queue_size", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.serve_forever": {
        "descr": "Handle requests until an explicit shutdown() request. Poll for shutdown every poll_interval seconds. Ignores self.timeout. It also calls service_actions(), which may be used by a subclass or mixin to provide actions specific to a given service. For example, the ForkingMixIn class uses service_actions() to clean up zombie child processes.", 
        "name": "socketserver.BaseServer.serve_forever", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.serve_forever", 
        "syntax": "BaseServer.serve_forever(poll_interval=0.5)", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.server_activate": {
        "descr": "Called by the server\u2019s constructor to activate the server. The default behavior just listen()s to the server\u2019s socket. May be overridden.", 
        "name": "socketserver.BaseServer.server_activate", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.server_activate", 
        "syntax": "BaseServer.server_activate()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.server_address": {
        "descr": "The address on which the server is listening. The format of addresses varies depending on the protocol family; see the documentation for the socket module for details. For Internet protocols, this is a tuple containing a string giving the address, and an integer port number: ('127.0.0.1', 80), for example.", 
        "name": "socketserver.BaseServer.server_address", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.server_address", 
        "syntax": "BaseServer.server_address", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.server_bind": {
        "descr": "Called by the server\u2019s constructor to bind the socket to the desired address. May be overridden.", 
        "name": "socketserver.BaseServer.server_bind", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.server_bind", 
        "syntax": "BaseServer.server_bind()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.service_actions": {
        "descr": "This is called in the serve_forever() loop. This method can be overridden by subclasses or mixin classes to perform actions specific to a given service, such as cleanup actions.", 
        "name": "socketserver.BaseServer.service_actions", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.service_actions", 
        "syntax": "BaseServer.service_actions()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.shutdown": {
        "descr": "Tell the serve_forever() loop to stop and wait until it does.", 
        "name": "socketserver.BaseServer.shutdown", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.shutdown", 
        "syntax": "BaseServer.shutdown()", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.socket": {
        "descr": "The socket object on which the server will listen for incoming requests.", 
        "name": "socketserver.BaseServer.socket", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.socket", 
        "syntax": "BaseServer.socket", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.socket_type": {
        "descr": "The type of socket used by the server; socket.SOCK_STREAM and socket.SOCK_DGRAM are two common values.", 
        "name": "socketserver.BaseServer.socket_type", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.socket_type", 
        "syntax": "BaseServer.socket_type", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.timeout": {
        "descr": "Timeout duration, measured in seconds, or None if no timeout is desired. If handle_request() receives no incoming requests within the timeout period, the handle_timeout() method is called.", 
        "name": "socketserver.BaseServer.timeout", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.timeout", 
        "syntax": "BaseServer.timeout", 
        "type": "Internet"
    }, 
    "socketserver.BaseServer.verify_request": {
        "descr": "Must return a Boolean value; if the value is True, the request will be processed, and if it\u2019s False, the request will be denied. This function can be overridden to implement access controls for a server. The default implementation always returns True.", 
        "name": "socketserver.BaseServer.verify_request", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.BaseServer.verify_request", 
        "syntax": "BaseServer.verify_request(request, client_address)", 
        "type": "Internet"
    }, 
    "socketserver.RequestHandler.finish": {
        "descr": "Called after the handle() method to perform any clean-up actions required. The default implementation does nothing. If setup() raises an exception, this function will not be called.", 
        "name": "socketserver.RequestHandler.finish", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.RequestHandler.finish", 
        "syntax": "RequestHandler.finish()", 
        "type": "Internet"
    }, 
    "socketserver.RequestHandler.handle": {
        "descr": "This function must do all the work required to service a request. The default implementation does nothing. Several instance attributes are available to it; the request is available as self.request; the client address as self.client_address; and the server instance as self.server, in case it needs access to per-server information.", 
        "name": "socketserver.RequestHandler.handle", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.RequestHandler.handle", 
        "syntax": "RequestHandler.handle()", 
        "type": "Internet"
    }, 
    "socketserver.RequestHandler.setup": {
        "descr": "Called before the handle() method to perform any initialization actions required. The default implementation does nothing.", 
        "name": "socketserver.RequestHandler.setup", 
        "params": [], 
        "path": "python/library/socketserver#socketserver.RequestHandler.setup", 
        "syntax": "RequestHandler.setup()", 
        "type": "Internet"
    }, 
    "sort": {
        "descr": "This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state).", 
        "name": "list.sort", 
        "params": [], 
        "path": "python/library/stdtypes#list.sort", 
        "syntax": "sort(*, key=None, reverse=None)", 
        "type": "Built-in Types"
    }, 
    "sorted": {
        "descr": "Return a new sorted list from the items in iterable.", 
        "name": "sorted", 
        "params": [], 
        "path": "python/library/functions#sorted", 
        "syntax": "sorted(iterable[, key][, reverse])", 
        "type": "Built-in Functions"
    }, 
    "span": {
        "descr": "For a match m, return the 2-tuple (m.start(group), m.end(group)). Note that if group did not contribute to the match, this is (-1, -1). group defaults to zero, the entire match.", 
        "name": "re.match.span", 
        "params": [], 
        "path": "python/library/re#re.match.span", 
        "syntax": "match.span([group])", 
        "type": "Text Processing"
    }, 
    "split": {
        "descr": "Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made).", 
        "name": "str.split", 
        "params": [], 
        "path": "python/library/stdtypes#str.split", 
        "syntax": "str.split(sep=None, maxsplit=-1)", 
        "type": "Built-in Types"
    }, 
    "splitlines": {
        "descr": "Return a list of the lines in the string, breaking at line boundaries. This method uses the universal newlines approach to splitting lines. Line breaks are not included in the resulting list unless keepends is given and true.", 
        "name": "str.splitlines", 
        "params": [], 
        "path": "python/library/stdtypes#str.splitlines", 
        "syntax": "str.splitlines([keepends])", 
        "type": "Built-in Types"
    }, 
    "spwd.getspall": {
        "descr": "Return a list of all available shadow password database entries, in arbitrary order.", 
        "name": "spwd.getspall", 
        "params": [], 
        "path": "python/library/spwd#spwd.getspall", 
        "syntax": "spwd.getspall()", 
        "type": "Unix"
    }, 
    "spwd.getspnam": {
        "descr": "Return the shadow password database entry for the given user name.", 
        "name": "spwd.getspnam", 
        "params": [], 
        "path": "python/library/spwd#spwd.getspnam", 
        "syntax": "spwd.getspnam(name)", 
        "type": "Unix"
    }, 
    "sqlite3.Connection": {
        "descr": "A SQLite database connection has the following attributes and methods:", 
        "name": "sqlite3.Connection", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection", 
        "syntax": "class sqlite3.Connection", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.close": {
        "descr": "This closes the database connection. Note that this does not automatically call commit(). If you just close your database connection without calling commit() first, your changes will be lost!", 
        "name": "sqlite3.Connection.close", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.close", 
        "syntax": "close()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.commit": {
        "descr": "This method commits the current transaction. If you don\u2019t call this method, anything you did since the last call to commit() is not visible from other database connections. If you wonder why you don\u2019t see the data you\u2019ve written to the database, please check you didn\u2019t forget to call this method.", 
        "name": "sqlite3.Connection.commit", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.commit", 
        "syntax": "commit()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.create_aggregate": {
        "descr": "Creates a user-defined aggregate function.", 
        "name": "sqlite3.Connection.create_aggregate", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.create_aggregate", 
        "syntax": "create_aggregate(name, num_params, aggregate_class)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.create_collation": {
        "descr": "Creates a collation with the specified name and callable. The callable will be passed two string arguments. It should return -1 if the first is ordered lower than the second, 0 if they are ordered equal and 1 if the first is ordered higher than the second. Note that this controls sorting (ORDER BY in SQL) so your comparisons don\u2019t affect other SQL operations.", 
        "name": "sqlite3.Connection.create_collation", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.create_collation", 
        "syntax": "create_collation(name, callable)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.create_function": {
        "descr": "Creates a user-defined function that you can later use from within SQL statements under the function name name. num_params is the number of parameters the function accepts, and func is a Python callable that is called as the SQL function.", 
        "name": "sqlite3.Connection.create_function", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.create_function", 
        "syntax": "create_function(name, num_params, func)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.cursor": {
        "descr": "The cursor method accepts a single optional parameter cursorClass. If supplied, this must be a custom cursor class that extends sqlite3.Cursor.", 
        "name": "sqlite3.Connection.cursor", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.cursor", 
        "syntax": "cursor([cursorClass])", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.enable_load_extension": {
        "descr": "This routine allows/disallows the SQLite engine to load SQLite extensions from shared libraries. SQLite extensions can define new functions, aggregates or whole new virtual table implementations. One well-known extension is the fulltext-search extension distributed with SQLite.", 
        "name": "sqlite3.Connection.enable_load_extension", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.enable_load_extension", 
        "syntax": "enable_load_extension(enabled)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.execute": {
        "descr": "This is a nonstandard shortcut that creates an intermediate cursor object by calling the cursor method, then calls the cursor\u2019s execute method with the parameters given.", 
        "name": "sqlite3.Connection.execute", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.execute", 
        "syntax": "execute(sql[, parameters])", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.executemany": {
        "descr": "This is a nonstandard shortcut that creates an intermediate cursor object by calling the cursor method, then calls the cursor\u2019s executemany method with the parameters given.", 
        "name": "sqlite3.Connection.executemany", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.executemany", 
        "syntax": "executemany(sql[, parameters])", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.executescript": {
        "descr": "This is a nonstandard shortcut that creates an intermediate cursor object by calling the cursor method, then calls the cursor\u2019s executescript method with the parameters given.", 
        "name": "sqlite3.Connection.executescript", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.executescript", 
        "syntax": "executescript(sql_script)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.in_transaction": {
        "descr": "True if a transaction is active (there are uncommitted changes), False otherwise. Read-only attribute.", 
        "name": "sqlite3.Connection.in_transaction", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.in_transaction", 
        "syntax": "in_transaction", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.interrupt": {
        "descr": "You can call this method from a different thread to abort any queries that might be executing on the connection. The query will then abort and the caller will get an exception.", 
        "name": "sqlite3.Connection.interrupt", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.interrupt", 
        "syntax": "interrupt()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.isolation_level": {
        "descr": "Get or set the current isolation level. None for autocommit mode or one of \u201cDEFERRED\u201d, \u201cIMMEDIATE\u201d or \u201cEXCLUSIVE\u201d. See section Controlling Transactions for a more detailed explanation.", 
        "name": "sqlite3.Connection.isolation_level", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.isolation_level", 
        "syntax": "isolation_level", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.iterdump": {
        "descr": "Returns an iterator to dump the database in an SQL text format. Useful when saving an in-memory database for later restoration. This function provides the same capabilities as the .dump command in the sqlite3 shell.", 
        "name": "sqlite3.Connection.iterdump", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.iterdump", 
        "syntax": "iterdump", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.load_extension": {
        "descr": "This routine loads a SQLite extension from a shared library. You have to enable extension loading with enable_load_extension() before you can use this routine.", 
        "name": "sqlite3.Connection.load_extension", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.load_extension", 
        "syntax": "load_extension(path)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.rollback": {
        "descr": "This method rolls back any changes to the database since the last call to commit().", 
        "name": "sqlite3.Connection.rollback", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.rollback", 
        "syntax": "rollback()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.row_factory": {
        "descr": "You can change this attribute to a callable that accepts the cursor and the original row as a tuple and will return the real result row. This way, you can implement more advanced ways of returning results, such as returning an object that can also access columns by name.", 
        "name": "sqlite3.Connection.row_factory", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.row_factory", 
        "syntax": "row_factory", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.set_authorizer": {
        "descr": "This routine registers a callback. The callback is invoked for each attempt to access a column of a table in the database. The callback should return SQLITE_OK if access is allowed, SQLITE_DENY if the entire SQL statement should be aborted with an error and SQLITE_IGNORE if the column should be treated as a NULL value. These constants are available in the sqlite3 module.", 
        "name": "sqlite3.Connection.set_authorizer", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.set_authorizer", 
        "syntax": "set_authorizer(authorizer_callback)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.set_progress_handler": {
        "descr": "This routine registers a callback. The callback is invoked for every n instructions of the SQLite virtual machine. This is useful if you want to get called from SQLite during long-running operations, for example to update a GUI.", 
        "name": "sqlite3.Connection.set_progress_handler", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.set_progress_handler", 
        "syntax": "set_progress_handler(handler, n)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.set_trace_callback": {
        "descr": "Registers trace_callback to be called for each SQL statement that is actually executed by the SQLite backend.", 
        "name": "sqlite3.Connection.set_trace_callback", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.set_trace_callback", 
        "syntax": "set_trace_callback(trace_callback)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.text_factory": {
        "descr": "Using this attribute you can control what objects are returned for the TEXT data type. By default, this attribute is set to str and the sqlite3 module will return Unicode objects for TEXT. If you want to return bytestrings instead, you can set it to bytes.", 
        "name": "sqlite3.Connection.text_factory", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.text_factory", 
        "syntax": "text_factory", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Connection.total_changes": {
        "descr": "Returns the total number of database rows that have been modified, inserted, or deleted since the database connection was opened.", 
        "name": "sqlite3.Connection.total_changes", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Connection.total_changes", 
        "syntax": "total_changes", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor": {
        "descr": "A Cursor instance has the following attributes and methods.", 
        "name": "sqlite3.Cursor", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor", 
        "syntax": "class sqlite3.Cursor", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.description": {
        "descr": "This read-only attribute provides the column names of the last query. To remain compatible with the Python DB API, it returns a 7-tuple for each column where the last six items of each tuple are None.", 
        "name": "sqlite3.Cursor.description", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.description", 
        "syntax": "description", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.execute": {
        "descr": "Executes an SQL statement. The SQL statement may be parametrized (i. e. placeholders instead of SQL literals). The sqlite3 module supports two kinds of placeholders: question marks (qmark style) and named placeholders (named style).", 
        "name": "sqlite3.Cursor.execute", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.execute", 
        "syntax": "execute(sql[, parameters])", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.executemany": {
        "descr": "Executes an SQL command against all parameter sequences or mappings found in the sequence sql. The sqlite3 module also allows using an iterator yielding parameters instead of a sequence.", 
        "name": "sqlite3.Cursor.executemany", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.executemany", 
        "syntax": "executemany(sql, seq_of_parameters)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.executescript": {
        "descr": "This is a nonstandard convenience method for executing multiple SQL statements at once. It issues a COMMIT statement first, then executes the SQL script it gets as a parameter.", 
        "name": "sqlite3.Cursor.executescript", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.executescript", 
        "syntax": "executescript(sql_script)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.fetchall": {
        "descr": "Fetches all (remaining) rows of a query result, returning a list. Note that the cursor\u2019s arraysize attribute can affect the performance of this operation. An empty list is returned when no rows are available.", 
        "name": "sqlite3.Cursor.fetchall", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.fetchall", 
        "syntax": "fetchall()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.fetchmany": {
        "descr": "Fetches the next set of rows of a query result, returning a list. An empty list is returned when no more rows are available.", 
        "name": "sqlite3.Cursor.fetchmany", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.fetchmany", 
        "syntax": "fetchmany(size=cursor.arraysize)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.fetchone": {
        "descr": "Fetches the next row of a query result set, returning a single sequence, or None when no more data is available.", 
        "name": "sqlite3.Cursor.fetchone", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.fetchone", 
        "syntax": "fetchone()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.lastrowid": {
        "descr": "This read-only attribute provides the rowid of the last modified row. It is only set if you issued a INSERT statement using the execute() method. For operations other than INSERT or when executemany() is called, lastrowid is set to None.", 
        "name": "sqlite3.Cursor.lastrowid", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.lastrowid", 
        "syntax": "lastrowid", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Cursor.rowcount": {
        "descr": "Although the Cursor class of the sqlite3 module implements this attribute, the database engine\u2019s own support for the determination of \u201crows affected\u201d/\u201drows selected\u201d is quirky.", 
        "name": "sqlite3.Cursor.rowcount", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Cursor.rowcount", 
        "syntax": "rowcount", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Row": {
        "descr": "A Row instance serves as a highly optimized row_factory for Connection objects. It tries to mimic a tuple in most of its features.", 
        "name": "sqlite3.Row", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Row", 
        "syntax": "class sqlite3.Row", 
        "type": "Data Persistence"
    }, 
    "sqlite3.Row.keys": {
        "descr": "This method returns a tuple of column names. Immediately after a query, it is the first member of each tuple in Cursor.description.", 
        "name": "sqlite3.Row.keys", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.Row.keys", 
        "syntax": "keys()", 
        "type": "Data Persistence"
    }, 
    "sqlite3.complete_statement": {
        "descr": "Returns True if the string sql contains one or more complete SQL statements terminated by semicolons. It does not verify that the SQL is syntactically correct, only that there are no unclosed string literals and the statement is terminated by a semicolon.", 
        "name": "sqlite3.complete_statement", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.complete_statement", 
        "syntax": "sqlite3.complete_statement(sql)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.connect": {
        "descr": "Opens a connection to the SQLite database file database. You can use \":memory:\" to open a database connection to a database that resides in RAM instead of on disk.", 
        "name": "sqlite3.connect", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.connect", 
        "syntax": "sqlite3.connect(database[, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements])", 
        "type": "Data Persistence"
    }, 
    "sqlite3.enable_callback_tracebacks": {
        "descr": "By default you will not get any tracebacks in user-defined functions, aggregates, converters, authorizer callbacks etc. If you want to debug them, you can call this function with flag set to True. Afterwards, you will get tracebacks from callbacks on sys.stderr. Use False to disable the feature again.", 
        "name": "sqlite3.enable_callback_tracebacks", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.enable_callback_tracebacks", 
        "syntax": "sqlite3.enable_callback_tracebacks(flag)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.register_adapter": {
        "descr": "Registers a callable to convert the custom Python type type into one of SQLite\u2019s supported types. The callable callable accepts as single parameter the Python value, and must return a value of the following types: int, float, str or bytes.", 
        "name": "sqlite3.register_adapter", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.register_adapter", 
        "syntax": "sqlite3.register_adapter(type, callable)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.register_converter": {
        "descr": "Registers a callable to convert a bytestring from the database into a custom Python type. The callable will be invoked for all database values that are of the type typename. Confer the parameter detect_types of the connect() function for how the type detection works. Note that the case of typename and the name of the type in your query must match!", 
        "name": "sqlite3.register_converter", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.register_converter", 
        "syntax": "sqlite3.register_converter(typename, callable)", 
        "type": "Data Persistence"
    }, 
    "sqlite3.sqlite_version": {
        "descr": "The version number of the run-time SQLite library, as a string.", 
        "name": "sqlite3.sqlite_version", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.sqlite_version", 
        "syntax": "sqlite3.sqlite_version", 
        "type": "Data Persistence"
    }, 
    "sqlite3.sqlite_version_info": {
        "descr": "The version number of the run-time SQLite library, as a tuple of integers.", 
        "name": "sqlite3.sqlite_version_info", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.sqlite_version_info", 
        "syntax": "sqlite3.sqlite_version_info", 
        "type": "Data Persistence"
    }, 
    "sqlite3.version": {
        "descr": "The version number of this module, as a string. This is not the version of the SQLite library.", 
        "name": "sqlite3.version", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.version", 
        "syntax": "sqlite3.version", 
        "type": "Data Persistence"
    }, 
    "sqlite3.version_info": {
        "descr": "The version number of this module, as a tuple of integers. This is not the version of the SQLite library.", 
        "name": "sqlite3.version_info", 
        "params": [], 
        "path": "python/library/sqlite3#sqlite3.version_info", 
        "syntax": "sqlite3.version_info", 
        "type": "Data Persistence"
    }, 
    "ssl.CertificateError": {
        "descr": "Raised to signal an error with a certificate (such as mismatching hostname). Certificate errors detected by OpenSSL, though, raise an SSLError.", 
        "name": "ssl.CertificateError", 
        "params": [], 
        "path": "python/library/ssl#ssl.CertificateError", 
        "syntax": "exception ssl.CertificateError", 
        "type": "Networking"
    }, 
    "ssl.DER_cert_to_PEM_cert": {
        "descr": "Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded string version of the same certificate.", 
        "name": "ssl.DER_cert_to_PEM_cert", 
        "params": [], 
        "path": "python/library/ssl#ssl.DER_cert_to_PEM_cert", 
        "syntax": "ssl.DER_cert_to_PEM_cert(DER_cert_bytes)", 
        "type": "Networking"
    }, 
    "ssl.OP_NO_SSLv2": {
        "descr": "Prevents an SSLv2 connection. This option is only applicable in conjunction with PROTOCOL_SSLv23. It prevents the peers from choosing SSLv2 as the protocol version.", 
        "name": "ssl.OP_NO_SSLv2", 
        "params": [], 
        "path": "python/library/ssl#ssl.OP_NO_SSLv2", 
        "syntax": "ssl.OP_NO_SSLv2", 
        "type": "Networking"
    }, 
    "ssl.OP_NO_SSLv3": {
        "descr": "Prevents an SSLv3 connection. This option is only applicable in conjunction with PROTOCOL_SSLv23. It prevents the peers from choosing SSLv3 as the protocol version.", 
        "name": "ssl.OP_NO_SSLv3", 
        "params": [], 
        "path": "python/library/ssl#ssl.OP_NO_SSLv3", 
        "syntax": "ssl.OP_NO_SSLv3", 
        "type": "Networking"
    }, 
    "ssl.OP_NO_TLSv1": {
        "descr": "Prevents a TLSv1 connection. This option is only applicable in conjunction with PROTOCOL_SSLv23. It prevents the peers from choosing TLSv1 as the protocol version.", 
        "name": "ssl.OP_NO_TLSv1", 
        "params": [], 
        "path": "python/library/ssl#ssl.OP_NO_TLSv1", 
        "syntax": "ssl.OP_NO_TLSv1", 
        "type": "Networking"
    }, 
    "ssl.PEM_cert_to_DER_cert": {
        "descr": "Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of bytes for that same certificate.", 
        "name": "ssl.PEM_cert_to_DER_cert", 
        "params": [], 
        "path": "python/library/ssl#ssl.PEM_cert_to_DER_cert", 
        "syntax": "ssl.PEM_cert_to_DER_cert(PEM_cert_string)", 
        "type": "Networking"
    }, 
    "ssl.PROTOCOL_SSLv2": {
        "descr": "Selects SSL version 2 or 3 as the channel encryption protocol. This is a setting to use with servers for maximum compatibility with the other end of an SSL connection, but it may cause the specific ciphers chosen for the encryption to be of fairly low quality.", 
        "name": "ssl.PROTOCOL_SSLv2", 
        "params": [], 
        "path": "python/library/ssl#ssl.PROTOCOL_SSLv2", 
        "syntax": "ssl.PROTOCOL_SSLv23", 
        "type": "Networking"
    }, 
    "ssl.PROTOCOL_SSLv23": {
        "descr": "Selects SSL version 2 or 3 as the channel encryption protocol. This is a setting to use with servers for maximum compatibility with the other end of an SSL connection, but it may cause the specific ciphers chosen for the encryption to be of fairly low quality.", 
        "name": "ssl.PROTOCOL_SSLv23", 
        "params": [], 
        "path": "python/library/ssl#ssl.PROTOCOL_SSLv23", 
        "syntax": "ssl.PROTOCOL_SSLv23", 
        "type": "Networking"
    }, 
    "ssl.PROTOCOL_SSLv3": {
        "descr": "Selects SSL version 3 as the channel encryption protocol. For clients, this is the maximally compatible SSL variant.", 
        "name": "ssl.PROTOCOL_SSLv3", 
        "params": [], 
        "path": "python/library/ssl#ssl.PROTOCOL_SSLv3", 
        "syntax": "ssl.PROTOCOL_SSLv3", 
        "type": "Networking"
    }, 
    "ssl.PROTOCOL_TLSv1": {
        "descr": "Selects TLS version 1 as the channel encryption protocol. This is the most modern version, and probably the best choice for maximum protection, if both sides can speak it.", 
        "name": "ssl.PROTOCOL_TLSv1", 
        "params": [], 
        "path": "python/library/ssl#ssl.PROTOCOL_TLSv1", 
        "syntax": "ssl.PROTOCOL_TLSv1", 
        "type": "Networking"
    }, 
    "ssl.RAND_add": {
        "descr": "Mixes the given bytes into the SSL pseudo-random number generator. The parameter entropy (a float) is a lower bound on the entropy contained in string (so you can always use 0.0). See RFC 1750 for more information on sources of entropy.", 
        "name": "ssl.RAND_add", 
        "params": [], 
        "path": "python/library/ssl#ssl.RAND_add", 
        "syntax": "ssl.RAND_add(bytes, entropy)", 
        "type": "Networking"
    }, 
    "ssl.RAND_bytes": {
        "descr": "Returns num cryptographically strong pseudo-random bytes. Raises an SSLError if the PRNG has not been seeded with enough data or if the operation is not supported by the current RAND method. RAND_status() can be used to check the status of the PRNG and RAND_add() can be used to seed the PRNG.", 
        "name": "ssl.RAND_bytes", 
        "params": [], 
        "path": "python/library/ssl#ssl.RAND_bytes", 
        "syntax": "ssl.RAND_bytes(num)", 
        "type": "Networking"
    }, 
    "ssl.RAND_egd": {
        "descr": "If you are running an entropy-gathering daemon (EGD) somewhere, and path is the pathname of a socket connection open to it, this will read 256 bytes of randomness from the socket, and add it to the SSL pseudo-random number generator to increase the security of generated secret keys. This is typically only necessary on systems without better sources of randomness.", 
        "name": "ssl.RAND_egd", 
        "params": [], 
        "path": "python/library/ssl#ssl.RAND_egd", 
        "syntax": "ssl.RAND_egd(path)", 
        "type": "Networking"
    }, 
    "ssl.RAND_pseudo_bytes": {
        "descr": "Returns (bytes, is_cryptographic): bytes are num pseudo-random bytes, is_cryptographic is True if the bytes generated are cryptographically strong. Raises an SSLError if the operation is not supported by the current RAND method.", 
        "name": "ssl.RAND_pseudo_bytes", 
        "params": [], 
        "path": "python/library/ssl#ssl.RAND_pseudo_bytes", 
        "syntax": "ssl.RAND_pseudo_bytes(num)", 
        "type": "Networking"
    }, 
    "ssl.RAND_status": {
        "descr": "Returns True if the SSL pseudo-random number generator has been seeded with \u2018enough\u2019 randomness, and False otherwise. You can use ssl.RAND_egd() and ssl.RAND_add() to increase the randomness of the pseudo-random number generator.", 
        "name": "ssl.RAND_status", 
        "params": [], 
        "path": "python/library/ssl#ssl.RAND_status", 
        "syntax": "ssl.RAND_status()", 
        "type": "Networking"
    }, 
    "ssl.SSLContext": {
        "descr": "Create a new SSL context. You must pass protocol which must be one of the PROTOCOL_* constants defined in this module. PROTOCOL_SSLv23 is recommended for maximum interoperability.", 
        "name": "ssl.SSLContext", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext", 
        "syntax": "class ssl.SSLContext(protocol)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.load_cert_chain": {
        "descr": "Load a private key and the corresponding certificate. The certfile string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate\u2019s authenticity. The keyfile string, if present, must point to a file containing the private key in. Otherwise the private key will be taken from certfile as well. See the discussion of Certificates for more information on how the certificate is stored in the certfile.", 
        "name": "ssl.SSLContext.load_cert_chain", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.load_cert_chain", 
        "syntax": "SSLContext.load_cert_chain(certfile, keyfile=None, password=None)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.load_dh_params": {
        "descr": "Load the key generation parameters for Diffie-Helman (DH) key exchange. Using DH key exchange improves forward secrecy at the expense of computational resources (both on the server and on the client). The dhfile parameter should be the path to a file containing DH parameters in PEM format.", 
        "name": "ssl.SSLContext.load_dh_params", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.load_dh_params", 
        "syntax": "SSLContext.load_dh_params(dhfile)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.load_verify_locations": {
        "descr": "Load a set of \u201ccertification authority\u201d (CA) certificates used to validate other peers\u2019 certificates when verify_mode is other than CERT_NONE. At least one of cafile or capath must be specified.", 
        "name": "ssl.SSLContext.load_verify_locations", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.load_verify_locations", 
        "syntax": "SSLContext.load_verify_locations(cafile=None, capath=None)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.options": {
        "descr": "An integer representing the set of SSL options enabled on this context. The default value is OP_ALL, but you can specify other options such as OP_NO_SSLv2 by ORing them together.", 
        "name": "ssl.SSLContext.options", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.options", 
        "syntax": "SSLContext.options", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.protocol": {
        "descr": "The protocol version chosen when constructing the context. This attribute is read-only.", 
        "name": "ssl.SSLContext.protocol", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.protocol", 
        "syntax": "SSLContext.protocol", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.session_stats": {
        "descr": "Get statistics about the SSL sessions created or managed by this context. A dictionary is returned which maps the names of each piece of information to their numeric values. For example, here is the total number of hits and misses in the session cache since the context was created:", 
        "name": "ssl.SSLContext.session_stats", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.session_stats", 
        "syntax": "SSLContext.session_stats()", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.set_ciphers": {
        "descr": "Set the available ciphers for sockets created with this context. It should be a string in the OpenSSL cipher list format. If no cipher can be selected (because compile-time options or other configuration forbids use of all the specified ciphers), an SSLError will be raised.", 
        "name": "ssl.SSLContext.set_ciphers", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.set_ciphers", 
        "syntax": "SSLContext.set_ciphers(ciphers)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.set_default_verify_paths": {
        "descr": "Load a set of default \u201ccertification authority\u201d (CA) certificates from a filesystem path defined when building the OpenSSL library. Unfortunately, there\u2019s no easy way to know whether this method succeeds: no error is returned if no certificates are to be found. When the OpenSSL library is provided as part of the operating system, though, it is likely to be configured properly.", 
        "name": "ssl.SSLContext.set_default_verify_paths", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.set_default_verify_paths", 
        "syntax": "SSLContext.set_default_verify_paths()", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.set_ecdh_curve": {
        "descr": "Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key exchange. ECDH is significantly faster than regular DH while arguably as secure. The curve_name parameter should be a string describing a well-known elliptic curve, for example prime256v1 for a widely supported curve.", 
        "name": "ssl.SSLContext.set_ecdh_curve", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.set_ecdh_curve", 
        "syntax": "SSLContext.set_ecdh_curve(curve_name)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.set_npn_protocols": {
        "descr": "Specify which protocols the socket should advertise during the SSL/TLS handshake. It should be a list of strings, like ['http/1.1', 'spdy/2'], ordered by preference. The selection of a protocol will happen during the handshake, and will play out according to the NPN draft specification. After a successful handshake, the SSLSocket.selected_npn_protocol() method will return the agreed-upon protocol.", 
        "name": "ssl.SSLContext.set_npn_protocols", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.set_npn_protocols", 
        "syntax": "SSLContext.set_npn_protocols(protocols)", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.verify_mode": {
        "descr": "Whether to try to verify other peers\u2019 certificates and how to behave if verification fails. This attribute must be one of CERT_NONE, CERT_OPTIONAL or CERT_REQUIRED.", 
        "name": "ssl.SSLContext.verify_mode", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.verify_mode", 
        "syntax": "SSLContext.verify_mode", 
        "type": "Networking"
    }, 
    "ssl.SSLContext.wrap_socket": {
        "descr": "Wrap an existing Python socket sock and return an SSLSocket object. sock must be a SOCK_STREAM socket; other socket types are unsupported.", 
        "name": "ssl.SSLContext.wrap_socket", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLContext.wrap_socket", 
        "syntax": "SSLContext.wrap_socket(sock, server_side=False, do_handshake_on_connect=True, suppress_ragged_eofs=True, server_hostname=None)", 
        "type": "Networking"
    }, 
    "ssl.SSLEOFError": {
        "descr": "A subclass of SSLError raised when the SSL connection has been terminated abruptly. Generally, you shouldn\u2019t try to reuse the underlying transport when this error is encountered.", 
        "name": "ssl.SSLEOFError", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLEOFError", 
        "syntax": "exception ssl.SSLEOFError", 
        "type": "Networking"
    }, 
    "ssl.SSLError": {
        "descr": "Raised to signal an error from the underlying SSL implementation (currently provided by the OpenSSL library). This signifies some problem in the higher-level encryption and authentication layer that\u2019s superimposed on the underlying network connection. This error is a subtype of OSError. The error code and message of SSLError instances are provided by the OpenSSL library.", 
        "name": "ssl.SSLError", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLError", 
        "syntax": "exception ssl.SSLError", 
        "type": "Networking"
    }, 
    "ssl.SSLError.library": {
        "descr": "A string mnemonic designating the OpenSSL submodule in which the error occurred, such as SSL, PEM or X509. The range of possible values depends on the OpenSSL version.", 
        "name": "ssl.SSLError.library", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLError.library", 
        "syntax": "library", 
        "type": "Networking"
    }, 
    "ssl.SSLError.reason": {
        "descr": "A string mnemonic designating the reason this error occurred, for example CERTIFICATE_VERIFY_FAILED. The range of possible values depends on the OpenSSL version.", 
        "name": "ssl.SSLError.reason", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLError.reason", 
        "syntax": "reason", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.cipher": {
        "descr": "Returns a three-value tuple containing the name of the cipher being used, the version of the SSL protocol that defines its use, and the number of secret bits being used. If no connection has been established, returns None.", 
        "name": "ssl.SSLSocket.cipher", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.cipher", 
        "syntax": "SSLSocket.cipher()", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.compression": {
        "descr": "Return the compression algorithm being used as a string, or None if the connection isn\u2019t compressed.", 
        "name": "ssl.SSLSocket.compression", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.compression", 
        "syntax": "SSLSocket.compression()", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.context": {
        "descr": "The SSLContext object this SSL socket is tied to. If the SSL socket was created using the top-level wrap_socket() function (rather than SSLContext.wrap_socket()), this is a custom context object created for this SSL socket.", 
        "name": "ssl.SSLSocket.context", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.context", 
        "syntax": "SSLSocket.context", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.do_handshake": {
        "descr": "Perform the SSL setup handshake.", 
        "name": "ssl.SSLSocket.do_handshake", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.do_handshake", 
        "syntax": "SSLSocket.do_handshake()", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.get_channel_binding": {
        "descr": "Get channel binding data for current connection, as a bytes object. Returns None if not connected or the handshake has not been completed.", 
        "name": "ssl.SSLSocket.get_channel_binding", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.get_channel_binding", 
        "syntax": "SSLSocket.get_channel_binding(cb_type=\"tls-unique\")", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.getpeercert": {
        "descr": "If there is no certificate for the peer on the other end of the connection, returns None.", 
        "name": "ssl.SSLSocket.getpeercert", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.getpeercert", 
        "syntax": "SSLSocket.getpeercert(binary_form=False)", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.selected_npn_protocol": {
        "descr": "Returns the protocol that was selected during the TLS/SSL handshake. If SSLContext.set_npn_protocols() was not called, or if the other party does not support NPN, or if the handshake has not yet happened, this will return None.", 
        "name": "ssl.SSLSocket.selected_npn_protocol", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.selected_npn_protocol", 
        "syntax": "SSLSocket.selected_npn_protocol()", 
        "type": "Networking"
    }, 
    "ssl.SSLSocket.unwrap": {
        "descr": "Performs the SSL shutdown handshake, which removes the TLS layer from the underlying socket, and returns the underlying socket object. This can be used to go from encrypted operation over a connection to unencrypted. The returned socket should always be used for further communication with the other side of the connection, rather than the original socket.", 
        "name": "ssl.SSLSocket.unwrap", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSocket.unwrap", 
        "syntax": "SSLSocket.unwrap()", 
        "type": "Networking"
    }, 
    "ssl.SSLSyscallError": {
        "descr": "A subclass of SSLError raised when a system error was encountered while trying to fulfill an operation on a SSL socket. Unfortunately, there is no easy way to inspect the original errno number.", 
        "name": "ssl.SSLSyscallError", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLSyscallError", 
        "syntax": "exception ssl.SSLSyscallError", 
        "type": "Networking"
    }, 
    "ssl.SSLWantReadError": {
        "descr": "A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs to be received on the underlying TCP transport before the request can be fulfilled.", 
        "name": "ssl.SSLWantReadError", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLWantReadError", 
        "syntax": "exception ssl.SSLWantReadError", 
        "type": "Networking"
    }, 
    "ssl.SSLWantWriteError": {
        "descr": "A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs to be sent on the underlying TCP transport before the request can be fulfilled.", 
        "name": "ssl.SSLWantWriteError", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLWantWriteError", 
        "syntax": "exception ssl.SSLWantWriteError", 
        "type": "Networking"
    }, 
    "ssl.SSLZeroReturnError": {
        "descr": "A subclass of SSLError raised when trying to read or write and the SSL connection has been closed cleanly. Note that this doesn\u2019t mean that the underlying transport (read TCP) has been closed.", 
        "name": "ssl.SSLZeroReturnError", 
        "params": [], 
        "path": "python/library/ssl#ssl.SSLZeroReturnError", 
        "syntax": "exception ssl.SSLZeroReturnError", 
        "type": "Networking"
    }, 
    "ssl.cert_time_to_seconds": {
        "descr": "Returns a floating-point value containing a normal seconds-after-the-epoch time value, given the time-string representing the \u201cnotBefore\u201d or \u201cnotAfter\u201d date from a certificate.", 
        "name": "ssl.cert_time_to_seconds", 
        "params": [], 
        "path": "python/library/ssl#ssl.cert_time_to_seconds", 
        "syntax": "ssl.cert_time_to_seconds(timestring)", 
        "type": "Networking"
    }, 
    "ssl.get_server_certificate": {
        "descr": "Given the address addr of an SSL-protected server, as a (hostname, port-number) pair, fetches the server\u2019s certificate, and returns it as a PEM-encoded string. If ssl_version is specified, uses that version of the SSL protocol to attempt to connect to the server. If ca_certs is specified, it should be a file containing a list of root certificates, the same format as used for the same parameter in wrap_socket(). The call will attempt to validate the server certificate against that set of root certificates, and will fail if the validation attempt fails.", 
        "name": "ssl.get_server_certificate", 
        "params": [], 
        "path": "python/library/ssl#ssl.get_server_certificate", 
        "syntax": "ssl.get_server_certificate(addr, ssl_version=PROTOCOL_SSLv3, ca_certs=None)", 
        "type": "Networking"
    }, 
    "ssl.match_hostname": {
        "descr": "Verify that cert (in decoded format as returned by SSLSocket.getpeercert()) matches the given hostname. The rules applied are those for checking the identity of HTTPS servers as outlined in RFC 2818 and RFC 6125, except that IP addresses are not currently supported. In addition to HTTPS, this function should be suitable for checking the identity of servers in various SSL-based protocols such as FTPS, IMAPS, POPS and others.", 
        "name": "ssl.match_hostname", 
        "params": [], 
        "path": "python/library/ssl#ssl.match_hostname", 
        "syntax": "ssl.match_hostname(cert, hostname)", 
        "type": "Networking"
    }, 
    "ssl.wrap_socket": {
        "descr": "Takes an instance sock of socket.socket, and returns an instance of ssl.SSLSocket, a subtype of socket.socket, which wraps the underlying socket in an SSL context. sock must be a SOCK_STREAM socket; other socket types are unsupported.", 
        "name": "ssl.wrap_socket", 
        "params": [], 
        "path": "python/library/ssl#ssl.wrap_socket", 
        "syntax": "ssl.wrap_socket(sock, keyfile=None, certfile=None, server_side=False, cert_reqs=CERT_NONE, ssl_version={see docs}, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True, ciphers=None)", 
        "type": "Networking"
    }, 
    "start": {
        "descr": "Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return -1 if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to m.group(g)) is", 
        "name": "re.match.start", 
        "params": [], 
        "path": "python/library/re#re.match.start", 
        "syntax": "match.start([group])", 
        "type": "Text Processing"
    }, 
    "startswith": {
        "descr": "Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", 
        "name": "str.startswith", 
        "params": [], 
        "path": "python/library/stdtypes#str.startswith", 
        "syntax": "str.startswith(prefix[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "stat.S_IFMT": {
        "descr": "Return the portion of the file\u2019s mode that describes the file type (used by the S_IS*() functions above).", 
        "name": "stat.S_IFMT", 
        "params": [], 
        "path": "python/library/stat#stat.S_IFMT", 
        "syntax": "stat.S_IFMT(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_IMODE": {
        "descr": "Return the portion of the file\u2019s mode that can be set by os.chmod()\u2014that is, the file\u2019s permission bits, plus the sticky bit, set-group-id, and set-user-id bits (on systems that support them).", 
        "name": "stat.S_IMODE", 
        "params": [], 
        "path": "python/library/stat#stat.S_IMODE", 
        "syntax": "stat.S_IMODE(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISBLK": {
        "descr": "Return non-zero if the mode is from a block special device file.", 
        "name": "stat.S_ISBLK", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISBLK", 
        "syntax": "stat.S_ISBLK(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISCHR": {
        "descr": "Return non-zero if the mode is from a character special device file.", 
        "name": "stat.S_ISCHR", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISCHR", 
        "syntax": "stat.S_ISCHR(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISDIR": {
        "descr": "Return non-zero if the mode is from a directory.", 
        "name": "stat.S_ISDIR", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISDIR", 
        "syntax": "stat.S_ISDIR(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISFIFO": {
        "descr": "Return non-zero if the mode is from a FIFO (named pipe).", 
        "name": "stat.S_ISFIFO", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISFIFO", 
        "syntax": "stat.S_ISFIFO(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISLNK": {
        "descr": "Return non-zero if the mode is from a symbolic link.", 
        "name": "stat.S_ISLNK", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISLNK", 
        "syntax": "stat.S_ISLNK(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISREG": {
        "descr": "Return non-zero if the mode is from a regular file.", 
        "name": "stat.S_ISREG", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISREG", 
        "syntax": "stat.S_ISREG(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.S_ISSOCK": {
        "descr": "Return non-zero if the mode is from a socket.", 
        "name": "stat.S_ISSOCK", 
        "params": [], 
        "path": "python/library/stat#stat.S_ISSOCK", 
        "syntax": "stat.S_ISSOCK(mode)", 
        "type": "File & Directory Access"
    }, 
    "stat.filemode": {
        "descr": "Convert a file\u2019s mode to a string of the form \u2018-rwxrwxrwx\u2019.", 
        "name": "stat.filemode", 
        "params": [], 
        "path": "python/library/stat#stat.filemode", 
        "syntax": "stat.filemode(mode)", 
        "type": "File & Directory Access"
    }, 
    "staticmethod": {
        "descr": "Return a static method for function.", 
        "name": "staticmethod", 
        "params": [], 
        "path": "python/library/functions#staticmethod", 
        "syntax": "staticmethod(function)", 
        "type": "Built-in Functions"
    }, 
    "str": {
        "descr": "Return a str version of object. See str() for details.", 
        "name": "str", 
        "params": [], 
        "path": "python/library/functions#str", 
        "syntax": "str(object='')", 
        "type": "Built-in Functions"
    }, 
    "str.capitalize": {
        "descr": "Return a copy of the string with its first character capitalized and the rest lowercased.", 
        "name": "str.capitalize", 
        "params": [], 
        "path": "python/library/stdtypes#str.capitalize", 
        "syntax": "str.capitalize()", 
        "type": "Built-in Types"
    }, 
    "str.casefold": {
        "descr": "Return a casefolded copy of the string. Casefolded strings may be used for caseless matching.", 
        "name": "str.casefold", 
        "params": [], 
        "path": "python/library/stdtypes#str.casefold", 
        "syntax": "str.casefold()", 
        "type": "Built-in Types"
    }, 
    "str.center": {
        "descr": "Return centered in a string of length width. Padding is done using the specified fillchar (default is a space).", 
        "name": "str.center", 
        "params": [], 
        "path": "python/library/stdtypes#str.center", 
        "syntax": "str.center(width[, fillchar])", 
        "type": "Built-in Types"
    }, 
    "str.count": {
        "descr": "Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.", 
        "name": "str.count", 
        "params": [], 
        "path": "python/library/stdtypes#str.count", 
        "syntax": "str.count(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.encode": {
        "descr": "Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme. The default for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(), see section Codec Base Classes. For a list of possible encodings, see section Standard Encodings.", 
        "name": "str.encode", 
        "params": [], 
        "path": "python/library/stdtypes#str.encode", 
        "syntax": "str.encode(encoding=\"utf-8\", errors=\"strict\")", 
        "type": "Built-in Types"
    }, 
    "str.endswith": {
        "descr": "Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position.", 
        "name": "str.endswith", 
        "params": [], 
        "path": "python/library/stdtypes#str.endswith", 
        "syntax": "str.endswith(suffix[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.expandtabs": {
        "descr": "Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\\n) or return (\\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed.", 
        "name": "str.expandtabs", 
        "params": [], 
        "path": "python/library/stdtypes#str.expandtabs", 
        "syntax": "str.expandtabs([tabsize])", 
        "type": "Built-in Types"
    }, 
    "str.find": {
        "descr": "Return the lowest index in the string where substring sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found.", 
        "name": "str.find", 
        "params": [], 
        "path": "python/library/stdtypes#str.find", 
        "syntax": "str.find(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.format": {
        "descr": "Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument.", 
        "name": "str.format", 
        "params": [], 
        "path": "python/library/stdtypes#str.format", 
        "syntax": "str.format(*args, **kwargs)", 
        "type": "Built-in Types"
    }, 
    "str.format_map": {
        "descr": "Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass:", 
        "name": "str.format_map", 
        "params": [], 
        "path": "python/library/stdtypes#str.format_map", 
        "syntax": "str.format_map(mapping)", 
        "type": "Built-in Types"
    }, 
    "str.index": {
        "descr": "Like find(), but raise ValueError when the substring is not found.", 
        "name": "str.index", 
        "params": [], 
        "path": "python/library/stdtypes#str.index", 
        "syntax": "str.index(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.isalnum": {
        "descr": "Return true if all characters in the string are alphanumeric and there is at least one character, false otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric().", 
        "name": "str.isalnum", 
        "params": [], 
        "path": "python/library/stdtypes#str.isalnum", 
        "syntax": "str.isalnum()", 
        "type": "Built-in Types"
    }, 
    "str.isalpha": {
        "descr": "Return true if all characters in the string are alphabetic and there is at least one character, false otherwise. Alphabetic characters are those characters defined in the Unicode character database as \u201cLetter\u201d, i.e., those with general category property being one of \u201cLm\u201d, \u201cLt\u201d, \u201cLu\u201d, \u201cLl\u201d, or \u201cLo\u201d. Note that this is different from the \u201cAlphabetic\u201d property defined in the Unicode Standard.", 
        "name": "str.isalpha", 
        "params": [], 
        "path": "python/library/stdtypes#str.isalpha", 
        "syntax": "str.isalpha()", 
        "type": "Built-in Types"
    }, 
    "str.isdecimal": {
        "descr": "Return true if all characters in the string are decimal characters and there is at least one character, false otherwise. Decimal characters are those from general category \u201cNd\u201d. This category includes digit characters, and all characters that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO.", 
        "name": "str.isdecimal", 
        "params": [], 
        "path": "python/library/stdtypes#str.isdecimal", 
        "syntax": "str.isdecimal()", 
        "type": "Built-in Types"
    }, 
    "str.isdigit": {
        "descr": "Return true if all characters in the string are digits and there is at least one character, false otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.", 
        "name": "str.isdigit", 
        "params": [], 
        "path": "python/library/stdtypes#str.isdigit", 
        "syntax": "str.isdigit()", 
        "type": "Built-in Types"
    }, 
    "str.isidentifier": {
        "descr": "Return true if the string is a valid identifier according to the language definition, section Identifiers and keywords.", 
        "name": "str.isidentifier", 
        "params": [], 
        "path": "python/library/stdtypes#str.isidentifier", 
        "syntax": "str.isidentifier()", 
        "type": "Built-in Types"
    }, 
    "str.islower": {
        "descr": "Return true if all cased characters [4] in the string are lowercase and there is at least one cased character, false otherwise.", 
        "name": "str.islower", 
        "params": [], 
        "path": "python/library/stdtypes#str.islower", 
        "syntax": "str.islower()", 
        "type": "Built-in Types"
    }, 
    "str.isnumeric": {
        "descr": "Return true if all characters in the string are numeric characters, and there is at least one character, false otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.", 
        "name": "str.isnumeric", 
        "params": [], 
        "path": "python/library/stdtypes#str.isnumeric", 
        "syntax": "str.isnumeric()", 
        "type": "Built-in Types"
    }, 
    "str.isprintable": {
        "descr": "Return true if all characters in the string are printable or the string is empty, false otherwise. Nonprintable characters are those characters defined in the Unicode character database as \u201cOther\u201d or \u201cSeparator\u201d, excepting the ASCII space (0x20) which is considered printable. (Note that printable characters in this context are those which should not be escaped when repr() is invoked on a string. It has no bearing on the handling of strings written to sys.stdout or sys.stderr.)", 
        "name": "str.isprintable", 
        "params": [], 
        "path": "python/library/stdtypes#str.isprintable", 
        "syntax": "str.isprintable()", 
        "type": "Built-in Types"
    }, 
    "str.isspace": {
        "descr": "Return true if there are only whitespace characters in the string and there is at least one character, false otherwise. Whitespace characters are those characters defined in the Unicode character database as \u201cOther\u201d or \u201cSeparator\u201d and those with bidirectional property being one of \u201cWS\u201d, \u201cB\u201d, or \u201cS\u201d.", 
        "name": "str.isspace", 
        "params": [], 
        "path": "python/library/stdtypes#str.isspace", 
        "syntax": "str.isspace()", 
        "type": "Built-in Types"
    }, 
    "str.istitle": {
        "descr": "Return true if the string is a titlecased string and there is at least one character, for example uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return false otherwise.", 
        "name": "str.istitle", 
        "params": [], 
        "path": "python/library/stdtypes#str.istitle", 
        "syntax": "str.istitle()", 
        "type": "Built-in Types"
    }, 
    "str.isupper": {
        "descr": "Return true if all cased characters [4] in the string are uppercase and there is at least one cased character, false otherwise.", 
        "name": "str.isupper", 
        "params": [], 
        "path": "python/library/stdtypes#str.isupper", 
        "syntax": "str.isupper()", 
        "type": "Built-in Types"
    }, 
    "str.join": {
        "descr": "Return a string which is the concatenation of the strings in the iterable iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method.", 
        "name": "str.join", 
        "params": [], 
        "path": "python/library/stdtypes#str.join", 
        "syntax": "str.join(iterable)", 
        "type": "Built-in Types"
    }, 
    "str.ljust": {
        "descr": "Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is a space). The original string is returned if width is less than or equal to len(s).", 
        "name": "str.ljust", 
        "params": [], 
        "path": "python/library/stdtypes#str.ljust", 
        "syntax": "str.ljust(width[, fillchar])", 
        "type": "Built-in Types"
    }, 
    "str.lower": {
        "descr": "Return a copy of the string with all the cased characters [4] converted to lowercase.", 
        "name": "str.lower", 
        "params": [], 
        "path": "python/library/stdtypes#str.lower", 
        "syntax": "str.lower()", 
        "type": "Built-in Types"
    }, 
    "str.lstrip": {
        "descr": "Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped:", 
        "name": "str.lstrip", 
        "params": [], 
        "path": "python/library/stdtypes#str.lstrip", 
        "syntax": "str.lstrip([chars])", 
        "type": "Built-in Types"
    }, 
    "str.partition": {
        "descr": "Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.", 
        "name": "str.partition", 
        "params": [], 
        "path": "python/library/stdtypes#str.partition", 
        "syntax": "str.partition(sep)", 
        "type": "Built-in Types"
    }, 
    "str.replace": {
        "descr": "Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.", 
        "name": "str.replace", 
        "params": [], 
        "path": "python/library/stdtypes#str.replace", 
        "syntax": "str.replace(old, new[, count])", 
        "type": "Built-in Types"
    }, 
    "str.rfind": {
        "descr": "Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.", 
        "name": "str.rfind", 
        "params": [], 
        "path": "python/library/stdtypes#str.rfind", 
        "syntax": "str.rfind(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.rindex": {
        "descr": "Like rfind() but raises ValueError when the substring sub is not found.", 
        "name": "str.rindex", 
        "params": [], 
        "path": "python/library/stdtypes#str.rindex", 
        "syntax": "str.rindex(sub[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.rjust": {
        "descr": "Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is a space). The original string is returned if width is less than or equal to len(s).", 
        "name": "str.rjust", 
        "params": [], 
        "path": "python/library/stdtypes#str.rjust", 
        "syntax": "str.rjust(width[, fillchar])", 
        "type": "Built-in Types"
    }, 
    "str.rpartition": {
        "descr": "Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself.", 
        "name": "str.rpartition", 
        "params": [], 
        "path": "python/library/stdtypes#str.rpartition", 
        "syntax": "str.rpartition(sep)", 
        "type": "Built-in Types"
    }, 
    "str.rsplit": {
        "descr": "Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below.", 
        "name": "str.rsplit", 
        "params": [], 
        "path": "python/library/stdtypes#str.rsplit", 
        "syntax": "str.rsplit(sep=None, maxsplit=-1)", 
        "type": "Built-in Types"
    }, 
    "str.rstrip": {
        "descr": "Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped:", 
        "name": "str.rstrip", 
        "params": [], 
        "path": "python/library/stdtypes#str.rstrip", 
        "syntax": "str.rstrip([chars])", 
        "type": "Built-in Types"
    }, 
    "str.split": {
        "descr": "Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made).", 
        "name": "str.split", 
        "params": [], 
        "path": "python/library/stdtypes#str.split", 
        "syntax": "str.split(sep=None, maxsplit=-1)", 
        "type": "Built-in Types"
    }, 
    "str.splitlines": {
        "descr": "Return a list of the lines in the string, breaking at line boundaries. This method uses the universal newlines approach to splitting lines. Line breaks are not included in the resulting list unless keepends is given and true.", 
        "name": "str.splitlines", 
        "params": [], 
        "path": "python/library/stdtypes#str.splitlines", 
        "syntax": "str.splitlines([keepends])", 
        "type": "Built-in Types"
    }, 
    "str.startswith": {
        "descr": "Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position.", 
        "name": "str.startswith", 
        "params": [], 
        "path": "python/library/stdtypes#str.startswith", 
        "syntax": "str.startswith(prefix[, start[, end]])", 
        "type": "Built-in Types"
    }, 
    "str.strip": {
        "descr": "Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped:", 
        "name": "str.strip", 
        "params": [], 
        "path": "python/library/stdtypes#str.strip", 
        "syntax": "str.strip([chars])", 
        "type": "Built-in Types"
    }, 
    "str.swapcase": {
        "descr": "Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.", 
        "name": "str.swapcase", 
        "params": [], 
        "path": "python/library/stdtypes#str.swapcase", 
        "syntax": "str.swapcase()", 
        "type": "Built-in Types"
    }, 
    "str.title": {
        "descr": "Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.", 
        "name": "str.title", 
        "params": [], 
        "path": "python/library/stdtypes#str.title", 
        "syntax": "str.title()", 
        "type": "Built-in Types"
    }, 
    "str.translate": {
        "descr": "Return a copy of the s where all characters have been mapped through the map which must be a dictionary of Unicode ordinals (integers) to Unicode ordinals, strings or None. Unmapped characters are left untouched. Characters mapped to None are deleted.", 
        "name": "str.translate", 
        "params": [], 
        "path": "python/library/stdtypes#str.translate", 
        "syntax": "str.translate(map)", 
        "type": "Built-in Types"
    }, 
    "str.upper": {
        "descr": "Return a copy of the string with all the cased characters [4] converted to uppercase. Note that str.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not \u201cLu\u201d (Letter, uppercase), but e.g. \u201cLt\u201d (Letter, titlecase).", 
        "name": "str.upper", 
        "params": [], 
        "path": "python/library/stdtypes#str.upper", 
        "syntax": "str.upper()", 
        "type": "Built-in Types"
    }, 
    "str.zfill": {
        "descr": "Return the numeric string left filled with zeros in a string of length width. A sign prefix is handled correctly. The original string is returned if width is less than or equal to len(s).", 
        "name": "str.zfill", 
        "params": [], 
        "path": "python/library/stdtypes#str.zfill", 
        "syntax": "str.zfill(width)", 
        "type": "Built-in Types"
    }, 
    "string": {
        "descr": "The string passed to match() or search().", 
        "name": "re.match.string", 
        "params": [], 
        "path": "python/library/re#re.match.string", 
        "syntax": "match.string", 
        "type": "Text Processing"
    }, 
    "string.Formatter": {
        "descr": "The Formatter class has the following public methods:", 
        "name": "string.Formatter", 
        "params": [], 
        "path": "python/library/string#string.Formatter", 
        "syntax": "class string.Formatter", 
        "type": "Text Processing"
    }, 
    "string.Formatter.check_unused_args": {
        "descr": "Implement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.", 
        "name": "string.Formatter.check_unused_args", 
        "params": [], 
        "path": "python/library/string#string.Formatter.check_unused_args", 
        "syntax": "check_unused_args(used_args, args, kwargs)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.convert_field": {
        "descr": "Converts the value (returned by get_field()) given a conversion type (as in the tuple returned by the parse() method). The default version understands \u2018s\u2019 (str), \u2018r\u2019 (repr) and \u2018a\u2019 (ascii) conversion types.", 
        "name": "string.Formatter.convert_field", 
        "params": [], 
        "path": "python/library/string#string.Formatter.convert_field", 
        "syntax": "convert_field(value, conversion)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.format": {
        "descr": "format() is the primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. format() is just a wrapper that calls vformat().", 
        "name": "string.Formatter.format", 
        "params": [], 
        "path": "python/library/string#string.Formatter.format", 
        "syntax": "format(format_string, *args, **kwargs)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.format_field": {
        "descr": "format_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.", 
        "name": "string.Formatter.format_field", 
        "params": [], 
        "path": "python/library/string#string.Formatter.format_field", 
        "syntax": "format_field(value, format_spec)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.get_field": {
        "descr": "Given field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101, such as \u201c0[name]\u201d or \u201clabel.title\u201d. args and kwargs are as passed in to vformat(). The return value used_key has the same meaning as the key parameter to get_value().", 
        "name": "string.Formatter.get_field", 
        "params": [], 
        "path": "python/library/string#string.Formatter.get_field", 
        "syntax": "get_field(field_name, args, kwargs)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.get_value": {
        "descr": "Retrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.", 
        "name": "string.Formatter.get_value", 
        "params": [], 
        "path": "python/library/string#string.Formatter.get_value", 
        "syntax": "get_value(key, args, kwargs)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.parse": {
        "descr": "Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.", 
        "name": "string.Formatter.parse", 
        "params": [], 
        "path": "python/library/string#string.Formatter.parse", 
        "syntax": "parse(format_string)", 
        "type": "Text Processing"
    }, 
    "string.Formatter.vformat": {
        "descr": "This function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.", 
        "name": "string.Formatter.vformat", 
        "params": [], 
        "path": "python/library/string#string.Formatter.vformat", 
        "syntax": "vformat(format_string, args, kwargs)", 
        "type": "Text Processing"
    }, 
    "string.Template": {
        "descr": "The constructor takes a single argument which is the template string.", 
        "name": "string.Template", 
        "params": [], 
        "path": "python/library/string#string.Template", 
        "syntax": "class string.Template(template)", 
        "type": "Text Processing"
    }, 
    "string.Template.safe_substitute": {
        "descr": "Like substitute(), except that if placeholders are missing from mapping and kwds, instead of raising a KeyError exception, the original placeholder will appear in the resulting string intact. Also, unlike with substitute(), any other appearances of the $ will simply return $ instead of raising ValueError.", 
        "name": "string.Template.safe_substitute", 
        "params": [], 
        "path": "python/library/string#string.Template.safe_substitute", 
        "syntax": "safe_substitute(mapping, **kwds)", 
        "type": "Text Processing"
    }, 
    "string.Template.substitute": {
        "descr": "Performs the template substitution, returning a new string. mapping is any dictionary-like object with keys that match the placeholders in the template. Alternatively, you can provide keyword arguments, where the keywords are the placeholders. When both mapping and kwds are given and there are duplicates, the placeholders from kwds take precedence.", 
        "name": "string.Template.substitute", 
        "params": [], 
        "path": "python/library/string#string.Template.substitute", 
        "syntax": "substitute(mapping, **kwds)", 
        "type": "Text Processing"
    }, 
    "string.Template.template": {
        "descr": "This is the object passed to the constructor\u2019s template argument. In general, you shouldn\u2019t change it, but read-only access is not enforced.", 
        "name": "string.Template.template", 
        "params": [], 
        "path": "python/library/string#string.Template.template", 
        "syntax": "template", 
        "type": "Text Processing"
    }, 
    "string.ascii_letters": {
        "descr": "The concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.", 
        "name": "string.ascii_letters", 
        "params": [], 
        "path": "python/library/string#string.ascii_letters", 
        "syntax": "string.ascii_letters", 
        "type": "Text Processing"
    }, 
    "string.ascii_lowercase": {
        "descr": "The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change.", 
        "name": "string.ascii_lowercase", 
        "params": [], 
        "path": "python/library/string#string.ascii_lowercase", 
        "syntax": "string.ascii_lowercase", 
        "type": "Text Processing"
    }, 
    "string.ascii_uppercase": {
        "descr": "The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change.", 
        "name": "string.ascii_uppercase", 
        "params": [], 
        "path": "python/library/string#string.ascii_uppercase", 
        "syntax": "string.ascii_uppercase", 
        "type": "Text Processing"
    }, 
    "string.capwords": {
        "descr": "Split the argument into words using str.split(), capitalize each word using str.capitalize(), and join the capitalized words using str.join(). If the optional second argument sep is absent or None, runs of whitespace characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.", 
        "name": "string.capwords", 
        "params": [], 
        "path": "python/library/string#string.capwords", 
        "syntax": "string.capwords(s, sep=None)", 
        "type": "Text Processing"
    }, 
    "string.digits": {
        "descr": "The string '0123456789'.", 
        "name": "string.digits", 
        "params": [], 
        "path": "python/library/string#string.digits", 
        "syntax": "string.digits", 
        "type": "Text Processing"
    }, 
    "string.hexdigits": {
        "descr": "The string '0123456789abcdefABCDEF'.", 
        "name": "string.hexdigits", 
        "params": [], 
        "path": "python/library/string#string.hexdigits", 
        "syntax": "string.hexdigits", 
        "type": "Text Processing"
    }, 
    "string.octdigits": {
        "descr": "The string '01234567'.", 
        "name": "string.octdigits", 
        "params": [], 
        "path": "python/library/string#string.octdigits", 
        "syntax": "string.octdigits", 
        "type": "Text Processing"
    }, 
    "string.printable": {
        "descr": "String of ASCII characters which are considered printable. This is a combination of digits, ascii_letters, punctuation, and whitespace.", 
        "name": "string.printable", 
        "params": [], 
        "path": "python/library/string#string.printable", 
        "syntax": "string.printable", 
        "type": "Text Processing"
    }, 
    "string.punctuation": {
        "descr": "String of ASCII characters which are considered punctuation characters in the C locale.", 
        "name": "string.punctuation", 
        "params": [], 
        "path": "python/library/string#string.punctuation", 
        "syntax": "string.punctuation", 
        "type": "Text Processing"
    }, 
    "string.whitespace": {
        "descr": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.", 
        "name": "string.whitespace", 
        "params": [], 
        "path": "python/library/string#string.whitespace", 
        "syntax": "string.whitespace", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_a1": {
        "descr": "Determine whether code is in tableA.1 (Unassigned code points in Unicode 3.2).", 
        "name": "stringprep.in_table_a1", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_a1", 
        "syntax": "stringprep.in_table_a1(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_b1": {
        "descr": "Determine whether code is in tableB.1 (Commonly mapped to nothing).", 
        "name": "stringprep.in_table_b1", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_b1", 
        "syntax": "stringprep.in_table_b1(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c11": {
        "descr": "Determine whether code is in tableC.1.1 (ASCII space characters).", 
        "name": "stringprep.in_table_c11", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c11", 
        "syntax": "stringprep.in_table_c11(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c11_c12": {
        "descr": "Determine whether code is in tableC.1 (Space characters, union of C.1.1 and C.1.2).", 
        "name": "stringprep.in_table_c11_c12", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c11_c12", 
        "syntax": "stringprep.in_table_c11_c12(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c12": {
        "descr": "Determine whether code is in tableC.1.2 (Non-ASCII space characters).", 
        "name": "stringprep.in_table_c12", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c12", 
        "syntax": "stringprep.in_table_c12(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c21": {
        "descr": "Determine whether code is in tableC.2.1 (ASCII control characters).", 
        "name": "stringprep.in_table_c21", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c21", 
        "syntax": "stringprep.in_table_c21(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c21_c22": {
        "descr": "Determine whether code is in tableC.2 (Control characters, union of C.2.1 and C.2.2).", 
        "name": "stringprep.in_table_c21_c22", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c21_c22", 
        "syntax": "stringprep.in_table_c21_c22(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c22": {
        "descr": "Determine whether code is in tableC.2.2 (Non-ASCII control characters).", 
        "name": "stringprep.in_table_c22", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c22", 
        "syntax": "stringprep.in_table_c22(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c3": {
        "descr": "Determine whether code is in tableC.3 (Private use).", 
        "name": "stringprep.in_table_c3", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c3", 
        "syntax": "stringprep.in_table_c3(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c4": {
        "descr": "Determine whether code is in tableC.4 (Non-character code points).", 
        "name": "stringprep.in_table_c4", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c4", 
        "syntax": "stringprep.in_table_c4(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c5": {
        "descr": "Determine whether code is in tableC.5 (Surrogate codes).", 
        "name": "stringprep.in_table_c5", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c5", 
        "syntax": "stringprep.in_table_c5(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c6": {
        "descr": "Determine whether code is in tableC.6 (Inappropriate for plain text).", 
        "name": "stringprep.in_table_c6", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c6", 
        "syntax": "stringprep.in_table_c6(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c7": {
        "descr": "Determine whether code is in tableC.7 (Inappropriate for canonical representation).", 
        "name": "stringprep.in_table_c7", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c7", 
        "syntax": "stringprep.in_table_c7(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c8": {
        "descr": "Determine whether code is in tableC.8 (Change display properties or are deprecated).", 
        "name": "stringprep.in_table_c8", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c8", 
        "syntax": "stringprep.in_table_c8(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_c9": {
        "descr": "Determine whether code is in tableC.9 (Tagging characters).", 
        "name": "stringprep.in_table_c9", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_c9", 
        "syntax": "stringprep.in_table_c9(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_d1": {
        "descr": "Determine whether code is in tableD.1 (Characters with bidirectional property \u201cR\u201d or \u201cAL\u201d).", 
        "name": "stringprep.in_table_d1", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_d1", 
        "syntax": "stringprep.in_table_d1(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.in_table_d2": {
        "descr": "Determine whether code is in tableD.2 (Characters with bidirectional property \u201cL\u201d).", 
        "name": "stringprep.in_table_d2", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.in_table_d2", 
        "syntax": "stringprep.in_table_d2(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.map_table_b2": {
        "descr": "Return the mapped value for code according to tableB.2 (Mapping for case-folding used with NFKC).", 
        "name": "stringprep.map_table_b2", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.map_table_b2", 
        "syntax": "stringprep.map_table_b2(code)", 
        "type": "Text Processing"
    }, 
    "stringprep.map_table_b3": {
        "descr": "Return the mapped value for code according to tableB.3 (Mapping for case-folding used with no normalization).", 
        "name": "stringprep.map_table_b3", 
        "params": [], 
        "path": "python/library/stringprep#stringprep.map_table_b3", 
        "syntax": "stringprep.map_table_b3(code)", 
        "type": "Text Processing"
    }, 
    "strip": {
        "descr": "Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped:", 
        "name": "str.strip", 
        "params": [], 
        "path": "python/library/stdtypes#str.strip", 
        "syntax": "str.strip([chars])", 
        "type": "Built-in Types"
    }, 
    "struct.Struct": {
        "descr": "Return a new Struct object which writes and reads binary data according to the format string format. Creating a Struct object once and calling its methods is more efficient than calling the struct functions with the same format since the format string only needs to be compiled once.", 
        "name": "struct.Struct", 
        "params": [], 
        "path": "python/library/struct#struct.Struct", 
        "syntax": "class struct.Struct(format)", 
        "type": "Binary Data"
    }, 
    "struct.Struct.format": {
        "descr": "The format string used to construct this Struct object.", 
        "name": "struct.Struct.format", 
        "params": [], 
        "path": "python/library/struct#struct.Struct.format", 
        "syntax": "format", 
        "type": "Binary Data"
    }, 
    "struct.Struct.pack": {
        "descr": "Identical to the pack() function, using the compiled format. (len(result) will equal self.size.)", 
        "name": "struct.Struct.pack", 
        "params": [], 
        "path": "python/library/struct#struct.Struct.pack", 
        "syntax": "pack(v1, v2, ...)", 
        "type": "Binary Data"
    }, 
    "struct.Struct.pack_into": {
        "descr": "Identical to the pack_into() function, using the compiled format.", 
        "name": "struct.Struct.pack_into", 
        "params": [], 
        "path": "python/library/struct#struct.Struct.pack_into", 
        "syntax": "pack_into(buffer, offset, v1, v2, ...)", 
        "type": "Binary Data"
    }, 
    "struct.Struct.size": {
        "descr": "The calculated size of the struct (and hence of the bytes object produced by the pack() method) corresponding to format.", 
        "name": "struct.Struct.size", 
        "params": [], 
        "path": "python/library/struct#struct.Struct.size", 
        "syntax": "size", 
        "type": "Binary Data"
    }, 
    "struct.Struct.unpack": {
        "descr": "Identical to the unpack() function, using the compiled format. (len(buffer) must equal self.size).", 
        "name": "struct.Struct.unpack", 
        "params": [], 
        "path": "python/library/struct#struct.Struct.unpack", 
        "syntax": "unpack(buffer)", 
        "type": "Binary Data"
    }, 
    "struct.Struct.unpack_from": {
        "descr": "Identical to the unpack_from() function, using the compiled format. (len(buffer[offset:]) must be at least self.size).", 
        "name": "struct.Struct.unpack_from", 
        "params": [], 
        "path": "python/library/struct#struct.Struct.unpack_from", 
        "syntax": "unpack_from(buffer, offset=0)", 
        "type": "Binary Data"
    }, 
    "struct.calcsize": {
        "descr": "Return the size of the struct (and hence of the bytes object produced by pack(fmt, ...)) corresponding to the format string fmt.", 
        "name": "struct.calcsize", 
        "params": [], 
        "path": "python/library/struct#struct.calcsize", 
        "syntax": "struct.calcsize(fmt)", 
        "type": "Binary Data"
    }, 
    "struct.error": {
        "descr": "Exception raised on various occasions; argument is a string describing what is wrong.", 
        "name": "struct.error", 
        "params": [], 
        "path": "python/library/struct#struct.error", 
        "syntax": "exception struct.error", 
        "type": "Binary Data"
    }, 
    "struct.pack": {
        "descr": "Return a bytes object containing the values v1, v2, ... packed according to the format string fmt. The arguments must match the values required by the format exactly.", 
        "name": "struct.pack", 
        "params": [], 
        "path": "python/library/struct#struct.pack", 
        "syntax": "struct.pack(fmt, v1, v2, ...)", 
        "type": "Binary Data"
    }, 
    "struct.pack_into": {
        "descr": "Pack the values v1, v2, ... according to the format string fmt and write the packed bytes into the writable buffer buffer starting at position offset. Note that offset is a required argument.", 
        "name": "struct.pack_into", 
        "params": [], 
        "path": "python/library/struct#struct.pack_into", 
        "syntax": "struct.pack_into(fmt, buffer, offset, v1, v2, ...)", 
        "type": "Binary Data"
    }, 
    "struct.unpack": {
        "descr": "Unpack from the buffer buffer (presumably packed by pack(fmt, ...)) according to the format string fmt. The result is a tuple even if it contains exactly one item. The buffer must contain exactly the amount of data required by the format (len(bytes) must equal calcsize(fmt)).", 
        "name": "struct.unpack", 
        "params": [], 
        "path": "python/library/struct#struct.unpack", 
        "syntax": "struct.unpack(fmt, buffer)", 
        "type": "Binary Data"
    }, 
    "struct.unpack_from": {
        "descr": "Unpack from buffer starting at position offset, according to the format string fmt. The result is a tuple even if it contains exactly one item. buffer must contain at least the amount of data required by the format (len(buffer[offset:]) must be at least calcsize(fmt)).", 
        "name": "struct.unpack_from", 
        "params": [], 
        "path": "python/library/struct#struct.unpack_from", 
        "syntax": "struct.unpack_from(fmt, buffer, offset=0)", 
        "type": "Binary Data"
    }, 
    "subprocess.CalledProcessError": {
        "descr": "Subclass of SubprocessError, raised when a process run by check_call() or check_output() returns a non-zero exit status.", 
        "name": "subprocess.CalledProcessError", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.CalledProcessError", 
        "syntax": "exception subprocess.CalledProcessError", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.CalledProcessError.cmd": {
        "descr": "Command that was used to spawn the child process.", 
        "name": "subprocess.CalledProcessError.cmd", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.CalledProcessError.cmd", 
        "syntax": "cmd", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.CalledProcessError.output": {
        "descr": "Output of the child process if this exception is raised by check_output(). Otherwise, None.", 
        "name": "subprocess.CalledProcessError.output", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.CalledProcessError.output", 
        "syntax": "output", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.CalledProcessError.returncode": {
        "descr": "Exit status of the child process.", 
        "name": "subprocess.CalledProcessError.returncode", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.CalledProcessError.returncode", 
        "syntax": "returncode", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen": {
        "descr": "Execute a child program in a new process. On Unix, the class uses os.execvp()-like behavior to execute the child program. On Windows, the class uses the Windows CreateProcess() function. The arguments to Popen are as follows.", 
        "name": "subprocess.Popen", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen", 
        "syntax": "class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=())", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.communicate": {
        "descr": "Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate. The optional input argument should be data to be sent to the child process, or None, if no data should be sent to the child. The type of input must be bytes or, if universal_newlines was True, a string.", 
        "name": "subprocess.Popen.communicate", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.communicate", 
        "syntax": "Popen.communicate(input=None, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.kill": {
        "descr": "Kills the child. On Posix OSs the function sends SIGKILL to the child. On Windows kill() is an alias for terminate().", 
        "name": "subprocess.Popen.kill", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.kill", 
        "syntax": "Popen.kill()", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.pid": {
        "descr": "The process ID of the child process.", 
        "name": "subprocess.Popen.pid", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.pid", 
        "syntax": "Popen.pid", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.poll": {
        "descr": "Check if child process has terminated. Set and return returncode attribute.", 
        "name": "subprocess.Popen.poll", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.poll", 
        "syntax": "Popen.poll()", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.returncode": {
        "descr": "The child return code, set by poll() and wait() (and indirectly by communicate()). A None value indicates that the process hasn\u2019t terminated yet.", 
        "name": "subprocess.Popen.returncode", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.returncode", 
        "syntax": "Popen.returncode", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.send_signal": {
        "descr": "Sends the signal signal to the child.", 
        "name": "subprocess.Popen.send_signal", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.send_signal", 
        "syntax": "Popen.send_signal(signal)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.stderr": {
        "descr": "If the stderr argument was PIPE, this attribute is a readable stream object as returned by open(). Reading from the stream provides error output from the child process. If the universal_newlines argument was True, the stream is a text stream, otherwise it is a byte stream. If the stderr argument was not PIPE, this attribute is None.", 
        "name": "subprocess.Popen.stderr", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.stderr", 
        "syntax": "Popen.stderr", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.stdin": {
        "descr": "If the stdin argument was PIPE, this attribute is a writeable stream object as returned by open(). If the universal_newlines argument was True, the stream is a text stream, otherwise it is a byte stream. If the stdin argument was not PIPE, this attribute is None.", 
        "name": "subprocess.Popen.stdin", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.stdin", 
        "syntax": "Popen.stdin", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.stdout": {
        "descr": "If the stdout argument was PIPE, this attribute is a readable stream object as returned by open(). Reading from the stream provides output from the child process. If the universal_newlines argument was True, the stream is a text stream, otherwise it is a byte stream. If the stdout argument was not PIPE, this attribute is None.", 
        "name": "subprocess.Popen.stdout", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.stdout", 
        "syntax": "Popen.stdout", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.terminate": {
        "descr": "Stop the child. On Posix OSs the method sends SIGTERM to the child. On Windows the Win32 API function TerminateProcess() is called to stop the child.", 
        "name": "subprocess.Popen.terminate", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.terminate", 
        "syntax": "Popen.terminate()", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.Popen.wait": {
        "descr": "Wait for child process to terminate. Set and return returncode attribute.", 
        "name": "subprocess.Popen.wait", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.Popen.wait", 
        "syntax": "Popen.wait(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.STARTUPINFO": {
        "descr": "Partial support of the Windows STARTUPINFO structure is used for Popen creation.", 
        "name": "subprocess.STARTUPINFO", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.STARTUPINFO", 
        "syntax": "class subprocess.STARTUPINFO", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.STARTUPINFO.dwFlags": {
        "descr": "A bit field that determines whether certain STARTUPINFO attributes are used when the process creates a window.", 
        "name": "subprocess.STARTUPINFO.dwFlags", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.STARTUPINFO.dwFlags", 
        "syntax": "dwFlags", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.STARTUPINFO.hStdError": {
        "descr": "If dwFlags specifies STARTF_USESTDHANDLES, this attribute is the standard error handle for the process. Otherwise, this attribute is ignored and the default for standard error is the console window\u2019s buffer.", 
        "name": "subprocess.STARTUPINFO.hStdError", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.STARTUPINFO.hStdError", 
        "syntax": "hStdError", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.STARTUPINFO.hStdInput": {
        "descr": "If dwFlags specifies STARTF_USESTDHANDLES, this attribute is the standard input handle for the process. If STARTF_USESTDHANDLES is not specified, the default for standard input is the keyboard buffer.", 
        "name": "subprocess.STARTUPINFO.hStdInput", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.STARTUPINFO.hStdInput", 
        "syntax": "hStdInput", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.STARTUPINFO.hStdOutput": {
        "descr": "If dwFlags specifies STARTF_USESTDHANDLES, this attribute is the standard output handle for the process. Otherwise, this attribute is ignored and the default for standard output is the console window\u2019s buffer.", 
        "name": "subprocess.STARTUPINFO.hStdOutput", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.STARTUPINFO.hStdOutput", 
        "syntax": "hStdOutput", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.STARTUPINFO.wShowWindow": {
        "descr": "If dwFlags specifies STARTF_USESHOWWINDOW, this attribute can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this attribute is ignored.", 
        "name": "subprocess.STARTUPINFO.wShowWindow", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.STARTUPINFO.wShowWindow", 
        "syntax": "wShowWindow", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.SubprocessError": {
        "descr": "Base class for all other exceptions from this module.", 
        "name": "subprocess.SubprocessError", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.SubprocessError", 
        "syntax": "exception subprocess.SubprocessError", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.TimeoutExpired": {
        "descr": "Subclass of SubprocessError, raised when a timeout expires while waiting for a child process.", 
        "name": "subprocess.TimeoutExpired", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.TimeoutExpired", 
        "syntax": "exception subprocess.TimeoutExpired", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.TimeoutExpired.cmd": {
        "descr": "Command that was used to spawn the child process.", 
        "name": "subprocess.TimeoutExpired.cmd", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.TimeoutExpired.cmd", 
        "syntax": "cmd", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.TimeoutExpired.output": {
        "descr": "Output of the child process if this exception is raised by check_output(). Otherwise, None.", 
        "name": "subprocess.TimeoutExpired.output", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.TimeoutExpired.output", 
        "syntax": "output", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.TimeoutExpired.timeout": {
        "descr": "Timeout in seconds.", 
        "name": "subprocess.TimeoutExpired.timeout", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.TimeoutExpired.timeout", 
        "syntax": "timeout", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.call": {
        "descr": "Run the command described by args. Wait for command to complete, then return the returncode attribute.", 
        "name": "subprocess.call", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.call", 
        "syntax": "subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.check_call": {
        "descr": "Run command with arguments. Wait for command to complete. If the return code was zero then return, otherwise raise CalledProcessError. The CalledProcessError object will have the return code in the returncode attribute.", 
        "name": "subprocess.check_call", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.check_call", 
        "syntax": "subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.check_output": {
        "descr": "Run command with arguments and return its output.", 
        "name": "subprocess.check_output", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.check_output", 
        "syntax": "subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.getoutput": {
        "descr": "Return output (stdout and stderr) of executing cmd in a shell.", 
        "name": "subprocess.getoutput", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.getoutput", 
        "syntax": "subprocess.getoutput(cmd)", 
        "type": "Concurrent Execution"
    }, 
    "subprocess.getstatusoutput": {
        "descr": "Return (status, output) of executing cmd in a shell.", 
        "name": "subprocess.getstatusoutput", 
        "params": [], 
        "path": "python/library/subprocess#subprocess.getstatusoutput", 
        "syntax": "subprocess.getstatusoutput(cmd)", 
        "type": "Concurrent Execution"
    }, 
    "sum": {
        "descr": "Sums start and the items of an iterable from left to right and returns the total. start defaults to 0. The iterable\u2018s items are normally numbers, and the start value is not allowed to be a string.", 
        "name": "sum", 
        "params": [], 
        "path": "python/library/functions#sum", 
        "syntax": "sum(iterable[, start])", 
        "type": "Built-in Functions"
    }, 
    "super": {
        "descr": "Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by getattr() except that the type itself is skipped.", 
        "name": "super", 
        "params": [], 
        "path": "python/library/functions#super", 
        "syntax": "super([type[, object-or-type]])", 
        "type": "Built-in Functions"
    }, 
    "swapcase": {
        "descr": "Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.", 
        "name": "str.swapcase", 
        "params": [], 
        "path": "python/library/stdtypes#str.swapcase", 
        "syntax": "str.swapcase()", 
        "type": "Built-in Types"
    }, 
    "sys.__displayhook__": {
        "descr": "These objects contain the original values of displayhook and excepthook at the start of the program. They are saved so that displayhook and excepthook can be restored in case they happen to get replaced with broken objects.", 
        "name": "sys.__displayhook__", 
        "params": [], 
        "path": "python/library/sys#sys.__displayhook__", 
        "syntax": "sys.__displayhook__", 
        "type": "Runtime"
    }, 
    "sys.__excepthook__": {
        "descr": "These objects contain the original values of displayhook and excepthook at the start of the program. They are saved so that displayhook and excepthook can be restored in case they happen to get replaced with broken objects.", 
        "name": "sys.__excepthook__", 
        "params": [], 
        "path": "python/library/sys#sys.__excepthook__", 
        "syntax": "sys.__excepthook__", 
        "type": "Runtime"
    }, 
    "sys.__stderr__": {
        "descr": "These objects contain the original values of stdin, stderr and stdout at the start of the program. They are used during finalization, and could be useful to print to the actual standard stream no matter if the sys.std* object has been redirected.", 
        "name": "sys.__stderr__", 
        "params": [], 
        "path": "python/library/sys#sys.__stderr__", 
        "syntax": "sys.__stderr__", 
        "type": "Runtime"
    }, 
    "sys.__stdin__": {
        "descr": "These objects contain the original values of stdin, stderr and stdout at the start of the program. They are used during finalization, and could be useful to print to the actual standard stream no matter if the sys.std* object has been redirected.", 
        "name": "sys.__stdin__", 
        "params": [], 
        "path": "python/library/sys#sys.__stdin__", 
        "syntax": "sys.__stdin__", 
        "type": "Runtime"
    }, 
    "sys.__stdout__": {
        "descr": "These objects contain the original values of stdin, stderr and stdout at the start of the program. They are used during finalization, and could be useful to print to the actual standard stream no matter if the sys.std* object has been redirected.", 
        "name": "sys.__stdout__", 
        "params": [], 
        "path": "python/library/sys#sys.__stdout__", 
        "syntax": "sys.__stdout__", 
        "type": "Runtime"
    }, 
    "sys._clear_type_cache": {
        "descr": "Clear the internal type cache. The type cache is used to speed up attribute and method lookups. Use the function only to drop unnecessary references during reference leak debugging.", 
        "name": "sys._clear_type_cache", 
        "params": [], 
        "path": "python/library/sys#sys._clear_type_cache", 
        "syntax": "sys._clear_type_cache()", 
        "type": "Runtime"
    }, 
    "sys._current_frames": {
        "descr": "Return a dictionary mapping each thread\u2019s identifier to the topmost stack frame currently active in that thread at the time the function is called. Note that functions in the traceback module can build the call stack given such a frame.", 
        "name": "sys._current_frames", 
        "params": [], 
        "path": "python/library/sys#sys._current_frames", 
        "syntax": "sys._current_frames()", 
        "type": "Runtime"
    }, 
    "sys._debugmallocstats": {
        "descr": "Print low-level information to stderr about the state of CPython\u2019s memory allocator.", 
        "name": "sys._debugmallocstats", 
        "params": [], 
        "path": "python/library/sys#sys._debugmallocstats", 
        "syntax": "sys._debugmallocstats()", 
        "type": "Runtime"
    }, 
    "sys._getframe": {
        "descr": "Return a frame object from the call stack. If optional integer depth is given, return the frame object that many calls below the top of the stack. If that is deeper than the call stack, ValueError is raised. The default for depth is zero, returning the frame at the top of the call stack.", 
        "name": "sys._getframe", 
        "params": [], 
        "path": "python/library/sys#sys._getframe", 
        "syntax": "sys._getframe([depth])", 
        "type": "Runtime"
    }, 
    "sys._xoptions": {
        "descr": "A dictionary of the various implementation-specific flags passed through the -X command-line option. Option names are either mapped to their values, if given explicitly, or to True. Example:", 
        "name": "sys._xoptions", 
        "params": [], 
        "path": "python/library/sys#sys._xoptions", 
        "syntax": "sys._xoptions", 
        "type": "Runtime"
    }, 
    "sys.abiflags": {
        "descr": "On POSIX systems where Python is build with the standard configure script, this contains the ABI flags as specified by PEP 3149.", 
        "name": "sys.abiflags", 
        "params": [], 
        "path": "python/library/sys#sys.abiflags", 
        "syntax": "sys.abiflags", 
        "type": "Runtime"
    }, 
    "sys.api_version": {
        "descr": "The C API version for this interpreter. Programmers may find this useful when debugging version conflicts between Python and extension modules.", 
        "name": "sys.api_version", 
        "params": [], 
        "path": "python/library/sys#sys.api_version", 
        "syntax": "sys.api_version", 
        "type": "Runtime"
    }, 
    "sys.argv": {
        "descr": "The list of command line arguments passed to a Python script. argv[0] is the script name (it is operating system dependent whether this is a full pathname or not). If the command was executed using the -c command line option to the interpreter, argv[0] is set to the string '-c'. If no script name was passed to the Python interpreter, argv[0] is the empty string.", 
        "name": "sys.argv", 
        "params": [], 
        "path": "python/library/sys#sys.argv", 
        "syntax": "sys.argv", 
        "type": "Runtime"
    }, 
    "sys.base_exec_prefix": {
        "descr": "Set during Python startup, before site.py is run, to the same value as exec_prefix. If not running in a virtual environment, the values will stay the same; if site.py finds that a virtual environment is in use, the values of prefix and exec_prefix will be changed to point to the virtual environment, whereas base_prefix and base_exec_prefix will remain pointing to the base Python installation (the one which the virtual environment was created from).", 
        "name": "sys.base_exec_prefix", 
        "params": [], 
        "path": "python/library/sys#sys.base_exec_prefix", 
        "syntax": "sys.base_exec_prefix", 
        "type": "Runtime"
    }, 
    "sys.base_prefix": {
        "descr": "Set during Python startup, before site.py is run, to the same value as prefix. If not running in a virtual environment, the values will stay the same; if site.py finds that a virtual environment is in use, the values of prefix and exec_prefix will be changed to point to the virtual environment, whereas base_prefix and base_exec_prefix will remain pointing to the base Python installation (the one which the virtual environment was created from).", 
        "name": "sys.base_prefix", 
        "params": [], 
        "path": "python/library/sys#sys.base_prefix", 
        "syntax": "sys.base_prefix", 
        "type": "Runtime"
    }, 
    "sys.builtin_module_names": {
        "descr": "A tuple of strings giving the names of all modules that are compiled into this Python interpreter. (This information is not available in any other way \u2014 modules.keys() only lists the imported modules.)", 
        "name": "sys.builtin_module_names", 
        "params": [], 
        "path": "python/library/sys#sys.builtin_module_names", 
        "syntax": "sys.builtin_module_names", 
        "type": "Runtime"
    }, 
    "sys.byteorder": {
        "descr": "An indicator of the native byte order. This will have the value 'big' on big-endian (most-significant byte first) platforms, and 'little' on little-endian (least-significant byte first) platforms.", 
        "name": "sys.byteorder", 
        "params": [], 
        "path": "python/library/sys#sys.byteorder", 
        "syntax": "sys.byteorder", 
        "type": "Runtime"
    }, 
    "sys.call_tracing": {
        "descr": "Call func(*args), while tracing is enabled. The tracing state is saved, and restored afterwards. This is intended to be called from a debugger from a checkpoint, to recursively debug some other code.", 
        "name": "sys.call_tracing", 
        "params": [], 
        "path": "python/library/sys#sys.call_tracing", 
        "syntax": "sys.call_tracing(func, args)", 
        "type": "Runtime"
    }, 
    "sys.copyright": {
        "descr": "A string containing the copyright pertaining to the Python interpreter.", 
        "name": "sys.copyright", 
        "params": [], 
        "path": "python/library/sys#sys.copyright", 
        "syntax": "sys.copyright", 
        "type": "Runtime"
    }, 
    "sys.displayhook": {
        "descr": "If value is not None, this function prints repr(value) to sys.stdout, and saves value in builtins._. If repr(value) is not encodable to sys.stdout.encoding with sys.stdout.errors error handler (which is probably 'strict'), encode it to sys.stdout.encoding with 'backslashreplace' error handler.", 
        "name": "sys.displayhook", 
        "params": [], 
        "path": "python/library/sys#sys.displayhook", 
        "syntax": "sys.displayhook(value)", 
        "type": "Runtime"
    }, 
    "sys.dllhandle": {
        "descr": "Integer specifying the handle of the Python DLL. Availability: Windows.", 
        "name": "sys.dllhandle", 
        "params": [], 
        "path": "python/library/sys#sys.dllhandle", 
        "syntax": "sys.dllhandle", 
        "type": "Runtime"
    }, 
    "sys.dont_write_bytecode": {
        "descr": "If this is true, Python won\u2019t try to write .pyc or .pyo files on the import of source modules. This value is initially set to True or False depending on the -B command line option and the PYTHONDONTWRITEBYTECODE environment variable, but you can set it yourself to control bytecode file generation.", 
        "name": "sys.dont_write_bytecode", 
        "params": [], 
        "path": "python/library/sys#sys.dont_write_bytecode", 
        "syntax": "sys.dont_write_bytecode", 
        "type": "Runtime"
    }, 
    "sys.exc_info": {
        "descr": "This function returns a tuple of three values that give information about the exception that is currently being handled. The information returned is specific both to the current thread and to the current stack frame. If the current stack frame is not handling an exception, the information is taken from the calling stack frame, or its caller, and so on until a stack frame is found that is handling an exception. Here, \u201chandling an exception\u201d is defined as \u201cexecuting an except clause.\u201d For any stack frame, only information about the exception being currently handled is accessible.", 
        "name": "sys.exc_info", 
        "params": [], 
        "path": "python/library/sys#sys.exc_info", 
        "syntax": "sys.exc_info()", 
        "type": "Runtime"
    }, 
    "sys.excepthook": {
        "descr": "This function prints out a given traceback and exception to sys.stderr.", 
        "name": "sys.excepthook", 
        "params": [], 
        "path": "python/library/sys#sys.excepthook", 
        "syntax": "sys.excepthook(type, value, traceback)", 
        "type": "Runtime"
    }, 
    "sys.exec_prefix": {
        "descr": "A string giving the site-specific directory prefix where the platform-dependent Python files are installed; by default, this is also '/usr/local'. This can be set at build time with the --exec-prefix argument to the configure script. Specifically, all configuration files (e.g. the pyconfig.h header file) are installed in the directory exec_prefix/lib/pythonX.Y/config, and shared library modules are installed in exec_prefix/lib/pythonX.Y/lib-dynload, where X.Y is the version number of Python, for example 3.2.", 
        "name": "sys.exec_prefix", 
        "params": [], 
        "path": "python/library/sys#sys.exec_prefix", 
        "syntax": "sys.exec_prefix", 
        "type": "Runtime"
    }, 
    "sys.executable": {
        "descr": "A string giving the absolute path of the executable binary for the Python interpreter, on systems where this makes sense. If Python is unable to retrieve the real path to its executable, sys.executable will be an empty string or None.", 
        "name": "sys.executable", 
        "params": [], 
        "path": "python/library/sys#sys.executable", 
        "syntax": "sys.executable", 
        "type": "Runtime"
    }, 
    "sys.exit": {
        "descr": "Exit from Python. This is implemented by raising the SystemExit exception, so cleanup actions specified by finally clauses of try statements are honored, and it is possible to intercept the exit attempt at an outer level.", 
        "name": "sys.exit", 
        "params": [], 
        "path": "python/library/sys#sys.exit", 
        "syntax": "sys.exit([arg])", 
        "type": "Runtime"
    }, 
    "sys.flags": {
        "descr": "The struct sequence flags exposes the status of command line flags. The attributes are read only.", 
        "name": "sys.flags", 
        "params": [], 
        "path": "python/library/sys#sys.flags", 
        "syntax": "sys.flags", 
        "type": "Runtime"
    }, 
    "sys.float_info": {
        "descr": "A struct sequence holding information about the float type. It contains low level information about the precision and internal representation. The values correspond to the various floating-point constants defined in the standard header file float.h for the \u2018C\u2019 programming language; see section 5.2.4.2.2 of the 1999 ISO/IEC C standard [C99], \u2018Characteristics of floating types\u2019, for details.", 
        "name": "sys.float_info", 
        "params": [], 
        "path": "python/library/sys#sys.float_info", 
        "syntax": "sys.float_info", 
        "type": "Runtime"
    }, 
    "sys.float_repr_style": {
        "descr": "A string indicating how the repr() function behaves for floats. If the string has value 'short' then for a finite float x, repr(x) aims to produce a short string with the property that float(repr(x)) == x. This is the usual behaviour in Python 3.1 and later. Otherwise, float_repr_style has value 'legacy' and repr(x) behaves in the same way as it did in versions of Python prior to 3.1.", 
        "name": "sys.float_repr_style", 
        "params": [], 
        "path": "python/library/sys#sys.float_repr_style", 
        "syntax": "sys.float_repr_style", 
        "type": "Runtime"
    }, 
    "sys.getcheckinterval": {
        "descr": "Return the interpreter\u2019s \u201ccheck interval\u201d; see setcheckinterval().", 
        "name": "sys.getcheckinterval", 
        "params": [], 
        "path": "python/library/sys#sys.getcheckinterval", 
        "syntax": "sys.getcheckinterval()", 
        "type": "Runtime"
    }, 
    "sys.getdefaultencoding": {
        "descr": "Return the name of the current default string encoding used by the Unicode implementation.", 
        "name": "sys.getdefaultencoding", 
        "params": [], 
        "path": "python/library/sys#sys.getdefaultencoding", 
        "syntax": "sys.getdefaultencoding()", 
        "type": "Runtime"
    }, 
    "sys.getdlopenflags": {
        "descr": "Return the current value of the flags that are used for dlopen() calls. The flag constants are defined in the ctypes and DLFCN modules. Availability: Unix.", 
        "name": "sys.getdlopenflags", 
        "params": [], 
        "path": "python/library/sys#sys.getdlopenflags", 
        "syntax": "sys.getdlopenflags()", 
        "type": "Runtime"
    }, 
    "sys.getfilesystemencoding": {
        "descr": "Return the name of the encoding used to convert Unicode filenames into system file names. The result value depends on the operating system:", 
        "name": "sys.getfilesystemencoding", 
        "params": [], 
        "path": "python/library/sys#sys.getfilesystemencoding", 
        "syntax": "sys.getfilesystemencoding()", 
        "type": "Runtime"
    }, 
    "sys.getprofile": {
        "descr": "", 
        "name": "sys.getprofile", 
        "params": [], 
        "path": "python/library/sys#sys.getprofile", 
        "syntax": "sys.getprofile()", 
        "type": "Runtime"
    }, 
    "sys.getrecursionlimit": {
        "descr": "Return the current value of the recursion limit, the maximum depth of the Python interpreter stack. This limit prevents infinite recursion from causing an overflow of the C stack and crashing Python. It can be set by setrecursionlimit().", 
        "name": "sys.getrecursionlimit", 
        "params": [], 
        "path": "python/library/sys#sys.getrecursionlimit", 
        "syntax": "sys.getrecursionlimit()", 
        "type": "Runtime"
    }, 
    "sys.getrefcount": {
        "descr": "Return the reference count of the object. The count returned is generally one higher than you might expect, because it includes the (temporary) reference as an argument to getrefcount().", 
        "name": "sys.getrefcount", 
        "params": [], 
        "path": "python/library/sys#sys.getrefcount", 
        "syntax": "sys.getrefcount(object)", 
        "type": "Runtime"
    }, 
    "sys.getsizeof": {
        "descr": "Return the size of an object in bytes. The object can be any type of object. All built-in objects will return correct results, but this does not have to hold true for third-party extensions as it is implementation specific.", 
        "name": "sys.getsizeof", 
        "params": [], 
        "path": "python/library/sys#sys.getsizeof", 
        "syntax": "sys.getsizeof(object[, default])", 
        "type": "Runtime"
    }, 
    "sys.getswitchinterval": {
        "descr": "Return the interpreter\u2019s \u201cthread switch interval\u201d; see setswitchinterval().", 
        "name": "sys.getswitchinterval", 
        "params": [], 
        "path": "python/library/sys#sys.getswitchinterval", 
        "syntax": "sys.getswitchinterval()", 
        "type": "Runtime"
    }, 
    "sys.gettrace": {
        "descr": "CPython implementation detail: The gettrace() function is intended only for implementing debuggers, profilers, coverage tools and the like. Its behavior is part of the implementation platform, rather than part of the language definition, and thus may not be available in all Python implementations.", 
        "name": "sys.gettrace", 
        "params": [], 
        "path": "python/library/sys#sys.gettrace", 
        "syntax": "sys.gettrace()", 
        "type": "Runtime"
    }, 
    "sys.getwindowsversion": {
        "descr": "Return a named tuple describing the Windows version currently running. The named elements are major, minor, build, platform, service_pack, service_pack_minor, service_pack_major, suite_mask, and product_type. service_pack contains a string while all other values are integers. The components can also be accessed by name, so sys.getwindowsversion()[0] is equivalent to sys.getwindowsversion().major. For compatibility with prior versions, only the first 5 elements are retrievable by indexing.", 
        "name": "sys.getwindowsversion", 
        "params": [], 
        "path": "python/library/sys#sys.getwindowsversion", 
        "syntax": "sys.getwindowsversion()", 
        "type": "Runtime"
    }, 
    "sys.hash_info": {
        "descr": "A struct sequence giving parameters of the numeric hash implementation. For more details about hashing of numeric types, see Hashing of numeric types.", 
        "name": "sys.hash_info", 
        "params": [], 
        "path": "python/library/sys#sys.hash_info", 
        "syntax": "sys.hash_info", 
        "type": "Runtime"
    }, 
    "sys.hexversion": {
        "descr": "The version number encoded as a single integer. This is guaranteed to increase with each version, including proper support for non-production releases. For example, to test that the Python interpreter is at least version 1.5.2, use:", 
        "name": "sys.hexversion", 
        "params": [], 
        "path": "python/library/sys#sys.hexversion", 
        "syntax": "sys.hexversion", 
        "type": "Runtime"
    }, 
    "sys.implementation": {
        "descr": "An object containing information about the implementation of the currently running Python interpreter. The following attributes are required to exist in all Python implementations.", 
        "name": "sys.implementation", 
        "params": [], 
        "path": "python/library/sys#sys.implementation", 
        "syntax": "sys.implementation", 
        "type": "Runtime"
    }, 
    "sys.int_info": {
        "descr": "A struct sequence that holds information about Python\u2019s internal representation of integers. The attributes are read only.", 
        "name": "sys.int_info", 
        "params": [], 
        "path": "python/library/sys#sys.int_info", 
        "syntax": "sys.int_info", 
        "type": "Runtime"
    }, 
    "sys.intern": {
        "descr": "Enter string in the table of \u201cinterned\u201d strings and return the interned string \u2013 which is string itself or a copy. Interning strings is useful to gain a little performance on dictionary lookup \u2013 if the keys in a dictionary are interned, and the lookup key is interned, the key comparisons (after hashing) can be done by a pointer compare instead of a string compare. Normally, the names used in Python programs are automatically interned, and the dictionaries used to hold module, class or instance attributes have interned keys.", 
        "name": "sys.intern", 
        "params": [], 
        "path": "python/library/sys#sys.intern", 
        "syntax": "sys.intern(string)", 
        "type": "Runtime"
    }, 
    "sys.last_traceback": {
        "descr": "These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback. Their intended use is to allow an interactive user to import a debugger module and engage in post-mortem debugging without having to re-execute the command that caused the error. (Typical use is import pdb; pdb.pm() to enter the post-mortem debugger; see pdb module for more information.)", 
        "name": "sys.last_traceback", 
        "params": [], 
        "path": "python/library/sys#sys.last_traceback", 
        "syntax": "sys.last_traceback", 
        "type": "Runtime"
    }, 
    "sys.last_type": {
        "descr": "These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback. Their intended use is to allow an interactive user to import a debugger module and engage in post-mortem debugging without having to re-execute the command that caused the error. (Typical use is import pdb; pdb.pm() to enter the post-mortem debugger; see pdb module for more information.)", 
        "name": "sys.last_type", 
        "params": [], 
        "path": "python/library/sys#sys.last_type", 
        "syntax": "sys.last_type", 
        "type": "Runtime"
    }, 
    "sys.last_value": {
        "descr": "These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback. Their intended use is to allow an interactive user to import a debugger module and engage in post-mortem debugging without having to re-execute the command that caused the error. (Typical use is import pdb; pdb.pm() to enter the post-mortem debugger; see pdb module for more information.)", 
        "name": "sys.last_value", 
        "params": [], 
        "path": "python/library/sys#sys.last_value", 
        "syntax": "sys.last_value", 
        "type": "Runtime"
    }, 
    "sys.maxsize": {
        "descr": "An integer giving the maximum value a variable of type Py_ssize_t can take. It\u2019s usually 2**31 - 1 on a 32-bit platform and 2**63 - 1 on a 64-bit platform.", 
        "name": "sys.maxsize", 
        "params": [], 
        "path": "python/library/sys#sys.maxsize", 
        "syntax": "sys.maxsize", 
        "type": "Runtime"
    }, 
    "sys.maxunicode": {
        "descr": "An integer giving the value of the largest Unicode code point, i.e. 1114111 (0x10FFFF in hexadecimal).", 
        "name": "sys.maxunicode", 
        "params": [], 
        "path": "python/library/sys#sys.maxunicode", 
        "syntax": "sys.maxunicode", 
        "type": "Runtime"
    }, 
    "sys.meta_path": {
        "descr": "A list of finder objects that have their find_module() methods called to see if one of the objects can find the module to be imported. The find_module() method is called at least with the absolute name of the module being imported. If the module to be imported is contained in package then the parent package\u2019s __path__ attribute is passed in as a second argument. The method returns None if the module cannot be found, else returns a loader.", 
        "name": "sys.meta_path", 
        "params": [], 
        "path": "python/library/sys#sys.meta_path", 
        "syntax": "sys.meta_path", 
        "type": "Runtime"
    }, 
    "sys.modules": {
        "descr": "This is a dictionary that maps module names to modules which have already been loaded. This can be manipulated to force reloading of modules and other tricks. However, replacing the dictionary will not necessarily work as expected and deleting essential items from the dictionary may cause Python to fail.", 
        "name": "sys.modules", 
        "params": [], 
        "path": "python/library/sys#sys.modules", 
        "syntax": "sys.modules", 
        "type": "Runtime"
    }, 
    "sys.path": {
        "descr": "As initialized upon program startup, the first item of this list, path[0], is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), path[0] is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted before the entries inserted as a result of PYTHONPATH.", 
        "name": "sys.path", 
        "params": [], 
        "path": "python/library/sys#sys.path", 
        "syntax": "sys.path", 
        "type": "Runtime"
    }, 
    "sys.path_hooks": {
        "descr": "A list of callables that take a path argument to try to create a finder for the path. If a finder can be created, it is to be returned by the callable, else raise ImportError.", 
        "name": "sys.path_hooks", 
        "params": [], 
        "path": "python/library/sys#sys.path_hooks", 
        "syntax": "sys.path_hooks", 
        "type": "Runtime"
    }, 
    "sys.path_importer_cache": {
        "descr": "A dictionary acting as a cache for finder objects. The keys are paths that have been passed to sys.path_hooks and the values are the finders that are found. If a path is a valid file system path but no finder is found on sys.path_hooks then None is stored.", 
        "name": "sys.path_importer_cache", 
        "params": [], 
        "path": "python/library/sys#sys.path_importer_cache", 
        "syntax": "sys.path_importer_cache", 
        "type": "Runtime"
    }, 
    "sys.platform": {
        "descr": "This string contains a platform identifier that can be used to append platform-specific components to sys.path, for instance.", 
        "name": "sys.platform", 
        "params": [], 
        "path": "python/library/sys#sys.platform", 
        "syntax": "sys.platform", 
        "type": "Runtime"
    }, 
    "sys.prefix": {
        "descr": "A string giving the site-specific directory prefix where the platform independent Python files are installed; by default, this is the string '/usr/local'. This can be set at build time with the --prefix argument to the configure script. The main collection of Python library modules is installed in the directory prefix/lib/pythonX.Y while the platform independent header files (all except pyconfig.h) are stored in prefix/include/pythonX.Y, where X.Y is the version number of Python, for example 3.2.", 
        "name": "sys.prefix", 
        "params": [], 
        "path": "python/library/sys#sys.prefix", 
        "syntax": "sys.prefix", 
        "type": "Runtime"
    }, 
    "sys.ps1": {
        "descr": "", 
        "name": "sys.ps1", 
        "params": [], 
        "path": "python/library/sys#sys.ps1", 
        "syntax": "sys.ps1", 
        "type": "Runtime"
    }, 
    "sys.ps2": {
        "descr": "", 
        "name": "sys.ps2", 
        "params": [], 
        "path": "python/library/sys#sys.ps2", 
        "syntax": "sys.ps2", 
        "type": "Runtime"
    }, 
    "sys.setcheckinterval": {
        "descr": "Set the interpreter\u2019s \u201ccheck interval\u201d. This integer value determines how often the interpreter checks for periodic things such as thread switches and signal handlers. The default is 100, meaning the check is performed every 100 Python virtual instructions. Setting it to a larger value may increase performance for programs using threads. Setting it to a value <= 0 checks every virtual instruction, maximizing responsiveness as well as overhead.", 
        "name": "sys.setcheckinterval", 
        "params": [], 
        "path": "python/library/sys#sys.setcheckinterval", 
        "syntax": "sys.setcheckinterval(interval)", 
        "type": "Runtime"
    }, 
    "sys.setdlopenflags": {
        "descr": "Set the flags used by the interpreter for dlopen() calls, such as when the interpreter loads extension modules. Among other things, this will enable a lazy resolving of symbols when importing a module, if called as sys.setdlopenflags(0). To share symbols across extension modules, call as sys.setdlopenflags(os.RTLD_GLOBAL). Symbolic names for the flag modules can be found in the os module (RTLD_xxx constants, e.g. os.RTLD_LAZY).", 
        "name": "sys.setdlopenflags", 
        "params": [], 
        "path": "python/library/sys#sys.setdlopenflags", 
        "syntax": "sys.setdlopenflags(n)", 
        "type": "Runtime"
    }, 
    "sys.setprofile": {
        "descr": "", 
        "name": "sys.setprofile", 
        "params": [], 
        "path": "python/library/sys#sys.setprofile", 
        "syntax": "sys.setprofile(profilefunc)", 
        "type": "Runtime"
    }, 
    "sys.setrecursionlimit": {
        "descr": "Set the maximum depth of the Python interpreter stack to limit. This limit prevents infinite recursion from causing an overflow of the C stack and crashing Python.", 
        "name": "sys.setrecursionlimit", 
        "params": [], 
        "path": "python/library/sys#sys.setrecursionlimit", 
        "syntax": "sys.setrecursionlimit(limit)", 
        "type": "Runtime"
    }, 
    "sys.setswitchinterval": {
        "descr": "Set the interpreter\u2019s thread switch interval (in seconds). This floating-point value determines the ideal duration of the \u201ctimeslices\u201d allocated to concurrently running Python threads. Please note that the actual value can be higher, especially if long-running internal functions or methods are used. Also, which thread becomes scheduled at the end of the interval is the operating system\u2019s decision. The interpreter doesn\u2019t have its own scheduler.", 
        "name": "sys.setswitchinterval", 
        "params": [], 
        "path": "python/library/sys#sys.setswitchinterval", 
        "syntax": "sys.setswitchinterval(interval)", 
        "type": "Runtime"
    }, 
    "sys.settrace": {
        "descr": "Trace functions should have three arguments: frame, event, and arg. frame is the current stack frame. event is a string: 'call', 'line', 'return', 'exception', 'c_call', 'c_return', or 'c_exception'. arg depends on the event type.", 
        "name": "sys.settrace", 
        "params": [], 
        "path": "python/library/sys#sys.settrace", 
        "syntax": "sys.settrace(tracefunc)", 
        "type": "Runtime"
    }, 
    "sys.settscdump": {
        "descr": "Activate dumping of VM measurements using the Pentium timestamp counter, if on_flag is true. Deactivate these dumps if on_flag is off. The function is available only if Python was compiled with --with-tsc. To understand the output of this dump, read Python/ceval.c in the Python sources.", 
        "name": "sys.settscdump", 
        "params": [], 
        "path": "python/library/sys#sys.settscdump", 
        "syntax": "sys.settscdump(on_flag)", 
        "type": "Runtime"
    }, 
    "sys.stderr": {
        "descr": "File objects used by the interpreter for standard input, output and errors:", 
        "name": "sys.stderr", 
        "params": [], 
        "path": "python/library/sys#sys.stderr", 
        "syntax": "sys.stderr", 
        "type": "Runtime"
    }, 
    "sys.stdin": {
        "descr": "File objects used by the interpreter for standard input, output and errors:", 
        "name": "sys.stdin", 
        "params": [], 
        "path": "python/library/sys#sys.stdin", 
        "syntax": "sys.stdin", 
        "type": "Runtime"
    }, 
    "sys.stdout": {
        "descr": "File objects used by the interpreter for standard input, output and errors:", 
        "name": "sys.stdout", 
        "params": [], 
        "path": "python/library/sys#sys.stdout", 
        "syntax": "sys.stdout", 
        "type": "Runtime"
    }, 
    "sys.thread_info": {
        "descr": "A struct sequence holding information about the thread implementation.", 
        "name": "sys.thread_info", 
        "params": [], 
        "path": "python/library/sys#sys.thread_info", 
        "syntax": "sys.thread_info", 
        "type": "Runtime"
    }, 
    "sys.tracebacklimit": {
        "descr": "When this variable is set to an integer value, it determines the maximum number of levels of traceback information printed when an unhandled exception occurs. The default is 1000. When set to 0 or less, all traceback information is suppressed and only the exception type and value are printed.", 
        "name": "sys.tracebacklimit", 
        "params": [], 
        "path": "python/library/sys#sys.tracebacklimit", 
        "syntax": "sys.tracebacklimit", 
        "type": "Runtime"
    }, 
    "sys.version": {
        "descr": "A string containing the version number of the Python interpreter plus additional information on the build number and compiler used. This string is displayed when the interactive interpreter is started. Do not extract version information out of it, rather, use version_info and the functions provided by the platform module.", 
        "name": "sys.version", 
        "params": [], 
        "path": "python/library/sys#sys.version", 
        "syntax": "sys.version", 
        "type": "Runtime"
    }, 
    "sys.version_info": {
        "descr": "A tuple containing the five components of the version number: major, minor, micro, releaselevel, and serial. All values except releaselevel are integers; the release level is 'alpha', 'beta', 'candidate', or 'final'. The version_info value corresponding to the Python version 2.0 is (2, 0, 0, 'final', 0). The components can also be accessed by name, so sys.version_info[0] is equivalent to sys.version_info.major and so on.", 
        "name": "sys.version_info", 
        "params": [], 
        "path": "python/library/sys#sys.version_info", 
        "syntax": "sys.version_info", 
        "type": "Runtime"
    }, 
    "sys.warnoptions": {
        "descr": "This is an implementation detail of the warnings framework; do not modify this value. Refer to the warnings module for more information on the warnings framework.", 
        "name": "sys.warnoptions", 
        "params": [], 
        "path": "python/library/sys#sys.warnoptions", 
        "syntax": "sys.warnoptions", 
        "type": "Runtime"
    }, 
    "sys.winver": {
        "descr": "The version number used to form registry keys on Windows platforms. This is stored as string resource 1000 in the Python DLL. The value is normally the first three characters of version. It is provided in the sys module for informational purposes; modifying this value has no effect on the registry keys used by Python. Availability: Windows.", 
        "name": "sys.winver", 
        "params": [], 
        "path": "python/library/sys#sys.winver", 
        "syntax": "sys.winver", 
        "type": "Runtime"
    }, 
    "sysconfig.get_config_h_filename": {
        "descr": "Return the path of pyconfig.h.", 
        "name": "sysconfig.get_config_h_filename", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_config_h_filename", 
        "syntax": "sysconfig.get_config_h_filename()", 
        "type": "Runtime"
    }, 
    "sysconfig.get_config_var": {
        "descr": "Return the value of a single variable name. Equivalent to get_config_vars().get(name).", 
        "name": "sysconfig.get_config_var", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_config_var", 
        "syntax": "sysconfig.get_config_var(name)", 
        "type": "Runtime"
    }, 
    "sysconfig.get_config_vars": {
        "descr": "With no arguments, return a dictionary of all configuration variables relevant for the current platform.", 
        "name": "sysconfig.get_config_vars", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_config_vars", 
        "syntax": "sysconfig.get_config_vars(*args)", 
        "type": "Runtime"
    }, 
    "sysconfig.get_makefile_filename": {
        "descr": "Return the path of Makefile.", 
        "name": "sysconfig.get_makefile_filename", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_makefile_filename", 
        "syntax": "sysconfig.get_makefile_filename()", 
        "type": "Runtime"
    }, 
    "sysconfig.get_path": {
        "descr": "Return an installation path corresponding to the path name, from the install scheme named scheme.", 
        "name": "sysconfig.get_path", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_path", 
        "syntax": "sysconfig.get_path(name[, scheme[, vars[, expand]]])", 
        "type": "Runtime"
    }, 
    "sysconfig.get_path_names": {
        "descr": "Return a tuple containing all path names currently supported in sysconfig.", 
        "name": "sysconfig.get_path_names", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_path_names", 
        "syntax": "sysconfig.get_path_names()", 
        "type": "Runtime"
    }, 
    "sysconfig.get_paths": {
        "descr": "Return a dictionary containing all installation paths corresponding to an installation scheme. See get_path() for more information.", 
        "name": "sysconfig.get_paths", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_paths", 
        "syntax": "sysconfig.get_paths([scheme[, vars[, expand]]])", 
        "type": "Runtime"
    }, 
    "sysconfig.get_platform": {
        "descr": "Return a string that identifies the current platform.", 
        "name": "sysconfig.get_platform", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_platform", 
        "syntax": "sysconfig.get_platform()", 
        "type": "Runtime"
    }, 
    "sysconfig.get_python_version": {
        "descr": "Return the MAJOR.MINOR Python version number as a string. Similar to sys.version[:3].", 
        "name": "sysconfig.get_python_version", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_python_version", 
        "syntax": "sysconfig.get_python_version()", 
        "type": "Runtime"
    }, 
    "sysconfig.get_scheme_names": {
        "descr": "Return a tuple containing all schemes currently supported in sysconfig.", 
        "name": "sysconfig.get_scheme_names", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.get_scheme_names", 
        "syntax": "sysconfig.get_scheme_names()", 
        "type": "Runtime"
    }, 
    "sysconfig.is_python_build": {
        "descr": "Return True if the current Python installation was built from source.", 
        "name": "sysconfig.is_python_build", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.is_python_build", 
        "syntax": "sysconfig.is_python_build()", 
        "type": "Runtime"
    }, 
    "sysconfig.parse_config_h": {
        "descr": "Parse a config.h-style file.", 
        "name": "sysconfig.parse_config_h", 
        "params": [], 
        "path": "python/library/sysconfig#sysconfig.parse_config_h", 
        "syntax": "sysconfig.parse_config_h(fp[, vars])", 
        "type": "Runtime"
    }, 
    "syslog.closelog": {
        "descr": "Reset the syslog module values and call the system library closelog().", 
        "name": "syslog.closelog", 
        "params": [], 
        "path": "python/library/syslog#syslog.closelog", 
        "syntax": "syslog.closelog()", 
        "type": "Unix"
    }, 
    "syslog.openlog": {
        "descr": "Logging options of subsequent syslog() calls can be set by calling openlog(). syslog() will call openlog() with no arguments if the log is not currently open.", 
        "name": "syslog.openlog", 
        "params": [], 
        "path": "python/library/syslog#syslog.openlog", 
        "syntax": "syslog.openlog([ident[, logoption[, facility]]])", 
        "type": "Unix"
    }, 
    "syslog.setlogmask": {
        "descr": "Set the priority mask to maskpri and return the previous mask value. Calls to syslog() with a priority level not set in maskpri are ignored. The default is to log all priorities. The function LOG_MASK(pri) calculates the mask for the individual priority pri. The function LOG_UPTO(pri) calculates the mask for all priorities up to and including pri.", 
        "name": "syslog.setlogmask", 
        "params": [], 
        "path": "python/library/syslog#syslog.setlogmask", 
        "syntax": "syslog.setlogmask(maskpri)", 
        "type": "Unix"
    }, 
    "syslog.syslog": {
        "descr": "Send the string message to the system logger. A trailing newline is added if necessary. Each message is tagged with a priority composed of a facility and a level. The optional priority argument, which defaults to LOG_INFO, determines the message priority. If the facility is not encoded in priority using logical-or (LOG_INFO | LOG_USER), the value given in the openlog() call is used.", 
        "name": "syslog.syslog", 
        "params": [], 
        "path": "python/library/syslog#syslog.syslog", 
        "syntax": "syslog.syslog(message)", 
        "type": "Unix"
    }, 
    "tarfile.CompressionError": {
        "descr": "Is raised when a compression method is not supported or when the data cannot be decoded properly.", 
        "name": "tarfile.CompressionError", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.CompressionError", 
        "syntax": "exception tarfile.CompressionError", 
        "type": "Data Compression"
    }, 
    "tarfile.ExtractError": {
        "descr": "Is raised for non-fatal errors when using TarFile.extract(), but only if TarFile.errorlevel== 2.", 
        "name": "tarfile.ExtractError", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.ExtractError", 
        "syntax": "exception tarfile.ExtractError", 
        "type": "Data Compression"
    }, 
    "tarfile.HeaderError": {
        "descr": "Is raised by TarInfo.frombuf() if the buffer it gets is invalid.", 
        "name": "tarfile.HeaderError", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.HeaderError", 
        "syntax": "exception tarfile.HeaderError", 
        "type": "Data Compression"
    }, 
    "tarfile.ReadError": {
        "descr": "Is raised when a tar archive is opened, that either cannot be handled by the tarfile module or is somehow invalid.", 
        "name": "tarfile.ReadError", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.ReadError", 
        "syntax": "exception tarfile.ReadError", 
        "type": "Data Compression"
    }, 
    "tarfile.StreamError": {
        "descr": "Is raised for the limitations that are typical for stream-like TarFile objects.", 
        "name": "tarfile.StreamError", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.StreamError", 
        "syntax": "exception tarfile.StreamError", 
        "type": "Data Compression"
    }, 
    "tarfile.TarError": {
        "descr": "Base class for all tarfile exceptions.", 
        "name": "tarfile.TarError", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarError", 
        "syntax": "exception tarfile.TarError", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile": {
        "descr": "Class for reading and writing tar archives. Do not use this class directly, better use tarfile.open() instead. See TarFile Objects.", 
        "name": "tarfile.TarFile", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile", 
        "syntax": "class tarfile.TarFile", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.add": {
        "descr": "Add the file name to the archive. name may be any type of file (directory, fifo, symbolic link, etc.). If given, arcname specifies an alternative name for the file in the archive. Directories are added recursively by default. This can be avoided by setting recursive to False. If exclude is given, it must be a function that takes one filename argument and returns a boolean value. Depending on this value the respective file is either excluded (True) or added (False). If filter is specified it must be a keyword argument. It should be a function that takes a TarInfo object argument and returns the changed TarInfo object. If it instead returns None the TarInfo object will be excluded from the archive. See Examples for an example.", 
        "name": "tarfile.TarFile.add", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.add", 
        "syntax": "TarFile.add(name, arcname=None, recursive=True, exclude=None, *, filter=None)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.addfile": {
        "descr": "Add the TarInfo object tarinfo to the archive. If fileobj is given, tarinfo.size bytes are read from it and added to the archive. You can create TarInfo objects using gettarinfo().", 
        "name": "tarfile.TarFile.addfile", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.addfile", 
        "syntax": "TarFile.addfile(tarinfo, fileobj=None)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.close": {
        "descr": "Close the TarFile. In write mode, two finishing zero blocks are appended to the archive.", 
        "name": "tarfile.TarFile.close", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.close", 
        "syntax": "TarFile.close()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.extract": {
        "descr": "Extract a member from the archive to the current working directory, using its full name. Its file information is extracted as accurately as possible. member may be a filename or a TarInfo object. You can specify a different directory using path. File attributes (owner, mtime, mode) are set unless set_attrs is false.", 
        "name": "tarfile.TarFile.extract", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.extract", 
        "syntax": "TarFile.extract(member, path=\"\", set_attrs=True)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.extractall": {
        "descr": "Extract all members from the archive to the current working directory or directory path. If optional members is given, it must be a subset of the list returned by getmembers(). Directory information like owner, modification time and permissions are set after all members have been extracted. This is done to work around two problems: A directory\u2019s modification time is reset each time a file is created in it. And, if a directory\u2019s permissions do not allow writing, extracting files to it will fail.", 
        "name": "tarfile.TarFile.extractall", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.extractall", 
        "syntax": "TarFile.extractall(path=\".\", members=None)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.extractfile": {
        "descr": "Extract a member from the archive as a file object. member may be a filename or a TarInfo object. If member is a regular file or a link, an io.BufferedReader object is returned. Otherwise, None is returned.", 
        "name": "tarfile.TarFile.extractfile", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.extractfile", 
        "syntax": "TarFile.extractfile(member)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.getmember": {
        "descr": "Return a TarInfo object for member name. If name can not be found in the archive, KeyError is raised.", 
        "name": "tarfile.TarFile.getmember", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.getmember", 
        "syntax": "TarFile.getmember(name)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.getmembers": {
        "descr": "Return the members of the archive as a list of TarInfo objects. The list has the same order as the members in the archive.", 
        "name": "tarfile.TarFile.getmembers", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.getmembers", 
        "syntax": "TarFile.getmembers()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.getnames": {
        "descr": "Return the members as a list of their names. It has the same order as the list returned by getmembers().", 
        "name": "tarfile.TarFile.getnames", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.getnames", 
        "syntax": "TarFile.getnames()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.gettarinfo": {
        "descr": "Create a TarInfo object for either the file name or the file object fileobj (using os.fstat() on its file descriptor). You can modify some of the TarInfo\u2018s attributes before you add it using addfile(). If given, arcname specifies an alternative name for the file in the archive.", 
        "name": "tarfile.TarFile.gettarinfo", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.gettarinfo", 
        "syntax": "TarFile.gettarinfo(name=None, arcname=None, fileobj=None)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.list": {
        "descr": "Print a table of contents to sys.stdout. If verbose is False, only the names of the members are printed. If it is True, output similar to that of ls -l is produced.", 
        "name": "tarfile.TarFile.list", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.list", 
        "syntax": "TarFile.list(verbose=True)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.next": {
        "descr": "Return the next member of the archive as a TarInfo object, when TarFile is opened for reading. Return None if there is no more available.", 
        "name": "tarfile.TarFile.next", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.next", 
        "syntax": "TarFile.next()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.open": {
        "descr": "Alternative constructor. The tarfile.open() function is actually a shortcut to this classmethod.", 
        "name": "tarfile.TarFile.open", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.open", 
        "syntax": "TarFile.open(...)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarFile.pax_headers": {
        "descr": "A dictionary containing key-value pairs of pax global headers.", 
        "name": "tarfile.TarFile.pax_headers", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarFile.pax_headers", 
        "syntax": "TarFile.pax_headers", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo": {
        "descr": "Create a TarInfo object.", 
        "name": "tarfile.TarInfo", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo", 
        "syntax": "class tarfile.TarInfo(name=\"\")", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.frombuf": {
        "descr": "Create and return a TarInfo object from string buffer buf.", 
        "name": "tarfile.TarInfo.frombuf", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.frombuf", 
        "syntax": "TarInfo.frombuf(buf)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.fromtarfile": {
        "descr": "Read the next member from the TarFile object tarfile and return it as a TarInfo object.", 
        "name": "tarfile.TarInfo.fromtarfile", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.fromtarfile", 
        "syntax": "TarInfo.fromtarfile(tarfile)", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.gid": {
        "descr": "Group ID of the user who originally stored this member.", 
        "name": "tarfile.TarInfo.gid", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.gid", 
        "syntax": "TarInfo.gid", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.gname": {
        "descr": "Group name.", 
        "name": "tarfile.TarInfo.gname", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.gname", 
        "syntax": "TarInfo.gname", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.isblk": {
        "descr": "Return True if it is a block device.", 
        "name": "tarfile.TarInfo.isblk", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.isblk", 
        "syntax": "TarInfo.isblk()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.ischr": {
        "descr": "Return True if it is a character device.", 
        "name": "tarfile.TarInfo.ischr", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.ischr", 
        "syntax": "TarInfo.ischr()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.isdev": {
        "descr": "Return True if it is one of character device, block device or FIFO.", 
        "name": "tarfile.TarInfo.isdev", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.isdev", 
        "syntax": "TarInfo.isdev()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.isdir": {
        "descr": "Return True if it is a directory.", 
        "name": "tarfile.TarInfo.isdir", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.isdir", 
        "syntax": "TarInfo.isdir()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.isfifo": {
        "descr": "Return True if it is a FIFO.", 
        "name": "tarfile.TarInfo.isfifo", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.isfifo", 
        "syntax": "TarInfo.isfifo()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.isfile": {
        "descr": "Return True if the Tarinfo object is a regular file.", 
        "name": "tarfile.TarInfo.isfile", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.isfile", 
        "syntax": "TarInfo.isfile()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.islnk": {
        "descr": "Return True if it is a hard link.", 
        "name": "tarfile.TarInfo.islnk", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.islnk", 
        "syntax": "TarInfo.islnk()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.isreg": {
        "descr": "Same as isfile().", 
        "name": "tarfile.TarInfo.isreg", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.isreg", 
        "syntax": "TarInfo.isreg()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.issym": {
        "descr": "Return True if it is a symbolic link.", 
        "name": "tarfile.TarInfo.issym", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.issym", 
        "syntax": "TarInfo.issym()", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.linkname": {
        "descr": "Name of the target file name, which is only present in TarInfo objects of type LNKTYPE and SYMTYPE.", 
        "name": "tarfile.TarInfo.linkname", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.linkname", 
        "syntax": "TarInfo.linkname", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.mode": {
        "descr": "Permission bits.", 
        "name": "tarfile.TarInfo.mode", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.mode", 
        "syntax": "TarInfo.mode", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.mtime": {
        "descr": "Time of last modification.", 
        "name": "tarfile.TarInfo.mtime", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.mtime", 
        "syntax": "TarInfo.mtime", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.name": {
        "descr": "Name of the archive member.", 
        "name": "tarfile.TarInfo.name", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.name", 
        "syntax": "TarInfo.name", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.pax_headers": {
        "descr": "A dictionary containing key-value pairs of an associated pax extended header.", 
        "name": "tarfile.TarInfo.pax_headers", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.pax_headers", 
        "syntax": "TarInfo.pax_headers", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.size": {
        "descr": "Size in bytes.", 
        "name": "tarfile.TarInfo.size", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.size", 
        "syntax": "TarInfo.size", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.tobuf": {
        "descr": "Create a string buffer from a TarInfo object. For information on the arguments see the constructor of the TarFile class.", 
        "name": "tarfile.TarInfo.tobuf", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.tobuf", 
        "syntax": "TarInfo.tobuf(format=DEFAULT_FORMAT, encoding=ENCODING, errors='surrogateescape')", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.type": {
        "descr": "File type. type is usually one of these constants: REGTYPE, AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, CONTTYPE, CHRTYPE, BLKTYPE, GNUTYPE_SPARSE. To determine the type of a TarInfo object more conveniently, use the is_*() methods below.", 
        "name": "tarfile.TarInfo.type", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.type", 
        "syntax": "TarInfo.type", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.uid": {
        "descr": "User ID of the user who originally stored this member.", 
        "name": "tarfile.TarInfo.uid", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.uid", 
        "syntax": "TarInfo.uid", 
        "type": "Data Compression"
    }, 
    "tarfile.TarInfo.uname": {
        "descr": "User name.", 
        "name": "tarfile.TarInfo.uname", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.TarInfo.uname", 
        "syntax": "TarInfo.uname", 
        "type": "Data Compression"
    }, 
    "tarfile.is_tarfile": {
        "descr": "Return True if name is a tar archive file, that the tarfile module can read.", 
        "name": "tarfile.is_tarfile", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.is_tarfile", 
        "syntax": "tarfile.is_tarfile(name)", 
        "type": "Data Compression"
    }, 
    "tarfile.open": {
        "descr": "Return a TarFile object for the pathname name. For detailed information on TarFile objects and the keyword arguments that are allowed, see TarFile Objects.", 
        "name": "tarfile.open", 
        "params": [], 
        "path": "python/library/tarfile#tarfile.open", 
        "syntax": "tarfile.open(name=None, mode='r', fileobj=None, bufsize=10240, **kwargs)", 
        "type": "Data Compression"
    }, 
    "telnetlib.Telnet": {
        "descr": "Telnet represents a connection to a Telnet server. The instance is initially not connected by default; the open() method must be used to establish a connection. Alternatively, the host name and optional port number can be passed to the constructor, to, in which case the connection to the server will be established before the constructor returns. The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used).", 
        "name": "telnetlib.Telnet", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet", 
        "syntax": "class telnetlib.Telnet(host=None, port=0[, timeout])", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.close": {
        "descr": "Close the connection.", 
        "name": "telnetlib.Telnet.close", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.close", 
        "syntax": "Telnet.close()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.expect": {
        "descr": "Read until one from a list of a regular expressions matches.", 
        "name": "telnetlib.Telnet.expect", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.expect", 
        "syntax": "Telnet.expect(list, timeout=None)", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.fileno": {
        "descr": "Return the file descriptor of the socket object used internally.", 
        "name": "telnetlib.Telnet.fileno", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.fileno", 
        "syntax": "Telnet.fileno()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.get_socket": {
        "descr": "Return the socket object used internally.", 
        "name": "telnetlib.Telnet.get_socket", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.get_socket", 
        "syntax": "Telnet.get_socket()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.interact": {
        "descr": "Interaction function, emulates a very dumb Telnet client.", 
        "name": "telnetlib.Telnet.interact", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.interact", 
        "syntax": "Telnet.interact()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.msg": {
        "descr": "Print a debug message when the debug level is > 0. If extra arguments are present, they are substituted in the message using the standard string formatting operator.", 
        "name": "telnetlib.Telnet.msg", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.msg", 
        "syntax": "Telnet.msg(msg, *args)", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.mt_interact": {
        "descr": "Multithreaded version of interact().", 
        "name": "telnetlib.Telnet.mt_interact", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.mt_interact", 
        "syntax": "Telnet.mt_interact()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.open": {
        "descr": "Connect to a host. The optional second argument is the port number, which defaults to the standard Telnet port (23). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used).", 
        "name": "telnetlib.Telnet.open", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.open", 
        "syntax": "Telnet.open(host, port=0[, timeout])", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_all": {
        "descr": "Read all data until EOF as bytes; block until connection closed.", 
        "name": "telnetlib.Telnet.read_all", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_all", 
        "syntax": "Telnet.read_all()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_eager": {
        "descr": "Read readily available data.", 
        "name": "telnetlib.Telnet.read_eager", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_eager", 
        "syntax": "Telnet.read_eager()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_lazy": {
        "descr": "Process and return data already in the queues (lazy).", 
        "name": "telnetlib.Telnet.read_lazy", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_lazy", 
        "syntax": "Telnet.read_lazy()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_sb_data": {
        "descr": "Return the data collected between a SB/SE pair (suboption begin/end). The callback should access these data when it was invoked with a SE command. This method never blocks.", 
        "name": "telnetlib.Telnet.read_sb_data", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_sb_data", 
        "syntax": "Telnet.read_sb_data()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_some": {
        "descr": "Read at least one byte of cooked data unless EOF is hit. Return b'' if EOF is hit. Block if no data is immediately available.", 
        "name": "telnetlib.Telnet.read_some", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_some", 
        "syntax": "Telnet.read_some()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_until": {
        "descr": "Read until a given byte string, expected, is encountered or until timeout seconds have passed.", 
        "name": "telnetlib.Telnet.read_until", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_until", 
        "syntax": "Telnet.read_until(expected, timeout=None)", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_very_eager": {
        "descr": "Read everything that can be without blocking in I/O (eager).", 
        "name": "telnetlib.Telnet.read_very_eager", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_very_eager", 
        "syntax": "Telnet.read_very_eager()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.read_very_lazy": {
        "descr": "Return any data available in the cooked queue (very lazy).", 
        "name": "telnetlib.Telnet.read_very_lazy", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.read_very_lazy", 
        "syntax": "Telnet.read_very_lazy()", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.set_debuglevel": {
        "descr": "Set the debug level. The higher the value of debuglevel, the more debug output you get (on sys.stdout).", 
        "name": "telnetlib.Telnet.set_debuglevel", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.set_debuglevel", 
        "syntax": "Telnet.set_debuglevel(debuglevel)", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.set_option_negotiation_callback": {
        "descr": "Each time a telnet option is read on the input flow, this callback (if set) is called with the following parameters: callback(telnet socket, command (DO/DONT/WILL/WONT), option). No other action is done afterwards by telnetlib.", 
        "name": "telnetlib.Telnet.set_option_negotiation_callback", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.set_option_negotiation_callback", 
        "syntax": "Telnet.set_option_negotiation_callback(callback)", 
        "type": "Internet"
    }, 
    "telnetlib.Telnet.write": {
        "descr": "Write a byte string to the socket, doubling any IAC characters. This can block if the connection is blocked. May raise OSError if the connection is closed.", 
        "name": "telnetlib.Telnet.write", 
        "params": [], 
        "path": "python/library/telnetlib#telnetlib.Telnet.write", 
        "syntax": "Telnet.write(buffer)", 
        "type": "Internet"
    }, 
    "tempfile.NamedTemporaryFile": {
        "descr": "This function operates exactly as TemporaryFile() does, except that the file is guaranteed to have a visible name in the file system (on Unix, the directory entry is not unlinked). That name can be retrieved from the name attribute of the file object. Whether the name can be used to open the file a second time, while the named temporary file is still open, varies across platforms (it can be so used on Unix; it cannot on Windows NT or later). If delete is true (the default), the file is deleted as soon as it is closed. The returned object is always a file-like object whose file attribute is the underlying true file object. This file-like object can be used in a with statement, just like a normal file.", 
        "name": "tempfile.NamedTemporaryFile", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.NamedTemporaryFile", 
        "syntax": "tempfile.NamedTemporaryFile(mode='w+b', buffering=None, encoding=None, newline=None, suffix='', prefix='tmp', dir=None, delete=True)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.SpooledTemporaryFile": {
        "descr": "This function operates exactly as TemporaryFile() does, except that data is spooled in memory until the file size exceeds max_size, or until the file\u2019s fileno() method is called, at which point the contents are written to disk and operation proceeds as with TemporaryFile().", 
        "name": "tempfile.SpooledTemporaryFile", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.SpooledTemporaryFile", 
        "syntax": "tempfile.SpooledTemporaryFile(max_size=0, mode='w+b', buffering=None, encoding=None, newline=None, suffix='', prefix='tmp', dir=None)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.TemporaryDirectory": {
        "descr": "This function creates a temporary directory using mkdtemp() (the supplied arguments are passed directly to the underlying function). The resulting object can be used as a context manager (see With Statement Context Managers). On completion of the context or destruction of the temporary directory object the newly created temporary directory and all its contents are removed from the filesystem.", 
        "name": "tempfile.TemporaryDirectory", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.TemporaryDirectory", 
        "syntax": "tempfile.TemporaryDirectory(suffix='', prefix='tmp', dir=None)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.TemporaryFile": {
        "descr": "Return a file-like object that can be used as a temporary storage area. The file is created using mkstemp(). It will be destroyed as soon as it is closed (including an implicit close when the object is garbage collected). Under Unix, the directory entry for the file is removed immediately after the file is created. Other platforms do not support this; your code should not rely on a temporary file created using this function having or not having a visible name in the file system.", 
        "name": "tempfile.TemporaryFile", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.TemporaryFile", 
        "syntax": "tempfile.TemporaryFile(mode='w+b', buffering=None, encoding=None, newline=None, suffix='', prefix='tmp', dir=None)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.gettempdir": {
        "descr": "Return the directory currently selected to create temporary files in. If tempdir is not None, this simply returns its contents; otherwise, the search described above is performed, and the result returned.", 
        "name": "tempfile.gettempdir", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.gettempdir", 
        "syntax": "tempfile.gettempdir()", 
        "type": "File & Directory Access"
    }, 
    "tempfile.gettempprefix": {
        "descr": "Return the filename prefix used to create temporary files. This does not contain the directory component.", 
        "name": "tempfile.gettempprefix", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.gettempprefix", 
        "syntax": "tempfile.gettempprefix()", 
        "type": "File & Directory Access"
    }, 
    "tempfile.mkdtemp": {
        "descr": "Creates a temporary directory in the most secure manner possible. There are no race conditions in the directory\u2019s creation. The directory is readable, writable, and searchable only by the creating user ID.", 
        "name": "tempfile.mkdtemp", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.mkdtemp", 
        "syntax": "tempfile.mkdtemp(suffix='', prefix='tmp', dir=None)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.mkstemp": {
        "descr": "Creates a temporary file in the most secure manner possible. There are no race conditions in the file\u2019s creation, assuming that the platform properly implements the os.O_EXCL flag for os.open(). The file is readable and writable only by the creating user ID. If the platform uses permission bits to indicate whether a file is executable, the file is executable by no one. The file descriptor is not inherited by child processes.", 
        "name": "tempfile.mkstemp", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.mkstemp", 
        "syntax": "tempfile.mkstemp(suffix='', prefix='tmp', dir=None, text=False)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.mktemp": {
        "descr": "Deprecated since version 2.3: Use mkstemp() instead.", 
        "name": "tempfile.mktemp", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.mktemp", 
        "syntax": "tempfile.mktemp(suffix='', prefix='tmp', dir=None)", 
        "type": "File & Directory Access"
    }, 
    "tempfile.tempdir": {
        "descr": "When set to a value other than None, this variable defines the default value for the dir argument to all the functions defined in this module.", 
        "name": "tempfile.tempdir", 
        "params": [], 
        "path": "python/library/tempfile#tempfile.tempdir", 
        "syntax": "tempfile.tempdir", 
        "type": "File & Directory Access"
    }, 
    "termios.tcdrain": {
        "descr": "Wait until all output written to file descriptor fd has been transmitted.", 
        "name": "termios.tcdrain", 
        "params": [], 
        "path": "python/library/termios#termios.tcdrain", 
        "syntax": "termios.tcdrain(fd)", 
        "type": "Unix"
    }, 
    "termios.tcflow": {
        "descr": "Suspend or resume input or output on file descriptor fd. The action argument can be TCOOFF to suspend output, TCOON to restart output, TCIOFF to suspend input, or TCION to restart input.", 
        "name": "termios.tcflow", 
        "params": [], 
        "path": "python/library/termios#termios.tcflow", 
        "syntax": "termios.tcflow(fd, action)", 
        "type": "Unix"
    }, 
    "termios.tcflush": {
        "descr": "Discard queued data on file descriptor fd. The queue selector specifies which queue: TCIFLUSH for the input queue, TCOFLUSH for the output queue, or TCIOFLUSH for both queues.", 
        "name": "termios.tcflush", 
        "params": [], 
        "path": "python/library/termios#termios.tcflush", 
        "syntax": "termios.tcflush(fd, queue)", 
        "type": "Unix"
    }, 
    "termios.tcgetattr": {
        "descr": "Return a list containing the tty attributes for file descriptor fd, as follows: [iflag, oflag, cflag, lflag, ispeed, ospeed, cc] where cc is a list of the tty special characters (each a string of length 1, except the items with indices VMIN and VTIME, which are integers when these fields are defined). The interpretation of the flags and the speeds as well as the indexing in the cc array must be done using the symbolic constants defined in the termios module.", 
        "name": "termios.tcgetattr", 
        "params": [], 
        "path": "python/library/termios#termios.tcgetattr", 
        "syntax": "termios.tcgetattr(fd)", 
        "type": "Unix"
    }, 
    "termios.tcsendbreak": {
        "descr": "Send a break on file descriptor fd. A zero duration sends a break for 0.25 \u20130.5 seconds; a nonzero duration has a system dependent meaning.", 
        "name": "termios.tcsendbreak", 
        "params": [], 
        "path": "python/library/termios#termios.tcsendbreak", 
        "syntax": "termios.tcsendbreak(fd, duration)", 
        "type": "Unix"
    }, 
    "termios.tcsetattr": {
        "descr": "Set the tty attributes for file descriptor fd from the attributes, which is a list like the one returned by tcgetattr(). The when argument determines when the attributes are changed: TCSANOW to change immediately, TCSADRAIN to change after transmitting all queued output, or TCSAFLUSH to change after transmitting all queued output and discarding all queued input.", 
        "name": "termios.tcsetattr", 
        "params": [], 
        "path": "python/library/termios#termios.tcsetattr", 
        "syntax": "termios.tcsetattr(fd, when, attributes)", 
        "type": "Unix"
    }, 
    "textwrap.TextWrapper": {
        "descr": "The TextWrapper constructor accepts a number of optional keyword arguments. Each keyword argument corresponds to an instance attribute, so for example", 
        "name": "textwrap.TextWrapper", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper", 
        "syntax": "class textwrap.TextWrapper(**kwargs)", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.break_long_words": {
        "descr": "(default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width. (Long words will be put on a line by themselves, in order to minimize the amount by which width is exceeded.)", 
        "name": "textwrap.TextWrapper.break_long_words", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.break_long_words", 
        "syntax": "break_long_words", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.break_on_hyphens": {
        "descr": "(default: True) If true, wrapping will occur preferably on whitespaces and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words. Default behaviour in previous versions was to always allow breaking hyphenated words.", 
        "name": "textwrap.TextWrapper.break_on_hyphens", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.break_on_hyphens", 
        "syntax": "break_on_hyphens", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.drop_whitespace": {
        "descr": "(default: True) If true, whitespace at the beginning and ending of every line (after wrapping but before indenting) is dropped. Whitespace at the beginning of the paragraph, however, is not dropped if non-whitespace follows it. If whitespace being dropped takes up an entire line, the whole line is dropped.", 
        "name": "textwrap.TextWrapper.drop_whitespace", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.drop_whitespace", 
        "syntax": "drop_whitespace", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.expand_tabs": {
        "descr": "(default: True) If true, then all tab characters in text will be expanded to spaces using the expandtabs() method of text.", 
        "name": "textwrap.TextWrapper.expand_tabs", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.expand_tabs", 
        "syntax": "expand_tabs", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.fill": {
        "descr": "Wraps the single paragraph in text, and returns a single string containing the wrapped paragraph.", 
        "name": "textwrap.TextWrapper.fill", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.fill", 
        "syntax": "fill(text)", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.fix_sentence_endings": {
        "descr": "(default: False) If true, TextWrapper attempts to detect sentence endings and ensure that sentences are always separated by exactly two spaces. This is generally desired for text in a monospaced font. However, the sentence detection algorithm is imperfect: it assumes that a sentence ending consists of a lowercase letter followed by one of '.', '!', or '?', possibly followed by one of '\"' or \"'\", followed by a space. One problem with this is algorithm is that it is unable to detect the difference between \u201cDr.\u201d in", 
        "name": "textwrap.TextWrapper.fix_sentence_endings", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.fix_sentence_endings", 
        "syntax": "fix_sentence_endings", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.initial_indent": {
        "descr": "(default: '') String that will be prepended to the first line of wrapped output. Counts towards the length of the first line. The empty string is not indented.", 
        "name": "textwrap.TextWrapper.initial_indent", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.initial_indent", 
        "syntax": "initial_indent", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.replace_whitespace": {
        "descr": "(default: True) If true, after tab expansion but before wrapping, the wrap() method will replace each whitespace character with a single space. The whitespace characters replaced are as follows: tab, newline, vertical tab, formfeed, and carriage return ('\\t\\n\\v\\f\\r').", 
        "name": "textwrap.TextWrapper.replace_whitespace", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.replace_whitespace", 
        "syntax": "replace_whitespace", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.subsequent_indent": {
        "descr": "(default: '') String that will be prepended to all lines of wrapped output except the first. Counts towards the length of each line except the first.", 
        "name": "textwrap.TextWrapper.subsequent_indent", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.subsequent_indent", 
        "syntax": "subsequent_indent", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.tabsize": {
        "descr": "(default: 8) If expand_tabs is true, then all tab characters in text will be expanded to zero or more spaces, depending on the current column and the given tab size.", 
        "name": "textwrap.TextWrapper.tabsize", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.tabsize", 
        "syntax": "tabsize", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.width": {
        "descr": "(default: 70) The maximum length of wrapped lines. As long as there are no individual words in the input text longer than width, TextWrapper guarantees that no output line will be longer than width characters.", 
        "name": "textwrap.TextWrapper.width", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.width", 
        "syntax": "width", 
        "type": "Text Processing"
    }, 
    "textwrap.TextWrapper.wrap": {
        "descr": "Wraps the single paragraph in text (a string) so every line is at most width characters long. All wrapping options are taken from instance attributes of the TextWrapper instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty.", 
        "name": "textwrap.TextWrapper.wrap", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.TextWrapper.wrap", 
        "syntax": "wrap(text)", 
        "type": "Text Processing"
    }, 
    "textwrap.dedent": {
        "descr": "Remove any common leading whitespace from every line in text.", 
        "name": "textwrap.dedent", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.dedent", 
        "syntax": "textwrap.dedent(text)", 
        "type": "Text Processing"
    }, 
    "textwrap.fill": {
        "descr": "Wraps the single paragraph in text, and returns a single string containing the wrapped paragraph. fill() is shorthand for", 
        "name": "textwrap.fill", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.fill", 
        "syntax": "textwrap.fill(text, width=70, **kwargs)", 
        "type": "Text Processing"
    }, 
    "textwrap.indent": {
        "descr": "Add prefix to the beginning of selected lines in text.", 
        "name": "textwrap.indent", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.indent", 
        "syntax": "textwrap.indent(text, prefix, predicate=None)", 
        "type": "Text Processing"
    }, 
    "textwrap.wrap": {
        "descr": "Wraps the single paragraph in text (a string) so every line is at most width characters long. Returns a list of output lines, without final newlines.", 
        "name": "textwrap.wrap", 
        "params": [], 
        "path": "python/library/textwrap#textwrap.wrap", 
        "syntax": "textwrap.wrap(text, width=70, **kwargs)", 
        "type": "Text Processing"
    }, 
    "threading.Barrier": {
        "descr": "Create a barrier object for parties number of threads. An action, when provided, is a callable to be called by one of the threads when they are released. timeout is the default timeout value if none is specified for the wait() method.", 
        "name": "threading.Barrier", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier", 
        "syntax": "class threading.Barrier(parties, action=None, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Barrier.abort": {
        "descr": "Put the barrier into a broken state. This causes any active or future calls to wait() to fail with the BrokenBarrierError. Use this for example if one of the needs to abort, to avoid deadlocking the application.", 
        "name": "threading.Barrier.abort", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier.abort", 
        "syntax": "abort()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Barrier.broken": {
        "descr": "A boolean that is True if the barrier is in the broken state.", 
        "name": "threading.Barrier.broken", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier.broken", 
        "syntax": "broken", 
        "type": "Concurrent Execution"
    }, 
    "threading.Barrier.n_waiting": {
        "descr": "The number of threads currently waiting in the barrier.", 
        "name": "threading.Barrier.n_waiting", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier.n_waiting", 
        "syntax": "n_waiting", 
        "type": "Concurrent Execution"
    }, 
    "threading.Barrier.parties": {
        "descr": "The number of threads required to pass the barrier.", 
        "name": "threading.Barrier.parties", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier.parties", 
        "syntax": "parties", 
        "type": "Concurrent Execution"
    }, 
    "threading.Barrier.reset": {
        "descr": "Return the barrier to the default, empty state. Any threads waiting on it will receive the BrokenBarrierError exception.", 
        "name": "threading.Barrier.reset", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier.reset", 
        "syntax": "reset()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Barrier.wait": {
        "descr": "Pass the barrier. When all the threads party to the barrier have called this function, they are all released simultaneously. If a timeout is provided, it is used in preference to any that was supplied to the class constructor.", 
        "name": "threading.Barrier.wait", 
        "params": [], 
        "path": "python/library/threading#threading.Barrier.wait", 
        "syntax": "wait(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.BoundedSemaphore": {
        "descr": "Class implementing bounded semaphore objects. A bounded semaphore checks to make sure its current value doesn\u2019t exceed its initial value. If it does, ValueError is raised. In most situations semaphores are used to guard resources with limited capacity. If the semaphore is released too many times it\u2019s a sign of a bug. If not given, value defaults to 1.", 
        "name": "threading.BoundedSemaphore", 
        "params": [], 
        "path": "python/library/threading#threading.BoundedSemaphore", 
        "syntax": "class threading.BoundedSemaphore(value=1)", 
        "type": "Concurrent Execution"
    }, 
    "threading.BrokenBarrierError": {
        "descr": "This exception, a subclass of RuntimeError, is raised when the Barrier object is reset or broken.", 
        "name": "threading.BrokenBarrierError", 
        "params": [], 
        "path": "python/library/threading#threading.BrokenBarrierError", 
        "syntax": "exception threading.BrokenBarrierError", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition": {
        "descr": "This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread.", 
        "name": "threading.Condition", 
        "params": [], 
        "path": "python/library/threading#threading.Condition", 
        "syntax": "class threading.Condition(lock=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition.acquire": {
        "descr": "Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns.", 
        "name": "threading.Condition.acquire", 
        "params": [], 
        "path": "python/library/threading#threading.Condition.acquire", 
        "syntax": "acquire(*args)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition.notify": {
        "descr": "By default, wake up one thread waiting on this condition, if any. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised.", 
        "name": "threading.Condition.notify", 
        "params": [], 
        "path": "python/library/threading#threading.Condition.notify", 
        "syntax": "notify(n=1)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition.notify_all": {
        "descr": "Wake up all threads waiting on this condition. This method acts like notify(), but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised.", 
        "name": "threading.Condition.notify_all", 
        "params": [], 
        "path": "python/library/threading#threading.Condition.notify_all", 
        "syntax": "notify_all()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition.release": {
        "descr": "Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value.", 
        "name": "threading.Condition.release", 
        "params": [], 
        "path": "python/library/threading#threading.Condition.release", 
        "syntax": "release()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition.wait": {
        "descr": "Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised.", 
        "name": "threading.Condition.wait", 
        "params": [], 
        "path": "python/library/threading#threading.Condition.wait", 
        "syntax": "wait(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Condition.wait_for": {
        "descr": "Wait until a condition evaluates to True. predicate should be a callable which result will be interpreted as a boolean value. A timeout may be provided giving the maximum time to wait.", 
        "name": "threading.Condition.wait_for", 
        "params": [], 
        "path": "python/library/threading#threading.Condition.wait_for", 
        "syntax": "wait_for(predicate, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Event": {
        "descr": "Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false.", 
        "name": "threading.Event", 
        "params": [], 
        "path": "python/library/threading#threading.Event", 
        "syntax": "class threading.Event", 
        "type": "Concurrent Execution"
    }, 
    "threading.Event.clear": {
        "descr": "Reset the internal flag to false. Subsequently, threads calling wait() will block until set() is called to set the internal flag to true again.", 
        "name": "threading.Event.clear", 
        "params": [], 
        "path": "python/library/threading#threading.Event.clear", 
        "syntax": "clear()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Event.is_set": {
        "descr": "Return true if and only if the internal flag is true.", 
        "name": "threading.Event.is_set", 
        "params": [], 
        "path": "python/library/threading#threading.Event.is_set", 
        "syntax": "is_set()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Event.set": {
        "descr": "Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call wait() once the flag is true will not block at all.", 
        "name": "threading.Event.set", 
        "params": [], 
        "path": "python/library/threading#threading.Event.set", 
        "syntax": "set()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Event.wait": {
        "descr": "Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs.", 
        "name": "threading.Event.wait", 
        "params": [], 
        "path": "python/library/threading#threading.Event.wait", 
        "syntax": "wait(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Lock": {
        "descr": "The class implementing primitive lock objects. Once a thread has acquired a lock, subsequent attempts to acquire it block, until it is released; any thread may release it.", 
        "name": "threading.Lock", 
        "params": [], 
        "path": "python/library/threading#threading.Lock", 
        "syntax": "class threading.Lock", 
        "type": "Concurrent Execution"
    }, 
    "threading.Lock.acquire": {
        "descr": "Acquire a lock, blocking or non-blocking.", 
        "name": "threading.Lock.acquire", 
        "params": [], 
        "path": "python/library/threading#threading.Lock.acquire", 
        "syntax": "acquire(blocking=True, timeout=-1)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Lock.release": {
        "descr": "Release a lock. This can be called from any thread, not only the thread which has acquired the lock.", 
        "name": "threading.Lock.release", 
        "params": [], 
        "path": "python/library/threading#threading.Lock.release", 
        "syntax": "release()", 
        "type": "Concurrent Execution"
    }, 
    "threading.RLock": {
        "descr": "This class implements reentrant lock objects. A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.", 
        "name": "threading.RLock", 
        "params": [], 
        "path": "python/library/threading#threading.RLock", 
        "syntax": "class threading.RLock", 
        "type": "Concurrent Execution"
    }, 
    "threading.RLock.acquire": {
        "descr": "Acquire a lock, blocking or non-blocking.", 
        "name": "threading.RLock.acquire", 
        "params": [], 
        "path": "python/library/threading#threading.RLock.acquire", 
        "syntax": "acquire(blocking=True, timeout=-1)", 
        "type": "Concurrent Execution"
    }, 
    "threading.RLock.release": {
        "descr": "Release a lock, decrementing the recursion level. If after the decrement it is zero, reset the lock to unlocked (not owned by any thread), and if any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed. If after the decrement the recursion level is still nonzero, the lock remains locked and owned by the calling thread.", 
        "name": "threading.RLock.release", 
        "params": [], 
        "path": "python/library/threading#threading.RLock.release", 
        "syntax": "release()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Semaphore": {
        "descr": "This class implements semaphore objects. A semaphore manages a counter representing the number of release() calls minus the number of acquire() calls, plus an initial value. The acquire() method blocks if necessary until it can return without making the counter negative. If not given, value defaults to 1.", 
        "name": "threading.Semaphore", 
        "params": [], 
        "path": "python/library/threading#threading.Semaphore", 
        "syntax": "class threading.Semaphore(value=1)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Semaphore.acquire": {
        "descr": "Acquire a semaphore.", 
        "name": "threading.Semaphore.acquire", 
        "params": [], 
        "path": "python/library/threading#threading.Semaphore.acquire", 
        "syntax": "acquire(blocking=True, timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Semaphore.release": {
        "descr": "Release a semaphore, incrementing the internal counter by one. When it was zero on entry and another thread is waiting for it to become larger than zero again, wake up that thread.", 
        "name": "threading.Semaphore.release", 
        "params": [], 
        "path": "python/library/threading#threading.Semaphore.release", 
        "syntax": "release()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread": {
        "descr": "This constructor should always be called with keyword arguments. Arguments are:", 
        "name": "threading.Thread", 
        "params": [], 
        "path": "python/library/threading#threading.Thread", 
        "syntax": "class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.daemon": {
        "descr": "A boolean value indicating whether this thread is a daemon thread (True) or not (False). This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.", 
        "name": "threading.Thread.daemon", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.daemon", 
        "syntax": "daemon", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.getName": {
        "descr": "Old getter/setter API for name; use it directly as a property instead.", 
        "name": "threading.Thread.getName", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.getName", 
        "syntax": "getName()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.ident": {
        "descr": "The \u2018thread identifier\u2019 of this thread or None if the thread has not been started. This is a nonzero integer. See the _thread.get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.", 
        "name": "threading.Thread.ident", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.ident", 
        "syntax": "ident", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.isDaemon": {
        "descr": "Old getter/setter API for daemon; use it directly as a property instead.", 
        "name": "threading.Thread.isDaemon", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.isDaemon", 
        "syntax": "isDaemon()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.is_alive": {
        "descr": "Return whether the thread is alive.", 
        "name": "threading.Thread.is_alive", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.is_alive", 
        "syntax": "is_alive()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.join": {
        "descr": "Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates \u2013 either normally or through an unhandled exception \u2013, or until the optional timeout occurs.", 
        "name": "threading.Thread.join", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.join", 
        "syntax": "join(timeout=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.name": {
        "descr": "A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.", 
        "name": "threading.Thread.name", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.name", 
        "syntax": "name", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.run": {
        "descr": "Method representing the thread\u2019s activity.", 
        "name": "threading.Thread.run", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.run", 
        "syntax": "run()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.setDaemon": {
        "descr": "Old getter/setter API for daemon; use it directly as a property instead.", 
        "name": "threading.Thread.setDaemon", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.setDaemon", 
        "syntax": "setDaemon()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.setName": {
        "descr": "Old getter/setter API for name; use it directly as a property instead.", 
        "name": "threading.Thread.setName", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.setName", 
        "syntax": "setName()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Thread.start": {
        "descr": "Start the thread\u2019s activity.", 
        "name": "threading.Thread.start", 
        "params": [], 
        "path": "python/library/threading#threading.Thread.start", 
        "syntax": "start()", 
        "type": "Concurrent Execution"
    }, 
    "threading.Timer": {
        "descr": "Create a timer that will run function with arguments args and keyword arguments kwargs, after interval seconds have passed. If args is None (the default) then an empty list will be used. If kwargs is None (the default) then an empty dict will be used.", 
        "name": "threading.Timer", 
        "params": [], 
        "path": "python/library/threading#threading.Timer", 
        "syntax": "class threading.Timer(interval, function, args=None, kwargs=None)", 
        "type": "Concurrent Execution"
    }, 
    "threading.Timer.cancel": {
        "descr": "Stop the timer, and cancel the execution of the timer\u2019s action. This will only work if the timer is still in its waiting stage.", 
        "name": "threading.Timer.cancel", 
        "params": [], 
        "path": "python/library/threading#threading.Timer.cancel", 
        "syntax": "cancel()", 
        "type": "Concurrent Execution"
    }, 
    "threading.active_count": {
        "descr": "Return the number of Thread objects currently alive. The returned count is equal to the length of the list returned by enumerate().", 
        "name": "threading.active_count", 
        "params": [], 
        "path": "python/library/threading#threading.active_count", 
        "syntax": "threading.active_count()", 
        "type": "Concurrent Execution"
    }, 
    "threading.current_thread": {
        "descr": "Return the current Thread object, corresponding to the caller\u2019s thread of control. If the caller\u2019s thread of control was not created through the threading module, a dummy thread object with limited functionality is returned.", 
        "name": "threading.current_thread", 
        "params": [], 
        "path": "python/library/threading#threading.current_thread", 
        "syntax": "threading.current_thread()", 
        "type": "Concurrent Execution"
    }, 
    "threading.enumerate": {
        "descr": "Return a list of all Thread objects currently alive. The list includes daemonic threads, dummy thread objects created by current_thread(), and the main thread. It excludes terminated threads and threads that have not yet been started.", 
        "name": "threading.enumerate", 
        "params": [], 
        "path": "python/library/threading#threading.enumerate", 
        "syntax": "threading.enumerate()", 
        "type": "Concurrent Execution"
    }, 
    "threading.get_ident": {
        "descr": "Return the \u2018thread identifier\u2019 of the current thread. This is a nonzero integer. Its value has no direct meaning; it is intended as a magic cookie to be used e.g. to index a dictionary of thread-specific data. Thread identifiers may be recycled when a thread exits and another thread is created.", 
        "name": "threading.get_ident", 
        "params": [], 
        "path": "python/library/threading#threading.get_ident", 
        "syntax": "threading.get_ident()", 
        "type": "Concurrent Execution"
    }, 
    "threading.local": {
        "descr": "A class that represents thread-local data.", 
        "name": "threading.local", 
        "params": [], 
        "path": "python/library/threading#threading.local", 
        "syntax": "class threading.local", 
        "type": "Concurrent Execution"
    }, 
    "threading.setprofile": {
        "descr": "", 
        "name": "threading.setprofile", 
        "params": [], 
        "path": "python/library/threading#threading.setprofile", 
        "syntax": "threading.setprofile(func)", 
        "type": "Concurrent Execution"
    }, 
    "threading.settrace": {
        "descr": "", 
        "name": "threading.settrace", 
        "params": [], 
        "path": "python/library/threading#threading.settrace", 
        "syntax": "threading.settrace(func)", 
        "type": "Concurrent Execution"
    }, 
    "threading.stack_size": {
        "descr": "Return the thread stack size used when creating new threads. The optional size argument specifies the stack size to be used for subsequently created threads, and must be 0 (use platform or configured default) or a positive integer value of at least 32,768 (32 KiB). If changing the thread stack size is unsupported, a RuntimeError is raised. If the specified stack size is invalid, a ValueError is raised and the stack size is unmodified. 32 KiB is currently the minimum supported stack size value to guarantee sufficient stack space for the interpreter itself. Note that some platforms may have particular restrictions on values for the stack size, such as requiring a minimum stack size > 32 KiB or requiring allocation in multiples of the system memory page size - platform documentation should be referred to for more information (4 KiB pages are common; using multiples of 4096 for the stack size is the suggested approach in the absence of more specific information). Availability: Windows, systems with POSIX threads.", 
        "name": "threading.stack_size", 
        "params": [], 
        "path": "python/library/threading#threading.stack_size", 
        "syntax": "threading.stack_size([size])", 
        "type": "Concurrent Execution"
    }, 
    "time.altzone": {
        "descr": "The offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if daylight is nonzero.", 
        "name": "time.altzone", 
        "params": [], 
        "path": "python/library/time#time.altzone", 
        "syntax": "time.altzone", 
        "type": "Operating System"
    }, 
    "time.asctime": {
        "descr": "Convert a tuple or struct_time representing a time as returned by gmtime() or localtime() to a string of the following form: 'Sun Jun 20 23:21:05 1993'. If t is not provided, the current time as returned by localtime() is used. Locale information is not used by asctime().", 
        "name": "time.asctime", 
        "params": [], 
        "path": "python/library/time#time.asctime", 
        "syntax": "time.asctime([t])", 
        "type": "Operating System"
    }, 
    "time.clock": {
        "descr": "On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number, based on the Win32 function QueryPerformanceCounter(). The resolution is typically better than one microsecond.", 
        "name": "time.clock", 
        "params": [], 
        "path": "python/library/time#time.clock", 
        "syntax": "time.clock()", 
        "type": "Operating System"
    }, 
    "time.clock_getres": {
        "descr": "Return the resolution (precision) of the specified clock clk_id.", 
        "name": "time.clock_getres", 
        "params": [], 
        "path": "python/library/time#time.clock_getres", 
        "syntax": "time.clock_getres(clk_id)", 
        "type": "Operating System"
    }, 
    "time.clock_gettime": {
        "descr": "Return the time of the specified clock clk_id.", 
        "name": "time.clock_gettime", 
        "params": [], 
        "path": "python/library/time#time.clock_gettime", 
        "syntax": "time.clock_gettime(clk_id)", 
        "type": "Operating System"
    }, 
    "time.clock_settime": {
        "descr": "Set the time of the specified clock clk_id.", 
        "name": "time.clock_settime", 
        "params": [], 
        "path": "python/library/time#time.clock_settime", 
        "syntax": "time.clock_settime(clk_id, time)", 
        "type": "Operating System"
    }, 
    "time.ctime": {
        "descr": "Convert a time expressed in seconds since the epoch to a string representing local time. If secs is not provided or None, the current time as returned by time() is used. ctime(secs) is equivalent to asctime(localtime(secs)). Locale information is not used by ctime().", 
        "name": "time.ctime", 
        "params": [], 
        "path": "python/library/time#time.ctime", 
        "syntax": "time.ctime([secs])", 
        "type": "Operating System"
    }, 
    "time.daylight": {
        "descr": "Nonzero if a DST timezone is defined.", 
        "name": "time.daylight", 
        "params": [], 
        "path": "python/library/time#time.daylight", 
        "syntax": "time.daylight", 
        "type": "Operating System"
    }, 
    "time.get_clock_info": {
        "descr": "Get information on the specified clock as a namespace object. Supported clock names and the corresponding functions to read their value are:", 
        "name": "time.get_clock_info", 
        "params": [], 
        "path": "python/library/time#time.get_clock_info", 
        "syntax": "time.get_clock_info(name)", 
        "type": "Operating System"
    }, 
    "time.gmtime": {
        "descr": "Convert a time expressed in seconds since the epoch to a struct_time in UTC in which the dst flag is always zero. If secs is not provided or None, the current time as returned by time() is used. Fractions of a second are ignored. See above for a description of the struct_time object. See calendar.timegm() for the inverse of this function.", 
        "name": "time.gmtime", 
        "params": [], 
        "path": "python/library/time#time.gmtime", 
        "syntax": "time.gmtime([secs])", 
        "type": "Operating System"
    }, 
    "time.localtime": {
        "descr": "Like gmtime() but converts to local time. If secs is not provided or None, the current time as returned by time() is used. The dst flag is set to 1 when DST applies to the given time.", 
        "name": "time.localtime", 
        "params": [], 
        "path": "python/library/time#time.localtime", 
        "syntax": "time.localtime([secs])", 
        "type": "Operating System"
    }, 
    "time.mktime": {
        "descr": "This is the inverse function of localtime(). Its argument is the struct_time or full 9-tuple (since the dst flag is needed; use -1 as the dst flag if it is unknown) which expresses the time in local time, not UTC. It returns a floating point number, for compatibility with time(). If the input value cannot be represented as a valid time, either OverflowError or ValueError will be raised (which depends on whether the invalid value is caught by Python or the underlying C libraries). The earliest date for which it can generate a time is platform-dependent.", 
        "name": "time.mktime", 
        "params": [], 
        "path": "python/library/time#time.mktime", 
        "syntax": "time.mktime(t)", 
        "type": "Operating System"
    }, 
    "time.monotonic": {
        "descr": "Return the value (in fractional seconds) of a monotonic clock, i.e. a clock that cannot go backwards. The clock is not affected by system clock updates. The reference point of the returned value is undefined, so that only the difference between the results of consecutive calls is valid.", 
        "name": "time.monotonic", 
        "params": [], 
        "path": "python/library/time#time.monotonic", 
        "syntax": "time.monotonic()", 
        "type": "Operating System"
    }, 
    "time.perf_counter": {
        "descr": "Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The reference point of the returned value is undefined, so that only the difference between the results of consecutive calls is valid.", 
        "name": "time.perf_counter", 
        "params": [], 
        "path": "python/library/time#time.perf_counter", 
        "syntax": "time.perf_counter()", 
        "type": "Operating System"
    }, 
    "time.process_time": {
        "descr": "Return the value (in fractional seconds) of the sum of the system and user CPU time of the current process. It does not include time elapsed during sleep. It is process-wide by definition. The reference point of the returned value is undefined, so that only the difference between the results of consecutive calls is valid.", 
        "name": "time.process_time", 
        "params": [], 
        "path": "python/library/time#time.process_time", 
        "syntax": "time.process_time()", 
        "type": "Operating System"
    }, 
    "time.sleep": {
        "descr": "Suspend execution for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal\u2019s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.", 
        "name": "time.sleep", 
        "params": [], 
        "path": "python/library/time#time.sleep", 
        "syntax": "time.sleep(secs)", 
        "type": "Operating System"
    }, 
    "time.strftime": {
        "descr": "Convert a tuple or struct_time representing a time as returned by gmtime() or localtime() to a string as specified by the format argument. If t is not provided, the current time as returned by localtime() is used. format must be a string. ValueError is raised if any field in t is outside of the allowed range.", 
        "name": "time.strftime", 
        "params": [], 
        "path": "python/library/time#time.strftime", 
        "syntax": "time.strftime(format[, t])", 
        "type": "Operating System"
    }, 
    "time.strptime": {
        "descr": "Parse a string representing a time according to a format. The return value is a struct_time as returned by gmtime() or localtime().", 
        "name": "time.strptime", 
        "params": [], 
        "path": "python/library/time#time.strptime", 
        "syntax": "time.strptime(string[, format])", 
        "type": "Operating System"
    }, 
    "time.struct_time": {
        "descr": "The type of the time value sequence returned by gmtime(), localtime(), and strptime(). It is an object with a named tuple interface: values can be accessed by index and by attribute name. The following values are present:", 
        "name": "time.struct_time", 
        "params": [], 
        "path": "python/library/time#time.struct_time", 
        "syntax": "class time.struct_time", 
        "type": "Operating System"
    }, 
    "time.time": {
        "descr": "Return the time in seconds since the epoch as a floating point number. Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls.", 
        "name": "time.time", 
        "params": [], 
        "path": "python/library/time#time.time", 
        "syntax": "time.time()", 
        "type": "Operating System"
    }, 
    "time.timezone": {
        "descr": "The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, positive in the US, zero in the UK).", 
        "name": "time.timezone", 
        "params": [], 
        "path": "python/library/time#time.timezone", 
        "syntax": "time.timezone", 
        "type": "Operating System"
    }, 
    "time.tzname": {
        "descr": "A tuple of two strings: the first is the name of the local non-DST timezone, the second is the name of the local DST timezone. If no DST timezone is defined, the second string should not be used.", 
        "name": "time.tzname", 
        "params": [], 
        "path": "python/library/time#time.tzname", 
        "syntax": "time.tzname", 
        "type": "Operating System"
    }, 
    "time.tzset": {
        "descr": "Resets the time conversion rules used by the library routines. The environment variable TZ specifies how this is done.", 
        "name": "time.tzset", 
        "params": [], 
        "path": "python/library/time#time.tzset", 
        "syntax": "time.tzset()", 
        "type": "Operating System"
    }, 
    "timeit.Timer": {
        "descr": "Class for timing execution speed of small code snippets.", 
        "name": "timeit.Timer", 
        "params": [], 
        "path": "python/library/timeit#timeit.Timer", 
        "syntax": "class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)", 
        "type": "Debugging & Profiling"
    }, 
    "timeit.Timer.print_exc": {
        "descr": "Helper to print a traceback from the timed code.", 
        "name": "timeit.Timer.print_exc", 
        "params": [], 
        "path": "python/library/timeit#timeit.Timer.print_exc", 
        "syntax": "print_exc(file=None)", 
        "type": "Debugging & Profiling"
    }, 
    "timeit.Timer.repeat": {
        "descr": "Call timeit() a few times.", 
        "name": "timeit.Timer.repeat", 
        "params": [], 
        "path": "python/library/timeit#timeit.Timer.repeat", 
        "syntax": "repeat(repeat=3, number=1000000)", 
        "type": "Debugging & Profiling"
    }, 
    "timeit.Timer.timeit": {
        "descr": "Time number executions of the main statement. This executes the setup statement once, and then returns the time it takes to execute the main statement a number of times, measured in seconds as a float. The argument is the number of times through the loop, defaulting to one million. The main statement, the setup statement and the timer function to be used are passed to the constructor.", 
        "name": "timeit.Timer.timeit", 
        "params": [], 
        "path": "python/library/timeit#timeit.Timer.timeit", 
        "syntax": "timeit(number=1000000)", 
        "type": "Debugging & Profiling"
    }, 
    "timeit.default_timer": {
        "descr": "The default timer, which is always time.perf_counter().", 
        "name": "timeit.default_timer", 
        "params": [], 
        "path": "python/library/timeit#timeit.default_timer", 
        "syntax": "timeit.default_timer()", 
        "type": "Debugging & Profiling"
    }, 
    "timeit.repeat": {
        "descr": "Create a Timer instance with the given statement, setup code and timer function and run its repeat() method with the given repeat count and number executions.", 
        "name": "timeit.repeat", 
        "params": [], 
        "path": "python/library/timeit#timeit.repeat", 
        "syntax": "timeit.repeat(stmt='pass', setup='pass', timer=<default timer>, repeat=3, number=1000000)", 
        "type": "Debugging & Profiling"
    }, 
    "timeit.timeit": {
        "descr": "Create a Timer instance with the given statement, setup code and timer function and run its timeit() method with number executions.", 
        "name": "timeit.timeit", 
        "params": [], 
        "path": "python/library/timeit#timeit.timeit", 
        "syntax": "timeit.timeit(stmt='pass', setup='pass', timer=<default timer>, number=1000000)", 
        "type": "Debugging & Profiling"
    }, 
    "title": {
        "descr": "Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.", 
        "name": "str.title", 
        "params": [], 
        "path": "python/library/stdtypes#str.title", 
        "syntax": "str.title()", 
        "type": "Built-in Types"
    }, 
    "tkinter.At": {
        "descr": "Deprecated since version 3.3.", 
        "name": "tkinter.At", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.At", 
        "syntax": "tkinter.At(x[, y])", 
        "type": "Tk"
    }, 
    "tkinter.AtEnd": {
        "descr": "Deprecated since version 3.3.", 
        "name": "tkinter.AtEnd", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.AtEnd", 
        "syntax": "tkinter.AtEnd()", 
        "type": "Tk"
    }, 
    "tkinter.AtInsert": {
        "descr": "Deprecated since version 3.3.", 
        "name": "tkinter.AtInsert", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.AtInsert", 
        "syntax": "tkinter.AtInsert()", 
        "type": "Tk"
    }, 
    "tkinter.AtSelFirst": {
        "descr": "Deprecated since version 3.3.", 
        "name": "tkinter.AtSelFirst", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.AtSelFirst", 
        "syntax": "tkinter.AtSelFirst()", 
        "type": "Tk"
    }, 
    "tkinter.AtSelLast": {
        "descr": "Deprecated since version 3.3.", 
        "name": "tkinter.AtSelLast", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.AtSelLast", 
        "syntax": "tkinter.AtSelLast()", 
        "type": "Tk"
    }, 
    "tkinter.Tcl": {
        "descr": "The Tcl() function is a factory function which creates an object much like that created by the Tk class, except that it does not initialize the Tk subsystem. This is most often useful when driving the Tcl interpreter in an environment where one doesn\u2019t want to create extraneous toplevel windows, or where one cannot (such as Unix/Linux systems without an X server). An object created by the Tcl() object can have a Toplevel window created (and the Tk subsystem initialized) by calling its loadtk() method.", 
        "name": "tkinter.Tcl", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.Tcl", 
        "syntax": "tkinter.Tcl(screenName=None, baseName=None, className='Tk', useTk=0)", 
        "type": "Tk"
    }, 
    "tkinter.Tk": {
        "descr": "The Tk class is instantiated without arguments. This creates a toplevel widget of Tk which usually is the main window of an application. Each instance has its own associated Tcl interpreter.", 
        "name": "tkinter.Tk", 
        "params": [], 
        "path": "python/library/tkinter#tkinter.Tk", 
        "syntax": "class tkinter.Tk(screenName=None, baseName=None, className='Tk', useTk=1)", 
        "type": "Tk"
    }, 
    "tkinter.scrolledtext.ScrolledText.frame": {
        "descr": "The frame which surrounds the text and scroll bar widgets.", 
        "name": "tkinter.scrolledtext.ScrolledText.frame", 
        "params": [], 
        "path": "python/library/tkinter.scrolledtext#tkinter.scrolledtext.ScrolledText.frame", 
        "syntax": "ScrolledText.frame", 
        "type": "Tk"
    }, 
    "tkinter.scrolledtext.ScrolledText.vbar": {
        "descr": "The scroll bar widget.", 
        "name": "tkinter.scrolledtext.ScrolledText.vbar", 
        "params": [], 
        "path": "python/library/tkinter.scrolledtext#tkinter.scrolledtext.ScrolledText.vbar", 
        "syntax": "ScrolledText.vbar", 
        "type": "Tk"
    }, 
    "tkinter.tix.Balloon": {
        "descr": "A Balloon that pops up over a widget to provide help. When the user moves the cursor inside a widget to which a Balloon widget has been bound, a small pop-up window with a descriptive message will be shown on the screen.", 
        "name": "tkinter.tix.Balloon", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Balloon", 
        "syntax": "class tkinter.tix.Balloon", 
        "type": "Tk"
    }, 
    "tkinter.tix.ButtonBox": {
        "descr": "The ButtonBox widget creates a box of buttons, such as is commonly used for Ok Cancel.", 
        "name": "tkinter.tix.ButtonBox", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.ButtonBox", 
        "syntax": "class tkinter.tix.ButtonBox", 
        "type": "Tk"
    }, 
    "tkinter.tix.CheckList": {
        "descr": "The CheckList widget displays a list of items to be selected by the user. CheckList acts similarly to the Tk checkbutton or radiobutton widgets, except it is capable of handling many more items than checkbuttons or radiobuttons.", 
        "name": "tkinter.tix.CheckList", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.CheckList", 
        "syntax": "class tkinter.tix.CheckList", 
        "type": "Tk"
    }, 
    "tkinter.tix.ComboBox": {
        "descr": "The ComboBox widget is similar to the combo box control in MS Windows. The user can select a choice by either typing in the entry subwidget or selecting from the listbox subwidget.", 
        "name": "tkinter.tix.ComboBox", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.ComboBox", 
        "syntax": "class tkinter.tix.ComboBox", 
        "type": "Tk"
    }, 
    "tkinter.tix.Control": {
        "descr": "The Control widget is also known as the SpinBox widget. The user can adjust the value by pressing the two arrow buttons or by entering the value directly into the entry. The new value will be checked against the user-defined upper and lower limits.", 
        "name": "tkinter.tix.Control", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Control", 
        "syntax": "class tkinter.tix.Control", 
        "type": "Tk"
    }, 
    "tkinter.tix.DirList": {
        "descr": "The DirList widget displays a list view of a directory, its previous directories and its sub-directories. The user can choose one of the directories displayed in the list or change to another directory.", 
        "name": "tkinter.tix.DirList", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.DirList", 
        "syntax": "class tkinter.tix.DirList", 
        "type": "Tk"
    }, 
    "tkinter.tix.DirSelectBox": {
        "descr": "The DirSelectBox is similar to the standard Motif(TM) directory-selection box. It is generally used for the user to choose a directory. DirSelectBox stores the directories mostly recently selected into a ComboBox widget so that they can be quickly selected again.", 
        "name": "tkinter.tix.DirSelectBox", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.DirSelectBox", 
        "syntax": "class tkinter.tix.DirSelectBox", 
        "type": "Tk"
    }, 
    "tkinter.tix.DirSelectDialog": {
        "descr": "The DirSelectDialog widget presents the directories in the file system in a dialog window. The user can use this dialog window to navigate through the file system to select the desired directory.", 
        "name": "tkinter.tix.DirSelectDialog", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.DirSelectDialog", 
        "syntax": "class tkinter.tix.DirSelectDialog", 
        "type": "Tk"
    }, 
    "tkinter.tix.DirTree": {
        "descr": "The DirTree widget displays a tree view of a directory, its previous directories and its sub-directories. The user can choose one of the directories displayed in the list or change to another directory.", 
        "name": "tkinter.tix.DirTree", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.DirTree", 
        "syntax": "class tkinter.tix.DirTree", 
        "type": "Tk"
    }, 
    "tkinter.tix.ExFileSelectBox": {
        "descr": "The ExFileSelectBox widget is usually embedded in a tixExFileSelectDialog widget. It provides an convenient method for the user to select files. The style of the ExFileSelectBox widget is very similar to the standard file dialog on MS Windows 3.1.", 
        "name": "tkinter.tix.ExFileSelectBox", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.ExFileSelectBox", 
        "syntax": "class tkinter.tix.ExFileSelectBox", 
        "type": "Tk"
    }, 
    "tkinter.tix.FileEntry": {
        "descr": "The FileEntry widget can be used to input a filename. The user can type in the filename manually. Alternatively, the user can press the button widget that sits next to the entry, which will bring up a file selection dialog.", 
        "name": "tkinter.tix.FileEntry", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.FileEntry", 
        "syntax": "class tkinter.tix.FileEntry", 
        "type": "Tk"
    }, 
    "tkinter.tix.FileSelectBox": {
        "descr": "The FileSelectBox is similar to the standard Motif(TM) file-selection box. It is generally used for the user to choose a file. FileSelectBox stores the files mostly recently selected into a ComboBox widget so that they can be quickly selected again.", 
        "name": "tkinter.tix.FileSelectBox", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.FileSelectBox", 
        "syntax": "class tkinter.tix.FileSelectBox", 
        "type": "Tk"
    }, 
    "tkinter.tix.Form": {
        "descr": "The Form geometry manager based on attachment rules for all Tk widgets.", 
        "name": "tkinter.tix.Form", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Form", 
        "syntax": "class tkinter.tix.Form", 
        "type": "Tk"
    }, 
    "tkinter.tix.HList": {
        "descr": "The HList widget can be used to display any data that have a hierarchical structure, for example, file system directory trees. The list entries are indented and connected by branch lines according to their places in the hierarchy.", 
        "name": "tkinter.tix.HList", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.HList", 
        "syntax": "class tkinter.tix.HList", 
        "type": "Tk"
    }, 
    "tkinter.tix.InputOnly": {
        "descr": "The InputOnly widgets are to accept inputs from the user, which can be done with the bind command (Unix only).", 
        "name": "tkinter.tix.InputOnly", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.InputOnly", 
        "syntax": "class tkinter.tix.InputOnly", 
        "type": "Tk"
    }, 
    "tkinter.tix.LabelEntry": {
        "descr": "The LabelEntry widget packages an entry widget and a label into one mega widget. It can be used be used to simplify the creation of \u201centry-form\u201d type of interface.", 
        "name": "tkinter.tix.LabelEntry", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.LabelEntry", 
        "syntax": "class tkinter.tix.LabelEntry", 
        "type": "Tk"
    }, 
    "tkinter.tix.LabelFrame": {
        "descr": "The LabelFrame widget packages a frame widget and a label into one mega widget. To create widgets inside a LabelFrame widget, one creates the new widgets relative to the frame subwidget and manage them inside the frame subwidget.", 
        "name": "tkinter.tix.LabelFrame", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.LabelFrame", 
        "syntax": "class tkinter.tix.LabelFrame", 
        "type": "Tk"
    }, 
    "tkinter.tix.ListNoteBook": {
        "descr": "The ListNoteBook widget is very similar to the TixNoteBook widget: it can be used to display many windows in a limited space using a notebook metaphor. The notebook is divided into a stack of pages (windows). At one time only one of these pages can be shown. The user can navigate through these pages by choosing the name of the desired page in the hlist subwidget.", 
        "name": "tkinter.tix.ListNoteBook", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.ListNoteBook", 
        "syntax": "class tkinter.tix.ListNoteBook", 
        "type": "Tk"
    }, 
    "tkinter.tix.Meter": {
        "descr": "The Meter widget can be used to show the progress of a background job which may take a long time to execute.", 
        "name": "tkinter.tix.Meter", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Meter", 
        "syntax": "class tkinter.tix.Meter", 
        "type": "Tk"
    }, 
    "tkinter.tix.NoteBook": {
        "descr": "The NoteBook widget can be used to display many windows in a limited space using a notebook metaphor. The notebook is divided into a stack of pages. At one time only one of these pages can be shown. The user can navigate through these pages by choosing the visual \u201ctabs\u201d at the top of the NoteBook widget.", 
        "name": "tkinter.tix.NoteBook", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.NoteBook", 
        "syntax": "class tkinter.tix.NoteBook", 
        "type": "Tk"
    }, 
    "tkinter.tix.OptionMenu": {
        "descr": "The OptionMenu creates a menu button of options.", 
        "name": "tkinter.tix.OptionMenu", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.OptionMenu", 
        "syntax": "class tkinter.tix.OptionMenu", 
        "type": "Tk"
    }, 
    "tkinter.tix.PanedWindow": {
        "descr": "The PanedWindow widget allows the user to interactively manipulate the sizes of several panes. The panes can be arranged either vertically or horizontally. The user changes the sizes of the panes by dragging the resize handle between two panes.", 
        "name": "tkinter.tix.PanedWindow", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.PanedWindow", 
        "syntax": "class tkinter.tix.PanedWindow", 
        "type": "Tk"
    }, 
    "tkinter.tix.PopupMenu": {
        "descr": "The PopupMenu widget can be used as a replacement of the tk_popup command. The advantage of the Tix PopupMenu widget is it requires less application code to manipulate.", 
        "name": "tkinter.tix.PopupMenu", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.PopupMenu", 
        "syntax": "class tkinter.tix.PopupMenu", 
        "type": "Tk"
    }, 
    "tkinter.tix.Select": {
        "descr": "The Select widget is a container of button subwidgets. It can be used to provide radio-box or check-box style of selection options for the user.", 
        "name": "tkinter.tix.Select", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Select", 
        "syntax": "class tkinter.tix.Select", 
        "type": "Tk"
    }, 
    "tkinter.tix.StdButtonBox": {
        "descr": "The StdButtonBox widget is a group of standard buttons for Motif-like dialog boxes.", 
        "name": "tkinter.tix.StdButtonBox", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.StdButtonBox", 
        "syntax": "class tkinter.tix.StdButtonBox", 
        "type": "Tk"
    }, 
    "tkinter.tix.TList": {
        "descr": "The TList widget can be used to display data in a tabular format. The list entries of a TList widget are similar to the entries in the Tk listbox widget. The main differences are (1) the TList widget can display the list entries in a two dimensional format and (2) you can use graphical images as well as multiple colors and fonts for the list entries.", 
        "name": "tkinter.tix.TList", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.TList", 
        "syntax": "class tkinter.tix.TList", 
        "type": "Tk"
    }, 
    "tkinter.tix.Tk": {
        "descr": "Toplevel widget of Tix which represents mostly the main window of an application. It has an associated Tcl interpreter.", 
        "name": "tkinter.tix.Tk", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Tk", 
        "syntax": "class tkinter.tix.Tk(screenName=None, baseName=None, className='Tix')", 
        "type": "Tk"
    }, 
    "tkinter.tix.Tree": {
        "descr": "The Tree widget can be used to display hierarchical data in a tree form. The user can adjust the view of the tree by opening or closing parts of the tree.", 
        "name": "tkinter.tix.Tree", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.Tree", 
        "syntax": "class tkinter.tix.Tree", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand": {
        "descr": "The tix commands provide access to miscellaneous elements of Tix\u2018s internal state and the Tix application context. Most of the information manipulated by these methods pertains to the application as a whole, or to a screen or display, rather than to a particular window.", 
        "name": "tkinter.tix.tixCommand", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand", 
        "syntax": "class tkinter.tix.tixCommand", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_addbitmapdir": {
        "descr": "Tix maintains a list of directories under which the tix_getimage() and tix_getbitmap() methods will search for image files. The standard bitmap directory is $TIX_LIBRARY/bitmaps. The tix_addbitmapdir() method adds directory into this list. By using this method, the image files of an applications can also be located using the tix_getimage() or tix_getbitmap() method.", 
        "name": "tkinter.tix.tixCommand.tix_addbitmapdir", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_addbitmapdir", 
        "syntax": "tixCommand.tix_addbitmapdir(directory)", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_cget": {
        "descr": "Returns the current value of the configuration option given by option. Option may be any of the configuration options.", 
        "name": "tkinter.tix.tixCommand.tix_cget", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_cget", 
        "syntax": "tixCommand.tix_cget(option)", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_configure": {
        "descr": "Query or modify the configuration options of the Tix application context. If no option is specified, returns a dictionary all of the available options. If option is specified with no value, then the method returns a list describing the one named option (this list will be identical to the corresponding sublist of the value returned if no option is specified). If one or more option-value pairs are specified, then the method modifies the given option(s) to have the given value(s); in this case the method returns an empty string. Option may be any of the configuration options.", 
        "name": "tkinter.tix.tixCommand.tix_configure", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_configure", 
        "syntax": "tixCommand.tix_configure(cnf=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_filedialog": {
        "descr": "Returns the file selection dialog that may be shared among different calls from this application. This method will create a file selection dialog widget when it is called the first time. This dialog will be returned by all subsequent calls to tix_filedialog(). An optional dlgclass parameter can be passed as a string to specified what type of file selection dialog widget is desired. Possible options are tix, FileSelectDialog or tixExFileSelectDialog.", 
        "name": "tkinter.tix.tixCommand.tix_filedialog", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_filedialog", 
        "syntax": "tixCommand.tix_filedialog([dlgclass])", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_getbitmap": {
        "descr": "Locates a bitmap file of the name name.xpm or name in one of the bitmap directories (see the tix_addbitmapdir() method). By using tix_getbitmap(), you can avoid hard coding the pathnames of the bitmap files in your application. When successful, it returns the complete pathname of the bitmap file, prefixed with the character @. The returned value can be used to configure the bitmap option of the Tk and Tix widgets.", 
        "name": "tkinter.tix.tixCommand.tix_getbitmap", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_getbitmap", 
        "syntax": "tixCommand.tix_getbitmap(name)", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_getimage": {
        "descr": "Locates an image file of the name name.xpm, name.xbm or name.ppm in one of the bitmap directories (see the tix_addbitmapdir() method above). If more than one file with the same name (but different extensions) exist, then the image type is chosen according to the depth of the X display: xbm images are chosen on monochrome displays and color images are chosen on color displays. By using tix_getimage(), you can avoid hard coding the pathnames of the image files in your application. When successful, this method returns the name of the newly created image, which can be used to configure the image option of the Tk and Tix widgets.", 
        "name": "tkinter.tix.tixCommand.tix_getimage", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_getimage", 
        "syntax": "tixCommand.tix_getimage(self, name)", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_option_get": {
        "descr": "Gets the options maintained by the Tix scheme mechanism.", 
        "name": "tkinter.tix.tixCommand.tix_option_get", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_option_get", 
        "syntax": "tixCommand.tix_option_get(name)", 
        "type": "Tk"
    }, 
    "tkinter.tix.tixCommand.tix_resetoptions": {
        "descr": "Resets the scheme and fontset of the Tix application to newScheme and newFontSet, respectively. This affects only those widgets created after this call. Therefore, it is best to call the resetoptions method before the creation of any widgets in a Tix application.", 
        "name": "tkinter.tix.tixCommand.tix_resetoptions", 
        "params": [], 
        "path": "python/library/tkinter.tix#tkinter.tix.tixCommand.tix_resetoptions", 
        "syntax": "tixCommand.tix_resetoptions(newScheme, newFontSet[, newScmPrio])", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Combobox": {
        "descr": "If newindex is specified, sets the combobox value to the element position newindex. Otherwise, returns the index of the current value or -1 if the current value is not in the values list.", 
        "name": "tkinter.ttk.Combobox", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Combobox", 
        "syntax": "class tkinter.ttk.Combobox", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Combobox.current": {
        "descr": "If newindex is specified, sets the combobox value to the element position newindex. Otherwise, returns the index of the current value or -1 if the current value is not in the values list.", 
        "name": "tkinter.ttk.Combobox.current", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Combobox.current", 
        "syntax": "current(newindex=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Combobox.get": {
        "descr": "Returns the current value of the combobox.", 
        "name": "tkinter.ttk.Combobox.get", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Combobox.get", 
        "syntax": "get()", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Combobox.set": {
        "descr": "Sets the value of the combobox to value.", 
        "name": "tkinter.ttk.Combobox.set", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Combobox.set", 
        "syntax": "set(value)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook": {
        "descr": "Adds a new tab to the notebook.", 
        "name": "tkinter.ttk.Notebook", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook", 
        "syntax": "class tkinter.ttk.Notebook", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.add": {
        "descr": "Adds a new tab to the notebook.", 
        "name": "tkinter.ttk.Notebook.add", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.add", 
        "syntax": "add(child, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.enable_traversal": {
        "descr": "Enable keyboard traversal for a toplevel window containing this notebook.", 
        "name": "tkinter.ttk.Notebook.enable_traversal", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.enable_traversal", 
        "syntax": "enable_traversal()", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.forget": {
        "descr": "Removes the tab specified by tab_id, unmaps and unmanages the associated window.", 
        "name": "tkinter.ttk.Notebook.forget", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.forget", 
        "syntax": "forget(tab_id)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.hide": {
        "descr": "Hides the tab specified by tab_id.", 
        "name": "tkinter.ttk.Notebook.hide", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.hide", 
        "syntax": "hide(tab_id)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.identify": {
        "descr": "Returns the name of the tab element at position x, y, or the empty string if none.", 
        "name": "tkinter.ttk.Notebook.identify", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.identify", 
        "syntax": "identify(x, y)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.index": {
        "descr": "Returns the numeric index of the tab specified by tab_id, or the total number of tabs if tab_id is the string \u201cend\u201d.", 
        "name": "tkinter.ttk.Notebook.index", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.index", 
        "syntax": "index(tab_id)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.insert": {
        "descr": "Inserts a pane at the specified position.", 
        "name": "tkinter.ttk.Notebook.insert", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.insert", 
        "syntax": "insert(pos, child, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.select": {
        "descr": "Selects the specified tab_id.", 
        "name": "tkinter.ttk.Notebook.select", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.select", 
        "syntax": "select(tab_id=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.tab": {
        "descr": "Query or modify the options of the specific tab_id.", 
        "name": "tkinter.ttk.Notebook.tab", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.tab", 
        "syntax": "tab(tab_id, option=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Notebook.tabs": {
        "descr": "Returns a list of windows managed by the notebook.", 
        "name": "tkinter.ttk.Notebook.tabs", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Notebook.tabs", 
        "syntax": "tabs()", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Progressbar": {
        "descr": "Begin autoincrement mode: schedules a recurring timer event that calls Progressbar.step() every interval milliseconds. If omitted, interval defaults to 50 milliseconds.", 
        "name": "tkinter.ttk.Progressbar", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Progressbar", 
        "syntax": "class tkinter.ttk.Progressbar", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Progressbar.start": {
        "descr": "Begin autoincrement mode: schedules a recurring timer event that calls Progressbar.step() every interval milliseconds. If omitted, interval defaults to 50 milliseconds.", 
        "name": "tkinter.ttk.Progressbar.start", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Progressbar.start", 
        "syntax": "start(interval=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Progressbar.step": {
        "descr": "Increments the progress bar\u2019s value by amount.", 
        "name": "tkinter.ttk.Progressbar.step", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Progressbar.step", 
        "syntax": "step(amount=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Progressbar.stop": {
        "descr": "Stop autoincrement mode: cancels any recurring timer event initiated by Progressbar.start() for this progress bar.", 
        "name": "tkinter.ttk.Progressbar.stop", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Progressbar.stop", 
        "syntax": "stop()", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style": {
        "descr": "This class is used to manipulate the style database.", 
        "name": "tkinter.ttk.Style", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style", 
        "syntax": "class tkinter.ttk.Style", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.configure": {
        "descr": "Query or set the default value of the specified option(s) in style.", 
        "name": "tkinter.ttk.Style.configure", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.configure", 
        "syntax": "configure(style, query_opt=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.element_create": {
        "descr": "Create a new element in the current theme, of the given etype which is expected to be either \u201cimage\u201d, \u201cfrom\u201d or \u201cvsapi\u201d. The latter is only available in Tk 8.6a for Windows XP and Vista and is not described here.", 
        "name": "tkinter.ttk.Style.element_create", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.element_create", 
        "syntax": "element_create(elementname, etype, *args, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.element_names": {
        "descr": "Returns the list of elements defined in the current theme.", 
        "name": "tkinter.ttk.Style.element_names", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.element_names", 
        "syntax": "element_names()", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.element_options": {
        "descr": "Returns the list of elementname\u2018s options.", 
        "name": "tkinter.ttk.Style.element_options", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.element_options", 
        "syntax": "element_options(elementname)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.layout": {
        "descr": "Define the widget layout for given style. If layoutspec is omitted, return the layout specification for given style.", 
        "name": "tkinter.ttk.Style.layout", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.layout", 
        "syntax": "layout(style, layoutspec=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.lookup": {
        "descr": "Returns the value specified for option in style.", 
        "name": "tkinter.ttk.Style.lookup", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.lookup", 
        "syntax": "lookup(style, option, state=None, default=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.map": {
        "descr": "Query or sets dynamic values of the specified option(s) in style.", 
        "name": "tkinter.ttk.Style.map", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.map", 
        "syntax": "map(style, query_opt=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.theme_create": {
        "descr": "Create a new theme.", 
        "name": "tkinter.ttk.Style.theme_create", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.theme_create", 
        "syntax": "theme_create(themename, parent=None, settings=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.theme_names": {
        "descr": "Returns a list of all known themes.", 
        "name": "tkinter.ttk.Style.theme_names", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.theme_names", 
        "syntax": "theme_names()", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.theme_settings": {
        "descr": "Temporarily sets the current theme to themename, apply specified settings and then restore the previous theme.", 
        "name": "tkinter.ttk.Style.theme_settings", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.theme_settings", 
        "syntax": "theme_settings(themename, settings)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Style.theme_use": {
        "descr": "If themename is not given, returns the theme in use. Otherwise, sets the current theme to themename, refreshes all widgets and emits a <<ThemeChanged>> event.", 
        "name": "tkinter.ttk.Style.theme_use", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Style.theme_use", 
        "syntax": "theme_use(themename=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview": {
        "descr": "Returns the bounding box (relative to the treeview widget\u2019s window) of the specified item in the form (x, y, width, height).", 
        "name": "tkinter.ttk.Treeview", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview", 
        "syntax": "class tkinter.ttk.Treeview", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.bbox": {
        "descr": "Returns the bounding box (relative to the treeview widget\u2019s window) of the specified item in the form (x, y, width, height).", 
        "name": "tkinter.ttk.Treeview.bbox", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.bbox", 
        "syntax": "bbox(item, column=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.column": {
        "descr": "Query or modify the options for the specified column.", 
        "name": "tkinter.ttk.Treeview.column", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.column", 
        "syntax": "column(column, option=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.delete": {
        "descr": "Delete all specified items and all their descendants.", 
        "name": "tkinter.ttk.Treeview.delete", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.delete", 
        "syntax": "delete(*items)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.detach": {
        "descr": "Unlinks all of the specified items from the tree.", 
        "name": "tkinter.ttk.Treeview.detach", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.detach", 
        "syntax": "detach(*items)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.exists": {
        "descr": "Returns True if the specified item is present in the tree.", 
        "name": "tkinter.ttk.Treeview.exists", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.exists", 
        "syntax": "exists(item)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.focus": {
        "descr": "If item is specified, sets the focus item to item. Otherwise, returns the current focus item, or \u2018\u2019 if there is none.", 
        "name": "tkinter.ttk.Treeview.focus", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.focus", 
        "syntax": "focus(item=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.get_children": {
        "descr": "Returns the list of children belonging to item.", 
        "name": "tkinter.ttk.Treeview.get_children", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.get_children", 
        "syntax": "get_children(item=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.heading": {
        "descr": "Query or modify the heading options for the specified column.", 
        "name": "tkinter.ttk.Treeview.heading", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.heading", 
        "syntax": "heading(column, option=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.identify": {
        "descr": "Returns a description of the specified component under the point given by x and y, or the empty string if no such component is present at that position.", 
        "name": "tkinter.ttk.Treeview.identify", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.identify", 
        "syntax": "identify(component, x, y)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.identify_column": {
        "descr": "Returns the data column identifier of the cell at position x.", 
        "name": "tkinter.ttk.Treeview.identify_column", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.identify_column", 
        "syntax": "identify_column(x)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.identify_element": {
        "descr": "Returns the element at position x, y.", 
        "name": "tkinter.ttk.Treeview.identify_element", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.identify_element", 
        "syntax": "identify_element(x, y)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.identify_region": {
        "descr": "Returns one of:", 
        "name": "tkinter.ttk.Treeview.identify_region", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.identify_region", 
        "syntax": "identify_region(x, y)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.identify_row": {
        "descr": "Returns the item ID of the item at position y.", 
        "name": "tkinter.ttk.Treeview.identify_row", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.identify_row", 
        "syntax": "identify_row(y)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.index": {
        "descr": "Returns the integer index of item within its parent\u2019s list of children.", 
        "name": "tkinter.ttk.Treeview.index", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.index", 
        "syntax": "index(item)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.insert": {
        "descr": "Creates a new item and returns the item identifier of the newly created item.", 
        "name": "tkinter.ttk.Treeview.insert", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.insert", 
        "syntax": "insert(parent, index, iid=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.item": {
        "descr": "Query or modify the options for the specified item.", 
        "name": "tkinter.ttk.Treeview.item", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.item", 
        "syntax": "item(item, option=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.move": {
        "descr": "Moves item to position index in parent\u2018s list of children.", 
        "name": "tkinter.ttk.Treeview.move", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.move", 
        "syntax": "move(item, parent, index)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.next": {
        "descr": "Returns the identifier of item\u2018s next sibling, or \u2018\u2019 if item is the last child of its parent.", 
        "name": "tkinter.ttk.Treeview.next", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.next", 
        "syntax": "next(item)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.parent": {
        "descr": "Returns the ID of the parent of item, or \u2018\u2019 if item is at the top level of the hierarchy.", 
        "name": "tkinter.ttk.Treeview.parent", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.parent", 
        "syntax": "parent(item)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.prev": {
        "descr": "Returns the identifier of item\u2018s previous sibling, or \u2018\u2019 if item is the first child of its parent.", 
        "name": "tkinter.ttk.Treeview.prev", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.prev", 
        "syntax": "prev(item)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.reattach": {
        "descr": "An alias for Treeview.move().", 
        "name": "tkinter.ttk.Treeview.reattach", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.reattach", 
        "syntax": "reattach(item, parent, index)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.see": {
        "descr": "Ensure that item is visible.", 
        "name": "tkinter.ttk.Treeview.see", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.see", 
        "syntax": "see(item)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.selection": {
        "descr": "If selop is not specified, returns selected items. Otherwise, it will act according to the following selection methods.", 
        "name": "tkinter.ttk.Treeview.selection", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.selection", 
        "syntax": "selection(selop=None, items=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.selection_add": {
        "descr": "Add items to the selection.", 
        "name": "tkinter.ttk.Treeview.selection_add", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.selection_add", 
        "syntax": "selection_add(items)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.selection_remove": {
        "descr": "Remove items from the selection.", 
        "name": "tkinter.ttk.Treeview.selection_remove", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.selection_remove", 
        "syntax": "selection_remove(items)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.selection_set": {
        "descr": "items becomes the new selection.", 
        "name": "tkinter.ttk.Treeview.selection_set", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.selection_set", 
        "syntax": "selection_set(items)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.selection_toggle": {
        "descr": "Toggle the selection state of each item in items.", 
        "name": "tkinter.ttk.Treeview.selection_toggle", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.selection_toggle", 
        "syntax": "selection_toggle(items)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.set": {
        "descr": "With one argument, returns a dictionary of column/value pairs for the specified item. With two arguments, returns the current value of the specified column. With three arguments, sets the value of given column in given item to the specified value.", 
        "name": "tkinter.ttk.Treeview.set", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.set", 
        "syntax": "set(item, column=None, value=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.set_children": {
        "descr": "Replaces item\u2018s child with newchildren.", 
        "name": "tkinter.ttk.Treeview.set_children", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.set_children", 
        "syntax": "set_children(item, *newchildren)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.tag_bind": {
        "descr": "Bind a callback for the given event sequence to the tag tagname. When an event is delivered to an item, the callbacks for each of the item\u2019s tags option are called.", 
        "name": "tkinter.ttk.Treeview.tag_bind", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.tag_bind", 
        "syntax": "tag_bind(tagname, sequence=None, callback=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.tag_configure": {
        "descr": "Query or modify the options for the specified tagname.", 
        "name": "tkinter.ttk.Treeview.tag_configure", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.tag_configure", 
        "syntax": "tag_configure(tagname, option=None, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.tag_has": {
        "descr": "If item is specified, returns 1 or 0 depending on whether the specified item has the given tagname. Otherwise, returns a list of all items that have the specified tag.", 
        "name": "tkinter.ttk.Treeview.tag_has", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.tag_has", 
        "syntax": "tag_has(tagname, item=None)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.xview": {
        "descr": "Query or modify horizontal position of the treeview.", 
        "name": "tkinter.ttk.Treeview.xview", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.xview", 
        "syntax": "xview(*args)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Treeview.yview": {
        "descr": "Query or modify vertical position of the treeview.", 
        "name": "tkinter.ttk.Treeview.yview", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Treeview.yview", 
        "syntax": "yview(*args)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Widget": {
        "descr": "Returns the name of the element at position x y, or the empty string if the point does not lie within any element.", 
        "name": "tkinter.ttk.Widget", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Widget", 
        "syntax": "class tkinter.ttk.Widget", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Widget.identify": {
        "descr": "Returns the name of the element at position x y, or the empty string if the point does not lie within any element.", 
        "name": "tkinter.ttk.Widget.identify", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Widget.identify", 
        "syntax": "identify(x, y)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Widget.instate": {
        "descr": "Test the widget\u2019s state. If a callback is not specified, returns True if the widget state matches statespec and False otherwise. If callback is specified then it is called with args if widget state matches statespec.", 
        "name": "tkinter.ttk.Widget.instate", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Widget.instate", 
        "syntax": "instate(statespec, callback=None, *args, **kw)", 
        "type": "Tk"
    }, 
    "tkinter.ttk.Widget.state": {
        "descr": "Modify or inquire widget state. If statespec is specified, sets the widget state according to it and return a new statespec indicating which flags were changed. If statespec is not specified, returns the currently-enabled state flags.", 
        "name": "tkinter.ttk.Widget.state", 
        "params": [], 
        "path": "python/library/tkinter.ttk#tkinter.ttk.Widget.state", 
        "syntax": "state(statespec=None)", 
        "type": "Tk"
    }, 
    "to_bytes": {
        "descr": "Return an array of bytes representing an integer.", 
        "name": "int.to_bytes", 
        "params": [], 
        "path": "python/library/stdtypes#int.to_bytes", 
        "syntax": "int.to_bytes(length, byteorder, *, signed=False)", 
        "type": "Built-in Types"
    }, 
    "tobytes": {
        "descr": "Convert the array to an array of machine values and return the bytes representation (the same sequence of bytes that would be written to a file by the tofile() method.)", 
        "name": "array.array.tobytes", 
        "params": [], 
        "path": "python/library/array#array.array.tobytes", 
        "syntax": "array.tobytes()", 
        "type": "Data Types"
    }, 
    "tofile": {
        "descr": "Write all items (as machine values) to the file object f.", 
        "name": "array.array.tofile", 
        "params": [], 
        "path": "python/library/array#array.array.tofile", 
        "syntax": "array.tofile(f)", 
        "type": "Data Types"
    }, 
    "tolist": {
        "descr": "Convert the array to an ordinary list with the same items.", 
        "name": "array.array.tolist", 
        "params": [], 
        "path": "python/library/array#array.array.tolist", 
        "syntax": "array.tolist()", 
        "type": "Data Types"
    }, 
    "tostring": {
        "descr": "Deprecated alias for tobytes().", 
        "name": "array.array.tostring", 
        "params": [], 
        "path": "python/library/array#array.array.tostring", 
        "syntax": "array.tostring()", 
        "type": "Data Types"
    }, 
    "tounicode": {
        "descr": "Convert the array to a unicode string. The array must be a type 'u' array; otherwise a ValueError is raised. Use array.tobytes().decode(enc) to obtain a unicode string from an array of some other type.", 
        "name": "array.array.tounicode", 
        "params": [], 
        "path": "python/library/array#array.array.tounicode", 
        "syntax": "array.tounicode()", 
        "type": "Data Types"
    }, 
    "trace.CoverageResults": {
        "descr": "A container for coverage results, created by Trace.results(). Should not be created directly by the user.", 
        "name": "trace.CoverageResults", 
        "params": [], 
        "path": "python/library/trace#trace.CoverageResults", 
        "syntax": "class trace.CoverageResults", 
        "type": "Debugging & Profiling"
    }, 
    "trace.CoverageResults.update": {
        "descr": "Merge in data from another CoverageResults object.", 
        "name": "trace.CoverageResults.update", 
        "params": [], 
        "path": "python/library/trace#trace.CoverageResults.update", 
        "syntax": "update(other)", 
        "type": "Debugging & Profiling"
    }, 
    "trace.CoverageResults.write_results": {
        "descr": "Write coverage results. Set show_missing to show lines that had no hits. Set summary to include in the output the coverage summary per module. coverdir specifies the directory into which the coverage result files will be output. If None, the results for each source file are placed in its directory.", 
        "name": "trace.CoverageResults.write_results", 
        "params": [], 
        "path": "python/library/trace#trace.CoverageResults.write_results", 
        "syntax": "write_results(show_missing=True, summary=False, coverdir=None)", 
        "type": "Debugging & Profiling"
    }, 
    "trace.Trace": {
        "descr": "Create an object to trace execution of a single statement or expression. All parameters are optional. count enables counting of line numbers. trace enables line execution tracing. countfuncs enables listing of the functions called during the run. countcallers enables call relationship tracking. ignoremods is a list of modules or packages to ignore. ignoredirs is a list of directories whose modules or packages should be ignored. infile is the name of the file from which to read stored count information. outfile is the name of the file in which to write updated count information. timing enables a timestamp relative to when tracing was started to be displayed.", 
        "name": "trace.Trace", 
        "params": [], 
        "path": "python/library/trace#trace.Trace", 
        "syntax": "class trace.Trace(count=1, trace=1, countfuncs=0, countcallers=0, ignoremods=(), ignoredirs=(), infile=None, outfile=None, timing=False)", 
        "type": "Debugging & Profiling"
    }, 
    "trace.Trace.results": {
        "descr": "Return a CoverageResults object that contains the cumulative results of all previous calls to run, runctx and runfunc for the given Trace instance. Does not reset the accumulated trace results.", 
        "name": "trace.Trace.results", 
        "params": [], 
        "path": "python/library/trace#trace.Trace.results", 
        "syntax": "results()", 
        "type": "Debugging & Profiling"
    }, 
    "trace.Trace.run": {
        "descr": "Execute the command and gather statistics from the execution with the current tracing parameters. cmd must be a string or code object, suitable for passing into exec().", 
        "name": "trace.Trace.run", 
        "params": [], 
        "path": "python/library/trace#trace.Trace.run", 
        "syntax": "run(cmd)", 
        "type": "Debugging & Profiling"
    }, 
    "trace.Trace.runctx": {
        "descr": "Execute the command and gather statistics from the execution with the current tracing parameters, in the defined global and local environments. If not defined, globals and locals default to empty dictionaries.", 
        "name": "trace.Trace.runctx", 
        "params": [], 
        "path": "python/library/trace#trace.Trace.runctx", 
        "syntax": "runctx(cmd, globals=None, locals=None)", 
        "type": "Debugging & Profiling"
    }, 
    "trace.Trace.runfunc": {
        "descr": "Call func with the given arguments under control of the Trace object with the current tracing parameters.", 
        "name": "trace.Trace.runfunc", 
        "params": [], 
        "path": "python/library/trace#trace.Trace.runfunc", 
        "syntax": "runfunc(func, *args, **kwds)", 
        "type": "Debugging & Profiling"
    }, 
    "traceback.extract_stack": {
        "descr": "Extract the raw traceback from the current stack frame. The return value has the same format as for extract_tb(). The optional f and limit arguments have the same meaning as for print_stack().", 
        "name": "traceback.extract_stack", 
        "params": [], 
        "path": "python/library/traceback#traceback.extract_stack", 
        "syntax": "traceback.extract_stack(f=None, limit=None)", 
        "type": "Runtime"
    }, 
    "traceback.extract_tb": {
        "descr": "Return a list of up to limit \u201cpre-processed\u201d stack trace entries extracted from the traceback object traceback. It is useful for alternate formatting of stack traces. If limit is omitted or None, all entries are extracted. A \u201cpre-processed\u201d stack trace entry is a quadruple (filename, line number, function name, text) representing the information that is usually printed for a stack trace. The text is a string with leading and trailing whitespace stripped; if the source is not available it is None.", 
        "name": "traceback.extract_tb", 
        "params": [], 
        "path": "python/library/traceback#traceback.extract_tb", 
        "syntax": "traceback.extract_tb(traceback, limit=None)", 
        "type": "Runtime"
    }, 
    "traceback.format_exc": {
        "descr": "This is like print_exc(limit) but returns a string instead of printing to a file.", 
        "name": "traceback.format_exc", 
        "params": [], 
        "path": "python/library/traceback#traceback.format_exc", 
        "syntax": "traceback.format_exc(limit=None, chain=True)", 
        "type": "Runtime"
    }, 
    "traceback.format_exception": {
        "descr": "Format a stack trace and the exception information. The arguments have the same meaning as the corresponding arguments to print_exception(). The return value is a list of strings, each ending in a newline and some containing internal newlines. When these lines are concatenated and printed, exactly the same text is printed as does print_exception().", 
        "name": "traceback.format_exception", 
        "params": [], 
        "path": "python/library/traceback#traceback.format_exception", 
        "syntax": "traceback.format_exception(type, value, tb, limit=None, chain=True)", 
        "type": "Runtime"
    }, 
    "traceback.format_exception_only": {
        "descr": "Format the exception part of a traceback. The arguments are the exception type and value such as given by sys.last_type and sys.last_value. The return value is a list of strings, each ending in a newline. Normally, the list contains a single string; however, for SyntaxError exceptions, it contains several lines that (when printed) display detailed information about where the syntax error occurred. The message indicating which exception occurred is the always last string in the list.", 
        "name": "traceback.format_exception_only", 
        "params": [], 
        "path": "python/library/traceback#traceback.format_exception_only", 
        "syntax": "traceback.format_exception_only(type, value)", 
        "type": "Runtime"
    }, 
    "traceback.format_list": {
        "descr": "Given a list of tuples as returned by extract_tb() or extract_stack(), return a list of strings ready for printing. Each string in the resulting list corresponds to the item with the same index in the argument list. Each string ends in a newline; the strings may contain internal newlines as well, for those items whose source text line is not None.", 
        "name": "traceback.format_list", 
        "params": [], 
        "path": "python/library/traceback#traceback.format_list", 
        "syntax": "traceback.format_list(list)", 
        "type": "Runtime"
    }, 
    "traceback.format_stack": {
        "descr": "A shorthand for format_list(extract_stack(f, limit)).", 
        "name": "traceback.format_stack", 
        "params": [], 
        "path": "python/library/traceback#traceback.format_stack", 
        "syntax": "traceback.format_stack(f=None, limit=None)", 
        "type": "Runtime"
    }, 
    "traceback.format_tb": {
        "descr": "A shorthand for format_list(extract_tb(tb, limit)).", 
        "name": "traceback.format_tb", 
        "params": [], 
        "path": "python/library/traceback#traceback.format_tb", 
        "syntax": "traceback.format_tb(tb, limit=None)", 
        "type": "Runtime"
    }, 
    "traceback.print_exc": {
        "descr": "This is a shorthand for print_exception(*sys.exc_info()).", 
        "name": "traceback.print_exc", 
        "params": [], 
        "path": "python/library/traceback#traceback.print_exc", 
        "syntax": "traceback.print_exc(limit=None, file=None, chain=True)", 
        "type": "Runtime"
    }, 
    "traceback.print_exception": {
        "descr": "Print exception information and up to limit stack trace entries from traceback to file. This differs from print_tb() in the following ways:", 
        "name": "traceback.print_exception", 
        "params": [], 
        "path": "python/library/traceback#traceback.print_exception", 
        "syntax": "traceback.print_exception(type, value, traceback, limit=None, file=None, chain=True)", 
        "type": "Runtime"
    }, 
    "traceback.print_last": {
        "descr": "This is a shorthand for print_exception(sys.last_type, sys.last_value, sys.last_traceback, limit, file). In general it will work only after an exception has reached an interactive prompt (see sys.last_type).", 
        "name": "traceback.print_last", 
        "params": [], 
        "path": "python/library/traceback#traceback.print_last", 
        "syntax": "traceback.print_last(limit=None, file=None, chain=True)", 
        "type": "Runtime"
    }, 
    "traceback.print_stack": {
        "descr": "This function prints a stack trace from its invocation point. The optional f argument can be used to specify an alternate stack frame to start. The optional limit and file arguments have the same meaning as for print_exception().", 
        "name": "traceback.print_stack", 
        "params": [], 
        "path": "python/library/traceback#traceback.print_stack", 
        "syntax": "traceback.print_stack(f=None, limit=None, file=None)", 
        "type": "Runtime"
    }, 
    "traceback.print_tb": {
        "descr": "Print up to limit stack trace entries from traceback. If limit is omitted or None, all entries are printed. If file is omitted or None, the output goes to sys.stderr; otherwise it should be an open file or file-like object to receive the output.", 
        "name": "traceback.print_tb", 
        "params": [], 
        "path": "python/library/traceback#traceback.print_tb", 
        "syntax": "traceback.print_tb(traceback, limit=None, file=None)", 
        "type": "Runtime"
    }, 
    "translate": {
        "descr": "Return a copy of the s where all characters have been mapped through the map which must be a dictionary of Unicode ordinals (integers) to Unicode ordinals, strings or None. Unmapped characters are left untouched. Characters mapped to None are deleted.", 
        "name": "str.translate", 
        "params": [], 
        "path": "python/library/stdtypes#str.translate", 
        "syntax": "str.translate(map)", 
        "type": "Built-in Types"
    }, 
    "tty.setcbreak": {
        "descr": "Change the mode of file descriptor fd to cbreak. If when is omitted, it defaults to termios.TCSAFLUSH, and is passed to termios.tcsetattr().", 
        "name": "tty.setcbreak", 
        "params": [], 
        "path": "python/library/tty#tty.setcbreak", 
        "syntax": "tty.setcbreak(fd, when=termios.TCSAFLUSH)", 
        "type": "Unix"
    }, 
    "tty.setraw": {
        "descr": "Change the mode of the file descriptor fd to raw. If when is omitted, it defaults to termios.TCSAFLUSH, and is passed to termios.tcsetattr().", 
        "name": "tty.setraw", 
        "params": [], 
        "path": "python/library/tty#tty.setraw", 
        "syntax": "tty.setraw(fd, when=termios.TCSAFLUSH)", 
        "type": "Unix"
    }, 
    "tuple": {
        "descr": "Rather than being a function, tuple is actually an immutable sequence type, as documented in Tuples and Sequence Types \u2014 list, tuple, range.", 
        "name": "tuple", 
        "params": [], 
        "path": "python/library/functions#tuple", 
        "syntax": "tuple([iterable])", 
        "type": "Built-in Functions"
    }, 
    "turtle.RawPen": {
        "descr": "Create a turtle. The turtle has all methods described above as \u201cmethods of Turtle/RawTurtle\u201d.", 
        "name": "turtle.RawPen", 
        "params": [], 
        "path": "python/library/turtle#turtle.RawPen", 
        "syntax": "class turtle.RawPen(canvas)", 
        "type": "Frameworks"
    }, 
    "turtle.RawTurtle": {
        "descr": "Create a turtle. The turtle has all methods described above as \u201cmethods of Turtle/RawTurtle\u201d.", 
        "name": "turtle.RawTurtle", 
        "params": [], 
        "path": "python/library/turtle#turtle.RawTurtle", 
        "syntax": "class turtle.RawTurtle(canvas)", 
        "type": "Frameworks"
    }, 
    "turtle.Screen": {
        "descr": "Subclass of TurtleScreen, with four methods added.", 
        "name": "turtle.Screen", 
        "params": [], 
        "path": "python/library/turtle#turtle.Screen", 
        "syntax": "class turtle.Screen", 
        "type": "Frameworks"
    }, 
    "turtle.ScrolledCanvas": {
        "descr": "Used by class Screen, which thus automatically provides a ScrolledCanvas as playground for the turtles.", 
        "name": "turtle.ScrolledCanvas", 
        "params": [], 
        "path": "python/library/turtle#turtle.ScrolledCanvas", 
        "syntax": "class turtle.ScrolledCanvas(master)", 
        "type": "Frameworks"
    }, 
    "turtle.Shape": {
        "descr": "Data structure modeling shapes. The pair (type_, data) must follow this specification:", 
        "name": "turtle.Shape", 
        "params": [], 
        "path": "python/library/turtle#turtle.Shape", 
        "syntax": "class turtle.Shape(type_, data)", 
        "type": "Frameworks"
    }, 
    "turtle.Shape.addcomponent": {
        "descr": "Example:", 
        "name": "turtle.Shape.addcomponent", 
        "params": [], 
        "path": "python/library/turtle#turtle.Shape.addcomponent", 
        "syntax": "addcomponent(poly, fill, outline=None)", 
        "type": "Frameworks"
    }, 
    "turtle.Turtle": {
        "descr": "Subclass of RawTurtle, has the same interface but draws on a default Screen object created automatically when needed for the first time.", 
        "name": "turtle.Turtle", 
        "params": [], 
        "path": "python/library/turtle#turtle.Turtle", 
        "syntax": "class turtle.Turtle", 
        "type": "Frameworks"
    }, 
    "turtle.TurtleScreen": {
        "descr": "Provides screen oriented methods like setbg() etc. that are described above.", 
        "name": "turtle.TurtleScreen", 
        "params": [], 
        "path": "python/library/turtle#turtle.TurtleScreen", 
        "syntax": "class turtle.TurtleScreen(cv)", 
        "type": "Frameworks"
    }, 
    "turtle.Vec2D": {
        "descr": "A two-dimensional vector class, used as a helper class for implementing turtle graphics. May be useful for turtle graphics programs too. Derived from tuple, so a vector is a tuple!", 
        "name": "turtle.Vec2D", 
        "params": [], 
        "path": "python/library/turtle#turtle.Vec2D", 
        "syntax": "class turtle.Vec2D(x, y)", 
        "type": "Frameworks"
    }, 
    "turtle.addshape": {
        "descr": "There are three different ways to call this function:", 
        "name": "turtle.addshape", 
        "params": [], 
        "path": "python/library/turtle#turtle.addshape", 
        "syntax": "turtle.addshape(name, shape=None)", 
        "type": "Frameworks"
    }, 
    "turtle.back": {
        "descr": "Move the turtle backward by distance, opposite to the direction the turtle is headed. Do not change the turtle\u2019s heading.", 
        "name": "turtle.back", 
        "params": [], 
        "path": "python/library/turtle#turtle.back", 
        "syntax": "turtle.back(distance)", 
        "type": "Frameworks"
    }, 
    "turtle.backward": {
        "descr": "Move the turtle backward by distance, opposite to the direction the turtle is headed. Do not change the turtle\u2019s heading.", 
        "name": "turtle.backward", 
        "params": [], 
        "path": "python/library/turtle#turtle.backward", 
        "syntax": "turtle.backward(distance)", 
        "type": "Frameworks"
    }, 
    "turtle.begin_fill": {
        "descr": "To be called just before drawing a shape to be filled.", 
        "name": "turtle.begin_fill", 
        "params": [], 
        "path": "python/library/turtle#turtle.begin_fill", 
        "syntax": "turtle.begin_fill()", 
        "type": "Frameworks"
    }, 
    "turtle.begin_poly": {
        "descr": "Start recording the vertices of a polygon. Current turtle position is first vertex of polygon.", 
        "name": "turtle.begin_poly", 
        "params": [], 
        "path": "python/library/turtle#turtle.begin_poly", 
        "syntax": "turtle.begin_poly()", 
        "type": "Frameworks"
    }, 
    "turtle.bgcolor": {
        "descr": "Set or return background color of the TurtleScreen.", 
        "name": "turtle.bgcolor", 
        "params": [], 
        "path": "python/library/turtle#turtle.bgcolor", 
        "syntax": "turtle.bgcolor(*args)", 
        "type": "Frameworks"
    }, 
    "turtle.bgpic": {
        "descr": "Set background image or return name of current backgroundimage. If picname is a filename, set the corresponding image as background. If picname is \"nopic\", delete background image, if present. If picname is None, return the filename of the current backgroundimage.", 
        "name": "turtle.bgpic", 
        "params": [], 
        "path": "python/library/turtle#turtle.bgpic", 
        "syntax": "turtle.bgpic(picname=None)", 
        "type": "Frameworks"
    }, 
    "turtle.bk": {
        "descr": "Move the turtle backward by distance, opposite to the direction the turtle is headed. Do not change the turtle\u2019s heading.", 
        "name": "turtle.bk", 
        "params": [], 
        "path": "python/library/turtle#turtle.bk", 
        "syntax": "turtle.bk(distance)", 
        "type": "Frameworks"
    }, 
    "turtle.bye": {
        "descr": "Shut the turtlegraphics window.", 
        "name": "turtle.bye", 
        "params": [], 
        "path": "python/library/turtle#turtle.bye", 
        "syntax": "turtle.bye()", 
        "type": "Frameworks"
    }, 
    "turtle.circle": {
        "descr": "Draw a circle with given radius. The center is radius units left of the turtle; extent \u2013 an angle \u2013 determines which part of the circle is drawn. If extent is not given, draw the entire circle. If extent is not a full circle, one endpoint of the arc is the current pen position. Draw the arc in counterclockwise direction if radius is positive, otherwise in clockwise direction. Finally the direction of the turtle is changed by the amount of extent.", 
        "name": "turtle.circle", 
        "params": [], 
        "path": "python/library/turtle#turtle.circle", 
        "syntax": "turtle.circle(radius, extent=None, steps=None)", 
        "type": "Frameworks"
    }, 
    "turtle.clear": {
        "descr": "Delete the turtle\u2019s drawings from the screen. Do not move turtle. State and position of the turtle as well as drawings of other turtles are not affected.", 
        "name": "turtle.clear", 
        "params": [], 
        "path": "python/library/turtle#turtle.clear", 
        "syntax": "turtle.clear()", 
        "type": "Frameworks"
    }, 
    "turtle.clearscreen": {
        "descr": "Delete all drawings and all turtles from the TurtleScreen. Reset the now empty TurtleScreen to its initial state: white background, no background image, no event bindings and tracing on.", 
        "name": "turtle.clearscreen", 
        "params": [], 
        "path": "python/library/turtle#turtle.clearscreen", 
        "syntax": "turtle.clearscreen()", 
        "type": "Frameworks"
    }, 
    "turtle.clearstamp": {
        "descr": "Delete stamp with given stampid.", 
        "name": "turtle.clearstamp", 
        "params": [], 
        "path": "python/library/turtle#turtle.clearstamp", 
        "syntax": "turtle.clearstamp(stampid)", 
        "type": "Frameworks"
    }, 
    "turtle.clearstamps": {
        "descr": "Delete all or first/last n of turtle\u2019s stamps. If n is None, delete all stamps, if n > 0 delete first n stamps, else if n < 0 delete last n stamps.", 
        "name": "turtle.clearstamps", 
        "params": [], 
        "path": "python/library/turtle#turtle.clearstamps", 
        "syntax": "turtle.clearstamps(n=None)", 
        "type": "Frameworks"
    }, 
    "turtle.clone": {
        "descr": "Create and return a clone of the turtle with same position, heading and turtle properties.", 
        "name": "turtle.clone", 
        "params": [], 
        "path": "python/library/turtle#turtle.clone", 
        "syntax": "turtle.clone()", 
        "type": "Frameworks"
    }, 
    "turtle.color": {
        "descr": "Return or set pencolor and fillcolor.", 
        "name": "turtle.color", 
        "params": [], 
        "path": "python/library/turtle#turtle.color", 
        "syntax": "turtle.color(*args)", 
        "type": "Frameworks"
    }, 
    "turtle.colormode": {
        "descr": "Return the colormode or set it to 1.0 or 255. Subsequently r, g, b values of color triples have to be in the range 0..cmode.", 
        "name": "turtle.colormode", 
        "params": [], 
        "path": "python/library/turtle#turtle.colormode", 
        "syntax": "turtle.colormode(cmode=None)", 
        "type": "Frameworks"
    }, 
    "turtle.degrees": {
        "descr": "Set angle measurement units, i.e. set number of \u201cdegrees\u201d for a full circle. Default value is 360 degrees.", 
        "name": "turtle.degrees", 
        "params": [], 
        "path": "python/library/turtle#turtle.degrees", 
        "syntax": "turtle.degrees(fullcircle=360.0)", 
        "type": "Frameworks"
    }, 
    "turtle.delay": {
        "descr": "Set or return the drawing delay in milliseconds. (This is approximately the time interval between two consecutive canvas updates.) The longer the drawing delay, the slower the animation.", 
        "name": "turtle.delay", 
        "params": [], 
        "path": "python/library/turtle#turtle.delay", 
        "syntax": "turtle.delay(delay=None)", 
        "type": "Frameworks"
    }, 
    "turtle.distance": {
        "descr": "Return the distance from the turtle to (x,y), the given vector, or the given other turtle, in turtle step units.", 
        "name": "turtle.distance", 
        "params": [], 
        "path": "python/library/turtle#turtle.distance", 
        "syntax": "turtle.distance(x, y=None)", 
        "type": "Frameworks"
    }, 
    "turtle.done": {
        "descr": "Starts event loop - calling Tkinter\u2019s mainloop function. Must be the last statement in a turtle graphics program. Must not be used if a script is run from within IDLE in -n mode (No subprocess) - for interactive use of turtle graphics.", 
        "name": "turtle.done", 
        "params": [], 
        "path": "python/library/turtle#turtle.done", 
        "syntax": "turtle.done()", 
        "type": "Frameworks"
    }, 
    "turtle.dot": {
        "descr": "Draw a circular dot with diameter size, using color. If size is not given, the maximum of pensize+4 and 2*pensize is used.", 
        "name": "turtle.dot", 
        "params": [], 
        "path": "python/library/turtle#turtle.dot", 
        "syntax": "turtle.dot(size=None, *color)", 
        "type": "Frameworks"
    }, 
    "turtle.down": {
        "descr": "Pull the pen down \u2013 drawing when moving.", 
        "name": "turtle.down", 
        "params": [], 
        "path": "python/library/turtle#turtle.down", 
        "syntax": "turtle.down()", 
        "type": "Frameworks"
    }, 
    "turtle.end_fill": {
        "descr": "Fill the shape drawn after the last call to begin_fill().", 
        "name": "turtle.end_fill", 
        "params": [], 
        "path": "python/library/turtle#turtle.end_fill", 
        "syntax": "turtle.end_fill()", 
        "type": "Frameworks"
    }, 
    "turtle.end_poly": {
        "descr": "Stop recording the vertices of a polygon. Current turtle position is last vertex of polygon. This will be connected with the first vertex.", 
        "name": "turtle.end_poly", 
        "params": [], 
        "path": "python/library/turtle#turtle.end_poly", 
        "syntax": "turtle.end_poly()", 
        "type": "Frameworks"
    }, 
    "turtle.exitonclick": {
        "descr": "Bind bye() method to mouse clicks on the Screen.", 
        "name": "turtle.exitonclick", 
        "params": [], 
        "path": "python/library/turtle#turtle.exitonclick", 
        "syntax": "turtle.exitonclick()", 
        "type": "Frameworks"
    }, 
    "turtle.fd": {
        "descr": "Move the turtle forward by the specified distance, in the direction the turtle is headed.", 
        "name": "turtle.fd", 
        "params": [], 
        "path": "python/library/turtle#turtle.fd", 
        "syntax": "turtle.fd(distance)", 
        "type": "Frameworks"
    }, 
    "turtle.fillcolor": {
        "descr": "Return or set the fillcolor.", 
        "name": "turtle.fillcolor", 
        "params": [], 
        "path": "python/library/turtle#turtle.fillcolor", 
        "syntax": "turtle.fillcolor(*args)", 
        "type": "Frameworks"
    }, 
    "turtle.filling": {
        "descr": "Return fillstate (True if filling, False else).", 
        "name": "turtle.filling", 
        "params": [], 
        "path": "python/library/turtle#turtle.filling", 
        "syntax": "turtle.filling()", 
        "type": "Frameworks"
    }, 
    "turtle.forward": {
        "descr": "Move the turtle forward by the specified distance, in the direction the turtle is headed.", 
        "name": "turtle.forward", 
        "params": [], 
        "path": "python/library/turtle#turtle.forward", 
        "syntax": "turtle.forward(distance)", 
        "type": "Frameworks"
    }, 
    "turtle.get_poly": {
        "descr": "Return the last recorded polygon.", 
        "name": "turtle.get_poly", 
        "params": [], 
        "path": "python/library/turtle#turtle.get_poly", 
        "syntax": "turtle.get_poly()", 
        "type": "Frameworks"
    }, 
    "turtle.get_shapepoly": {
        "descr": "Return the current shape polygon as tuple of coordinate pairs. This can be used to define a new shape or components of a compound shape.", 
        "name": "turtle.get_shapepoly", 
        "params": [], 
        "path": "python/library/turtle#turtle.get_shapepoly", 
        "syntax": "turtle.get_shapepoly()", 
        "type": "Frameworks"
    }, 
    "turtle.getcanvas": {
        "descr": "Return the Canvas of this TurtleScreen. Useful for insiders who know what to do with a Tkinter Canvas.", 
        "name": "turtle.getcanvas", 
        "params": [], 
        "path": "python/library/turtle#turtle.getcanvas", 
        "syntax": "turtle.getcanvas()", 
        "type": "Frameworks"
    }, 
    "turtle.getpen": {
        "descr": "Return the Turtle object itself. Only reasonable use: as a function to return the \u201canonymous turtle\u201d:", 
        "name": "turtle.getpen", 
        "params": [], 
        "path": "python/library/turtle#turtle.getpen", 
        "syntax": "turtle.getpen()", 
        "type": "Frameworks"
    }, 
    "turtle.getscreen": {
        "descr": "Return the TurtleScreen object the turtle is drawing on. TurtleScreen methods can then be called for that object.", 
        "name": "turtle.getscreen", 
        "params": [], 
        "path": "python/library/turtle#turtle.getscreen", 
        "syntax": "turtle.getscreen()", 
        "type": "Frameworks"
    }, 
    "turtle.getshapes": {
        "descr": "Return a list of names of all currently available turtle shapes.", 
        "name": "turtle.getshapes", 
        "params": [], 
        "path": "python/library/turtle#turtle.getshapes", 
        "syntax": "turtle.getshapes()", 
        "type": "Frameworks"
    }, 
    "turtle.getturtle": {
        "descr": "Return the Turtle object itself. Only reasonable use: as a function to return the \u201canonymous turtle\u201d:", 
        "name": "turtle.getturtle", 
        "params": [], 
        "path": "python/library/turtle#turtle.getturtle", 
        "syntax": "turtle.getturtle()", 
        "type": "Frameworks"
    }, 
    "turtle.goto": {
        "descr": "If y is None, x must be a pair of coordinates or a Vec2D (e.g. as returned by pos()).", 
        "name": "turtle.goto", 
        "params": [], 
        "path": "python/library/turtle#turtle.goto", 
        "syntax": "turtle.goto(x, y=None)", 
        "type": "Frameworks"
    }, 
    "turtle.heading": {
        "descr": "Return the turtle\u2019s current heading (value depends on the turtle mode, see mode()).", 
        "name": "turtle.heading", 
        "params": [], 
        "path": "python/library/turtle#turtle.heading", 
        "syntax": "turtle.heading()", 
        "type": "Frameworks"
    }, 
    "turtle.hideturtle": {
        "descr": "Make the turtle invisible. It\u2019s a good idea to do this while you\u2019re in the middle of doing some complex drawing, because hiding the turtle speeds up the drawing observably.", 
        "name": "turtle.hideturtle", 
        "params": [], 
        "path": "python/library/turtle#turtle.hideturtle", 
        "syntax": "turtle.hideturtle()", 
        "type": "Frameworks"
    }, 
    "turtle.home": {
        "descr": "Move turtle to the origin \u2013 coordinates (0,0) \u2013 and set its heading to its start-orientation (which depends on the mode, see mode()).", 
        "name": "turtle.home", 
        "params": [], 
        "path": "python/library/turtle#turtle.home", 
        "syntax": "turtle.home()", 
        "type": "Frameworks"
    }, 
    "turtle.ht": {
        "descr": "Make the turtle invisible. It\u2019s a good idea to do this while you\u2019re in the middle of doing some complex drawing, because hiding the turtle speeds up the drawing observably.", 
        "name": "turtle.ht", 
        "params": [], 
        "path": "python/library/turtle#turtle.ht", 
        "syntax": "turtle.ht()", 
        "type": "Frameworks"
    }, 
    "turtle.isdown": {
        "descr": "Return True if pen is down, False if it\u2019s up.", 
        "name": "turtle.isdown", 
        "params": [], 
        "path": "python/library/turtle#turtle.isdown", 
        "syntax": "turtle.isdown()", 
        "type": "Frameworks"
    }, 
    "turtle.isvisible": {
        "descr": "Return True if the Turtle is shown, False if it\u2019s hidden.", 
        "name": "turtle.isvisible", 
        "params": [], 
        "path": "python/library/turtle#turtle.isvisible", 
        "syntax": "turtle.isvisible()", 
        "type": "Frameworks"
    }, 
    "turtle.left": {
        "descr": "Turn turtle left by angle units. (Units are by default degrees, but can be set via the degrees() and radians() functions.) Angle orientation depends on the turtle mode, see mode().", 
        "name": "turtle.left", 
        "params": [], 
        "path": "python/library/turtle#turtle.left", 
        "syntax": "turtle.left(angle)", 
        "type": "Frameworks"
    }, 
    "turtle.listen": {
        "descr": "Set focus on TurtleScreen (in order to collect key-events). Dummy arguments are provided in order to be able to pass listen() to the onclick method.", 
        "name": "turtle.listen", 
        "params": [], 
        "path": "python/library/turtle#turtle.listen", 
        "syntax": "turtle.listen(xdummy=None, ydummy=None)", 
        "type": "Frameworks"
    }, 
    "turtle.lt": {
        "descr": "Turn turtle left by angle units. (Units are by default degrees, but can be set via the degrees() and radians() functions.) Angle orientation depends on the turtle mode, see mode().", 
        "name": "turtle.lt", 
        "params": [], 
        "path": "python/library/turtle#turtle.lt", 
        "syntax": "turtle.lt(angle)", 
        "type": "Frameworks"
    }, 
    "turtle.mainloop": {
        "descr": "Starts event loop - calling Tkinter\u2019s mainloop function. Must be the last statement in a turtle graphics program. Must not be used if a script is run from within IDLE in -n mode (No subprocess) - for interactive use of turtle graphics.", 
        "name": "turtle.mainloop", 
        "params": [], 
        "path": "python/library/turtle#turtle.mainloop", 
        "syntax": "turtle.mainloop()", 
        "type": "Frameworks"
    }, 
    "turtle.mode": {
        "descr": "Set turtle mode (\u201cstandard\u201d, \u201clogo\u201d or \u201cworld\u201d) and perform reset. If mode is not given, current mode is returned.", 
        "name": "turtle.mode", 
        "params": [], 
        "path": "python/library/turtle#turtle.mode", 
        "syntax": "turtle.mode(mode=None)", 
        "type": "Frameworks"
    }, 
    "turtle.numinput": {
        "descr": "Pop up a dialog window for input of a number. title is the title of the dialog window, prompt is a text mostly describing what numerical information to input. default: default value, minval: minimum value for imput, maxval: maximum value for input The number input must be in the range minval .. maxval if these are given. If not, a hint is issued and the dialog remains open for correction. Return the number input. If the dialog is canceled, return None.", 
        "name": "turtle.numinput", 
        "params": [], 
        "path": "python/library/turtle#turtle.numinput", 
        "syntax": "turtle.numinput(title, prompt, default=None, minval=None, maxval=None)", 
        "type": "Frameworks"
    }, 
    "turtle.onclick": {
        "descr": "Bind fun to mouse-click events on this turtle. If fun is None, existing bindings are removed. Example for the anonymous turtle, i.e. the procedural way:", 
        "name": "turtle.onclick", 
        "params": [], 
        "path": "python/library/turtle#turtle.onclick", 
        "syntax": "turtle.onclick(fun, btn=1, add=None)", 
        "type": "Frameworks"
    }, 
    "turtle.ondrag": {
        "descr": "Bind fun to mouse-move events on this turtle. If fun is None, existing bindings are removed.", 
        "name": "turtle.ondrag", 
        "params": [], 
        "path": "python/library/turtle#turtle.ondrag", 
        "syntax": "turtle.ondrag(fun, btn=1, add=None)", 
        "type": "Frameworks"
    }, 
    "turtle.onkey": {
        "descr": "Bind fun to key-release event of key. If fun is None, event bindings are removed. Remark: in order to be able to register key-events, TurtleScreen must have the focus. (See method listen().)", 
        "name": "turtle.onkey", 
        "params": [], 
        "path": "python/library/turtle#turtle.onkey", 
        "syntax": "turtle.onkey(fun, key)", 
        "type": "Frameworks"
    }, 
    "turtle.onkeypress": {
        "descr": "Bind fun to key-press event of key if key is given, or to any key-press-event if no key is given. Remark: in order to be able to register key-events, TurtleScreen must have focus. (See method listen().)", 
        "name": "turtle.onkeypress", 
        "params": [], 
        "path": "python/library/turtle#turtle.onkeypress", 
        "syntax": "turtle.onkeypress(fun, key=None)", 
        "type": "Frameworks"
    }, 
    "turtle.onkeyrelease": {
        "descr": "Bind fun to key-release event of key. If fun is None, event bindings are removed. Remark: in order to be able to register key-events, TurtleScreen must have the focus. (See method listen().)", 
        "name": "turtle.onkeyrelease", 
        "params": [], 
        "path": "python/library/turtle#turtle.onkeyrelease", 
        "syntax": "turtle.onkeyrelease(fun, key)", 
        "type": "Frameworks"
    }, 
    "turtle.onrelease": {
        "descr": "Bind fun to mouse-button-release events on this turtle. If fun is None, existing bindings are removed.", 
        "name": "turtle.onrelease", 
        "params": [], 
        "path": "python/library/turtle#turtle.onrelease", 
        "syntax": "turtle.onrelease(fun, btn=1, add=None)", 
        "type": "Frameworks"
    }, 
    "turtle.onscreenclick": {
        "descr": "Bind fun to mouse-click events on this screen. If fun is None, existing bindings are removed.", 
        "name": "turtle.onscreenclick", 
        "params": [], 
        "path": "python/library/turtle#turtle.onscreenclick", 
        "syntax": "turtle.onscreenclick(fun, btn=1, add=None)", 
        "type": "Frameworks"
    }, 
    "turtle.ontimer": {
        "descr": "Install a timer that calls fun after t milliseconds.", 
        "name": "turtle.ontimer", 
        "params": [], 
        "path": "python/library/turtle#turtle.ontimer", 
        "syntax": "turtle.ontimer(fun, t=0)", 
        "type": "Frameworks"
    }, 
    "turtle.pd": {
        "descr": "Pull the pen down \u2013 drawing when moving.", 
        "name": "turtle.pd", 
        "params": [], 
        "path": "python/library/turtle#turtle.pd", 
        "syntax": "turtle.pd()", 
        "type": "Frameworks"
    }, 
    "turtle.pen": {
        "descr": "Return or set the pen\u2019s attributes in a \u201cpen-dictionary\u201d with the following key/value pairs:", 
        "name": "turtle.pen", 
        "params": [], 
        "path": "python/library/turtle#turtle.pen", 
        "syntax": "turtle.pen(pen=None, **pendict)", 
        "type": "Frameworks"
    }, 
    "turtle.pencolor": {
        "descr": "Return or set the pencolor.", 
        "name": "turtle.pencolor", 
        "params": [], 
        "path": "python/library/turtle#turtle.pencolor", 
        "syntax": "turtle.pencolor(*args)", 
        "type": "Frameworks"
    }, 
    "turtle.pendown": {
        "descr": "Pull the pen down \u2013 drawing when moving.", 
        "name": "turtle.pendown", 
        "params": [], 
        "path": "python/library/turtle#turtle.pendown", 
        "syntax": "turtle.pendown()", 
        "type": "Frameworks"
    }, 
    "turtle.pensize": {
        "descr": "Set the line thickness to width or return it. If resizemode is set to \u201cauto\u201d and turtleshape is a polygon, that polygon is drawn with the same line thickness. If no argument is given, the current pensize is returned.", 
        "name": "turtle.pensize", 
        "params": [], 
        "path": "python/library/turtle#turtle.pensize", 
        "syntax": "turtle.pensize(width=None)", 
        "type": "Frameworks"
    }, 
    "turtle.penup": {
        "descr": "Pull the pen up \u2013 no drawing when moving.", 
        "name": "turtle.penup", 
        "params": [], 
        "path": "python/library/turtle#turtle.penup", 
        "syntax": "turtle.penup()", 
        "type": "Frameworks"
    }, 
    "turtle.pos": {
        "descr": "Return the turtle\u2019s current location (x,y) (as a Vec2D vector).", 
        "name": "turtle.pos", 
        "params": [], 
        "path": "python/library/turtle#turtle.pos", 
        "syntax": "turtle.pos()", 
        "type": "Frameworks"
    }, 
    "turtle.position": {
        "descr": "Return the turtle\u2019s current location (x,y) (as a Vec2D vector).", 
        "name": "turtle.position", 
        "params": [], 
        "path": "python/library/turtle#turtle.position", 
        "syntax": "turtle.position()", 
        "type": "Frameworks"
    }, 
    "turtle.pu": {
        "descr": "Pull the pen up \u2013 no drawing when moving.", 
        "name": "turtle.pu", 
        "params": [], 
        "path": "python/library/turtle#turtle.pu", 
        "syntax": "turtle.pu()", 
        "type": "Frameworks"
    }, 
    "turtle.radians": {
        "descr": "Set the angle measurement units to radians. Equivalent to degrees(2*math.pi).", 
        "name": "turtle.radians", 
        "params": [], 
        "path": "python/library/turtle#turtle.radians", 
        "syntax": "turtle.radians()", 
        "type": "Frameworks"
    }, 
    "turtle.register_shape": {
        "descr": "There are three different ways to call this function:", 
        "name": "turtle.register_shape", 
        "params": [], 
        "path": "python/library/turtle#turtle.register_shape", 
        "syntax": "turtle.register_shape(name, shape=None)", 
        "type": "Frameworks"
    }, 
    "turtle.reset": {
        "descr": "Delete the turtle\u2019s drawings from the screen, re-center the turtle and set variables to the default values.", 
        "name": "turtle.reset", 
        "params": [], 
        "path": "python/library/turtle#turtle.reset", 
        "syntax": "turtle.reset()", 
        "type": "Frameworks"
    }, 
    "turtle.resetscreen": {
        "descr": "Reset all Turtles on the Screen to their initial state.", 
        "name": "turtle.resetscreen", 
        "params": [], 
        "path": "python/library/turtle#turtle.resetscreen", 
        "syntax": "turtle.resetscreen()", 
        "type": "Frameworks"
    }, 
    "turtle.resizemode": {
        "descr": "Set resizemode to one of the values: \u201cauto\u201d, \u201cuser\u201d, \u201cnoresize\u201d. If rmode is not given, return current resizemode. Different resizemodes have the following effects:", 
        "name": "turtle.resizemode", 
        "params": [], 
        "path": "python/library/turtle#turtle.resizemode", 
        "syntax": "turtle.resizemode(rmode=None)", 
        "type": "Frameworks"
    }, 
    "turtle.right": {
        "descr": "Turn turtle right by angle units. (Units are by default degrees, but can be set via the degrees() and radians() functions.) Angle orientation depends on the turtle mode, see mode().", 
        "name": "turtle.right", 
        "params": [], 
        "path": "python/library/turtle#turtle.right", 
        "syntax": "turtle.right(angle)", 
        "type": "Frameworks"
    }, 
    "turtle.rt": {
        "descr": "Turn turtle right by angle units. (Units are by default degrees, but can be set via the degrees() and radians() functions.) Angle orientation depends on the turtle mode, see mode().", 
        "name": "turtle.rt", 
        "params": [], 
        "path": "python/library/turtle#turtle.rt", 
        "syntax": "turtle.rt(angle)", 
        "type": "Frameworks"
    }, 
    "turtle.screensize": {
        "descr": "If no arguments are given, return current (canvaswidth, canvasheight). Else resize the canvas the turtles are drawing on. Do not alter the drawing window. To observe hidden parts of the canvas, use the scrollbars. With this method, one can make visible those parts of a drawing which were outside the canvas before.", 
        "name": "turtle.screensize", 
        "params": [], 
        "path": "python/library/turtle#turtle.screensize", 
        "syntax": "turtle.screensize(canvwidth=None, canvheight=None, bg=None)", 
        "type": "Frameworks"
    }, 
    "turtle.seth": {
        "descr": "Set the orientation of the turtle to to_angle. Here are some common directions in degrees:", 
        "name": "turtle.seth", 
        "params": [], 
        "path": "python/library/turtle#turtle.seth", 
        "syntax": "turtle.seth(to_angle)", 
        "type": "Frameworks"
    }, 
    "turtle.setheading": {
        "descr": "Set the orientation of the turtle to to_angle. Here are some common directions in degrees:", 
        "name": "turtle.setheading", 
        "params": [], 
        "path": "python/library/turtle#turtle.setheading", 
        "syntax": "turtle.setheading(to_angle)", 
        "type": "Frameworks"
    }, 
    "turtle.setpos": {
        "descr": "If y is None, x must be a pair of coordinates or a Vec2D (e.g. as returned by pos()).", 
        "name": "turtle.setpos", 
        "params": [], 
        "path": "python/library/turtle#turtle.setpos", 
        "syntax": "turtle.setpos(x, y=None)", 
        "type": "Frameworks"
    }, 
    "turtle.setposition": {
        "descr": "If y is None, x must be a pair of coordinates or a Vec2D (e.g. as returned by pos()).", 
        "name": "turtle.setposition", 
        "params": [], 
        "path": "python/library/turtle#turtle.setposition", 
        "syntax": "turtle.setposition(x, y=None)", 
        "type": "Frameworks"
    }, 
    "turtle.settiltangle": {
        "descr": "Rotate the turtleshape to point in the direction specified by angle, regardless of its current tilt-angle. Do not change the turtle\u2019s heading (direction of movement).", 
        "name": "turtle.settiltangle", 
        "params": [], 
        "path": "python/library/turtle#turtle.settiltangle", 
        "syntax": "turtle.settiltangle(angle)", 
        "type": "Frameworks"
    }, 
    "turtle.setundobuffer": {
        "descr": "Set or disable undobuffer. If size is an integer an empty undobuffer of given size is installed. size gives the maximum number of turtle actions that can be undone by the undo() method/function. If size is None, the undobuffer is disabled.", 
        "name": "turtle.setundobuffer", 
        "params": [], 
        "path": "python/library/turtle#turtle.setundobuffer", 
        "syntax": "turtle.setundobuffer(size)", 
        "type": "Frameworks"
    }, 
    "turtle.setup": {
        "descr": "Set the size and position of the main window. Default values of arguments are stored in the configuration dictionary and can be changed via a turtle.cfg file.", 
        "name": "turtle.setup", 
        "params": [], 
        "path": "python/library/turtle#turtle.setup", 
        "syntax": "turtle.setup(width=_CFG[\"width\"], height=_CFG[\"height\"], startx=_CFG[\"leftright\"], starty=_CFG[\"topbottom\"])", 
        "type": "Frameworks"
    }, 
    "turtle.setworldcoordinates": {
        "descr": "Set up user-defined coordinate system and switch to mode \u201cworld\u201d if necessary. This performs a screen.reset(). If mode \u201cworld\u201d is already active, all drawings are redrawn according to the new coordinates.", 
        "name": "turtle.setworldcoordinates", 
        "params": [], 
        "path": "python/library/turtle#turtle.setworldcoordinates", 
        "syntax": "turtle.setworldcoordinates(llx, lly, urx, ury)", 
        "type": "Frameworks"
    }, 
    "turtle.setx": {
        "descr": "Set the turtle\u2019s first coordinate to x, leave second coordinate unchanged.", 
        "name": "turtle.setx", 
        "params": [], 
        "path": "python/library/turtle#turtle.setx", 
        "syntax": "turtle.setx(x)", 
        "type": "Frameworks"
    }, 
    "turtle.sety": {
        "descr": "Set the turtle\u2019s second coordinate to y, leave first coordinate unchanged.", 
        "name": "turtle.sety", 
        "params": [], 
        "path": "python/library/turtle#turtle.sety", 
        "syntax": "turtle.sety(y)", 
        "type": "Frameworks"
    }, 
    "turtle.shape": {
        "descr": "Set turtle shape to shape with given name or, if name is not given, return name of current shape. Shape with name must exist in the TurtleScreen\u2019s shape dictionary. Initially there are the following polygon shapes: \u201carrow\u201d, \u201cturtle\u201d, \u201ccircle\u201d, \u201csquare\u201d, \u201ctriangle\u201d, \u201cclassic\u201d. To learn about how to deal with shapes see Screen method register_shape().", 
        "name": "turtle.shape", 
        "params": [], 
        "path": "python/library/turtle#turtle.shape", 
        "syntax": "turtle.shape(name=None)", 
        "type": "Frameworks"
    }, 
    "turtle.shapesize": {
        "descr": "Return or set the pen\u2019s attributes x/y-stretchfactors and/or outline. Set resizemode to \u201cuser\u201d. If and only if resizemode is set to \u201cuser\u201d, the turtle will be displayed stretched according to its stretchfactors: stretch_wid is stretchfactor perpendicular to its orientation, stretch_len is stretchfactor in direction of its orientation, outline determines the width of the shapes\u2019s outline.", 
        "name": "turtle.shapesize", 
        "params": [], 
        "path": "python/library/turtle#turtle.shapesize", 
        "syntax": "turtle.shapesize(stretch_wid=None, stretch_len=None, outline=None)", 
        "type": "Frameworks"
    }, 
    "turtle.shapetransform": {
        "descr": "Set or return the current transformation matrix of the turtle shape.", 
        "name": "turtle.shapetransform", 
        "params": [], 
        "path": "python/library/turtle#turtle.shapetransform", 
        "syntax": "turtle.shapetransform(t11=None, t12=None, t21=None, t22=None)", 
        "type": "Frameworks"
    }, 
    "turtle.shearfactor": {
        "descr": "Set or return the current shearfactor. Shear the turtleshape according to the given shearfactor shear, which is the tangent of the shear angle. Do not change the turtle\u2019s heading (direction of movement). If shear is not given: return the current shearfactor, i. e. the tangent of the shear angle, by which lines parallel to the heading of the turtle are sheared.", 
        "name": "turtle.shearfactor", 
        "params": [], 
        "path": "python/library/turtle#turtle.shearfactor", 
        "syntax": "turtle.shearfactor(shear=None)", 
        "type": "Frameworks"
    }, 
    "turtle.showturtle": {
        "descr": "Make the turtle visible.", 
        "name": "turtle.showturtle", 
        "params": [], 
        "path": "python/library/turtle#turtle.showturtle", 
        "syntax": "turtle.showturtle()", 
        "type": "Frameworks"
    }, 
    "turtle.speed": {
        "descr": "Set the turtle\u2019s speed to an integer value in the range 0..10. If no argument is given, return current speed.", 
        "name": "turtle.speed", 
        "params": [], 
        "path": "python/library/turtle#turtle.speed", 
        "syntax": "turtle.speed(speed=None)", 
        "type": "Frameworks"
    }, 
    "turtle.st": {
        "descr": "Make the turtle visible.", 
        "name": "turtle.st", 
        "params": [], 
        "path": "python/library/turtle#turtle.st", 
        "syntax": "turtle.st()", 
        "type": "Frameworks"
    }, 
    "turtle.stamp": {
        "descr": "Stamp a copy of the turtle shape onto the canvas at the current turtle position. Return a stamp_id for that stamp, which can be used to delete it by calling clearstamp(stamp_id).", 
        "name": "turtle.stamp", 
        "params": [], 
        "path": "python/library/turtle#turtle.stamp", 
        "syntax": "turtle.stamp()", 
        "type": "Frameworks"
    }, 
    "turtle.textinput": {
        "descr": "Pop up a dialog window for input of a string. Parameter title is the title of the dialog window, propmt is a text mostly describing what information to input. Return the string input. If the dialog is canceled, return None.", 
        "name": "turtle.textinput", 
        "params": [], 
        "path": "python/library/turtle#turtle.textinput", 
        "syntax": "turtle.textinput(title, prompt)", 
        "type": "Frameworks"
    }, 
    "turtle.tilt": {
        "descr": "Rotate the turtleshape by angle from its current tilt-angle, but do not change the turtle\u2019s heading (direction of movement).", 
        "name": "turtle.tilt", 
        "params": [], 
        "path": "python/library/turtle#turtle.tilt", 
        "syntax": "turtle.tilt(angle)", 
        "type": "Frameworks"
    }, 
    "turtle.tiltangle": {
        "descr": "Set or return the current tilt-angle. If angle is given, rotate the turtleshape to point in the direction specified by angle, regardless of its current tilt-angle. Do not change the turtle\u2019s heading (direction of movement). If angle is not given: return the current tilt-angle, i. e. the angle between the orientation of the turtleshape and the heading of the turtle (its direction of movement).", 
        "name": "turtle.tiltangle", 
        "params": [], 
        "path": "python/library/turtle#turtle.tiltangle", 
        "syntax": "turtle.tiltangle(angle=None)", 
        "type": "Frameworks"
    }, 
    "turtle.title": {
        "descr": "Set title of turtle window to titlestring.", 
        "name": "turtle.title", 
        "params": [], 
        "path": "python/library/turtle#turtle.title", 
        "syntax": "turtle.title(titlestring)", 
        "type": "Frameworks"
    }, 
    "turtle.towards": {
        "descr": "Return the angle between the line from turtle position to position specified by (x,y), the vector or the other turtle. This depends on the turtle\u2019s start orientation which depends on the mode - \u201cstandard\u201d/\u201dworld\u201d or \u201clogo\u201d).", 
        "name": "turtle.towards", 
        "params": [], 
        "path": "python/library/turtle#turtle.towards", 
        "syntax": "turtle.towards(x, y=None)", 
        "type": "Frameworks"
    }, 
    "turtle.tracer": {
        "descr": "Turn turtle animation on/off and set delay for update drawings. If n is given, only each n-th regular screen update is really performed. (Can be used to accelerate the drawing of complex graphics.) When called without arguments, returns the currently stored value of n. Second argument sets delay value (see delay()).", 
        "name": "turtle.tracer", 
        "params": [], 
        "path": "python/library/turtle#turtle.tracer", 
        "syntax": "turtle.tracer(n=None, delay=None)", 
        "type": "Frameworks"
    }, 
    "turtle.turtles": {
        "descr": "Return the list of turtles on the screen.", 
        "name": "turtle.turtles", 
        "params": [], 
        "path": "python/library/turtle#turtle.turtles", 
        "syntax": "turtle.turtles()", 
        "type": "Frameworks"
    }, 
    "turtle.turtlesize": {
        "descr": "Return or set the pen\u2019s attributes x/y-stretchfactors and/or outline. Set resizemode to \u201cuser\u201d. If and only if resizemode is set to \u201cuser\u201d, the turtle will be displayed stretched according to its stretchfactors: stretch_wid is stretchfactor perpendicular to its orientation, stretch_len is stretchfactor in direction of its orientation, outline determines the width of the shapes\u2019s outline.", 
        "name": "turtle.turtlesize", 
        "params": [], 
        "path": "python/library/turtle#turtle.turtlesize", 
        "syntax": "turtle.turtlesize(stretch_wid=None, stretch_len=None, outline=None)", 
        "type": "Frameworks"
    }, 
    "turtle.undo": {
        "descr": "Undo (repeatedly) the last turtle action(s). Number of available undo actions is determined by the size of the undobuffer.", 
        "name": "turtle.undo", 
        "params": [], 
        "path": "python/library/turtle#turtle.undo", 
        "syntax": "turtle.undo()", 
        "type": "Frameworks"
    }, 
    "turtle.undobufferentries": {
        "descr": "Return number of entries in the undobuffer.", 
        "name": "turtle.undobufferentries", 
        "params": [], 
        "path": "python/library/turtle#turtle.undobufferentries", 
        "syntax": "turtle.undobufferentries()", 
        "type": "Frameworks"
    }, 
    "turtle.up": {
        "descr": "Pull the pen up \u2013 no drawing when moving.", 
        "name": "turtle.up", 
        "params": [], 
        "path": "python/library/turtle#turtle.up", 
        "syntax": "turtle.up()", 
        "type": "Frameworks"
    }, 
    "turtle.update": {
        "descr": "Perform a TurtleScreen update. To be used when tracer is turned off.", 
        "name": "turtle.update", 
        "params": [], 
        "path": "python/library/turtle#turtle.update", 
        "syntax": "turtle.update()", 
        "type": "Frameworks"
    }, 
    "turtle.width": {
        "descr": "Set the line thickness to width or return it. If resizemode is set to \u201cauto\u201d and turtleshape is a polygon, that polygon is drawn with the same line thickness. If no argument is given, the current pensize is returned.", 
        "name": "turtle.width", 
        "params": [], 
        "path": "python/library/turtle#turtle.width", 
        "syntax": "turtle.width(width=None)", 
        "type": "Frameworks"
    }, 
    "turtle.window_height": {
        "descr": "Return the height of the turtle window.", 
        "name": "turtle.window_height", 
        "params": [], 
        "path": "python/library/turtle#turtle.window_height", 
        "syntax": "turtle.window_height()", 
        "type": "Frameworks"
    }, 
    "turtle.window_width": {
        "descr": "Return the width of the turtle window.", 
        "name": "turtle.window_width", 
        "params": [], 
        "path": "python/library/turtle#turtle.window_width", 
        "syntax": "turtle.window_width()", 
        "type": "Frameworks"
    }, 
    "turtle.write": {
        "descr": "Write text - the string representation of arg - at the current turtle position according to align (\u201cleft\u201d, \u201ccenter\u201d or right\u201d) and with the given font. If move is true, the pen is moved to the bottom-right corner of the text. By default, move is False.", 
        "name": "turtle.write", 
        "params": [], 
        "path": "python/library/turtle#turtle.write", 
        "syntax": "turtle.write(arg, move=False, align=\"left\", font=(\"Arial\", 8, \"normal\"))", 
        "type": "Frameworks"
    }, 
    "turtle.write_docstringdict": {
        "descr": "Create and write docstring-dictionary to a Python script with the given filename. This function has to be called explicitly (it is not used by the turtle graphics classes). The docstring dictionary will be written to the Python script filename.py. It is intended to serve as a template for translation of the docstrings into different languages.", 
        "name": "turtle.write_docstringdict", 
        "params": [], 
        "path": "python/library/turtle#turtle.write_docstringdict", 
        "syntax": "turtle.write_docstringdict(filename=\"turtle_docstringdict\")", 
        "type": "Frameworks"
    }, 
    "turtle.xcor": {
        "descr": "Return the turtle\u2019s x coordinate.", 
        "name": "turtle.xcor", 
        "params": [], 
        "path": "python/library/turtle#turtle.xcor", 
        "syntax": "turtle.xcor()", 
        "type": "Frameworks"
    }, 
    "turtle.ycor": {
        "descr": "Return the turtle\u2019s y coordinate.", 
        "name": "turtle.ycor", 
        "params": [], 
        "path": "python/library/turtle#turtle.ycor", 
        "syntax": "turtle.ycor()", 
        "type": "Frameworks"
    }, 
    "type": {
        "descr": "The isinstance() built-in function is recommended for testing the type of an object, because it takes subclasses into account.", 
        "name": "type", 
        "params": [], 
        "path": "python/library/functions#type", 
        "syntax": "type(object)", 
        "type": "Built-in Functions"
    }, 
    "typecode": {
        "descr": "The typecode character used to create the array.", 
        "name": "array.array.typecode", 
        "params": [], 
        "path": "python/library/array#array.array.typecode", 
        "syntax": "array.typecode", 
        "type": "Data Types"
    }, 
    "typecodes": {
        "descr": "A string with all available type codes.", 
        "name": "array.typecodes", 
        "params": [], 
        "path": "python/library/array#array.typecodes", 
        "syntax": "array.typecodes", 
        "type": "Data Types"
    }, 
    "types.BuiltinFunctionType": {
        "descr": "The type of built-in functions like len() or sys.exit(), and methods of built-in classes. (Here, the term \u201cbuilt-in\u201d means \u201cwritten in C\u201d.)", 
        "name": "types.BuiltinFunctionType", 
        "params": [], 
        "path": "python/library/types#types.BuiltinFunctionType", 
        "syntax": "types.BuiltinFunctionType", 
        "type": "Data Types"
    }, 
    "types.BuiltinMethodType": {
        "descr": "The type of built-in functions like len() or sys.exit(), and methods of built-in classes. (Here, the term \u201cbuilt-in\u201d means \u201cwritten in C\u201d.)", 
        "name": "types.BuiltinMethodType", 
        "params": [], 
        "path": "python/library/types#types.BuiltinMethodType", 
        "syntax": "types.BuiltinMethodType", 
        "type": "Data Types"
    }, 
    "types.CodeType": {
        "descr": "", 
        "name": "types.CodeType", 
        "params": [], 
        "path": "python/library/types#types.CodeType", 
        "syntax": "types.CodeType", 
        "type": "Data Types"
    }, 
    "types.FrameType": {
        "descr": "The type of frame objects such as found in tb.tb_frame if tb is a traceback object.", 
        "name": "types.FrameType", 
        "params": [], 
        "path": "python/library/types#types.FrameType", 
        "syntax": "types.FrameType", 
        "type": "Data Types"
    }, 
    "types.FunctionType": {
        "descr": "The type of user-defined functions and functions created by lambda expressions.", 
        "name": "types.FunctionType", 
        "params": [], 
        "path": "python/library/types#types.FunctionType", 
        "syntax": "types.FunctionType", 
        "type": "Data Types"
    }, 
    "types.GeneratorType": {
        "descr": "The type of generator-iterator objects, produced by calling a generator function.", 
        "name": "types.GeneratorType", 
        "params": [], 
        "path": "python/library/types#types.GeneratorType", 
        "syntax": "types.GeneratorType", 
        "type": "Data Types"
    }, 
    "types.GetSetDescriptorType": {
        "descr": "The type of objects defined in extension modules with PyGetSetDef, such as FrameType.f_locals or array.array.typecode. This type is used as descriptor for object attributes; it has the same purpose as the property type, but for classes defined in extension modules.", 
        "name": "types.GetSetDescriptorType", 
        "params": [], 
        "path": "python/library/types#types.GetSetDescriptorType", 
        "syntax": "types.GetSetDescriptorType", 
        "type": "Data Types"
    }, 
    "types.LambdaType": {
        "descr": "The type of user-defined functions and functions created by lambda expressions.", 
        "name": "types.LambdaType", 
        "params": [], 
        "path": "python/library/types#types.LambdaType", 
        "syntax": "types.LambdaType", 
        "type": "Data Types"
    }, 
    "types.MappingProxyType": {
        "descr": "Read-only proxy of a mapping. It provides a dynamic view on the mapping\u2019s entries, which means that when the mapping changes, the view reflects these changes.", 
        "name": "types.MappingProxyType", 
        "params": [], 
        "path": "python/library/types#types.MappingProxyType", 
        "syntax": "class types.MappingProxyType(mapping)", 
        "type": "Data Types"
    }, 
    "types.MappingProxyType.copy": {
        "descr": "Return a shallow copy of the underlying mapping.", 
        "name": "types.MappingProxyType.copy", 
        "params": [], 
        "path": "python/library/types#types.MappingProxyType.copy", 
        "syntax": "copy()", 
        "type": "Data Types"
    }, 
    "types.MappingProxyType.get": {
        "descr": "Return the value for key if key is in the underlying mapping, else default. If default is not given, it defaults to None, so that this method never raises a KeyError.", 
        "name": "types.MappingProxyType.get", 
        "params": [], 
        "path": "python/library/types#types.MappingProxyType.get", 
        "syntax": "get(key[, default])", 
        "type": "Data Types"
    }, 
    "types.MappingProxyType.items": {
        "descr": "Return a new view of the underlying mapping\u2019s items ((key, value) pairs).", 
        "name": "types.MappingProxyType.items", 
        "params": [], 
        "path": "python/library/types#types.MappingProxyType.items", 
        "syntax": "items()", 
        "type": "Data Types"
    }, 
    "types.MappingProxyType.keys": {
        "descr": "Return a new view of the underlying mapping\u2019s keys.", 
        "name": "types.MappingProxyType.keys", 
        "params": [], 
        "path": "python/library/types#types.MappingProxyType.keys", 
        "syntax": "keys()", 
        "type": "Data Types"
    }, 
    "types.MappingProxyType.values": {
        "descr": "Return a new view of the underlying mapping\u2019s values.", 
        "name": "types.MappingProxyType.values", 
        "params": [], 
        "path": "python/library/types#types.MappingProxyType.values", 
        "syntax": "values()", 
        "type": "Data Types"
    }, 
    "types.MemberDescriptorType": {
        "descr": "The type of objects defined in extension modules with PyMemberDef, such as datetime.timedelta.days. This type is used as descriptor for simple C data members which use standard conversion functions; it has the same purpose as the property type, but for classes defined in extension modules.", 
        "name": "types.MemberDescriptorType", 
        "params": [], 
        "path": "python/library/types#types.MemberDescriptorType", 
        "syntax": "types.MemberDescriptorType", 
        "type": "Data Types"
    }, 
    "types.MethodType": {
        "descr": "The type of methods of user-defined class instances.", 
        "name": "types.MethodType", 
        "params": [], 
        "path": "python/library/types#types.MethodType", 
        "syntax": "types.MethodType", 
        "type": "Data Types"
    }, 
    "types.ModuleType": {
        "descr": "The type of modules.", 
        "name": "types.ModuleType", 
        "params": [], 
        "path": "python/library/types#types.ModuleType", 
        "syntax": "types.ModuleType", 
        "type": "Data Types"
    }, 
    "types.SimpleNamespace": {
        "descr": "A simple object subclass that provides attribute access to its namespace, as well as a meaningful repr.", 
        "name": "types.SimpleNamespace", 
        "params": [], 
        "path": "python/library/types#types.SimpleNamespace", 
        "syntax": "class types.SimpleNamespace", 
        "type": "Data Types"
    }, 
    "types.TracebackType": {
        "descr": "The type of traceback objects such as found in sys.exc_info()[2].", 
        "name": "types.TracebackType", 
        "params": [], 
        "path": "python/library/types#types.TracebackType", 
        "syntax": "types.TracebackType", 
        "type": "Data Types"
    }, 
    "types.new_class": {
        "descr": "Creates a class object dynamically using the appropriate metaclass.", 
        "name": "types.new_class", 
        "params": [], 
        "path": "python/library/types#types.new_class", 
        "syntax": "types.new_class(name, bases=(), kwds=None, exec_body=None)", 
        "type": "Data Types"
    }, 
    "types.prepare_class": {
        "descr": "Calculates the appropriate metaclass and creates the class namespace.", 
        "name": "types.prepare_class", 
        "params": [], 
        "path": "python/library/types#types.prepare_class", 
        "syntax": "types.prepare_class(name, bases=(), kwds=None)", 
        "type": "Data Types"
    }, 
    "unicodedata.bidirectional": {
        "descr": "Returns the bidirectional class assigned to the character chr as string. If no such value is defined, an empty string is returned.", 
        "name": "unicodedata.bidirectional", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.bidirectional", 
        "syntax": "unicodedata.bidirectional(chr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.category": {
        "descr": "Returns the general category assigned to the character chr as string.", 
        "name": "unicodedata.category", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.category", 
        "syntax": "unicodedata.category(chr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.combining": {
        "descr": "Returns the canonical combining class assigned to the character chr as integer. Returns 0 if no combining class is defined.", 
        "name": "unicodedata.combining", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.combining", 
        "syntax": "unicodedata.combining(chr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.decimal": {
        "descr": "Returns the decimal value assigned to the character chr as integer. If no such value is defined, default is returned, or, if not given, ValueError is raised.", 
        "name": "unicodedata.decimal", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.decimal", 
        "syntax": "unicodedata.decimal(chr[, default])", 
        "type": "Text Processing"
    }, 
    "unicodedata.decomposition": {
        "descr": "Returns the character decomposition mapping assigned to the character chr as string. An empty string is returned in case no such mapping is defined.", 
        "name": "unicodedata.decomposition", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.decomposition", 
        "syntax": "unicodedata.decomposition(chr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.digit": {
        "descr": "Returns the digit value assigned to the character chr as integer. If no such value is defined, default is returned, or, if not given, ValueError is raised.", 
        "name": "unicodedata.digit", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.digit", 
        "syntax": "unicodedata.digit(chr[, default])", 
        "type": "Text Processing"
    }, 
    "unicodedata.east_asian_width": {
        "descr": "Returns the east asian width assigned to the character chr as string.", 
        "name": "unicodedata.east_asian_width", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.east_asian_width", 
        "syntax": "unicodedata.east_asian_width(chr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.lookup": {
        "descr": "Look up character by name. If a character with the given name is found, return the corresponding character. If not found, KeyError is raised.", 
        "name": "unicodedata.lookup", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.lookup", 
        "syntax": "unicodedata.lookup(name)", 
        "type": "Text Processing"
    }, 
    "unicodedata.mirrored": {
        "descr": "Returns the mirrored property assigned to the character chr as integer. Returns 1 if the character has been identified as a \u201cmirrored\u201d character in bidirectional text, 0 otherwise.", 
        "name": "unicodedata.mirrored", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.mirrored", 
        "syntax": "unicodedata.mirrored(chr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.name": {
        "descr": "Returns the name assigned to the character chr as a string. If no name is defined, default is returned, or, if not given, ValueError is raised.", 
        "name": "unicodedata.name", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.name", 
        "syntax": "unicodedata.name(chr[, default])", 
        "type": "Text Processing"
    }, 
    "unicodedata.normalize": {
        "descr": "Return the normal form form for the Unicode string unistr. Valid values for form are \u2018NFC\u2019, \u2018NFKC\u2019, \u2018NFD\u2019, and \u2018NFKD\u2019.", 
        "name": "unicodedata.normalize", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.normalize", 
        "syntax": "unicodedata.normalize(form, unistr)", 
        "type": "Text Processing"
    }, 
    "unicodedata.numeric": {
        "descr": "Returns the numeric value assigned to the character chr as float. If no such value is defined, default is returned, or, if not given, ValueError is raised.", 
        "name": "unicodedata.numeric", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.numeric", 
        "syntax": "unicodedata.numeric(chr[, default])", 
        "type": "Text Processing"
    }, 
    "unicodedata.ucd_3_2_0": {
        "descr": "This is an object that has the same methods as the entire module, but uses the Unicode database version 3.2 instead, for applications that require this specific version of the Unicode database (such as IDNA).", 
        "name": "unicodedata.ucd_3_2_0", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.ucd_3_2_0", 
        "syntax": "unicodedata.ucd_3_2_0", 
        "type": "Text Processing"
    }, 
    "unicodedata.unidata_version": {
        "descr": "The version of the Unicode database used in this module.", 
        "name": "unicodedata.unidata_version", 
        "params": [], 
        "path": "python/library/unicodedata#unicodedata.unidata_version", 
        "syntax": "unicodedata.unidata_version", 
        "type": "Text Processing"
    }, 
    "unittest.FunctionTestCase": {
        "descr": "This class implements the portion of the TestCase interface which allows the test runner to drive the test, but does not provide the methods which test code can use to check and report errors. This is used to create test cases using legacy test code, allowing it to be integrated into a unittest-based test framework.", 
        "name": "unittest.FunctionTestCase", 
        "params": [], 
        "path": "python/library/unittest#unittest.FunctionTestCase", 
        "syntax": "class unittest.FunctionTestCase(testFunc, setUp=None, tearDown=None, description=None)", 
        "type": "Development Tools"
    }, 
    "unittest.SkipTest": {
        "descr": "This exception is raised to skip a test.", 
        "name": "unittest.SkipTest", 
        "params": [], 
        "path": "python/library/unittest#unittest.SkipTest", 
        "syntax": "exception unittest.SkipTest(reason)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase": {
        "descr": "Instances of the TestCase class represent the logical test units in the unittest universe. This class is intended to be used as a base class, with specific tests being implemented by concrete subclasses. This class implements the interface needed by the test runner to allow it to drive the tests, and methods that the test code can use to check for and report various kinds of failure.", 
        "name": "unittest.TestCase", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase", 
        "syntax": "class unittest.TestCase(methodName='runTest')", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.addCleanup": {
        "descr": "Add a function to be called after tearDown() to cleanup resources used during the test. Functions will be called in reverse order to the order they are added (LIFO). They are called with any arguments and keyword arguments passed into addCleanup() when they are added.", 
        "name": "unittest.TestCase.addCleanup", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.addCleanup", 
        "syntax": "addCleanup(function, *args, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.addTypeEqualityFunc": {
        "descr": "Registers a type-specific method called by assertEqual() to check if two objects of exactly the same typeobj (not subclasses) compare equal. function must take two positional arguments and a third msg=None keyword argument just as assertEqual() does. It must raise self.failureException(msg) when inequality between the first two parameters is detected \u2013 possibly providing useful information and explaining the inequalities in details in the error message.", 
        "name": "unittest.TestCase.addTypeEqualityFunc", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.addTypeEqualityFunc", 
        "syntax": "addTypeEqualityFunc(typeobj, function)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertAlmostEqual": {
        "descr": "Test that first and second are approximately (or not approximately) equal by computing the difference, rounding to the given number of decimal places (default 7), and comparing to zero. Note that these methods round the values to the given number of decimal places (i.e. like the round() function) and not significant digits.", 
        "name": "unittest.TestCase.assertAlmostEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertAlmostEqual", 
        "syntax": "assertAlmostEqual(first, second, places=7, msg=None, delta=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertCountEqual": {
        "descr": "Test that sequence first contains the same elements as second, regardless of their order. When they don\u2019t, an error message listing the differences between the sequences will be generated.", 
        "name": "unittest.TestCase.assertCountEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertCountEqual", 
        "syntax": "assertCountEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertDictEqual": {
        "descr": "Test that two dictionaries are equal. If not, an error message is constructed that shows the differences in the dictionaries. This method will be used by default to compare dictionaries in calls to assertEqual().", 
        "name": "unittest.TestCase.assertDictEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertDictEqual", 
        "syntax": "assertDictEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertEqual": {
        "descr": "Test that first and second are equal. If the values do not compare equal, the test will fail.", 
        "name": "unittest.TestCase.assertEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertEqual", 
        "syntax": "assertEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertFalse": {
        "descr": "Test that expr is true (or false).", 
        "name": "unittest.TestCase.assertFalse", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertFalse", 
        "syntax": "assertFalse(expr, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertGreater": {
        "descr": "Test that first is respectively >, >=, < or <= than second depending on the method name. If not, the test will fail:", 
        "name": "unittest.TestCase.assertGreater", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertGreater", 
        "syntax": "assertGreater(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertGreaterEqual": {
        "descr": "Test that first is respectively >, >=, < or <= than second depending on the method name. If not, the test will fail:", 
        "name": "unittest.TestCase.assertGreaterEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertGreaterEqual", 
        "syntax": "assertGreaterEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertIn": {
        "descr": "Test that first is (or is not) in second.", 
        "name": "unittest.TestCase.assertIn", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertIn", 
        "syntax": "assertIn(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertIs": {
        "descr": "Test that first and second evaluate (or don\u2019t evaluate) to the same object.", 
        "name": "unittest.TestCase.assertIs", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertIs", 
        "syntax": "assertIs(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertIsInstance": {
        "descr": "Test that obj is (or is not) an instance of cls (which can be a class or a tuple of classes, as supported by isinstance()). To check for the exact type, use assertIs(type(obj), cls).", 
        "name": "unittest.TestCase.assertIsInstance", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertIsInstance", 
        "syntax": "assertIsInstance(obj, cls, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertIsNone": {
        "descr": "Test that expr is (or is not) None.", 
        "name": "unittest.TestCase.assertIsNone", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertIsNone", 
        "syntax": "assertIsNone(expr, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertIsNot": {
        "descr": "Test that first and second evaluate (or don\u2019t evaluate) to the same object.", 
        "name": "unittest.TestCase.assertIsNot", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertIsNot", 
        "syntax": "assertIsNot(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertIsNotNone": {
        "descr": "Test that expr is (or is not) None.", 
        "name": "unittest.TestCase.assertIsNotNone", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertIsNotNone", 
        "syntax": "assertIsNotNone(expr, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertLess": {
        "descr": "Test that first is respectively >, >=, < or <= than second depending on the method name. If not, the test will fail:", 
        "name": "unittest.TestCase.assertLess", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertLess", 
        "syntax": "assertLess(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertLessEqual": {
        "descr": "Test that first is respectively >, >=, < or <= than second depending on the method name. If not, the test will fail:", 
        "name": "unittest.TestCase.assertLessEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertLessEqual", 
        "syntax": "assertLessEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertListEqual": {
        "descr": "Tests that two lists or tuples are equal. If not, an error message is constructed that shows only the differences between the two. An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with assertEqual().", 
        "name": "unittest.TestCase.assertListEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertListEqual", 
        "syntax": "assertListEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertMultiLineEqual": {
        "descr": "Test that the multiline string first is equal to the string second. When not equal a diff of the two strings highlighting the differences will be included in the error message. This method is used by default when comparing strings with assertEqual().", 
        "name": "unittest.TestCase.assertMultiLineEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertMultiLineEqual", 
        "syntax": "assertMultiLineEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertNotAlmostEqual": {
        "descr": "Test that first and second are approximately (or not approximately) equal by computing the difference, rounding to the given number of decimal places (default 7), and comparing to zero. Note that these methods round the values to the given number of decimal places (i.e. like the round() function) and not significant digits.", 
        "name": "unittest.TestCase.assertNotAlmostEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertNotAlmostEqual", 
        "syntax": "assertNotAlmostEqual(first, second, places=7, msg=None, delta=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertNotEqual": {
        "descr": "Test that first and second are not equal. If the values do compare equal, the test will fail.", 
        "name": "unittest.TestCase.assertNotEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertNotEqual", 
        "syntax": "assertNotEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertNotIn": {
        "descr": "Test that first is (or is not) in second.", 
        "name": "unittest.TestCase.assertNotIn", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertNotIn", 
        "syntax": "assertNotIn(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertNotIsInstance": {
        "descr": "Test that obj is (or is not) an instance of cls (which can be a class or a tuple of classes, as supported by isinstance()). To check for the exact type, use assertIs(type(obj), cls).", 
        "name": "unittest.TestCase.assertNotIsInstance", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertNotIsInstance", 
        "syntax": "assertNotIsInstance(obj, cls, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertNotRegex": {
        "descr": "Test that a regex search matches (or does not match) text. In case of failure, the error message will include the pattern and the text (or the pattern and the part of text that unexpectedly matched). regex may be a regular expression object or a string containing a regular expression suitable for use by re.search().", 
        "name": "unittest.TestCase.assertNotRegex", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertNotRegex", 
        "syntax": "assertNotRegex(text, regex, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertRaises": {
        "descr": "Test that an exception is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises(). The test passes if exception is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as exception.", 
        "name": "unittest.TestCase.assertRaises", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertRaises", 
        "syntax": "assertRaises(exception, callable, *args, **kwds)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertRaisesRegex": {
        "descr": "Like assertRaises() but also tests that regex matches on the string representation of the raised exception. regex may be a regular expression object or a string containing a regular expression suitable for use by re.search(). Examples:", 
        "name": "unittest.TestCase.assertRaisesRegex", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertRaisesRegex", 
        "syntax": "assertRaisesRegex(exception, regex, callable, *args, **kwds)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertRegex": {
        "descr": "Test that a regex search matches (or does not match) text. In case of failure, the error message will include the pattern and the text (or the pattern and the part of text that unexpectedly matched). regex may be a regular expression object or a string containing a regular expression suitable for use by re.search().", 
        "name": "unittest.TestCase.assertRegex", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertRegex", 
        "syntax": "assertRegex(text, regex, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertSequenceEqual": {
        "descr": "Tests that two sequences are equal. If a seq_type is supplied, both first and second must be instances of seq_type or a failure will be raised. If the sequences are different an error message is constructed that shows the difference between the two.", 
        "name": "unittest.TestCase.assertSequenceEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertSequenceEqual", 
        "syntax": "assertSequenceEqual(first, second, msg=None, seq_type=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertSetEqual": {
        "descr": "Tests that two sets are equal. If not, an error message is constructed that lists the differences between the sets. This method is used by default when comparing sets or frozensets with assertEqual().", 
        "name": "unittest.TestCase.assertSetEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertSetEqual", 
        "syntax": "assertSetEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertTrue": {
        "descr": "Test that expr is true (or false).", 
        "name": "unittest.TestCase.assertTrue", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertTrue", 
        "syntax": "assertTrue(expr, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertTupleEqual": {
        "descr": "Tests that two lists or tuples are equal. If not, an error message is constructed that shows only the differences between the two. An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with assertEqual().", 
        "name": "unittest.TestCase.assertTupleEqual", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertTupleEqual", 
        "syntax": "assertTupleEqual(first, second, msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertWarns": {
        "descr": "Test that a warning is triggered when callable is called with any positional or keyword arguments that are also passed to assertWarns(). The test passes if warning is triggered and fails if it isn\u2019t. Any exception is an error. To catch any of a group of warnings, a tuple containing the warning classes may be passed as warnings.", 
        "name": "unittest.TestCase.assertWarns", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertWarns", 
        "syntax": "assertWarns(warning, callable, *args, **kwds)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.assertWarnsRegex": {
        "descr": "Like assertWarns() but also tests that regex matches on the message of the triggered warning. regex may be a regular expression object or a string containing a regular expression suitable for use by re.search(). Example:", 
        "name": "unittest.TestCase.assertWarnsRegex", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.assertWarnsRegex", 
        "syntax": "assertWarnsRegex(warning, regex, callable, *args, **kwds)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.countTestCases": {
        "descr": "Return the number of tests represented by this test object. For TestCase instances, this will always be 1.", 
        "name": "unittest.TestCase.countTestCases", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.countTestCases", 
        "syntax": "countTestCases()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.debug": {
        "descr": "Run the test without collecting the result. This allows exceptions raised by the test to be propagated to the caller, and can be used to support running tests under a debugger.", 
        "name": "unittest.TestCase.debug", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.debug", 
        "syntax": "debug()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.defaultTestResult": {
        "descr": "Return an instance of the test result class that should be used for this test case class (if no other result instance is provided to the run() method).", 
        "name": "unittest.TestCase.defaultTestResult", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.defaultTestResult", 
        "syntax": "defaultTestResult()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.doCleanups": {
        "descr": "This method is called unconditionally after tearDown(), or after setUp() if setUp() raises an exception.", 
        "name": "unittest.TestCase.doCleanups", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.doCleanups", 
        "syntax": "doCleanups()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.fail": {
        "descr": "Signals a test failure unconditionally, with msg or None for the error message.", 
        "name": "unittest.TestCase.fail", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.fail", 
        "syntax": "fail(msg=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.failureException": {
        "descr": "This class attribute gives the exception raised by the test method. If a test framework needs to use a specialized exception, possibly to carry additional information, it must subclass this exception in order to \u201cplay fair\u201d with the framework. The initial value of this attribute is AssertionError.", 
        "name": "unittest.TestCase.failureException", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.failureException", 
        "syntax": "failureException", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.id": {
        "descr": "Return a string identifying the specific test case. This is usually the full name of the test method, including the module and class name.", 
        "name": "unittest.TestCase.id", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.id", 
        "syntax": "id()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.longMessage": {
        "descr": "If set to True then any explicit failure message you pass in to the assert methods will be appended to the end of the normal failure message. The normal messages contain useful information about the objects involved, for example the message from assertEqual shows you the repr of the two unequal objects. Setting this attribute to True allows you to have a custom error message in addition to the normal one.", 
        "name": "unittest.TestCase.longMessage", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.longMessage", 
        "syntax": "longMessage", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.maxDiff": {
        "descr": "This attribute controls the maximum length of diffs output by assert methods that report diffs on failure. It defaults to 80*8 characters. Assert methods affected by this attribute are assertSequenceEqual() (including all the sequence comparison methods that delegate to it), assertDictEqual() and assertMultiLineEqual().", 
        "name": "unittest.TestCase.maxDiff", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.maxDiff", 
        "syntax": "maxDiff", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.run": {
        "descr": "Run the test, collecting the result into the TestResult object passed as result. If result is omitted or None, a temporary result object is created (by calling the defaultTestResult() method) and used. The result object is returned to run()\u2018s caller.", 
        "name": "unittest.TestCase.run", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.run", 
        "syntax": "run(result=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.setUp": {
        "descr": "Method called to prepare the test fixture. This is called immediately before calling the test method; any exception raised by this method will be considered an error rather than a test failure. The default implementation does nothing.", 
        "name": "unittest.TestCase.setUp", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.setUp", 
        "syntax": "setUp()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.setUpClass": {
        "descr": "A class method called before tests in an individual class run. setUpClass is called with the class as the only argument and must be decorated as a classmethod():", 
        "name": "unittest.TestCase.setUpClass", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.setUpClass", 
        "syntax": "setUpClass()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.shortDescription": {
        "descr": "Returns a description of the test, or None if no description has been provided. The default implementation of this method returns the first line of the test method\u2019s docstring, if available, or None.", 
        "name": "unittest.TestCase.shortDescription", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.shortDescription", 
        "syntax": "shortDescription()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.skipTest": {
        "descr": "Calling this during a test method or setUp() skips the current test. See Skipping tests and expected failures for more information.", 
        "name": "unittest.TestCase.skipTest", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.skipTest", 
        "syntax": "skipTest(reason)", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.tearDown": {
        "descr": "Method called immediately after the test method has been called and the result recorded. This is called even if the test method raised an exception, so the implementation in subclasses may need to be particularly careful about checking internal state. Any exception raised by this method will be considered an error rather than a test failure. This method will only be called if the setUp() succeeds, regardless of the outcome of the test method. The default implementation does nothing.", 
        "name": "unittest.TestCase.tearDown", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.tearDown", 
        "syntax": "tearDown()", 
        "type": "Development Tools"
    }, 
    "unittest.TestCase.tearDownClass": {
        "descr": "A class method called after tests in an individual class have run. tearDownClass is called with the class as the only argument and must be decorated as a classmethod():", 
        "name": "unittest.TestCase.tearDownClass", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestCase.tearDownClass", 
        "syntax": "tearDownClass()", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader": {
        "descr": "The TestLoader class is used to create test suites from classes and modules. Normally, there is no need to create an instance of this class; the unittest module provides an instance that can be shared as unittest.defaultTestLoader. Using a subclass or instance, however, allows customization of some configurable properties.", 
        "name": "unittest.TestLoader", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader", 
        "syntax": "class unittest.TestLoader", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.discover": {
        "descr": "Find and return all test modules from the specified start directory, recursing into subdirectories to find them. Only test files that match pattern will be loaded. (Using shell style pattern matching.) Only module names that are importable (i.e. are valid Python identifiers) will be loaded.", 
        "name": "unittest.TestLoader.discover", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.discover", 
        "syntax": "discover(start_dir, pattern='test*.py', top_level_dir=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.getTestCaseNames": {
        "descr": "Return a sorted sequence of method names found within testCaseClass; this should be a subclass of TestCase.", 
        "name": "unittest.TestLoader.getTestCaseNames", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.getTestCaseNames", 
        "syntax": "getTestCaseNames(testCaseClass)", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.loadTestsFromModule": {
        "descr": "Return a suite of all tests cases contained in the given module. This method searches module for classes derived from TestCase and creates an instance of the class for each test method defined for the class.", 
        "name": "unittest.TestLoader.loadTestsFromModule", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.loadTestsFromModule", 
        "syntax": "loadTestsFromModule(module)", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.loadTestsFromName": {
        "descr": "Return a suite of all tests cases given a string specifier.", 
        "name": "unittest.TestLoader.loadTestsFromName", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.loadTestsFromName", 
        "syntax": "loadTestsFromName(name, module=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.loadTestsFromNames": {
        "descr": "Similar to loadTestsFromName(), but takes a sequence of names rather than a single name. The return value is a test suite which supports all the tests defined for each name.", 
        "name": "unittest.TestLoader.loadTestsFromNames", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.loadTestsFromNames", 
        "syntax": "loadTestsFromNames(names, module=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.loadTestsFromTestCase": {
        "descr": "Return a suite of all tests cases contained in the TestCase-derived testCaseClass.", 
        "name": "unittest.TestLoader.loadTestsFromTestCase", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.loadTestsFromTestCase", 
        "syntax": "loadTestsFromTestCase(testCaseClass)", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.sortTestMethodsUsing": {
        "descr": "Function to be used to compare method names when sorting them in getTestCaseNames() and all the loadTestsFrom*() methods.", 
        "name": "unittest.TestLoader.sortTestMethodsUsing", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.sortTestMethodsUsing", 
        "syntax": "sortTestMethodsUsing", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.suiteClass": {
        "descr": "Callable object that constructs a test suite from a list of tests. No methods on the resulting object are needed. The default value is the TestSuite class.", 
        "name": "unittest.TestLoader.suiteClass", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.suiteClass", 
        "syntax": "suiteClass", 
        "type": "Development Tools"
    }, 
    "unittest.TestLoader.testMethodPrefix": {
        "descr": "String giving the prefix of method names which will be interpreted as test methods. The default value is 'test'.", 
        "name": "unittest.TestLoader.testMethodPrefix", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestLoader.testMethodPrefix", 
        "syntax": "testMethodPrefix", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult": {
        "descr": "This class is used to compile information about which tests have succeeded and which have failed.", 
        "name": "unittest.TestResult", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult", 
        "syntax": "class unittest.TestResult", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.addError": {
        "descr": "Called when the test case test raises an unexpected exception. err is a tuple of the form returned by sys.exc_info(): (type, value, traceback).", 
        "name": "unittest.TestResult.addError", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.addError", 
        "syntax": "addError(test, err)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.addExpectedFailure": {
        "descr": "Called when the test case test fails, but was marked with the expectedFailure() decorator.", 
        "name": "unittest.TestResult.addExpectedFailure", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.addExpectedFailure", 
        "syntax": "addExpectedFailure(test, err)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.addFailure": {
        "descr": "Called when the test case test signals a failure. err is a tuple of the form returned by sys.exc_info(): (type, value, traceback).", 
        "name": "unittest.TestResult.addFailure", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.addFailure", 
        "syntax": "addFailure(test, err)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.addSkip": {
        "descr": "Called when the test case test is skipped. reason is the reason the test gave for skipping.", 
        "name": "unittest.TestResult.addSkip", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.addSkip", 
        "syntax": "addSkip(test, reason)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.addSuccess": {
        "descr": "Called when the test case test succeeds.", 
        "name": "unittest.TestResult.addSuccess", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.addSuccess", 
        "syntax": "addSuccess(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.addUnexpectedSuccess": {
        "descr": "Called when the test case test was marked with the expectedFailure() decorator, but succeeded.", 
        "name": "unittest.TestResult.addUnexpectedSuccess", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.addUnexpectedSuccess", 
        "syntax": "addUnexpectedSuccess(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.buffer": {
        "descr": "If set to true, sys.stdout and sys.stderr will be buffered in between startTest() and stopTest() being called. Collected output will only be echoed onto the real sys.stdout and sys.stderr if the test fails or errors. Any output is also attached to the failure / error message.", 
        "name": "unittest.TestResult.buffer", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.buffer", 
        "syntax": "buffer", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.errors": {
        "descr": "A list containing 2-tuples of TestCase instances and strings holding formatted tracebacks. Each tuple represents a test which raised an unexpected exception.", 
        "name": "unittest.TestResult.errors", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.errors", 
        "syntax": "errors", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.expectedFailures": {
        "descr": "A list containing 2-tuples of TestCase instances and strings holding formatted tracebacks. Each tuple represents an expected failure of the test case.", 
        "name": "unittest.TestResult.expectedFailures", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.expectedFailures", 
        "syntax": "expectedFailures", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.failfast": {
        "descr": "If set to true stop() will be called on the first failure or error, halting the test run.", 
        "name": "unittest.TestResult.failfast", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.failfast", 
        "syntax": "failfast", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.failures": {
        "descr": "A list containing 2-tuples of TestCase instances and strings holding formatted tracebacks. Each tuple represents a test where a failure was explicitly signalled using the TestCase.assert*() methods.", 
        "name": "unittest.TestResult.failures", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.failures", 
        "syntax": "failures", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.shouldStop": {
        "descr": "Set to True when the execution of tests should stop by stop().", 
        "name": "unittest.TestResult.shouldStop", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.shouldStop", 
        "syntax": "shouldStop", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.skipped": {
        "descr": "A list containing 2-tuples of TestCase instances and strings holding the reason for skipping the test.", 
        "name": "unittest.TestResult.skipped", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.skipped", 
        "syntax": "skipped", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.startTest": {
        "descr": "Called when the test case test is about to be run.", 
        "name": "unittest.TestResult.startTest", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.startTest", 
        "syntax": "startTest(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.startTestRun": {
        "descr": "Called once before any tests are executed.", 
        "name": "unittest.TestResult.startTestRun", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.startTestRun", 
        "syntax": "startTestRun(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.stop": {
        "descr": "This method can be called to signal that the set of tests being run should be aborted by setting the shouldStop attribute to True. TestRunner objects should respect this flag and return without running any additional tests.", 
        "name": "unittest.TestResult.stop", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.stop", 
        "syntax": "stop()", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.stopTest": {
        "descr": "Called after the test case test has been executed, regardless of the outcome.", 
        "name": "unittest.TestResult.stopTest", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.stopTest", 
        "syntax": "stopTest(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.stopTestRun": {
        "descr": "Called once after all tests are executed.", 
        "name": "unittest.TestResult.stopTestRun", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.stopTestRun", 
        "syntax": "stopTestRun(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.testsRun": {
        "descr": "The total number of tests run so far.", 
        "name": "unittest.TestResult.testsRun", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.testsRun", 
        "syntax": "testsRun", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.unexpectedSuccesses": {
        "descr": "A list containing TestCase instances that were marked as expected failures, but succeeded.", 
        "name": "unittest.TestResult.unexpectedSuccesses", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.unexpectedSuccesses", 
        "syntax": "unexpectedSuccesses", 
        "type": "Development Tools"
    }, 
    "unittest.TestResult.wasSuccessful": {
        "descr": "Return True if all tests run so far have passed, otherwise returns False.", 
        "name": "unittest.TestResult.wasSuccessful", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestResult.wasSuccessful", 
        "syntax": "wasSuccessful()", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite": {
        "descr": "This class represents an aggregation of individual tests cases and test suites. The class presents the interface needed by the test runner to allow it to be run as any other test case. Running a TestSuite instance is the same as iterating over the suite, running each test individually.", 
        "name": "unittest.TestSuite", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite", 
        "syntax": "class unittest.TestSuite(tests=())", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite.__iter__": {
        "descr": "Tests grouped by a TestSuite are always accessed by iteration. Subclasses can lazily provide tests by overriding __iter__(). Note that this method maybe called several times on a single suite (for example when counting tests or comparing for equality) so the tests returned must be the same for repeated iterations.", 
        "name": "unittest.TestSuite.__iter__", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite.__iter__", 
        "syntax": "__iter__()", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite.addTest": {
        "descr": "Add a TestCase or TestSuite to the suite.", 
        "name": "unittest.TestSuite.addTest", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite.addTest", 
        "syntax": "addTest(test)", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite.addTests": {
        "descr": "Add all the tests from an iterable of TestCase and TestSuite instances to this test suite.", 
        "name": "unittest.TestSuite.addTests", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite.addTests", 
        "syntax": "addTests(tests)", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite.countTestCases": {
        "descr": "Return the number of tests represented by this test object, including all individual tests and sub-suites.", 
        "name": "unittest.TestSuite.countTestCases", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite.countTestCases", 
        "syntax": "countTestCases()", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite.debug": {
        "descr": "Run the tests associated with this suite without collecting the result. This allows exceptions raised by the test to be propagated to the caller and can be used to support running tests under a debugger.", 
        "name": "unittest.TestSuite.debug", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite.debug", 
        "syntax": "debug()", 
        "type": "Development Tools"
    }, 
    "unittest.TestSuite.run": {
        "descr": "Run the tests associated with this suite, collecting the result into the test result object passed as result. Note that unlike TestCase.run(), TestSuite.run() requires the result object to be passed in.", 
        "name": "unittest.TestSuite.run", 
        "params": [], 
        "path": "python/library/unittest#unittest.TestSuite.run", 
        "syntax": "run(result)", 
        "type": "Development Tools"
    }, 
    "unittest.TextTestResult": {
        "descr": "A concrete implementation of TestResult used by the TextTestRunner.", 
        "name": "unittest.TextTestResult", 
        "params": [], 
        "path": "python/library/unittest#unittest.TextTestResult", 
        "syntax": "class unittest.TextTestResult(stream, descriptions, verbosity)", 
        "type": "Development Tools"
    }, 
    "unittest.TextTestRunner": {
        "descr": "A basic test runner implementation that outputs results to a stream. If stream is None, the default, sys.stderr is used as the output stream. This class has a few configurable parameters, but is essentially very simple. Graphical applications which run test suites should provide alternate implementations.", 
        "name": "unittest.TextTestRunner", 
        "params": [], 
        "path": "python/library/unittest#unittest.TextTestRunner", 
        "syntax": "class unittest.TextTestRunner(stream=None, descriptions=True, verbosity=1, failfast=False, buffer=False, resultclass=None, warnings=None)", 
        "type": "Development Tools"
    }, 
    "unittest.TextTestRunner._makeResult": {
        "descr": "This method returns the instance of TestResult used by run(). It is not intended to be called directly, but can be overridden in subclasses to provide a custom TestResult.", 
        "name": "unittest.TextTestRunner._makeResult", 
        "params": [], 
        "path": "python/library/unittest#unittest.TextTestRunner._makeResult", 
        "syntax": "_makeResult()", 
        "type": "Development Tools"
    }, 
    "unittest.defaultTestLoader": {
        "descr": "Instance of the TestLoader class intended to be shared. If no customization of the TestLoader is needed, this instance can be used instead of repeatedly creating new instances.", 
        "name": "unittest.defaultTestLoader", 
        "params": [], 
        "path": "python/library/unittest#unittest.defaultTestLoader", 
        "syntax": "unittest.defaultTestLoader", 
        "type": "Development Tools"
    }, 
    "unittest.expectedFailure": {
        "descr": "Mark the test as an expected failure. If the test fails when run, the test is not counted as a failure.", 
        "name": "unittest.expectedFailure", 
        "params": [], 
        "path": "python/library/unittest#unittest.expectedFailure", 
        "syntax": "@unittest.expectedFailure", 
        "type": "Development Tools"
    }, 
    "unittest.installHandler": {
        "descr": "Install the control-c handler. When a signal.SIGINT is received (usually in response to the user pressing control-c) all registered results have stop() called.", 
        "name": "unittest.installHandler", 
        "params": [], 
        "path": "python/library/unittest#unittest.installHandler", 
        "syntax": "unittest.installHandler()", 
        "type": "Development Tools"
    }, 
    "unittest.main": {
        "descr": "A command-line program that loads a set of tests from module and runs them; this is primarily for making test modules conveniently executable. The simplest use for this function is to include the following line at the end of a test script:", 
        "name": "unittest.main", 
        "params": [], 
        "path": "python/library/unittest#unittest.main", 
        "syntax": "unittest.main(module='__main__', defaultTest=None, argv=None, testRunner=None, testLoader=unittest.defaultTestLoader, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.MagicMock": {
        "descr": "MagicMock is a subclass of Mock with default implementations of most of the magic methods. You can use MagicMock without having to configure the magic methods yourself.", 
        "name": "unittest.mock.MagicMock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.MagicMock", 
        "syntax": "class unittest.mock.MagicMock(*args, **kw)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock": {
        "descr": "Create a new Mock object. Mock takes several optional arguments that specify the behaviour of the Mock object:", 
        "name": "unittest.mock.Mock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock", 
        "syntax": "class unittest.mock.Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.__class__": {
        "descr": "Normally the __class__ attribute of an object will return its type. For a mock object with a spec __class__ returns the spec class instead. This allows mock objects to pass isinstance tests for the object they are replacing / masquerading as:", 
        "name": "unittest.mock.Mock.__class__", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.__class__", 
        "syntax": "__class__", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.__dir__": {
        "descr": "Mock objects limit the results of dir(some_mock) to useful results. For mocks with a spec this includes all the permitted attributes for the mock.", 
        "name": "unittest.mock.Mock.__dir__", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.__dir__", 
        "syntax": "__dir__()", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock._get_child_mock": {
        "descr": "Create the child mocks for attributes and return value. By default child mocks will be the same type as the parent. Subclasses of Mock may want to override this to customize the way child mocks are made.", 
        "name": "unittest.mock.Mock._get_child_mock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock._get_child_mock", 
        "syntax": "_get_child_mock(**kw)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.assert_any_call": {
        "descr": "assert the mock has been called with the specified arguments.", 
        "name": "unittest.mock.Mock.assert_any_call", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.assert_any_call", 
        "syntax": "assert_any_call(*args, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.assert_called_once_with": {
        "descr": "Assert that the mock was called exactly once and with the specified arguments.", 
        "name": "unittest.mock.Mock.assert_called_once_with", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.assert_called_once_with", 
        "syntax": "assert_called_once_with(*args, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.assert_called_with": {
        "descr": "This method is a convenient way of asserting that calls are made in a particular way:", 
        "name": "unittest.mock.Mock.assert_called_with", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.assert_called_with", 
        "syntax": "assert_called_with(*args, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.assert_has_calls": {
        "descr": "assert the mock has been called with the specified calls. The mock_calls list is checked for the calls.", 
        "name": "unittest.mock.Mock.assert_has_calls", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.assert_has_calls", 
        "syntax": "assert_has_calls(calls, any_order=False)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.attach_mock": {
        "descr": "Attach a mock as an attribute of this one, replacing its name and parent. Calls to the attached mock will be recorded in the method_calls and mock_calls attributes of this one.", 
        "name": "unittest.mock.Mock.attach_mock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.attach_mock", 
        "syntax": "attach_mock(mock, attribute)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.call_args": {
        "descr": "This is either None (if the mock hasn\u2019t been called), or the arguments that the mock was last called with. This will be in the form of a tuple: the first member is any ordered arguments the mock was called with (or an empty tuple) and the second member is any keyword arguments (or an empty dictionary).", 
        "name": "unittest.mock.Mock.call_args", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.call_args", 
        "syntax": "call_args", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.call_args_list": {
        "descr": "This is a list of all the calls made to the mock object in sequence (so the length of the list is the number of times it has been called). Before any calls have been made it is an empty list. The call object can be used for conveniently constructing lists of calls to compare with call_args_list.", 
        "name": "unittest.mock.Mock.call_args_list", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.call_args_list", 
        "syntax": "call_args_list", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.call_count": {
        "descr": "An integer telling you how many times the mock object has been called:", 
        "name": "unittest.mock.Mock.call_count", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.call_count", 
        "syntax": "call_count", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.called": {
        "descr": "A boolean representing whether or not the mock object has been called:", 
        "name": "unittest.mock.Mock.called", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.called", 
        "syntax": "called", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.configure_mock": {
        "descr": "Set attributes on the mock through keyword arguments.", 
        "name": "unittest.mock.Mock.configure_mock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.configure_mock", 
        "syntax": "configure_mock(**kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.method_calls": {
        "descr": "As well as tracking calls to themselves, mocks also track calls to methods and attributes, and their methods and attributes:", 
        "name": "unittest.mock.Mock.method_calls", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.method_calls", 
        "syntax": "method_calls", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.mock_add_spec": {
        "descr": "Add a spec to a mock. spec can either be an object or a list of strings. Only attributes on the spec can be fetched as attributes from the mock.", 
        "name": "unittest.mock.Mock.mock_add_spec", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.mock_add_spec", 
        "syntax": "mock_add_spec(spec, spec_set=False)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.mock_calls": {
        "descr": "mock_calls records all calls to the mock object, its methods, magic methods and return value mocks.", 
        "name": "unittest.mock.Mock.mock_calls", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.mock_calls", 
        "syntax": "mock_calls", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.reset_mock": {
        "descr": "The reset_mock method resets all the call attributes on a mock object:", 
        "name": "unittest.mock.Mock.reset_mock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.reset_mock", 
        "syntax": "reset_mock()", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.return_value": {
        "descr": "Set this to configure the value returned by calling the mock:", 
        "name": "unittest.mock.Mock.return_value", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.return_value", 
        "syntax": "return_value", 
        "type": "Development Tools"
    }, 
    "unittest.mock.Mock.side_effect": {
        "descr": "This can either be a function to be called when the mock is called, or an exception (class or instance) to be raised.", 
        "name": "unittest.mock.Mock.side_effect", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.Mock.side_effect", 
        "syntax": "side_effect", 
        "type": "Development Tools"
    }, 
    "unittest.mock.NonCallableMagicMock": {
        "descr": "A non-callable version of MagicMock.", 
        "name": "unittest.mock.NonCallableMagicMock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.NonCallableMagicMock", 
        "syntax": "class unittest.mock.NonCallableMagicMock(*args, **kw)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.NonCallableMock": {
        "descr": "A non-callable version of Mock. The constructor parameters have the same meaning of Mock, with the exception of return_value and side_effect which have no meaning on a non-callable mock.", 
        "name": "unittest.mock.NonCallableMock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.NonCallableMock", 
        "syntax": "class unittest.mock.NonCallableMock(spec=None, wraps=None, name=None, spec_set=None, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.PropertyMock": {
        "descr": "A mock intended to be used as a property, or other descriptor, on a class. PropertyMock provides __get__ and __set__ methods so you can specify a return value when it is fetched.", 
        "name": "unittest.mock.PropertyMock", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.PropertyMock", 
        "syntax": "class unittest.mock.PropertyMock(*args, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.call": {
        "descr": "call is a helper object for making simpler assertions, for comparing with call_args, call_args_list, mock_calls and method_calls. call can also be used with assert_has_calls().", 
        "name": "unittest.mock.call", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.call", 
        "syntax": "unittest.mock.call(*args, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.call.call_list": {
        "descr": "For a call object that represents multiple calls, call_list returns a list of all the intermediate calls as well as the final call.", 
        "name": "unittest.mock.call.call_list", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.call.call_list", 
        "syntax": "call.call_list()", 
        "type": "Development Tools"
    }, 
    "unittest.mock.create_autospec": {
        "descr": "Create a mock object using another object as a spec. Attributes on the mock will use the corresponding attribute on the spec object as their spec.", 
        "name": "unittest.mock.create_autospec", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.create_autospec", 
        "syntax": "unittest.mock.create_autospec(spec, spec_set=False, instance=False, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.mock_open": {
        "descr": "A helper function to create a mock to replace the use of open. It works for open called directly or used as a context manager.", 
        "name": "unittest.mock.mock_open", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.mock_open", 
        "syntax": "unittest.mock.mock_open(mock=None, read_data=None)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.patch": {
        "descr": "patch acts as a function decorator, class decorator or a context manager. Inside the body of the function or with statement, the target is patched with a new object. When the function/with statement exits the patch is undone.", 
        "name": "unittest.mock.patch", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.patch", 
        "syntax": "unittest.mock.patch(target, new=DEFAULT, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.patch.dict": {
        "descr": "Patch a dictionary, or dictionary like object, and restore the dictionary to its original state after the test.", 
        "name": "unittest.mock.patch.dict", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.patch.dict", 
        "syntax": "patch.dict(in_dict, values=(), clear=False, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.patch.multiple": {
        "descr": "Perform multiple patches in a single call. It takes the object to be patched (either as an object or a string to fetch the object by importing) and keyword arguments for the patches:", 
        "name": "unittest.mock.patch.multiple", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.patch.multiple", 
        "syntax": "patch.multiple(target, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.patch.object": {
        "descr": "patch the named member (attribute) on an object (target) with a mock object.", 
        "name": "unittest.mock.patch.object", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.patch.object", 
        "syntax": "patch.object(target, attribute, new=DEFAULT, spec=None, create=False, spec_set=None, autospec=None, new_callable=None, **kwargs)", 
        "type": "Development Tools"
    }, 
    "unittest.mock.patch.stopall": {
        "descr": "Stop all active patches. Only stops patches started with start.", 
        "name": "unittest.mock.patch.stopall", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.patch.stopall", 
        "syntax": "patch.stopall()", 
        "type": "Development Tools"
    }, 
    "unittest.mock.sentinel": {
        "descr": "The sentinel object provides a convenient way of providing unique objects for your tests.", 
        "name": "unittest.mock.sentinel", 
        "params": [], 
        "path": "python/library/unittest.mock#unittest.mock.sentinel", 
        "syntax": "unittest.mock.sentinel", 
        "type": "Development Tools"
    }, 
    "unittest.registerResult": {
        "descr": "Register a TestResult object for control-c handling. Registering a result stores a weak reference to it, so it doesn\u2019t prevent the result from being garbage collected.", 
        "name": "unittest.registerResult", 
        "params": [], 
        "path": "python/library/unittest#unittest.registerResult", 
        "syntax": "unittest.registerResult(result)", 
        "type": "Development Tools"
    }, 
    "unittest.removeHandler": {
        "descr": "When called without arguments this function removes the control-c handler if it has been installed. This function can also be used as a test decorator to temporarily remove the handler whilst the test is being executed:", 
        "name": "unittest.removeHandler", 
        "params": [], 
        "path": "python/library/unittest#unittest.removeHandler", 
        "syntax": "unittest.removeHandler(function=None)", 
        "type": "Development Tools"
    }, 
    "unittest.removeResult": {
        "descr": "Remove a registered result. Once a result has been removed then stop() will no longer be called on that result object in response to a control-c.", 
        "name": "unittest.removeResult", 
        "params": [], 
        "path": "python/library/unittest#unittest.removeResult", 
        "syntax": "unittest.removeResult(result)", 
        "type": "Development Tools"
    }, 
    "unittest.skip": {
        "descr": "Unconditionally skip the decorated test. reason should describe why the test is being skipped.", 
        "name": "unittest.skip", 
        "params": [], 
        "path": "python/library/unittest#unittest.skip", 
        "syntax": "@unittest.skip(reason)", 
        "type": "Development Tools"
    }, 
    "unittest.skipIf": {
        "descr": "Skip the decorated test if condition is true.", 
        "name": "unittest.skipIf", 
        "params": [], 
        "path": "python/library/unittest#unittest.skipIf", 
        "syntax": "@unittest.skipIf(condition, reason)", 
        "type": "Development Tools"
    }, 
    "unittest.skipUnless": {
        "descr": "Skip the decorated test unless condition is true.", 
        "name": "unittest.skipUnless", 
        "params": [], 
        "path": "python/library/unittest#unittest.skipUnless", 
        "syntax": "@unittest.skipUnless(condition, reason)", 
        "type": "Development Tools"
    }, 
    "update": {
        "descr": "Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None.", 
        "name": "dict.update", 
        "params": [], 
        "path": "python/library/stdtypes#dict.update", 
        "syntax": "update([other])", 
        "type": "Built-in Types"
    }, 
    "upper": {
        "descr": "Return a copy of the string with all the cased characters [4] converted to uppercase. Note that str.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not \u201cLu\u201d (Letter, uppercase), but e.g. \u201cLt\u201d (Letter, titlecase).", 
        "name": "str.upper", 
        "params": [], 
        "path": "python/library/stdtypes#str.upper", 
        "syntax": "str.upper()", 
        "type": "Built-in Types"
    }, 
    "urllib.error.ContentTooShortError": {
        "descr": "This exception is raised when the urlretrieve() function detects that the amount of the downloaded data is less than the expected amount (given by the Content-Length header). The content attribute stores the downloaded (and supposedly truncated) data.", 
        "name": "urllib.error.ContentTooShortError", 
        "params": [], 
        "path": "python/library/urllib.error#urllib.error.ContentTooShortError", 
        "syntax": "exception urllib.error.ContentTooShortError(msg, content)", 
        "type": "Internet"
    }, 
    "urllib.error.HTTPError": {
        "descr": "Though being an exception (a subclass of URLError), an HTTPError can also function as a non-exceptional file-like return value (the same thing that urlopen() returns). This is useful when handling exotic HTTP errors, such as requests for authentication.", 
        "name": "urllib.error.HTTPError", 
        "params": [], 
        "path": "python/library/urllib.error#urllib.error.HTTPError", 
        "syntax": "exception urllib.error.HTTPError", 
        "type": "Internet"
    }, 
    "urllib.error.HTTPError.code": {
        "descr": "An HTTP status code as defined in RFC 2616. This numeric value corresponds to a value found in the dictionary of codes as found in http.server.BaseHTTPRequestHandler.responses.", 
        "name": "urllib.error.HTTPError.code", 
        "params": [], 
        "path": "python/library/urllib.error#urllib.error.HTTPError.code", 
        "syntax": "code", 
        "type": "Internet"
    }, 
    "urllib.error.HTTPError.reason": {
        "descr": "This is usually a string explaining the reason for this error.", 
        "name": "urllib.error.HTTPError.reason", 
        "params": [], 
        "path": "python/library/urllib.error#urllib.error.HTTPError.reason", 
        "syntax": "reason", 
        "type": "Internet"
    }, 
    "urllib.error.URLError": {
        "descr": "The handlers raise this exception (or derived exceptions) when they run into a problem. It is a subclass of OSError.", 
        "name": "urllib.error.URLError", 
        "params": [], 
        "path": "python/library/urllib.error#urllib.error.URLError", 
        "syntax": "exception urllib.error.URLError", 
        "type": "Internet"
    }, 
    "urllib.error.URLError.reason": {
        "descr": "The reason for this error. It can be a message string or another exception instance.", 
        "name": "urllib.error.URLError.reason", 
        "params": [], 
        "path": "python/library/urllib.error#urllib.error.URLError.reason", 
        "syntax": "reason", 
        "type": "Internet"
    }, 
    "urllib.parse.DefragResult": {
        "descr": "Concrete class for urldefrag() results containing str data. The encode() method returns a DefragResultBytes instance.", 
        "name": "urllib.parse.DefragResult", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.DefragResult", 
        "syntax": "class urllib.parse.DefragResult(url, fragment)", 
        "type": "Internet"
    }, 
    "urllib.parse.DefragResultBytes": {
        "descr": "Concrete class for urldefrag() results containing bytes data. The decode() method returns a DefragResult instance.", 
        "name": "urllib.parse.DefragResultBytes", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.DefragResultBytes", 
        "syntax": "class urllib.parse.DefragResultBytes(url, fragment)", 
        "type": "Internet"
    }, 
    "urllib.parse.ParseResult": {
        "descr": "Concrete class for urlparse() results containing str data. The encode() method returns a ParseResultBytes instance.", 
        "name": "urllib.parse.ParseResult", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.ParseResult", 
        "syntax": "class urllib.parse.ParseResult(scheme, netloc, path, params, query, fragment)", 
        "type": "Internet"
    }, 
    "urllib.parse.ParseResultBytes": {
        "descr": "Concrete class for urlparse() results containing bytes data. The decode() method returns a ParseResult instance.", 
        "name": "urllib.parse.ParseResultBytes", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.ParseResultBytes", 
        "syntax": "class urllib.parse.ParseResultBytes(scheme, netloc, path, params, query, fragment)", 
        "type": "Internet"
    }, 
    "urllib.parse.SplitResult": {
        "descr": "Concrete class for urlsplit() results containing str data. The encode() method returns a SplitResultBytes instance.", 
        "name": "urllib.parse.SplitResult", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.SplitResult", 
        "syntax": "class urllib.parse.SplitResult(scheme, netloc, path, query, fragment)", 
        "type": "Internet"
    }, 
    "urllib.parse.SplitResultBytes": {
        "descr": "Concrete class for urlsplit() results containing bytes data. The decode() method returns a SplitResult instance.", 
        "name": "urllib.parse.SplitResultBytes", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.SplitResultBytes", 
        "syntax": "class urllib.parse.SplitResultBytes(scheme, netloc, path, query, fragment)", 
        "type": "Internet"
    }, 
    "urllib.parse.parse_qs": {
        "descr": "Parse a query string given as a string argument (data of type application/x-www-form-urlencoded). Data are returned as a dictionary. The dictionary keys are the unique query variable names and the values are lists of values for each name.", 
        "name": "urllib.parse.parse_qs", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.parse_qs", 
        "syntax": "urllib.parse.parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace')", 
        "type": "Internet"
    }, 
    "urllib.parse.parse_qsl": {
        "descr": "Parse a query string given as a string argument (data of type application/x-www-form-urlencoded). Data are returned as a list of name, value pairs.", 
        "name": "urllib.parse.parse_qsl", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.parse_qsl", 
        "syntax": "urllib.parse.parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace')", 
        "type": "Internet"
    }, 
    "urllib.parse.quote": {
        "descr": "Replace special characters in string using the %xx escape. Letters, digits, and the characters '_.-' are never quoted. By default, this function is intended for quoting the path section of URL. The optional safe parameter specifies additional ASCII characters that should not be quoted \u2014 its default value is '/'.", 
        "name": "urllib.parse.quote", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.quote", 
        "syntax": "urllib.parse.quote(string, safe='/', encoding=None, errors=None)", 
        "type": "Internet"
    }, 
    "urllib.parse.quote_from_bytes": {
        "descr": "Like quote(), but accepts a bytes object rather than a str, and does not perform string-to-bytes encoding.", 
        "name": "urllib.parse.quote_from_bytes", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.quote_from_bytes", 
        "syntax": "urllib.parse.quote_from_bytes(bytes, safe='/')", 
        "type": "Internet"
    }, 
    "urllib.parse.quote_plus": {
        "descr": "Like quote(), but also replace spaces by plus signs, as required for quoting HTML form values when building up a query string to go into a URL. Plus signs in the original string are escaped unless they are included in safe. It also does not have safe default to '/'.", 
        "name": "urllib.parse.quote_plus", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.quote_plus", 
        "syntax": "urllib.parse.quote_plus(string, safe='', encoding=None, errors=None)", 
        "type": "Internet"
    }, 
    "urllib.parse.unquote": {
        "descr": "Replace %xx escapes by their single-character equivalent. The optional encoding and errors parameters specify how to decode percent-encoded sequences into Unicode characters, as accepted by the bytes.decode() method.", 
        "name": "urllib.parse.unquote", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.unquote", 
        "syntax": "urllib.parse.unquote(string, encoding='utf-8', errors='replace')", 
        "type": "Internet"
    }, 
    "urllib.parse.unquote_plus": {
        "descr": "Like unquote(), but also replace plus signs by spaces, as required for unquoting HTML form values.", 
        "name": "urllib.parse.unquote_plus", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.unquote_plus", 
        "syntax": "urllib.parse.unquote_plus(string, encoding='utf-8', errors='replace')", 
        "type": "Internet"
    }, 
    "urllib.parse.unquote_to_bytes": {
        "descr": "Replace %xx escapes by their single-octet equivalent, and return a bytes object.", 
        "name": "urllib.parse.unquote_to_bytes", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.unquote_to_bytes", 
        "syntax": "urllib.parse.unquote_to_bytes(string)", 
        "type": "Internet"
    }, 
    "urllib.parse.urldefrag": {
        "descr": "If url contains a fragment identifier, return a modified version of url with no fragment identifier, and the fragment identifier as a separate string. If there is no fragment identifier in url, return url unmodified and an empty string.", 
        "name": "urllib.parse.urldefrag", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urldefrag", 
        "syntax": "urllib.parse.urldefrag(url)", 
        "type": "Internet"
    }, 
    "urllib.parse.urlencode": {
        "descr": "Convert a mapping object or a sequence of two-element tuples, which may either be a str or a bytes, to a \u201cpercent-encoded\u201d string. If the resultant string is to be used as a data for POST operation with urlopen() function, then it should be properly encoded to bytes, otherwise it would result in a TypeError.", 
        "name": "urllib.parse.urlencode", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urlencode", 
        "syntax": "urllib.parse.urlencode(query, doseq=False, safe='', encoding=None, errors=None)", 
        "type": "Internet"
    }, 
    "urllib.parse.urljoin": {
        "descr": "Construct a full (\u201cabsolute\u201d) URL by combining a \u201cbase URL\u201d (base) with another URL (url). Informally, this uses components of the base URL, in particular the addressing scheme, the network location and (part of) the path, to provide missing components in the relative URL. For example:", 
        "name": "urllib.parse.urljoin", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urljoin", 
        "syntax": "urllib.parse.urljoin(base, url, allow_fragments=True)", 
        "type": "Internet"
    }, 
    "urllib.parse.urllib.parse.SplitResult.geturl": {
        "descr": "Return the re-combined version of the original URL as a string. This may differ from the original URL in that the scheme may be normalized to lower case and empty components may be dropped. Specifically, empty parameters, queries, and fragment identifiers will be removed.", 
        "name": "urllib.parse.urllib.parse.SplitResult.geturl", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urllib.parse.SplitResult.geturl", 
        "syntax": "urllib.parse.SplitResult.geturl()", 
        "type": "Internet"
    }, 
    "urllib.parse.urlparse": {
        "descr": "Parse a URL into six components, returning a 6-tuple. This corresponds to the general structure of a URL: scheme://netloc/path;parameters?query#fragment. Each tuple item is a string, possibly empty. The components are not broken up in smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the path component, which is retained if present. For example:", 
        "name": "urllib.parse.urlparse", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urlparse", 
        "syntax": "urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)", 
        "type": "Internet"
    }, 
    "urllib.parse.urlsplit": {
        "descr": "This is similar to urlparse(), but does not split the params from the URL. This should generally be used instead of urlparse() if the more recent URL syntax allowing parameters to be applied to each segment of the path portion of the URL (see RFC 2396) is wanted. A separate function is needed to separate the path segments and parameters. This function returns a 5-tuple: (addressing scheme, network location, path, query, fragment identifier).", 
        "name": "urllib.parse.urlsplit", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urlsplit", 
        "syntax": "urllib.parse.urlsplit(urlstring, scheme='', allow_fragments=True)", 
        "type": "Internet"
    }, 
    "urllib.parse.urlunparse": {
        "descr": "Construct a URL from a tuple as returned by urlparse(). The parts argument can be any six-item iterable. This may result in a slightly different, but equivalent URL, if the URL that was parsed originally had unnecessary delimiters (for example, a ? with an empty query; the RFC states that these are equivalent).", 
        "name": "urllib.parse.urlunparse", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urlunparse", 
        "syntax": "urllib.parse.urlunparse(parts)", 
        "type": "Internet"
    }, 
    "urllib.parse.urlunsplit": {
        "descr": "Combine the elements of a tuple as returned by urlsplit() into a complete URL as a string. The parts argument can be any five-item iterable. This may result in a slightly different, but equivalent URL, if the URL that was parsed originally had unnecessary delimiters (for example, a ? with an empty query; the RFC states that these are equivalent).", 
        "name": "urllib.parse.urlunsplit", 
        "params": [], 
        "path": "python/library/urllib.parse#urllib.parse.urlunsplit", 
        "syntax": "urllib.parse.urlunsplit(parts)", 
        "type": "Internet"
    }, 
    "urllib.request.AbstractBasicAuthHandler": {
        "descr": "This is a mixin class that helps with HTTP authentication, both to the remote host and to a proxy. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported.", 
        "name": "urllib.request.AbstractBasicAuthHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.AbstractBasicAuthHandler", 
        "syntax": "class urllib.request.AbstractBasicAuthHandler(password_mgr=None)", 
        "type": "Internet"
    }, 
    "urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed": {
        "descr": "Handle an authentication request by getting a user/password pair, and re-trying the request. authreq should be the name of the header where the information about the realm is included in the request, host specifies the URL and path to authenticate for, req should be the (failed) Request object, and headers should be the error headers.", 
        "name": "urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed", 
        "syntax": "AbstractBasicAuthHandler.http_error_auth_reqed(authreq, host, req, headers)", 
        "type": "Internet"
    }, 
    "urllib.request.AbstractDigestAuthHandler": {
        "descr": "This is a mixin class that helps with HTTP authentication, both to the remote host and to a proxy. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported.", 
        "name": "urllib.request.AbstractDigestAuthHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.AbstractDigestAuthHandler", 
        "syntax": "class urllib.request.AbstractDigestAuthHandler(password_mgr=None)", 
        "type": "Internet"
    }, 
    "urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed": {
        "descr": "authreq should be the name of the header where the information about the realm is included in the request, host should be the host to authenticate to, req should be the (failed) Request object, and headers should be the error headers.", 
        "name": "urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed", 
        "syntax": "AbstractDigestAuthHandler.http_error_auth_reqed(authreq, host, req, headers)", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler": {
        "descr": "This is the base class for all registered handlers \u2014 and handles only the simple mechanics of registration.", 
        "name": "urllib.request.BaseHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler", 
        "syntax": "class urllib.request.BaseHandler", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.add_parent": {
        "descr": "Add a director as parent.", 
        "name": "urllib.request.BaseHandler.add_parent", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.add_parent", 
        "syntax": "BaseHandler.add_parent(director)", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.close": {
        "descr": "Remove any parents.", 
        "name": "urllib.request.BaseHandler.close", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.close", 
        "syntax": "BaseHandler.close()", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.default_open": {
        "descr": "This method is not defined in BaseHandler, but subclasses should define it if they want to catch all URLs.", 
        "name": "urllib.request.BaseHandler.default_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.default_open", 
        "syntax": "BaseHandler.default_open(req)", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.http_error_default": {
        "descr": "This method is not defined in BaseHandler, but subclasses should override it if they intend to provide a catch-all for otherwise unhandled HTTP errors. It will be called automatically by the OpenerDirector getting the error, and should not normally be called in other circumstances.", 
        "name": "urllib.request.BaseHandler.http_error_default", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.http_error_default", 
        "syntax": "BaseHandler.http_error_default(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.http_error_nnn": {
        "descr": "nnn should be a three-digit HTTP error code. This method is also not defined in BaseHandler, but will be called, if it exists, on an instance of a subclass, when an HTTP error with code nnn occurs.", 
        "name": "urllib.request.BaseHandler.http_error_nnn", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.http_error_nnn", 
        "syntax": "BaseHandler.http_error_nnn(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.parent": {
        "descr": "A valid OpenerDirector, which can be used to open using a different protocol, or handle errors.", 
        "name": "urllib.request.BaseHandler.parent", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.parent", 
        "syntax": "BaseHandler.parent", 
        "type": "Internet"
    }, 
    "urllib.request.BaseHandler.unknown_open": {
        "descr": "This method is not defined in BaseHandler, but subclasses should define it if they want to catch all URLs with no specific registered handler to open it.", 
        "name": "urllib.request.BaseHandler.unknown_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.BaseHandler.unknown_open", 
        "syntax": "BaseHandler.unknown_open(req)", 
        "type": "Internet"
    }, 
    "urllib.request.CacheFTPHandler": {
        "descr": "Open FTP URLs, keeping a cache of open FTP connections to minimize delays.", 
        "name": "urllib.request.CacheFTPHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.CacheFTPHandler", 
        "syntax": "class urllib.request.CacheFTPHandler", 
        "type": "Internet"
    }, 
    "urllib.request.CacheFTPHandler.setMaxConns": {
        "descr": "Set maximum number of cached connections to m.", 
        "name": "urllib.request.CacheFTPHandler.setMaxConns", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.CacheFTPHandler.setMaxConns", 
        "syntax": "CacheFTPHandler.setMaxConns(m)", 
        "type": "Internet"
    }, 
    "urllib.request.CacheFTPHandler.setTimeout": {
        "descr": "Set timeout of connections to t seconds.", 
        "name": "urllib.request.CacheFTPHandler.setTimeout", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.CacheFTPHandler.setTimeout", 
        "syntax": "CacheFTPHandler.setTimeout(t)", 
        "type": "Internet"
    }, 
    "urllib.request.FTPHandler": {
        "descr": "Open FTP URLs.", 
        "name": "urllib.request.FTPHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.FTPHandler", 
        "syntax": "class urllib.request.FTPHandler", 
        "type": "Internet"
    }, 
    "urllib.request.FTPHandler.ftp_open": {
        "descr": "Open the FTP file indicated by req. The login is always done with empty username and password.", 
        "name": "urllib.request.FTPHandler.ftp_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.FTPHandler.ftp_open", 
        "syntax": "FTPHandler.ftp_open(req)", 
        "type": "Internet"
    }, 
    "urllib.request.FancyURLopener": {
        "descr": "Deprecated since version 3.3.", 
        "name": "urllib.request.FancyURLopener", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.FancyURLopener", 
        "syntax": "class urllib.request.FancyURLopener(...)", 
        "type": "Internet"
    }, 
    "urllib.request.FancyURLopener.prompt_user_passwd": {
        "descr": "Return information needed to authenticate the user at the given host in the specified security realm. The return value should be a tuple, (user, password), which can be used for basic authentication.", 
        "name": "urllib.request.FancyURLopener.prompt_user_passwd", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.FancyURLopener.prompt_user_passwd", 
        "syntax": "prompt_user_passwd(host, realm)", 
        "type": "Internet"
    }, 
    "urllib.request.FileHandler": {
        "descr": "Open local files.", 
        "name": "urllib.request.FileHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.FileHandler", 
        "syntax": "class urllib.request.FileHandler", 
        "type": "Internet"
    }, 
    "urllib.request.FileHandler.file_open": {
        "descr": "Open the file locally, if there is no host name, or the host name is 'localhost'.", 
        "name": "urllib.request.FileHandler.file_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.FileHandler.file_open", 
        "syntax": "FileHandler.file_open(req)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPBasicAuthHandler": {
        "descr": "Handle authentication with the remote host. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported. HTTPBasicAuthHandler will raise a ValueError when presented with a wrong Authentication scheme.", 
        "name": "urllib.request.HTTPBasicAuthHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPBasicAuthHandler", 
        "syntax": "class urllib.request.HTTPBasicAuthHandler(password_mgr=None)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPBasicAuthHandler.http_error_401": {
        "descr": "Retry the request with authentication information, if available.", 
        "name": "urllib.request.HTTPBasicAuthHandler.http_error_401", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPBasicAuthHandler.http_error_401", 
        "syntax": "HTTPBasicAuthHandler.http_error_401(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPCookieProcessor": {
        "descr": "A class to handle HTTP Cookies.", 
        "name": "urllib.request.HTTPCookieProcessor", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPCookieProcessor", 
        "syntax": "class urllib.request.HTTPCookieProcessor(cookiejar=None)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPCookieProcessor.cookiejar": {
        "descr": "The http.cookiejar.CookieJar in which cookies are stored.", 
        "name": "urllib.request.HTTPCookieProcessor.cookiejar", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPCookieProcessor.cookiejar", 
        "syntax": "HTTPCookieProcessor.cookiejar", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPDefaultErrorHandler": {
        "descr": "A class which defines a default handler for HTTP error responses; all responses are turned into HTTPError exceptions.", 
        "name": "urllib.request.HTTPDefaultErrorHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPDefaultErrorHandler", 
        "syntax": "class urllib.request.HTTPDefaultErrorHandler", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPDigestAuthHandler": {
        "descr": "Handle authentication with the remote host. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported. When both Digest Authentication Handler and Basic Authentication Handler are both added, Digest Authentication is always tried first. If the Digest Authentication returns a 40x response again, it is sent to Basic Authentication handler to Handle. This Handler method will raise a ValueError when presented with an authentication scheme other than Digest or Basic.", 
        "name": "urllib.request.HTTPDigestAuthHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPDigestAuthHandler", 
        "syntax": "class urllib.request.HTTPDigestAuthHandler(password_mgr=None)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPDigestAuthHandler.http_error_401": {
        "descr": "Retry the request with authentication information, if available.", 
        "name": "urllib.request.HTTPDigestAuthHandler.http_error_401", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPDigestAuthHandler.http_error_401", 
        "syntax": "HTTPDigestAuthHandler.http_error_401(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPErrorProcessor": {
        "descr": "Process HTTP error responses.", 
        "name": "urllib.request.HTTPErrorProcessor", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPErrorProcessor", 
        "syntax": "class urllib.request.HTTPErrorProcessor", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPErrorProcessor.http_response": {
        "descr": "Process HTTP error responses.", 
        "name": "urllib.request.HTTPErrorProcessor.http_response", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPErrorProcessor.http_response", 
        "syntax": "HTTPErrorProcessor.http_response()", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPErrorProcessor.https_response": {
        "descr": "Process HTTPS error responses.", 
        "name": "urllib.request.HTTPErrorProcessor.https_response", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPErrorProcessor.https_response", 
        "syntax": "HTTPErrorProcessor.https_response()", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPHandler": {
        "descr": "A class to handle opening of HTTP URLs.", 
        "name": "urllib.request.HTTPHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPHandler", 
        "syntax": "class urllib.request.HTTPHandler", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPHandler.http_open": {
        "descr": "Send an HTTP request, which can be either GET or POST, depending on req.has_data().", 
        "name": "urllib.request.HTTPHandler.http_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPHandler.http_open", 
        "syntax": "HTTPHandler.http_open(req)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPPasswordMgr": {
        "descr": "Keep a database of (realm, uri) -> (user, password) mappings.", 
        "name": "urllib.request.HTTPPasswordMgr", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPPasswordMgr", 
        "syntax": "class urllib.request.HTTPPasswordMgr", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPPasswordMgr.add_password": {
        "descr": "uri can be either a single URI, or a sequence of URIs. realm, user and passwd must be strings. This causes (user, passwd) to be used as authentication tokens when authentication for realm and a super-URI of any of the given URIs is given.", 
        "name": "urllib.request.HTTPPasswordMgr.add_password", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPPasswordMgr.add_password", 
        "syntax": "HTTPPasswordMgr.add_password(realm, uri, user, passwd)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPPasswordMgr.find_user_password": {
        "descr": "Get user/password for given realm and URI, if any. This method will return (None, None) if there is no matching user/password.", 
        "name": "urllib.request.HTTPPasswordMgr.find_user_password", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPPasswordMgr.find_user_password", 
        "syntax": "HTTPPasswordMgr.find_user_password(realm, authuri)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPPasswordMgrWithDefaultRealm": {
        "descr": "Keep a database of (realm, uri) -> (user, password) mappings. A realm of None is considered a catch-all realm, which is searched if no other realm fits.", 
        "name": "urllib.request.HTTPPasswordMgrWithDefaultRealm", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPPasswordMgrWithDefaultRealm", 
        "syntax": "class urllib.request.HTTPPasswordMgrWithDefaultRealm", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPRedirectHandler": {
        "descr": "A class to handle redirections.", 
        "name": "urllib.request.HTTPRedirectHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPRedirectHandler", 
        "syntax": "class urllib.request.HTTPRedirectHandler", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPRedirectHandler.http_error_301": {
        "descr": "Redirect to the Location: or URI: URL. This method is called by the parent OpenerDirector when getting an HTTP \u2018moved permanently\u2019 response.", 
        "name": "urllib.request.HTTPRedirectHandler.http_error_301", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_301", 
        "syntax": "HTTPRedirectHandler.http_error_301(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPRedirectHandler.http_error_302": {
        "descr": "The same as http_error_301(), but called for the \u2018found\u2019 response.", 
        "name": "urllib.request.HTTPRedirectHandler.http_error_302", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_302", 
        "syntax": "HTTPRedirectHandler.http_error_302(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPRedirectHandler.http_error_303": {
        "descr": "The same as http_error_301(), but called for the \u2018see other\u2019 response.", 
        "name": "urllib.request.HTTPRedirectHandler.http_error_303", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_303", 
        "syntax": "HTTPRedirectHandler.http_error_303(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPRedirectHandler.http_error_307": {
        "descr": "The same as http_error_301(), but called for the \u2018temporary redirect\u2019 response.", 
        "name": "urllib.request.HTTPRedirectHandler.http_error_307", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_307", 
        "syntax": "HTTPRedirectHandler.http_error_307(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPRedirectHandler.redirect_request": {
        "descr": "Return a Request or None in response to a redirect. This is called by the default implementations of the http_error_30*() methods when a redirection is received from the server. If a redirection should take place, return a new Request to allow http_error_30*() to perform the redirect to newurl. Otherwise, raise HTTPError if no other handler should try to handle this URL, or return None if you can\u2019t but another handler might.", 
        "name": "urllib.request.HTTPRedirectHandler.redirect_request", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPRedirectHandler.redirect_request", 
        "syntax": "HTTPRedirectHandler.redirect_request(req, fp, code, msg, hdrs, newurl)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPSHandler": {
        "descr": "A class to handle opening of HTTPS URLs. context and check_hostname have the same meaning as in http.client.HTTPSConnection.", 
        "name": "urllib.request.HTTPSHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPSHandler", 
        "syntax": "class urllib.request.HTTPSHandler(debuglevel=0, context=None, check_hostname=None)", 
        "type": "Internet"
    }, 
    "urllib.request.HTTPSHandler.https_open": {
        "descr": "Send an HTTPS request, which can be either GET or POST, depending on req.has_data().", 
        "name": "urllib.request.HTTPSHandler.https_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.HTTPSHandler.https_open", 
        "syntax": "HTTPSHandler.https_open(req)", 
        "type": "Internet"
    }, 
    "urllib.request.OpenerDirector": {
        "descr": "The OpenerDirector class opens URLs via BaseHandlers chained together. It manages the chaining of handlers, and recovery from errors.", 
        "name": "urllib.request.OpenerDirector", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.OpenerDirector", 
        "syntax": "class urllib.request.OpenerDirector", 
        "type": "Internet"
    }, 
    "urllib.request.OpenerDirector.add_handler": {
        "descr": "handler should be an instance of BaseHandler. The following methods are searched, and added to the possible chains (note that HTTP errors are a special case).", 
        "name": "urllib.request.OpenerDirector.add_handler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.OpenerDirector.add_handler", 
        "syntax": "OpenerDirector.add_handler(handler)", 
        "type": "Internet"
    }, 
    "urllib.request.OpenerDirector.error": {
        "descr": "Handle an error of the given protocol. This will call the registered error handlers for the given protocol with the given arguments (which are protocol specific). The HTTP protocol is a special case which uses the HTTP response code to determine the specific error handler; refer to the http_error_*() methods of the handler classes.", 
        "name": "urllib.request.OpenerDirector.error", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.OpenerDirector.error", 
        "syntax": "OpenerDirector.error(proto, *args)", 
        "type": "Internet"
    }, 
    "urllib.request.OpenerDirector.open": {
        "descr": "Open the given url (which can be a request object or a string), optionally passing the given data. Arguments, return values and exceptions raised are the same as those of urlopen() (which simply calls the open() method on the currently installed global OpenerDirector). The optional timeout parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). The timeout feature actually works only for HTTP, HTTPS and FTP connections).", 
        "name": "urllib.request.OpenerDirector.open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.OpenerDirector.open", 
        "syntax": "OpenerDirector.open(url, data=None[, timeout])", 
        "type": "Internet"
    }, 
    "urllib.request.ProxyBasicAuthHandler": {
        "descr": "Handle authentication with the proxy. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported.", 
        "name": "urllib.request.ProxyBasicAuthHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.ProxyBasicAuthHandler", 
        "syntax": "class urllib.request.ProxyBasicAuthHandler(password_mgr=None)", 
        "type": "Internet"
    }, 
    "urllib.request.ProxyBasicAuthHandler.http_error_407": {
        "descr": "Retry the request with authentication information, if available.", 
        "name": "urllib.request.ProxyBasicAuthHandler.http_error_407", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.ProxyBasicAuthHandler.http_error_407", 
        "syntax": "ProxyBasicAuthHandler.http_error_407(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.ProxyDigestAuthHandler": {
        "descr": "Handle authentication with the proxy. password_mgr, if given, should be something that is compatible with HTTPPasswordMgr; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported.", 
        "name": "urllib.request.ProxyDigestAuthHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.ProxyDigestAuthHandler", 
        "syntax": "class urllib.request.ProxyDigestAuthHandler(password_mgr=None)", 
        "type": "Internet"
    }, 
    "urllib.request.ProxyDigestAuthHandler.http_error_407": {
        "descr": "Retry the request with authentication information, if available.", 
        "name": "urllib.request.ProxyDigestAuthHandler.http_error_407", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.ProxyDigestAuthHandler.http_error_407", 
        "syntax": "ProxyDigestAuthHandler.http_error_407(req, fp, code, msg, hdrs)", 
        "type": "Internet"
    }, 
    "urllib.request.ProxyHandler": {
        "descr": "Cause requests to go through a proxy. If proxies is given, it must be a dictionary mapping protocol names to URLs of proxies. The default is to read the list of proxies from the environment variables <protocol>_proxy. If no proxy environment variables are set, then in a Windows environment proxy settings are obtained from the registry\u2019s Internet Settings section, and in a Mac OS X environment proxy information is retrieved from the OS X System Configuration Framework.", 
        "name": "urllib.request.ProxyHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.ProxyHandler", 
        "syntax": "class urllib.request.ProxyHandler(proxies=None)", 
        "type": "Internet"
    }, 
    "urllib.request.Request": {
        "descr": "This class is an abstraction of a URL request.", 
        "name": "urllib.request.Request", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request", 
        "syntax": "class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.add_data": {
        "descr": "Set the Request data to data. This is ignored by all handlers except HTTP handlers \u2014 and there it should be a byte string, and will change the request to be POST rather than GET. Deprecated in 3.3, use Request.data.", 
        "name": "urllib.request.Request.add_data", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.add_data", 
        "syntax": "Request.add_data(data)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.add_header": {
        "descr": "Add another header to the request. Headers are currently ignored by all handlers except HTTP handlers, where they are added to the list of headers sent to the server. Note that there cannot be more than one header with the same name, and later calls will overwrite previous calls in case the key collides. Currently, this is no loss of HTTP functionality, since all headers which have meaning when used more than once have a (header-specific) way of gaining the same functionality using only one header.", 
        "name": "urllib.request.Request.add_header", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.add_header", 
        "syntax": "Request.add_header(key, val)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.add_unredirected_header": {
        "descr": "Add a header that will not be added to a redirected request.", 
        "name": "urllib.request.Request.add_unredirected_header", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.add_unredirected_header", 
        "syntax": "Request.add_unredirected_header(key, header)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.data": {
        "descr": "The entity body for the request, or None if not specified.", 
        "name": "urllib.request.Request.data", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.data", 
        "syntax": "Request.data", 
        "type": "Internet"
    }, 
    "urllib.request.Request.full_url": {
        "descr": "The original URL passed to the constructor.", 
        "name": "urllib.request.Request.full_url", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.full_url", 
        "syntax": "Request.full_url", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_data": {
        "descr": "Return the instance\u2019s data. Deprecated in 3.3, use Request.data.", 
        "name": "urllib.request.Request.get_data", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_data", 
        "syntax": "Request.get_data()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_full_url": {
        "descr": "Return the URL given in the constructor.", 
        "name": "urllib.request.Request.get_full_url", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_full_url", 
        "syntax": "Request.get_full_url()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_header": {
        "descr": "Return the value of the given header. If the header is not present, return the default value.", 
        "name": "urllib.request.Request.get_header", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_header", 
        "syntax": "Request.get_header(header_name, default=None)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_host": {
        "descr": "Return the host to which a connection will be made. Deprecated in 3.3, use Request.host.", 
        "name": "urllib.request.Request.get_host", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_host", 
        "syntax": "Request.get_host()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_method": {
        "descr": "Return a string indicating the HTTP request method. If Request.method is not None, return its value, otherwise return 'GET' if Request.data is None, or 'POST' if it\u2019s not. This is only meaningful for HTTP requests.", 
        "name": "urllib.request.Request.get_method", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_method", 
        "syntax": "Request.get_method()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_origin_req_host": {
        "descr": "Return the request-host of the origin transaction, as defined by RFC 2965. See the documentation for the Request constructor. Deprecated in 3.3, use Request.origin_req_host.", 
        "name": "urllib.request.Request.get_origin_req_host", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_origin_req_host", 
        "syntax": "Request.get_origin_req_host()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_selector": {
        "descr": "Return the selector \u2014 the part of the URL that is sent to the server. Deprecated in 3.3, use Request.selector.", 
        "name": "urllib.request.Request.get_selector", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_selector", 
        "syntax": "Request.get_selector()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.get_type": {
        "descr": "Return the type of the URL \u2014 also known as the scheme. Deprecated in 3.3, use Request.type.", 
        "name": "urllib.request.Request.get_type", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.get_type", 
        "syntax": "Request.get_type()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.has_data": {
        "descr": "Return whether the instance has a non-None data. Deprecated in 3.3, use Request.data.", 
        "name": "urllib.request.Request.has_data", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.has_data", 
        "syntax": "Request.has_data()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.has_header": {
        "descr": "Return whether the instance has the named header (checks both regular and unredirected).", 
        "name": "urllib.request.Request.has_header", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.has_header", 
        "syntax": "Request.has_header(header)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.header_items": {
        "descr": "Return a list of tuples (header_name, header_value) of the Request headers.", 
        "name": "urllib.request.Request.header_items", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.header_items", 
        "syntax": "Request.header_items()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.host": {
        "descr": "The URI authority, typically a host, but may also contain a port separated by a colon.", 
        "name": "urllib.request.Request.host", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.host", 
        "syntax": "Request.host", 
        "type": "Internet"
    }, 
    "urllib.request.Request.is_unverifiable": {
        "descr": "Return whether the request is unverifiable, as defined by RFC 2965. See the documentation for the Request constructor. Deprecated in 3.3, use Request.unverifiable.", 
        "name": "urllib.request.Request.is_unverifiable", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.is_unverifiable", 
        "syntax": "Request.is_unverifiable()", 
        "type": "Internet"
    }, 
    "urllib.request.Request.method": {
        "descr": "The HTTP request method to use. This value is used by get_method() to override the computed HTTP request method that would otherwise be returned. This attribute is initialized with the value of the method argument passed to the constructor.", 
        "name": "urllib.request.Request.method", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.method", 
        "syntax": "Request.method", 
        "type": "Internet"
    }, 
    "urllib.request.Request.origin_req_host": {
        "descr": "The original host for the request, without port.", 
        "name": "urllib.request.Request.origin_req_host", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.origin_req_host", 
        "syntax": "Request.origin_req_host", 
        "type": "Internet"
    }, 
    "urllib.request.Request.selector": {
        "descr": "The URI path. If the Request uses a proxy, then selector will be the full url that is passed to the proxy.", 
        "name": "urllib.request.Request.selector", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.selector", 
        "syntax": "Request.selector", 
        "type": "Internet"
    }, 
    "urllib.request.Request.set_proxy": {
        "descr": "Prepare the request by connecting to a proxy server. The host and type will replace those of the instance, and the instance\u2019s selector will be the original URL given in the constructor.", 
        "name": "urllib.request.Request.set_proxy", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.set_proxy", 
        "syntax": "Request.set_proxy(host, type)", 
        "type": "Internet"
    }, 
    "urllib.request.Request.type": {
        "descr": "The URI scheme.", 
        "name": "urllib.request.Request.type", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.type", 
        "syntax": "Request.type", 
        "type": "Internet"
    }, 
    "urllib.request.Request.unverifiable": {
        "descr": "boolean, indicates whether the request is unverifiable as defined by RFC 2965.", 
        "name": "urllib.request.Request.unverifiable", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.Request.unverifiable", 
        "syntax": "Request.unverifiable", 
        "type": "Internet"
    }, 
    "urllib.request.URLopener": {
        "descr": "Deprecated since version 3.3.", 
        "name": "urllib.request.URLopener", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.URLopener", 
        "syntax": "class urllib.request.URLopener(proxies=None, **x509)", 
        "type": "Internet"
    }, 
    "urllib.request.URLopener.open": {
        "descr": "Open fullurl using the appropriate protocol. This method sets up cache and proxy information, then calls the appropriate open method with its input arguments. If the scheme is not recognized, open_unknown() is called. The data argument has the same meaning as the data argument of urlopen().", 
        "name": "urllib.request.URLopener.open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.URLopener.open", 
        "syntax": "open(fullurl, data=None)", 
        "type": "Internet"
    }, 
    "urllib.request.URLopener.open_unknown": {
        "descr": "Overridable interface to open unknown URL types.", 
        "name": "urllib.request.URLopener.open_unknown", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.URLopener.open_unknown", 
        "syntax": "open_unknown(fullurl, data=None)", 
        "type": "Internet"
    }, 
    "urllib.request.URLopener.retrieve": {
        "descr": "Retrieves the contents of url and places it in filename. The return value is a tuple consisting of a local filename and either a email.message.Message object containing the response headers (for remote URLs) or None (for local URLs). The caller must then open and read the contents of filename. If filename is not given and the URL refers to a local file, the input filename is returned. If the URL is non-local and filename is not given, the filename is the output of tempfile.mktemp() with a suffix that matches the suffix of the last path component of the input URL. If reporthook is given, it must be a function accepting three numeric parameters: A chunk number, the maximum size chunks are read in and the total size of the download (-1 if unknown). It will be called once at the start and after each chunk of data is read from the network. reporthook is ignored for local URLs.", 
        "name": "urllib.request.URLopener.retrieve", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.URLopener.retrieve", 
        "syntax": "retrieve(url, filename=None, reporthook=None, data=None)", 
        "type": "Internet"
    }, 
    "urllib.request.URLopener.version": {
        "descr": "Variable that specifies the user agent of the opener object. To get urllib to tell servers that it is a particular user agent, set this in a subclass as a class variable or in the constructor before calling the base constructor.", 
        "name": "urllib.request.URLopener.version", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.URLopener.version", 
        "syntax": "version", 
        "type": "Internet"
    }, 
    "urllib.request.UnknownHandler": {
        "descr": "A catch-all class to handle unknown URLs.", 
        "name": "urllib.request.UnknownHandler", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.UnknownHandler", 
        "syntax": "class urllib.request.UnknownHandler", 
        "type": "Internet"
    }, 
    "urllib.request.UnknownHandler.unknown_open": {
        "descr": "Raise a URLError exception.", 
        "name": "urllib.request.UnknownHandler.unknown_open", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.UnknownHandler.unknown_open", 
        "syntax": "UnknownHandler.unknown_open()", 
        "type": "Internet"
    }, 
    "urllib.request.build_opener": {
        "descr": "Return an OpenerDirector instance, which chains the handlers in the order given. handlers can be either instances of BaseHandler, or subclasses of BaseHandler (in which case it must be possible to call the constructor without any parameters). Instances of the following classes will be in front of the handlers, unless the handlers contain them, instances of them or subclasses of them: ProxyHandler (if proxy settings are detected), UnknownHandler, HTTPHandler, HTTPDefaultErrorHandler, HTTPRedirectHandler, FTPHandler, FileHandler, HTTPErrorProcessor.", 
        "name": "urllib.request.build_opener", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.build_opener", 
        "syntax": "urllib.request.build_opener([handler, ...])", 
        "type": "Internet"
    }, 
    "urllib.request.getproxies": {
        "descr": "This helper function returns a dictionary of scheme to proxy server URL mappings. It scans the environment for variables named <scheme>_proxy, in a case insensitive approach, for all operating systems first, and when it cannot find it, looks for proxy information from Mac OSX System Configuration for Mac OS X and Windows Systems Registry for Windows.", 
        "name": "urllib.request.getproxies", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.getproxies", 
        "syntax": "urllib.request.getproxies()", 
        "type": "Internet"
    }, 
    "urllib.request.install_opener": {
        "descr": "Install an OpenerDirector instance as the default global opener. Installing an opener is only necessary if you want urlopen to use that opener; otherwise, simply call OpenerDirector.open() instead of urlopen(). The code does not check for a real OpenerDirector, and any class with the appropriate interface will work.", 
        "name": "urllib.request.install_opener", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.install_opener", 
        "syntax": "urllib.request.install_opener(opener)", 
        "type": "Internet"
    }, 
    "urllib.request.pathname2url": {
        "descr": "Convert the pathname path from the local syntax for a path to the form used in the path component of a URL. This does not produce a complete URL. The return value will already be quoted using the quote() function.", 
        "name": "urllib.request.pathname2url", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.pathname2url", 
        "syntax": "urllib.request.pathname2url(path)", 
        "type": "Internet"
    }, 
    "urllib.request.url2pathname": {
        "descr": "Convert the path component path from a percent-encoded URL to the local syntax for a path. This does not accept a complete URL. This function uses unquote() to decode path.", 
        "name": "urllib.request.url2pathname", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.url2pathname", 
        "syntax": "urllib.request.url2pathname(path)", 
        "type": "Internet"
    }, 
    "urllib.request.urlcleanup": {
        "descr": "Cleans up temporary files that may have been left behind by previous calls to urlretrieve().", 
        "name": "urllib.request.urlcleanup", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.urlcleanup", 
        "syntax": "urllib.request.urlcleanup()", 
        "type": "Internet"
    }, 
    "urllib.request.urlopen": {
        "descr": "Open the URL url, which can be either a string or a Request object.", 
        "name": "urllib.request.urlopen", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.urlopen", 
        "syntax": "urllib.request.urlopen(url, data=None[, timeout], *, cafile=None, capath=None, cadefault=False)", 
        "type": "Internet"
    }, 
    "urllib.request.urlretrieve": {
        "descr": "Copy a network object denoted by a URL to a local file. If the URL points to a local file, the object will not be copied unless filename is supplied. Return a tuple (filename, headers) where filename is the local file name under which the object can be found, and headers is whatever the info() method of the object returned by urlopen() returned (for a remote object). Exceptions are the same as for urlopen().", 
        "name": "urllib.request.urlretrieve", 
        "params": [], 
        "path": "python/library/urllib.request#urllib.request.urlretrieve", 
        "syntax": "urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser": {
        "descr": "This class provides methods to read, parse and answer questions about the robots.txt file at url.", 
        "name": "urllib.robotparser.RobotFileParser", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser", 
        "syntax": "class urllib.robotparser.RobotFileParser(url='')", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser.can_fetch": {
        "descr": "Returns True if the useragent is allowed to fetch the url according to the rules contained in the parsed robots.txt file.", 
        "name": "urllib.robotparser.RobotFileParser.can_fetch", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser.can_fetch", 
        "syntax": "can_fetch(useragent, url)", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser.modified": {
        "descr": "Sets the time the robots.txt file was last fetched to the current time.", 
        "name": "urllib.robotparser.RobotFileParser.modified", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser.modified", 
        "syntax": "modified()", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser.mtime": {
        "descr": "Returns the time the robots.txt file was last fetched. This is useful for long-running web spiders that need to check for new robots.txt files periodically.", 
        "name": "urllib.robotparser.RobotFileParser.mtime", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser.mtime", 
        "syntax": "mtime()", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser.parse": {
        "descr": "Parses the lines argument.", 
        "name": "urllib.robotparser.RobotFileParser.parse", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser.parse", 
        "syntax": "parse(lines)", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser.read": {
        "descr": "Reads the robots.txt URL and feeds it to the parser.", 
        "name": "urllib.robotparser.RobotFileParser.read", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser.read", 
        "syntax": "read()", 
        "type": "Internet"
    }, 
    "urllib.robotparser.RobotFileParser.set_url": {
        "descr": "Sets the URL referring to a robots.txt file.", 
        "name": "urllib.robotparser.RobotFileParser.set_url", 
        "params": [], 
        "path": "python/library/urllib.robotparser#urllib.robotparser.RobotFileParser.set_url", 
        "syntax": "set_url(url)", 
        "type": "Internet"
    }, 
    "uu.Error": {
        "descr": "Subclass of Exception, this can be raised by uu.decode() under various situations, such as described above, but also including a badly formatted header, or truncated input file.", 
        "name": "uu.Error", 
        "params": [], 
        "path": "python/library/uu#uu.Error", 
        "syntax": "exception uu.Error", 
        "type": "Internet Data"
    }, 
    "uu.decode": {
        "descr": "This call decodes uuencoded file in_file placing the result on file out_file. If out_file is a pathname, mode is used to set the permission bits if the file must be created. Defaults for out_file and mode are taken from the uuencode header. However, if the file specified in the header already exists, a uu.Error is raised.", 
        "name": "uu.decode", 
        "params": [], 
        "path": "python/library/uu#uu.decode", 
        "syntax": "uu.decode(in_file, out_file=None, mode=None, quiet=False)", 
        "type": "Internet Data"
    }, 
    "uu.encode": {
        "descr": "Uuencode file in_file into file out_file. The uuencoded file will have the header specifying name and mode as the defaults for the results of decoding the file. The default defaults are taken from in_file, or '-' and 0o666 respectively.", 
        "name": "uu.encode", 
        "params": [], 
        "path": "python/library/uu#uu.encode", 
        "syntax": "uu.encode(in_file, out_file, name=None, mode=None)", 
        "type": "Internet Data"
    }, 
    "uuid.UUID": {
        "descr": "Create a UUID from either a string of 32 hexadecimal digits, a string of 16 bytes as the bytes argument, a string of 16 bytes in little-endian order as the bytes_le argument, a tuple of six integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version, 8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as the fields argument, or a single 128-bit integer as the int argument. When a string of hex digits is given, curly braces, hyphens, and a URN prefix are all optional. For example, these expressions all yield the same UUID:", 
        "name": "uuid.UUID", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID", 
        "syntax": "class uuid.UUID(hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None)", 
        "type": "Internet"
    }, 
    "uuid.UUID.bytes": {
        "descr": "The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).", 
        "name": "uuid.UUID.bytes", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.bytes", 
        "syntax": "UUID.bytes", 
        "type": "Internet"
    }, 
    "uuid.UUID.bytes_le": {
        "descr": "The UUID as a 16-byte string (with time_low, time_mid, and time_hi_version in little-endian byte order).", 
        "name": "uuid.UUID.bytes_le", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.bytes_le", 
        "syntax": "UUID.bytes_le", 
        "type": "Internet"
    }, 
    "uuid.UUID.fields": {
        "descr": "A tuple of the six integer fields of the UUID, which are also available as six individual attributes and two derived attributes:", 
        "name": "uuid.UUID.fields", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.fields", 
        "syntax": "UUID.fields", 
        "type": "Internet"
    }, 
    "uuid.UUID.hex": {
        "descr": "The UUID as a 32-character hexadecimal string.", 
        "name": "uuid.UUID.hex", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.hex", 
        "syntax": "UUID.hex", 
        "type": "Internet"
    }, 
    "uuid.UUID.int": {
        "descr": "The UUID as a 128-bit integer.", 
        "name": "uuid.UUID.int", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.int", 
        "syntax": "UUID.int", 
        "type": "Internet"
    }, 
    "uuid.UUID.urn": {
        "descr": "The UUID as a URN as specified in RFC 4122.", 
        "name": "uuid.UUID.urn", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.urn", 
        "syntax": "UUID.urn", 
        "type": "Internet"
    }, 
    "uuid.UUID.variant": {
        "descr": "The UUID variant, which determines the internal layout of the UUID. This will be one of the integer constants RESERVED_NCS, RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE.", 
        "name": "uuid.UUID.variant", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.variant", 
        "syntax": "UUID.variant", 
        "type": "Internet"
    }, 
    "uuid.UUID.version": {
        "descr": "The UUID version number (1 through 5, meaningful only when the variant is RFC_4122).", 
        "name": "uuid.UUID.version", 
        "params": [], 
        "path": "python/library/uuid#uuid.UUID.version", 
        "syntax": "UUID.version", 
        "type": "Internet"
    }, 
    "uuid.getnode": {
        "descr": "Get the hardware address as a 48-bit positive integer. The first time this runs, it may launch a separate program, which could be quite slow. If all attempts to obtain the hardware address fail, we choose a random 48-bit number with its eighth bit set to 1 as recommended in RFC 4122. \u201cHardware address\u201d means the MAC address of a network interface, and on a machine with multiple network interfaces the MAC address of any one of them may be returned.", 
        "name": "uuid.getnode", 
        "params": [], 
        "path": "python/library/uuid#uuid.getnode", 
        "syntax": "uuid.getnode()", 
        "type": "Internet"
    }, 
    "uuid.uuid1": {
        "descr": "Generate a UUID from a host ID, sequence number, and the current time. If node is not given, getnode() is used to obtain the hardware address. If clock_seq is given, it is used as the sequence number; otherwise a random 14-bit sequence number is chosen.", 
        "name": "uuid.uuid1", 
        "params": [], 
        "path": "python/library/uuid#uuid.uuid1", 
        "syntax": "uuid.uuid1(node=None, clock_seq=None)", 
        "type": "Internet"
    }, 
    "uuid.uuid3": {
        "descr": "Generate a UUID based on the MD5 hash of a namespace identifier (which is a UUID) and a name (which is a string).", 
        "name": "uuid.uuid3", 
        "params": [], 
        "path": "python/library/uuid#uuid.uuid3", 
        "syntax": "uuid.uuid3(namespace, name)", 
        "type": "Internet"
    }, 
    "uuid.uuid4": {
        "descr": "Generate a random UUID.", 
        "name": "uuid.uuid4", 
        "params": [], 
        "path": "python/library/uuid#uuid.uuid4", 
        "syntax": "uuid.uuid4()", 
        "type": "Internet"
    }, 
    "uuid.uuid5": {
        "descr": "Generate a UUID based on the SHA-1 hash of a namespace identifier (which is a UUID) and a name (which is a string).", 
        "name": "uuid.uuid5", 
        "params": [], 
        "path": "python/library/uuid#uuid.uuid5", 
        "syntax": "uuid.uuid5(namespace, name)", 
        "type": "Internet"
    }, 
    "values": {
        "descr": "Return a new view of the dictionary\u2019s values. See the documentation of view objects.", 
        "name": "dict.values", 
        "params": [], 
        "path": "python/library/stdtypes#dict.values", 
        "syntax": "values()", 
        "type": "Built-in Types"
    }, 
    "vars": {
        "descr": "Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute.", 
        "name": "vars", 
        "params": [], 
        "path": "python/library/functions#vars", 
        "syntax": "vars([object])", 
        "type": "Built-in Functions"
    }, 
    "venv.EnvBuilder": {
        "descr": "The EnvBuilder class accepts the following keyword arguments on instantiation:", 
        "name": "venv.EnvBuilder", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder", 
        "syntax": "class venv.EnvBuilder(system_site_packages=False, clear=False, symlinks=False, upgrade=False)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.create": {
        "descr": "This method takes as required argument the path (absolute or relative to the current directory) of the target directory which is to contain the virtual environment. The create method will either create the environment in the specified directory, or raise an appropriate exception.", 
        "name": "venv.EnvBuilder.create", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.create", 
        "syntax": "create(env_dir)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.create_configuration": {
        "descr": "Creates the pyvenv.cfg configuration file in the environment.", 
        "name": "venv.EnvBuilder.create_configuration", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.create_configuration", 
        "syntax": "create_configuration(context)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.ensure_directories": {
        "descr": "Creates the environment directory and all necessary directories, and returns a context object. This is just a holder for attributes (such as paths), for use by the other methods. The directories are allowed to exist already, as long as either clear or upgrade were specified to allow operating on an existing environment directory.", 
        "name": "venv.EnvBuilder.ensure_directories", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.ensure_directories", 
        "syntax": "ensure_directories(env_dir)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.install_scripts": {
        "descr": "path is the path to a directory that should contain subdirectories \u201ccommon\u201d, \u201cposix\u201d, \u201cnt\u201d, each containing scripts destined for the bin directory in the environment. The contents of \u201ccommon\u201d and the directory corresponding to os.name are copied after some text replacement of placeholders:", 
        "name": "venv.EnvBuilder.install_scripts", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.install_scripts", 
        "syntax": "install_scripts(context, path)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.post_setup": {
        "descr": "A placeholder method which can be overridden in third party implementations to pre-install packages in the virtual environment or perform other post-creation steps.", 
        "name": "venv.EnvBuilder.post_setup", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.post_setup", 
        "syntax": "post_setup(context)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.setup_python": {
        "descr": "Creates a copy of the Python executable (and, under Windows, DLLs) in the environment. On a POSIX system, if a specific executable python3.x was used, symlinks to python and python3 will be created pointing to that executable, unless files with those names already exist.", 
        "name": "venv.EnvBuilder.setup_python", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.setup_python", 
        "syntax": "setup_python(context)", 
        "type": "Development Tools"
    }, 
    "venv.EnvBuilder.setup_scripts": {
        "descr": "Installs activation scripts appropriate to the platform into the virtual environment.", 
        "name": "venv.EnvBuilder.setup_scripts", 
        "params": [], 
        "path": "python/library/venv#venv.EnvBuilder.setup_scripts", 
        "syntax": "setup_scripts(context)", 
        "type": "Development Tools"
    }, 
    "venv.create": {
        "descr": "Create an EnvBuilder with the given keyword arguments, and call its create() method with the env_dir argument.", 
        "name": "venv.create", 
        "params": [], 
        "path": "python/library/venv#venv.create", 
        "syntax": "venv.create(env_dir, system_site_packages=False, clear=False, symlinks=False)", 
        "type": "Development Tools"
    }, 
    "warnings.catch_warnings": {
        "descr": "A context manager that copies and, upon exit, restores the warnings filter and the showwarning() function. If the record argument is False (the default) the context manager returns None on entry. If record is True, a list is returned that is progressively populated with objects as seen by a custom showwarning() function (which also suppresses output to sys.stdout). Each object in the list has attributes with the same names as the arguments to showwarning().", 
        "name": "warnings.catch_warnings", 
        "params": [], 
        "path": "python/library/warnings#warnings.catch_warnings", 
        "syntax": "class warnings.catch_warnings(*, record=False, module=None)", 
        "type": "Runtime"
    }, 
    "warnings.filterwarnings": {
        "descr": "Insert an entry into the list of warnings filter specifications. The entry is inserted at the front by default; if append is true, it is inserted at the end. This checks the types of the arguments, compiles the message and module regular expressions, and inserts them as a tuple in the list of warnings filters. Entries closer to the front of the list override entries later in the list, if both match a particular warning. Omitted arguments default to a value that matches everything.", 
        "name": "warnings.filterwarnings", 
        "params": [], 
        "path": "python/library/warnings#warnings.filterwarnings", 
        "syntax": "warnings.filterwarnings(action, message='', category=Warning, module='', lineno=0, append=False)", 
        "type": "Runtime"
    }, 
    "warnings.formatwarning": {
        "descr": "Format a warning the standard way. This returns a string which may contain embedded newlines and ends in a newline. line is a line of source code to be included in the warning message; if line is not supplied, formatwarning() will try to read the line specified by filename and lineno.", 
        "name": "warnings.formatwarning", 
        "params": [], 
        "path": "python/library/warnings#warnings.formatwarning", 
        "syntax": "warnings.formatwarning(message, category, filename, lineno, line=None)", 
        "type": "Runtime"
    }, 
    "warnings.resetwarnings": {
        "descr": "Reset the warnings filter. This discards the effect of all previous calls to filterwarnings(), including that of the -W command line options and calls to simplefilter().", 
        "name": "warnings.resetwarnings", 
        "params": [], 
        "path": "python/library/warnings#warnings.resetwarnings", 
        "syntax": "warnings.resetwarnings()", 
        "type": "Runtime"
    }, 
    "warnings.showwarning": {
        "descr": "Write a warning to a file. The default implementation calls formatwarning(message, category, filename, lineno, line) and writes the resulting string to file, which defaults to sys.stderr. You may replace this function with any callable by assigning to warnings.showwarning. line is a line of source code to be included in the warning message; if line is not supplied, showwarning() will try to read the line specified by filename and lineno.", 
        "name": "warnings.showwarning", 
        "params": [], 
        "path": "python/library/warnings#warnings.showwarning", 
        "syntax": "warnings.showwarning(message, category, filename, lineno, file=None, line=None)", 
        "type": "Runtime"
    }, 
    "warnings.simplefilter": {
        "descr": "Insert a simple entry into the list of warnings filter specifications. The meaning of the function parameters is as for filterwarnings(), but regular expressions are not needed as the filter inserted always matches any message in any module as long as the category and line number match.", 
        "name": "warnings.simplefilter", 
        "params": [], 
        "path": "python/library/warnings#warnings.simplefilter", 
        "syntax": "warnings.simplefilter(action, category=Warning, lineno=0, append=False)", 
        "type": "Runtime"
    }, 
    "warnings.warn": {
        "descr": "Issue a warning, or maybe ignore it or raise an exception. The category argument, if given, must be a warning category class (see above); it defaults to UserWarning. Alternatively message can be a Warning instance, in which case category will be ignored and message.__class__ will be used. In this case the message text will be str(message). This function raises an exception if the particular warning issued is changed into an error by the warnings filter see above. The stacklevel argument can be used by wrapper functions written in Python, like this:", 
        "name": "warnings.warn", 
        "params": [], 
        "path": "python/library/warnings#warnings.warn", 
        "syntax": "warnings.warn(message, category=None, stacklevel=1)", 
        "type": "Runtime"
    }, 
    "warnings.warn_explicit": {
        "descr": "This is a low-level interface to the functionality of warn(), passing in explicitly the message, category, filename and line number, and optionally the module name and the registry (which should be the __warningregistry__ dictionary of the module). The module name defaults to the filename with .py stripped; if no registry is passed, the warning is never suppressed. message must be a string and category a subclass of Warning or message may be a Warning instance, in which case category will be ignored.", 
        "name": "warnings.warn_explicit", 
        "params": [], 
        "path": "python/library/warnings#warnings.warn_explicit", 
        "syntax": "warnings.warn_explicit(message, category, filename, lineno, module=None, registry=None, module_globals=None)", 
        "type": "Runtime"
    }, 
    "wave.Error": {
        "descr": "An error raised when something is impossible because it violates the WAV specification or hits an implementation deficiency.", 
        "name": "wave.Error", 
        "params": [], 
        "path": "python/library/wave#wave.Error", 
        "syntax": "exception wave.Error", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.close": {
        "descr": "Close the stream if it was opened by wave, and make the instance unusable. This is called automatically on object collection.", 
        "name": "wave.Wave_read.close", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.close", 
        "syntax": "Wave_read.close()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getcompname": {
        "descr": "Human-readable version of getcomptype(). Usually 'not compressed' parallels 'NONE'.", 
        "name": "wave.Wave_read.getcompname", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getcompname", 
        "syntax": "Wave_read.getcompname()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getcomptype": {
        "descr": "Returns compression type ('NONE' is the only supported type).", 
        "name": "wave.Wave_read.getcomptype", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getcomptype", 
        "syntax": "Wave_read.getcomptype()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getframerate": {
        "descr": "Returns sampling frequency.", 
        "name": "wave.Wave_read.getframerate", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getframerate", 
        "syntax": "Wave_read.getframerate()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getmark": {
        "descr": "Raise an error.", 
        "name": "wave.Wave_read.getmark", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getmark", 
        "syntax": "Wave_read.getmark(id)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getmarkers": {
        "descr": "Returns None.", 
        "name": "wave.Wave_read.getmarkers", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getmarkers", 
        "syntax": "Wave_read.getmarkers()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getnchannels": {
        "descr": "Returns number of audio channels (1 for mono, 2 for stereo).", 
        "name": "wave.Wave_read.getnchannels", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getnchannels", 
        "syntax": "Wave_read.getnchannels()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getnframes": {
        "descr": "Returns number of audio frames.", 
        "name": "wave.Wave_read.getnframes", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getnframes", 
        "syntax": "Wave_read.getnframes()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getparams": {
        "descr": "Returns a tuple (nchannels, sampwidth, framerate, nframes, comptype, compname), equivalent to output of the get*() methods.", 
        "name": "wave.Wave_read.getparams", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getparams", 
        "syntax": "Wave_read.getparams()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.getsampwidth": {
        "descr": "Returns sample width in bytes.", 
        "name": "wave.Wave_read.getsampwidth", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.getsampwidth", 
        "syntax": "Wave_read.getsampwidth()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.readframes": {
        "descr": "Reads and returns at most n frames of audio, as a string of bytes.", 
        "name": "wave.Wave_read.readframes", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.readframes", 
        "syntax": "Wave_read.readframes(n)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.rewind": {
        "descr": "Rewind the file pointer to the beginning of the audio stream.", 
        "name": "wave.Wave_read.rewind", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.rewind", 
        "syntax": "Wave_read.rewind()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.setpos": {
        "descr": "Set the file pointer to the specified position.", 
        "name": "wave.Wave_read.setpos", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.setpos", 
        "syntax": "Wave_read.setpos(pos)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_read.tell": {
        "descr": "Return current file pointer position.", 
        "name": "wave.Wave_read.tell", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_read.tell", 
        "syntax": "Wave_read.tell()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.close": {
        "descr": "Make sure nframes is correct, and close the file if it was opened by wave. This method is called upon object collection.", 
        "name": "wave.Wave_write.close", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.close", 
        "syntax": "Wave_write.close()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.setcomptype": {
        "descr": "Set the compression type and description. At the moment, only compression type NONE is supported, meaning no compression.", 
        "name": "wave.Wave_write.setcomptype", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.setcomptype", 
        "syntax": "Wave_write.setcomptype(type, name)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.setframerate": {
        "descr": "Set the frame rate to n.", 
        "name": "wave.Wave_write.setframerate", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.setframerate", 
        "syntax": "Wave_write.setframerate(n)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.setnchannels": {
        "descr": "Set the number of channels.", 
        "name": "wave.Wave_write.setnchannels", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.setnchannels", 
        "syntax": "Wave_write.setnchannels(n)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.setnframes": {
        "descr": "Set the number of frames to n. This will be changed later if more frames are written.", 
        "name": "wave.Wave_write.setnframes", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.setnframes", 
        "syntax": "Wave_write.setnframes(n)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.setparams": {
        "descr": "The tuple should be (nchannels, sampwidth, framerate, nframes, comptype, compname), with values valid for the set*() methods. Sets all parameters.", 
        "name": "wave.Wave_write.setparams", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.setparams", 
        "syntax": "Wave_write.setparams(tuple)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.setsampwidth": {
        "descr": "Set the sample width to n bytes.", 
        "name": "wave.Wave_write.setsampwidth", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.setsampwidth", 
        "syntax": "Wave_write.setsampwidth(n)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.tell": {
        "descr": "Return current position in the file, with the same disclaimer for the Wave_read.tell() and Wave_read.setpos() methods.", 
        "name": "wave.Wave_write.tell", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.tell", 
        "syntax": "Wave_write.tell()", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.writeframes": {
        "descr": "Write audio frames and make sure nframes is correct.", 
        "name": "wave.Wave_write.writeframes", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.writeframes", 
        "syntax": "Wave_write.writeframes(data)", 
        "type": "Multimedia"
    }, 
    "wave.Wave_write.writeframesraw": {
        "descr": "Write audio frames, without correcting nframes.", 
        "name": "wave.Wave_write.writeframesraw", 
        "params": [], 
        "path": "python/library/wave#wave.Wave_write.writeframesraw", 
        "syntax": "Wave_write.writeframesraw(data)", 
        "type": "Multimedia"
    }, 
    "wave.open": {
        "descr": "If file is a string, open the file by that name, otherwise treat it as a seekable file-like object. mode can be any of", 
        "name": "wave.open", 
        "params": [], 
        "path": "python/library/wave#wave.open", 
        "syntax": "wave.open(file, mode=None)", 
        "type": "Multimedia"
    }, 
    "wave.openfp": {
        "descr": "A synonym for open(), maintained for backwards compatibility.", 
        "name": "wave.openfp", 
        "params": [], 
        "path": "python/library/wave#wave.openfp", 
        "syntax": "wave.openfp(file, mode)", 
        "type": "Multimedia"
    }, 
    "weakref.CallableProxyType": {
        "descr": "The type object for proxies of callable objects.", 
        "name": "weakref.CallableProxyType", 
        "params": [], 
        "path": "python/library/weakref#weakref.CallableProxyType", 
        "syntax": "weakref.CallableProxyType", 
        "type": "Data Types"
    }, 
    "weakref.ProxyType": {
        "descr": "The type object for proxies of objects which are not callable.", 
        "name": "weakref.ProxyType", 
        "params": [], 
        "path": "python/library/weakref#weakref.ProxyType", 
        "syntax": "weakref.ProxyType", 
        "type": "Data Types"
    }, 
    "weakref.ProxyTypes": {
        "descr": "Sequence containing all the type objects for proxies. This can make it simpler to test if an object is a proxy without being dependent on naming both proxy types.", 
        "name": "weakref.ProxyTypes", 
        "params": [], 
        "path": "python/library/weakref#weakref.ProxyTypes", 
        "syntax": "weakref.ProxyTypes", 
        "type": "Data Types"
    }, 
    "weakref.ReferenceError": {
        "descr": "Exception raised when a proxy object is used but the underlying object has been collected. This is the same as the standard ReferenceError exception.", 
        "name": "weakref.ReferenceError", 
        "params": [], 
        "path": "python/library/weakref#weakref.ReferenceError", 
        "syntax": "exception weakref.ReferenceError", 
        "type": "Data Types"
    }, 
    "weakref.ReferenceType": {
        "descr": "The type object for weak references objects.", 
        "name": "weakref.ReferenceType", 
        "params": [], 
        "path": "python/library/weakref#weakref.ReferenceType", 
        "syntax": "weakref.ReferenceType", 
        "type": "Data Types"
    }, 
    "weakref.WeakKeyDictionary": {
        "descr": "Mapping class that references keys weakly. Entries in the dictionary will be discarded when there is no longer a strong reference to the key. This can be used to associate additional data with an object owned by other parts of an application without adding attributes to those objects. This can be especially useful with objects that override attribute accesses.", 
        "name": "weakref.WeakKeyDictionary", 
        "params": [], 
        "path": "python/library/weakref#weakref.WeakKeyDictionary", 
        "syntax": "class weakref.WeakKeyDictionary([dict])", 
        "type": "Data Types"
    }, 
    "weakref.WeakKeyDictionary.keyrefs": {
        "descr": "Return an iterable of the weak references to the keys.", 
        "name": "weakref.WeakKeyDictionary.keyrefs", 
        "params": [], 
        "path": "python/library/weakref#weakref.WeakKeyDictionary.keyrefs", 
        "syntax": "WeakKeyDictionary.keyrefs()", 
        "type": "Data Types"
    }, 
    "weakref.WeakSet": {
        "descr": "Set class that keeps weak references to its elements. An element will be discarded when no strong reference to it exists any more.", 
        "name": "weakref.WeakSet", 
        "params": [], 
        "path": "python/library/weakref#weakref.WeakSet", 
        "syntax": "class weakref.WeakSet([elements])", 
        "type": "Data Types"
    }, 
    "weakref.WeakValueDictionary": {
        "descr": "Mapping class that references values weakly. Entries in the dictionary will be discarded when no strong reference to the value exists any more.", 
        "name": "weakref.WeakValueDictionary", 
        "params": [], 
        "path": "python/library/weakref#weakref.WeakValueDictionary", 
        "syntax": "class weakref.WeakValueDictionary([dict])", 
        "type": "Data Types"
    }, 
    "weakref.WeakValueDictionary.valuerefs": {
        "descr": "Return an iterable of the weak references to the values.", 
        "name": "weakref.WeakValueDictionary.valuerefs", 
        "params": [], 
        "path": "python/library/weakref#weakref.WeakValueDictionary.valuerefs", 
        "syntax": "WeakValueDictionary.valuerefs()", 
        "type": "Data Types"
    }, 
    "weakref.getweakrefcount": {
        "descr": "Return the number of weak references and proxies which refer to object.", 
        "name": "weakref.getweakrefcount", 
        "params": [], 
        "path": "python/library/weakref#weakref.getweakrefcount", 
        "syntax": "weakref.getweakrefcount(object)", 
        "type": "Data Types"
    }, 
    "weakref.getweakrefs": {
        "descr": "Return a list of all weak reference and proxy objects which refer to object.", 
        "name": "weakref.getweakrefs", 
        "params": [], 
        "path": "python/library/weakref#weakref.getweakrefs", 
        "syntax": "weakref.getweakrefs(object)", 
        "type": "Data Types"
    }, 
    "weakref.proxy": {
        "descr": "Return a proxy to object which uses a weak reference. This supports use of the proxy in most contexts instead of requiring the explicit dereferencing used with weak reference objects. The returned object will have a type of either ProxyType or CallableProxyType, depending on whether object is callable. Proxy objects are not hashable regardless of the referent; this avoids a number of problems related to their fundamentally mutable nature, and prevent their use as dictionary keys. callback is the same as the parameter of the same name to the ref() function.", 
        "name": "weakref.proxy", 
        "params": [], 
        "path": "python/library/weakref#weakref.proxy", 
        "syntax": "weakref.proxy(object[, callback])", 
        "type": "Data Types"
    }, 
    "weakref.ref": {
        "descr": "Return a weak reference to object. The original object can be retrieved by calling the reference object if the referent is still alive; if the referent is no longer alive, calling the reference object will cause None to be returned. If callback is provided and not None, and the returned weakref object is still alive, the callback will be called when the object is about to be finalized; the weak reference object will be passed as the only parameter to the callback; the referent will no longer be available.", 
        "name": "weakref.ref", 
        "params": [], 
        "path": "python/library/weakref#weakref.ref", 
        "syntax": "class weakref.ref(object[, callback])", 
        "type": "Data Types"
    }, 
    "webbrowser.Error": {
        "descr": "Exception raised when a browser control error occurs.", 
        "name": "webbrowser.Error", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.Error", 
        "syntax": "exception webbrowser.Error", 
        "type": "Internet"
    }, 
    "webbrowser.controller.open": {
        "descr": "Display url using the browser handled by this controller. If new is 1, a new browser window is opened if possible. If new is 2, a new browser page (\u201ctab\u201d) is opened if possible.", 
        "name": "webbrowser.controller.open", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.controller.open", 
        "syntax": "controller.open(url, new=0, autoraise=True)", 
        "type": "Internet"
    }, 
    "webbrowser.controller.open_new": {
        "descr": "Open url in a new window of the browser handled by this controller, if possible, otherwise, open url in the only browser window. Alias open_new().", 
        "name": "webbrowser.controller.open_new", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.controller.open_new", 
        "syntax": "controller.open_new(url)", 
        "type": "Internet"
    }, 
    "webbrowser.controller.open_new_tab": {
        "descr": "Open url in a new page (\u201ctab\u201d) of the browser handled by this controller, if possible, otherwise equivalent to open_new().", 
        "name": "webbrowser.controller.open_new_tab", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.controller.open_new_tab", 
        "syntax": "controller.open_new_tab(url)", 
        "type": "Internet"
    }, 
    "webbrowser.get": {
        "descr": "Return a controller object for the browser type using. If using is None, return a controller for a default browser appropriate to the caller\u2019s environment.", 
        "name": "webbrowser.get", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.get", 
        "syntax": "webbrowser.get(using=None)", 
        "type": "Internet"
    }, 
    "webbrowser.open": {
        "descr": "Display url using the default browser. If new is 0, the url is opened in the same browser window if possible. If new is 1, a new browser window is opened if possible. If new is 2, a new browser page (\u201ctab\u201d) is opened if possible. If autoraise is True, the window is raised if possible (note that under many window managers this will occur regardless of the setting of this variable).", 
        "name": "webbrowser.open", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.open", 
        "syntax": "webbrowser.open(url, new=0, autoraise=True)", 
        "type": "Internet"
    }, 
    "webbrowser.open_new": {
        "descr": "Open url in a new window of the default browser, if possible, otherwise, open url in the only browser window.", 
        "name": "webbrowser.open_new", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.open_new", 
        "syntax": "webbrowser.open_new(url)", 
        "type": "Internet"
    }, 
    "webbrowser.open_new_tab": {
        "descr": "Open url in a new page (\u201ctab\u201d) of the default browser, if possible, otherwise equivalent to open_new().", 
        "name": "webbrowser.open_new_tab", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.open_new_tab", 
        "syntax": "webbrowser.open_new_tab(url)", 
        "type": "Internet"
    }, 
    "webbrowser.register": {
        "descr": "Register the browser type name. Once a browser type is registered, the get() function can return a controller for that browser type. If instance is not provided, or is None, constructor will be called without parameters to create an instance when needed. If instance is provided, constructor will never be called, and may be None.", 
        "name": "webbrowser.register", 
        "params": [], 
        "path": "python/library/webbrowser#webbrowser.register", 
        "syntax": "webbrowser.register(name, constructor, instance=None)", 
        "type": "Internet"
    }, 
    "winreg.CloseKey": {
        "descr": "Closes a previously opened registry key. The hkey argument specifies a previously opened key.", 
        "name": "winreg.CloseKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.CloseKey", 
        "syntax": "winreg.CloseKey(hkey)", 
        "type": "MS Windows"
    }, 
    "winreg.ConnectRegistry": {
        "descr": "Establishes a connection to a predefined registry handle on another computer, and returns a handle object.", 
        "name": "winreg.ConnectRegistry", 
        "params": [], 
        "path": "python/library/winreg#winreg.ConnectRegistry", 
        "syntax": "winreg.ConnectRegistry(computer_name, key)", 
        "type": "MS Windows"
    }, 
    "winreg.CreateKey": {
        "descr": "Creates or opens the specified key, returning a handle object.", 
        "name": "winreg.CreateKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.CreateKey", 
        "syntax": "winreg.CreateKey(key, sub_key)", 
        "type": "MS Windows"
    }, 
    "winreg.CreateKeyEx": {
        "descr": "Creates or opens the specified key, returning a handle object.", 
        "name": "winreg.CreateKeyEx", 
        "params": [], 
        "path": "python/library/winreg#winreg.CreateKeyEx", 
        "syntax": "winreg.CreateKeyEx(key, sub_key, reserved=0, access=KEY_WRITE)", 
        "type": "MS Windows"
    }, 
    "winreg.DeleteKey": {
        "descr": "Deletes the specified key.", 
        "name": "winreg.DeleteKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.DeleteKey", 
        "syntax": "winreg.DeleteKey(key, sub_key)", 
        "type": "MS Windows"
    }, 
    "winreg.DeleteKeyEx": {
        "descr": "Deletes the specified key.", 
        "name": "winreg.DeleteKeyEx", 
        "params": [], 
        "path": "python/library/winreg#winreg.DeleteKeyEx", 
        "syntax": "winreg.DeleteKeyEx(key, sub_key, access=KEY_WOW64_64KEY, reserved=0)", 
        "type": "MS Windows"
    }, 
    "winreg.DeleteValue": {
        "descr": "Removes a named value from a registry key.", 
        "name": "winreg.DeleteValue", 
        "params": [], 
        "path": "python/library/winreg#winreg.DeleteValue", 
        "syntax": "winreg.DeleteValue(key, value)", 
        "type": "MS Windows"
    }, 
    "winreg.DisableReflectionKey": {
        "descr": "Disables registry reflection for 32-bit processes running on a 64-bit operating system.", 
        "name": "winreg.DisableReflectionKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.DisableReflectionKey", 
        "syntax": "winreg.DisableReflectionKey(key)", 
        "type": "MS Windows"
    }, 
    "winreg.EnableReflectionKey": {
        "descr": "Restores registry reflection for the specified disabled key.", 
        "name": "winreg.EnableReflectionKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.EnableReflectionKey", 
        "syntax": "winreg.EnableReflectionKey(key)", 
        "type": "MS Windows"
    }, 
    "winreg.EnumKey": {
        "descr": "Enumerates subkeys of an open registry key, returning a string.", 
        "name": "winreg.EnumKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.EnumKey", 
        "syntax": "winreg.EnumKey(key, index)", 
        "type": "MS Windows"
    }, 
    "winreg.EnumValue": {
        "descr": "Enumerates values of an open registry key, returning a tuple.", 
        "name": "winreg.EnumValue", 
        "params": [], 
        "path": "python/library/winreg#winreg.EnumValue", 
        "syntax": "winreg.EnumValue(key, index)", 
        "type": "MS Windows"
    }, 
    "winreg.ExpandEnvironmentStrings": {
        "descr": "Expands environment variable placeholders %NAME% in strings like REG_EXPAND_SZ:", 
        "name": "winreg.ExpandEnvironmentStrings", 
        "params": [], 
        "path": "python/library/winreg#winreg.ExpandEnvironmentStrings", 
        "syntax": "winreg.ExpandEnvironmentStrings(str)", 
        "type": "MS Windows"
    }, 
    "winreg.FlushKey": {
        "descr": "Writes all the attributes of a key to the registry.", 
        "name": "winreg.FlushKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.FlushKey", 
        "syntax": "winreg.FlushKey(key)", 
        "type": "MS Windows"
    }, 
    "winreg.LoadKey": {
        "descr": "Creates a subkey under the specified key and stores registration information from a specified file into that subkey.", 
        "name": "winreg.LoadKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.LoadKey", 
        "syntax": "winreg.LoadKey(key, sub_key, file_name)", 
        "type": "MS Windows"
    }, 
    "winreg.OpenKey": {
        "descr": "Opens the specified key, returning a handle object.", 
        "name": "winreg.OpenKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.OpenKey", 
        "syntax": "winreg.OpenKey(key, sub_key, reserved=0, access=KEY_READ)", 
        "type": "MS Windows"
    }, 
    "winreg.OpenKeyEx": {
        "descr": "Opens the specified key, returning a handle object.", 
        "name": "winreg.OpenKeyEx", 
        "params": [], 
        "path": "python/library/winreg#winreg.OpenKeyEx", 
        "syntax": "winreg.OpenKeyEx(key, sub_key, reserved=0, access=KEY_READ)", 
        "type": "MS Windows"
    }, 
    "winreg.PyHKEY.Close": {
        "descr": "Closes the underlying Windows handle.", 
        "name": "winreg.PyHKEY.Close", 
        "params": [], 
        "path": "python/library/winreg#winreg.PyHKEY.Close", 
        "syntax": "PyHKEY.Close()", 
        "type": "MS Windows"
    }, 
    "winreg.PyHKEY.Detach": {
        "descr": "Detaches the Windows handle from the handle object.", 
        "name": "winreg.PyHKEY.Detach", 
        "params": [], 
        "path": "python/library/winreg#winreg.PyHKEY.Detach", 
        "syntax": "PyHKEY.Detach()", 
        "type": "MS Windows"
    }, 
    "winreg.PyHKEY.__enter__": {
        "descr": "The HKEY object implements __enter__() and __exit__() and thus supports the context protocol for the with statement:", 
        "name": "winreg.PyHKEY.__enter__", 
        "params": [], 
        "path": "python/library/winreg#winreg.PyHKEY.__enter__", 
        "syntax": "PyHKEY.__enter__()", 
        "type": "MS Windows"
    }, 
    "winreg.PyHKEY.__exit__": {
        "descr": "The HKEY object implements __enter__() and __exit__() and thus supports the context protocol for the with statement:", 
        "name": "winreg.PyHKEY.__exit__", 
        "params": [], 
        "path": "python/library/winreg#winreg.PyHKEY.__exit__", 
        "syntax": "PyHKEY.__exit__(*exc_info)", 
        "type": "MS Windows"
    }, 
    "winreg.QueryInfoKey": {
        "descr": "Returns information about a key, as a tuple.", 
        "name": "winreg.QueryInfoKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.QueryInfoKey", 
        "syntax": "winreg.QueryInfoKey(key)", 
        "type": "MS Windows"
    }, 
    "winreg.QueryReflectionKey": {
        "descr": "Determines the reflection state for the specified key.", 
        "name": "winreg.QueryReflectionKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.QueryReflectionKey", 
        "syntax": "winreg.QueryReflectionKey(key)", 
        "type": "MS Windows"
    }, 
    "winreg.QueryValue": {
        "descr": "Retrieves the unnamed value for a key, as a string.", 
        "name": "winreg.QueryValue", 
        "params": [], 
        "path": "python/library/winreg#winreg.QueryValue", 
        "syntax": "winreg.QueryValue(key, sub_key)", 
        "type": "MS Windows"
    }, 
    "winreg.QueryValueEx": {
        "descr": "Retrieves the type and data for a specified value name associated with an open registry key.", 
        "name": "winreg.QueryValueEx", 
        "params": [], 
        "path": "python/library/winreg#winreg.QueryValueEx", 
        "syntax": "winreg.QueryValueEx(key, value_name)", 
        "type": "MS Windows"
    }, 
    "winreg.SaveKey": {
        "descr": "Saves the specified key, and all its subkeys to the specified file.", 
        "name": "winreg.SaveKey", 
        "params": [], 
        "path": "python/library/winreg#winreg.SaveKey", 
        "syntax": "winreg.SaveKey(key, file_name)", 
        "type": "MS Windows"
    }, 
    "winreg.SetValue": {
        "descr": "Associates a value with a specified key.", 
        "name": "winreg.SetValue", 
        "params": [], 
        "path": "python/library/winreg#winreg.SetValue", 
        "syntax": "winreg.SetValue(key, sub_key, type, value)", 
        "type": "MS Windows"
    }, 
    "winreg.SetValueEx": {
        "descr": "Stores data in the value field of an open registry key.", 
        "name": "winreg.SetValueEx", 
        "params": [], 
        "path": "python/library/winreg#winreg.SetValueEx", 
        "syntax": "winreg.SetValueEx(key, value_name, reserved, type, value)", 
        "type": "MS Windows"
    }, 
    "winsound.Beep": {
        "descr": "Beep the PC\u2019s speaker. The frequency parameter specifies frequency, in hertz, of the sound, and must be in the range 37 through 32,767. The duration parameter specifies the number of milliseconds the sound should last. If the system is not able to beep the speaker, RuntimeError is raised.", 
        "name": "winsound.Beep", 
        "params": [], 
        "path": "python/library/winsound#winsound.Beep", 
        "syntax": "winsound.Beep(frequency, duration)", 
        "type": "MS Windows"
    }, 
    "winsound.MessageBeep": {
        "descr": "Call the underlying MessageBeep() function from the Platform API. This plays a sound as specified in the registry. The type argument specifies which sound to play; possible values are -1, MB_ICONASTERISK, MB_ICONEXCLAMATION, MB_ICONHAND, MB_ICONQUESTION, and MB_OK, all described below. The value -1 produces a \u201csimple beep\u201d; this is the final fallback if a sound cannot be played otherwise.", 
        "name": "winsound.MessageBeep", 
        "params": [], 
        "path": "python/library/winsound#winsound.MessageBeep", 
        "syntax": "winsound.MessageBeep(type=MB_OK)", 
        "type": "MS Windows"
    }, 
    "winsound.PlaySound": {
        "descr": "Call the underlying PlaySound() function from the Platform API. The sound parameter may be a filename, audio data as a string, or None. Its interpretation depends on the value of flags, which can be a bitwise ORed combination of the constants described below. If the sound parameter is None, any currently playing waveform sound is stopped. If the system indicates an error, RuntimeError is raised.", 
        "name": "winsound.PlaySound", 
        "params": [], 
        "path": "python/library/winsound#winsound.PlaySound", 
        "syntax": "winsound.PlaySound(sound, flags)", 
        "type": "MS Windows"
    }, 
    "wsgiref.handlers.BaseCGIHandler": {
        "descr": "Similar to CGIHandler, but instead of using the sys and os modules, the CGI environment and I/O streams are specified explicitly. The multithread and multiprocess values are used to set the wsgi.multithread and wsgi.multiprocess flags for any applications run by the handler instance.", 
        "name": "wsgiref.handlers.BaseCGIHandler", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseCGIHandler", 
        "syntax": "class wsgiref.handlers.BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler": {
        "descr": "This is an abstract base class for running WSGI applications. Each instance will handle a single HTTP request, although in principle you could create a subclass that was reusable for multiple requests.", 
        "name": "wsgiref.handlers.BaseHandler", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler", 
        "syntax": "class wsgiref.handlers.BaseHandler", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler._flush": {
        "descr": "Force buffered data to be transmitted to the client. It\u2019s okay if this method is a no-op (i.e., if _write() actually sends the data).", 
        "name": "wsgiref.handlers.BaseHandler._flush", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler._flush", 
        "syntax": "_flush()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler._write": {
        "descr": "Buffer the bytes data for transmission to the client. It\u2019s okay if this method actually transmits the data; BaseHandler just separates write and flush operations for greater efficiency when the underlying system actually has such a distinction.", 
        "name": "wsgiref.handlers.BaseHandler._write", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler._write", 
        "syntax": "_write(data)", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.add_cgi_vars": {
        "descr": "Insert CGI variables for the current request into the environ attribute.", 
        "name": "wsgiref.handlers.BaseHandler.add_cgi_vars", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.add_cgi_vars", 
        "syntax": "add_cgi_vars()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.error_body": {
        "descr": "The error response body. This should be an HTTP response body bytestring. It defaults to the plain text, \u201cA server error occurred. Please contact the administrator.\u201d", 
        "name": "wsgiref.handlers.BaseHandler.error_body", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.error_body", 
        "syntax": "error_body", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.error_headers": {
        "descr": "The HTTP headers used for error responses. This should be a list of WSGI response headers ((name, value) tuples), as described in PEP 3333. The default list just sets the content type to text/plain.", 
        "name": "wsgiref.handlers.BaseHandler.error_headers", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.error_headers", 
        "syntax": "error_headers", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.error_output": {
        "descr": "This method is a WSGI application to generate an error page for the user. It is only invoked if an error occurs before headers are sent to the client.", 
        "name": "wsgiref.handlers.BaseHandler.error_output", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.error_output", 
        "syntax": "error_output(environ, start_response)", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.error_status": {
        "descr": "The HTTP status used for error responses. This should be a status string as defined in PEP 3333; it defaults to a 500 code and message.", 
        "name": "wsgiref.handlers.BaseHandler.error_status", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.error_status", 
        "syntax": "error_status", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.get_scheme": {
        "descr": "Return the URL scheme being used for the current request. The default implementation uses the guess_scheme() function from wsgiref.util to guess whether the scheme should be \u201chttp\u201d or \u201chttps\u201d, based on the current request\u2019s environ variables.", 
        "name": "wsgiref.handlers.BaseHandler.get_scheme", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.get_scheme", 
        "syntax": "get_scheme()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.get_stderr": {
        "descr": "Return an output stream object suitable for use as the wsgi.errors of the request currently being processed.", 
        "name": "wsgiref.handlers.BaseHandler.get_stderr", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.get_stderr", 
        "syntax": "get_stderr()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.get_stdin": {
        "descr": "Return an input stream object suitable for use as the wsgi.input of the request currently being processed.", 
        "name": "wsgiref.handlers.BaseHandler.get_stdin", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.get_stdin", 
        "syntax": "get_stdin()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.http_version": {
        "descr": "If origin_server is true, this string attribute is used to set the HTTP version of the response set to the client. It defaults to \"1.0\".", 
        "name": "wsgiref.handlers.BaseHandler.http_version", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.http_version", 
        "syntax": "http_version", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.log_exception": {
        "descr": "Log the exc_info tuple in the server log. exc_info is a (type, value, traceback) tuple. The default implementation simply writes the traceback to the request\u2019s wsgi.errors stream and flushes it. Subclasses can override this method to change the format or retarget the output, mail the traceback to an administrator, or whatever other action may be deemed suitable.", 
        "name": "wsgiref.handlers.BaseHandler.log_exception", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.log_exception", 
        "syntax": "log_exception(exc_info)", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.origin_server": {
        "descr": "This attribute should be set to a true value if the handler\u2019s _write() and _flush() are being used to communicate directly to the client, rather than via a CGI-like gateway protocol that wants the HTTP status in a special Status: header.", 
        "name": "wsgiref.handlers.BaseHandler.origin_server", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.origin_server", 
        "syntax": "origin_server", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.os_environ": {
        "descr": "The default environment variables to be included in every request\u2019s WSGI environment. By default, this is a copy of os.environ at the time that wsgiref.handlers was imported, but subclasses can either create their own at the class or instance level. Note that the dictionary should be considered read-only, since the default value is shared between multiple classes and instances.", 
        "name": "wsgiref.handlers.BaseHandler.os_environ", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.os_environ", 
        "syntax": "os_environ", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.run": {
        "descr": "Run the specified WSGI application, app.", 
        "name": "wsgiref.handlers.BaseHandler.run", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.run", 
        "syntax": "run(app)", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.sendfile": {
        "descr": "Override to implement platform-specific file transmission. This method is called only if the application\u2019s return value is an instance of the class specified by the wsgi_file_wrapper attribute. It should return a true value if it was able to successfully transmit the file, so that the default transmission code will not be executed. The default implementation of this method just returns a false value.", 
        "name": "wsgiref.handlers.BaseHandler.sendfile", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.sendfile", 
        "syntax": "sendfile()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.server_software": {
        "descr": "If the origin_server attribute is set, this attribute\u2019s value is used to set the default SERVER_SOFTWARE WSGI environment variable, and also to set a default Server: header in HTTP responses. It is ignored for handlers (such as BaseCGIHandler and CGIHandler) that are not HTTP origin servers.", 
        "name": "wsgiref.handlers.BaseHandler.server_software", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.server_software", 
        "syntax": "server_software", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.setup_environ": {
        "descr": "Set the environ attribute to a fully-populated WSGI environment. The default implementation uses all of the above methods and attributes, plus the get_stdin(), get_stderr(), and add_cgi_vars() methods and the wsgi_file_wrapper attribute. It also inserts a SERVER_SOFTWARE key if not present, as long as the origin_server attribute is a true value and the server_software attribute is set.", 
        "name": "wsgiref.handlers.BaseHandler.setup_environ", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.setup_environ", 
        "syntax": "setup_environ()", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.traceback_limit": {
        "descr": "The maximum number of frames to include in tracebacks output by the default log_exception() method. If None, all frames are included.", 
        "name": "wsgiref.handlers.BaseHandler.traceback_limit", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.traceback_limit", 
        "syntax": "traceback_limit", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.wsgi_file_wrapper": {
        "descr": "A wsgi.file_wrapper factory, or None. The default value of this attribute is the wsgiref.util.FileWrapper class.", 
        "name": "wsgiref.handlers.BaseHandler.wsgi_file_wrapper", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_file_wrapper", 
        "syntax": "wsgi_file_wrapper", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.wsgi_multiprocess": {
        "descr": "The value to be used for the wsgi.multiprocess environment variable. It defaults to true in BaseHandler, but may have a different default (or be set by the constructor) in the other subclasses.", 
        "name": "wsgiref.handlers.BaseHandler.wsgi_multiprocess", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_multiprocess", 
        "syntax": "wsgi_multiprocess", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.wsgi_multithread": {
        "descr": "The value to be used for the wsgi.multithread environment variable. It defaults to true in BaseHandler, but may have a different default (or be set by the constructor) in the other subclasses.", 
        "name": "wsgiref.handlers.BaseHandler.wsgi_multithread", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_multithread", 
        "syntax": "wsgi_multithread", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.BaseHandler.wsgi_run_once": {
        "descr": "The value to be used for the wsgi.run_once environment variable. It defaults to false in BaseHandler, but CGIHandler sets it to true by default.", 
        "name": "wsgiref.handlers.BaseHandler.wsgi_run_once", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_run_once", 
        "syntax": "wsgi_run_once", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.CGIHandler": {
        "descr": "CGI-based invocation via sys.stdin, sys.stdout, sys.stderr and os.environ. This is useful when you have a WSGI application and want to run it as a CGI script. Simply invoke CGIHandler().run(app), where app is the WSGI application object you wish to invoke.", 
        "name": "wsgiref.handlers.CGIHandler", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.CGIHandler", 
        "syntax": "class wsgiref.handlers.CGIHandler", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.IISCGIHandler": {
        "descr": "A specialized alternative to CGIHandler, for use when deploying on Microsoft\u2019s IIS web server, without having set the config allowPathInfo option (IIS>=7) or metabase allowPathInfoForScriptMappings (IIS<7).", 
        "name": "wsgiref.handlers.IISCGIHandler", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.IISCGIHandler", 
        "syntax": "class wsgiref.handlers.IISCGIHandler", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.SimpleHandler": {
        "descr": "Similar to BaseCGIHandler, but designed for use with HTTP origin servers. If you are writing an HTTP server implementation, you will probably want to subclass this instead of BaseCGIHandler", 
        "name": "wsgiref.handlers.SimpleHandler", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.SimpleHandler", 
        "syntax": "class wsgiref.handlers.SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)", 
        "type": "Internet"
    }, 
    "wsgiref.handlers.read_environ": {
        "descr": "Transcode CGI variables from os.environ to PEP 3333 \u201cbytes in unicode\u201d strings, returning a new dictionary. This function is used by CGIHandler and IISCGIHandler in place of directly using os.environ, which is not necessarily WSGI-compliant on all platforms and web servers using Python 3 \u2013 specifically, ones where the OS\u2019s actual environment is Unicode (i.e. Windows), or ones where the environment is bytes, but the system encoding used by Python to decode it is anything other than ISO-8859-1 (e.g. Unix systems using UTF-8).", 
        "name": "wsgiref.handlers.read_environ", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.handlers.read_environ", 
        "syntax": "wsgiref.handlers.read_environ()", 
        "type": "Internet"
    }, 
    "wsgiref.headers.Headers": {
        "descr": "Create a mapping-like object wrapping headers, which must be a list of header name/value tuples as described in PEP 3333.", 
        "name": "wsgiref.headers.Headers", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.headers.Headers", 
        "syntax": "class wsgiref.headers.Headers(headers)", 
        "type": "Internet"
    }, 
    "wsgiref.headers.Headers.add_header": {
        "descr": "Add a (possibly multi-valued) header, with optional MIME parameters specified via keyword arguments.", 
        "name": "wsgiref.headers.Headers.add_header", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.headers.Headers.add_header", 
        "syntax": "add_header(name, value, **_params)", 
        "type": "Internet"
    }, 
    "wsgiref.headers.Headers.get_all": {
        "descr": "Return a list of all the values for the named header.", 
        "name": "wsgiref.headers.Headers.get_all", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.headers.Headers.get_all", 
        "syntax": "get_all(name)", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIRequestHandler": {
        "descr": "Create an HTTP handler for the given request (i.e. a socket), client_address (a (host,port) tuple), and server (WSGIServer instance).", 
        "name": "wsgiref.simple_server.WSGIRequestHandler", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIRequestHandler", 
        "syntax": "class wsgiref.simple_server.WSGIRequestHandler(request, client_address, server)", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIRequestHandler.get_environ": {
        "descr": "Returns a dictionary containing the WSGI environment for a request. The default implementation copies the contents of the WSGIServer object\u2019s base_environ dictionary attribute and then adds various headers derived from the HTTP request. Each call to this method should return a new dictionary containing all of the relevant CGI environment variables as specified in PEP 3333.", 
        "name": "wsgiref.simple_server.WSGIRequestHandler.get_environ", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIRequestHandler.get_environ", 
        "syntax": "get_environ()", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIRequestHandler.get_stderr": {
        "descr": "Return the object that should be used as the wsgi.errors stream. The default implementation just returns sys.stderr.", 
        "name": "wsgiref.simple_server.WSGIRequestHandler.get_stderr", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIRequestHandler.get_stderr", 
        "syntax": "get_stderr()", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIRequestHandler.handle": {
        "descr": "Process the HTTP request. The default implementation creates a handler instance using a wsgiref.handlers class to implement the actual WSGI application interface.", 
        "name": "wsgiref.simple_server.WSGIRequestHandler.handle", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIRequestHandler.handle", 
        "syntax": "handle()", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIServer": {
        "descr": "Create a WSGIServer instance. server_address should be a (host,port) tuple, and RequestHandlerClass should be the subclass of http.server.BaseHTTPRequestHandler that will be used to process requests.", 
        "name": "wsgiref.simple_server.WSGIServer", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIServer", 
        "syntax": "class wsgiref.simple_server.WSGIServer(server_address, RequestHandlerClass)", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIServer.get_app": {
        "descr": "Returns the currently-set application callable.", 
        "name": "wsgiref.simple_server.WSGIServer.get_app", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIServer.get_app", 
        "syntax": "get_app()", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.WSGIServer.set_app": {
        "descr": "Sets the callable application as the WSGI application that will receive requests.", 
        "name": "wsgiref.simple_server.WSGIServer.set_app", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.WSGIServer.set_app", 
        "syntax": "set_app(application)", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.demo_app": {
        "descr": "This function is a small but complete WSGI application that returns a text page containing the message \u201cHello world!\u201d and a list of the key/value pairs provided in the environ parameter. It\u2019s useful for verifying that a WSGI server (such as wsgiref.simple_server) is able to run a simple WSGI application correctly.", 
        "name": "wsgiref.simple_server.demo_app", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.demo_app", 
        "syntax": "wsgiref.simple_server.demo_app(environ, start_response)", 
        "type": "Internet"
    }, 
    "wsgiref.simple_server.make_server": {
        "descr": "Create a new WSGI server listening on host and port, accepting connections for app. The return value is an instance of the supplied server_class, and will process requests using the specified handler_class. app must be a WSGI application object, as defined by PEP 3333.", 
        "name": "wsgiref.simple_server.make_server", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.simple_server.make_server", 
        "syntax": "wsgiref.simple_server.make_server(host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler)", 
        "type": "Internet"
    }, 
    "wsgiref.util.FileWrapper": {
        "descr": "A wrapper to convert a file-like object to an iterator. The resulting objects support both __getitem__() and __iter__() iteration styles, for compatibility with Python 2.1 and Jython. As the object is iterated over, the optional blksize parameter will be repeatedly passed to the filelike object\u2019s read() method to obtain bytestrings to yield. When read() returns an empty bytestring, iteration is ended and is not resumable.", 
        "name": "wsgiref.util.FileWrapper", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.FileWrapper", 
        "syntax": "class wsgiref.util.FileWrapper(filelike, blksize=8192)", 
        "type": "Internet"
    }, 
    "wsgiref.util.application_uri": {
        "descr": "Similar to request_uri(), except that the PATH_INFO and QUERY_STRING variables are ignored. The result is the base URI of the application object addressed by the request.", 
        "name": "wsgiref.util.application_uri", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.application_uri", 
        "syntax": "wsgiref.util.application_uri(environ)", 
        "type": "Internet"
    }, 
    "wsgiref.util.guess_scheme": {
        "descr": "Return a guess for whether wsgi.url_scheme should be \u201chttp\u201d or \u201chttps\u201d, by checking for a HTTPS environment variable in the environ dictionary. The return value is a string.", 
        "name": "wsgiref.util.guess_scheme", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.guess_scheme", 
        "syntax": "wsgiref.util.guess_scheme(environ)", 
        "type": "Internet"
    }, 
    "wsgiref.util.is_hop_by_hop": {
        "descr": "Return true if \u2018header_name\u2019 is an HTTP/1.1 \u201cHop-by-Hop\u201d header, as defined by RFC 2616.", 
        "name": "wsgiref.util.is_hop_by_hop", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.is_hop_by_hop", 
        "syntax": "wsgiref.util.is_hop_by_hop(header_name)", 
        "type": "Internet"
    }, 
    "wsgiref.util.request_uri": {
        "descr": "Return the full request URI, optionally including the query string, using the algorithm found in the \u201cURL Reconstruction\u201d section of PEP 3333. If include_query is false, the query string is not included in the resulting URI.", 
        "name": "wsgiref.util.request_uri", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.request_uri", 
        "syntax": "wsgiref.util.request_uri(environ, include_query=True)", 
        "type": "Internet"
    }, 
    "wsgiref.util.setup_testing_defaults": {
        "descr": "Update environ with trivial defaults for testing purposes.", 
        "name": "wsgiref.util.setup_testing_defaults", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.setup_testing_defaults", 
        "syntax": "wsgiref.util.setup_testing_defaults(environ)", 
        "type": "Internet"
    }, 
    "wsgiref.util.shift_path_info": {
        "descr": "Shift a single name from PATH_INFO to SCRIPT_NAME and return the name. The environ dictionary is modified in-place; use a copy if you need to keep the original PATH_INFO or SCRIPT_NAME intact.", 
        "name": "wsgiref.util.shift_path_info", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.util.shift_path_info", 
        "syntax": "wsgiref.util.shift_path_info(environ)", 
        "type": "Internet"
    }, 
    "wsgiref.validate.validator": {
        "descr": "Wrap application and return a new WSGI application object. The returned application will forward all requests to the original application, and will check that both the application and the server invoking it are conforming to the WSGI specification and to RFC 2616.", 
        "name": "wsgiref.validate.validator", 
        "params": [], 
        "path": "python/library/wsgiref#wsgiref.validate.validator", 
        "syntax": "wsgiref.validate.validator(application)", 
        "type": "Internet"
    }, 
    "xdrlib.ConversionError": {
        "descr": "Class derived from Error. Contains no additional instance variables.", 
        "name": "xdrlib.ConversionError", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.ConversionError", 
        "syntax": "exception xdrlib.ConversionError", 
        "type": "File Formats"
    }, 
    "xdrlib.Error": {
        "descr": "The base exception class. Error has a single public attribute msg containing the description of the error.", 
        "name": "xdrlib.Error", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Error", 
        "syntax": "exception xdrlib.Error", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer": {
        "descr": "Packer is the class for packing data into XDR representation. The Packer class is instantiated with no arguments.", 
        "name": "xdrlib.Packer", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer", 
        "syntax": "class xdrlib.Packer", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.get_buffer": {
        "descr": "Returns the current pack buffer as a string.", 
        "name": "xdrlib.Packer.get_buffer", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.get_buffer", 
        "syntax": "Packer.get_buffer()", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_array": {
        "descr": "Packs a variable length list of homogeneous items. First, the length of the list is packed as an unsigned integer, then each element is packed as in pack_farray() above.", 
        "name": "xdrlib.Packer.pack_array", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_array", 
        "syntax": "Packer.pack_array(list, pack_item)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_bytes": {
        "descr": "Packs a variable length byte stream, similarly to pack_string().", 
        "name": "xdrlib.Packer.pack_bytes", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_bytes", 
        "syntax": "Packer.pack_bytes(bytes)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_double": {
        "descr": "Packs the double-precision floating point number value.", 
        "name": "xdrlib.Packer.pack_double", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_double", 
        "syntax": "Packer.pack_double(value)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_farray": {
        "descr": "Packs a fixed length list (array) of homogeneous items. n is the length of the list; it is not packed into the buffer, but a ValueError exception is raised if len(array) is not equal to n. As above, pack_item is the function used to pack each element.", 
        "name": "xdrlib.Packer.pack_farray", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_farray", 
        "syntax": "Packer.pack_farray(n, array, pack_item)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_float": {
        "descr": "Packs the single-precision floating point number value.", 
        "name": "xdrlib.Packer.pack_float", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_float", 
        "syntax": "Packer.pack_float(value)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_fopaque": {
        "descr": "Packs a fixed length opaque data stream, similarly to pack_fstring().", 
        "name": "xdrlib.Packer.pack_fopaque", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_fopaque", 
        "syntax": "Packer.pack_fopaque(n, data)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_fstring": {
        "descr": "Packs a fixed length string, s. n is the length of the string but it is not packed into the data buffer. The string is padded with null bytes if necessary to guaranteed 4 byte alignment.", 
        "name": "xdrlib.Packer.pack_fstring", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_fstring", 
        "syntax": "Packer.pack_fstring(n, s)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_list": {
        "descr": "Packs a list of homogeneous items. This method is useful for lists with an indeterminate size; i.e. the size is not available until the entire list has been walked. For each item in the list, an unsigned integer 1 is packed first, followed by the data value from the list. pack_item is the function that is called to pack the individual item. At the end of the list, an unsigned integer 0 is packed.", 
        "name": "xdrlib.Packer.pack_list", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_list", 
        "syntax": "Packer.pack_list(list, pack_item)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_opaque": {
        "descr": "Packs a variable length opaque data string, similarly to pack_string().", 
        "name": "xdrlib.Packer.pack_opaque", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_opaque", 
        "syntax": "Packer.pack_opaque(data)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.pack_string": {
        "descr": "Packs a variable length string, s. The length of the string is first packed as an unsigned integer, then the string data is packed with pack_fstring().", 
        "name": "xdrlib.Packer.pack_string", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.pack_string", 
        "syntax": "Packer.pack_string(s)", 
        "type": "File Formats"
    }, 
    "xdrlib.Packer.reset": {
        "descr": "Resets the pack buffer to the empty string.", 
        "name": "xdrlib.Packer.reset", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Packer.reset", 
        "syntax": "Packer.reset()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker": {
        "descr": "Unpacker is the complementary class which unpacks XDR data values from a string buffer. The input buffer is given as data.", 
        "name": "xdrlib.Unpacker", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker", 
        "syntax": "class xdrlib.Unpacker(data)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.done": {
        "descr": "Indicates unpack completion. Raises an Error exception if all of the data has not been unpacked.", 
        "name": "xdrlib.Unpacker.done", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.done", 
        "syntax": "Unpacker.done()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.get_buffer": {
        "descr": "Returns the current unpack data buffer as a string.", 
        "name": "xdrlib.Unpacker.get_buffer", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.get_buffer", 
        "syntax": "Unpacker.get_buffer()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.get_position": {
        "descr": "Returns the current unpack position in the data buffer.", 
        "name": "xdrlib.Unpacker.get_position", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.get_position", 
        "syntax": "Unpacker.get_position()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.reset": {
        "descr": "Resets the string buffer with the given data.", 
        "name": "xdrlib.Unpacker.reset", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.reset", 
        "syntax": "Unpacker.reset(data)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.set_position": {
        "descr": "Sets the data buffer unpack position to position. You should be careful about using get_position() and set_position().", 
        "name": "xdrlib.Unpacker.set_position", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.set_position", 
        "syntax": "Unpacker.set_position(position)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_array": {
        "descr": "Unpacks and returns a variable length list of homogeneous items. First, the length of the list is unpacked as an unsigned integer, then each element is unpacked as in unpack_farray() above.", 
        "name": "xdrlib.Unpacker.unpack_array", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_array", 
        "syntax": "Unpacker.unpack_array(unpack_item)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_bytes": {
        "descr": "Unpacks and returns a variable length byte stream, similarly to unpack_string().", 
        "name": "xdrlib.Unpacker.unpack_bytes", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_bytes", 
        "syntax": "Unpacker.unpack_bytes()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_double": {
        "descr": "Unpacks a double-precision floating point number, similarly to unpack_float().", 
        "name": "xdrlib.Unpacker.unpack_double", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_double", 
        "syntax": "Unpacker.unpack_double()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_farray": {
        "descr": "Unpacks and returns (as a list) a fixed length array of homogeneous items. n is number of list elements to expect in the buffer. As above, unpack_item is the function used to unpack each element.", 
        "name": "xdrlib.Unpacker.unpack_farray", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_farray", 
        "syntax": "Unpacker.unpack_farray(n, unpack_item)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_float": {
        "descr": "Unpacks a single-precision floating point number.", 
        "name": "xdrlib.Unpacker.unpack_float", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_float", 
        "syntax": "Unpacker.unpack_float()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_fopaque": {
        "descr": "Unpacks and returns a fixed length opaque data stream, similarly to unpack_fstring().", 
        "name": "xdrlib.Unpacker.unpack_fopaque", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_fopaque", 
        "syntax": "Unpacker.unpack_fopaque(n)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_fstring": {
        "descr": "Unpacks and returns a fixed length string. n is the number of characters expected. Padding with null bytes to guaranteed 4 byte alignment is assumed.", 
        "name": "xdrlib.Unpacker.unpack_fstring", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_fstring", 
        "syntax": "Unpacker.unpack_fstring(n)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_list": {
        "descr": "Unpacks and returns a list of homogeneous items. The list is unpacked one element at a time by first unpacking an unsigned integer flag. If the flag is 1, then the item is unpacked and appended to the list. A flag of 0 indicates the end of the list. unpack_item is the function that is called to unpack the items.", 
        "name": "xdrlib.Unpacker.unpack_list", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_list", 
        "syntax": "Unpacker.unpack_list(unpack_item)", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_opaque": {
        "descr": "Unpacks and returns a variable length opaque data string, similarly to unpack_string().", 
        "name": "xdrlib.Unpacker.unpack_opaque", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_opaque", 
        "syntax": "Unpacker.unpack_opaque()", 
        "type": "File Formats"
    }, 
    "xdrlib.Unpacker.unpack_string": {
        "descr": "Unpacks and returns a variable length string. The length of the string is first unpacked as an unsigned integer, then the string data is unpacked with unpack_fstring().", 
        "name": "xdrlib.Unpacker.unpack_string", 
        "params": [], 
        "path": "python/library/xdrlib#xdrlib.Unpacker.unpack_string", 
        "syntax": "Unpacker.unpack_string()", 
        "type": "File Formats"
    }, 
    "xml.dom.Attr.localName": {
        "descr": "The part of the name following the colon if there is one, else the entire name. This is a read-only attribute.", 
        "name": "xml.dom.Attr.localName", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Attr.localName", 
        "syntax": "Attr.localName", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Attr.name": {
        "descr": "The attribute name. In a namespace-using document it may include a colon.", 
        "name": "xml.dom.Attr.name", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Attr.name", 
        "syntax": "Attr.name", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Attr.prefix": {
        "descr": "The part of the name preceding the colon if there is one, else the empty string.", 
        "name": "xml.dom.Attr.prefix", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Attr.prefix", 
        "syntax": "Attr.prefix", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Attr.value": {
        "descr": "The text value of the attribute. This is a synonym for the nodeValue attribute.", 
        "name": "xml.dom.Attr.value", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Attr.value", 
        "syntax": "Attr.value", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Comment.data": {
        "descr": "The content of the comment as a string. The attribute contains all characters between the leading <!-- and trailing -->, but does not include them.", 
        "name": "xml.dom.Comment.data", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Comment.data", 
        "syntax": "Comment.data", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DOMException": {
        "descr": "Base exception class used for all specific DOM exceptions. This exception class cannot be directly instantiated.", 
        "name": "xml.dom.DOMException", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DOMException", 
        "syntax": "exception xml.dom.DOMException", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DOMImplementation.createDocument": {
        "descr": "Return a new Document object (the root of the DOM), with a child Element object having the given namespaceUri and qualifiedName. The doctype must be a DocumentType object created by createDocumentType(), or None. In the Python DOM API, the first two arguments can also be None in order to indicate that no Element child is to be created.", 
        "name": "xml.dom.DOMImplementation.createDocument", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DOMImplementation.createDocument", 
        "syntax": "DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DOMImplementation.createDocumentType": {
        "descr": "Return a new DocumentType object that encapsulates the given qualifiedName, publicId, and systemId strings, representing the information contained in an XML document type declaration.", 
        "name": "xml.dom.DOMImplementation.createDocumentType", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DOMImplementation.createDocumentType", 
        "syntax": "DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DOMImplementation.hasFeature": {
        "descr": "Return true if the feature identified by the pair of strings feature and version is implemented.", 
        "name": "xml.dom.DOMImplementation.hasFeature", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DOMImplementation.hasFeature", 
        "syntax": "DOMImplementation.hasFeature(feature, version)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createAttribute": {
        "descr": "Create and return an attribute node. This method does not associate the attribute node with any particular element. You must use setAttributeNode() on the appropriate Element object to use the newly created attribute instance.", 
        "name": "xml.dom.Document.createAttribute", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createAttribute", 
        "syntax": "Document.createAttribute(name)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createAttributeNS": {
        "descr": "Create and return an attribute node with a namespace. The tagName may have a prefix. This method does not associate the attribute node with any particular element. You must use setAttributeNode() on the appropriate Element object to use the newly created attribute instance.", 
        "name": "xml.dom.Document.createAttributeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createAttributeNS", 
        "syntax": "Document.createAttributeNS(namespaceURI, qualifiedName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createComment": {
        "descr": "Create and return a comment node containing the data passed as a parameter. As with the other creation methods, this one does not insert the node into the tree.", 
        "name": "xml.dom.Document.createComment", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createComment", 
        "syntax": "Document.createComment(data)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createElement": {
        "descr": "Create and return a new element node. The element is not inserted into the document when it is created. You need to explicitly insert it with one of the other methods such as insertBefore() or appendChild().", 
        "name": "xml.dom.Document.createElement", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createElement", 
        "syntax": "Document.createElement(tagName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createElementNS": {
        "descr": "Create and return a new element with a namespace. The tagName may have a prefix. The element is not inserted into the document when it is created. You need to explicitly insert it with one of the other methods such as insertBefore() or appendChild().", 
        "name": "xml.dom.Document.createElementNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createElementNS", 
        "syntax": "Document.createElementNS(namespaceURI, tagName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createProcessingInstruction": {
        "descr": "Create and return a processing instruction node containing the target and data passed as parameters. As with the other creation methods, this one does not insert the node into the tree.", 
        "name": "xml.dom.Document.createProcessingInstruction", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createProcessingInstruction", 
        "syntax": "Document.createProcessingInstruction(target, data)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.createTextNode": {
        "descr": "Create and return a text node containing the data passed as a parameter. As with the other creation methods, this one does not insert the node into the tree.", 
        "name": "xml.dom.Document.createTextNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.createTextNode", 
        "syntax": "Document.createTextNode(data)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.documentElement": {
        "descr": "The one and only root element of the document.", 
        "name": "xml.dom.Document.documentElement", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.documentElement", 
        "syntax": "Document.documentElement", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.getElementsByTagName": {
        "descr": "Search for all descendants (direct children, children\u2019s children, etc.) with a particular element type name.", 
        "name": "xml.dom.Document.getElementsByTagName", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.getElementsByTagName", 
        "syntax": "Document.getElementsByTagName(tagName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Document.getElementsByTagNameNS": {
        "descr": "Search for all descendants (direct children, children\u2019s children, etc.) with a particular namespace URI and localname. The localname is the part of the namespace after the prefix.", 
        "name": "xml.dom.Document.getElementsByTagNameNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Document.getElementsByTagNameNS", 
        "syntax": "Document.getElementsByTagNameNS(namespaceURI, localName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DocumentType.entities": {
        "descr": "This is a NamedNodeMap giving the definitions of external entities. For entity names defined more than once, only the first definition is provided (others are ignored as required by the XML recommendation). This may be None if the information is not provided by the parser, or if no entities are defined.", 
        "name": "xml.dom.DocumentType.entities", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DocumentType.entities", 
        "syntax": "DocumentType.entities", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DocumentType.internalSubset": {
        "descr": "A string giving the complete internal subset from the document. This does not include the brackets which enclose the subset. If the document has no internal subset, this should be None.", 
        "name": "xml.dom.DocumentType.internalSubset", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DocumentType.internalSubset", 
        "syntax": "DocumentType.internalSubset", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DocumentType.name": {
        "descr": "The name of the root element as given in the DOCTYPE declaration, if present.", 
        "name": "xml.dom.DocumentType.name", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DocumentType.name", 
        "syntax": "DocumentType.name", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DocumentType.notations": {
        "descr": "This is a NamedNodeMap giving the definitions of notations. For notation names defined more than once, only the first definition is provided (others are ignored as required by the XML recommendation). This may be None if the information is not provided by the parser, or if no notations are defined.", 
        "name": "xml.dom.DocumentType.notations", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DocumentType.notations", 
        "syntax": "DocumentType.notations", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DocumentType.publicId": {
        "descr": "The public identifier for the external subset of the document type definition. This will be a string or None.", 
        "name": "xml.dom.DocumentType.publicId", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DocumentType.publicId", 
        "syntax": "DocumentType.publicId", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DocumentType.systemId": {
        "descr": "The system identifier for the external subset of the document type definition. This will be a URI as a string, or None.", 
        "name": "xml.dom.DocumentType.systemId", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DocumentType.systemId", 
        "syntax": "DocumentType.systemId", 
        "type": "Structured Markup"
    }, 
    "xml.dom.DomstringSizeErr": {
        "descr": "Raised when a specified range of text does not fit into a string. This is not known to be used in the Python DOM implementations, but may be received from DOM implementations not written in Python.", 
        "name": "xml.dom.DomstringSizeErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.DomstringSizeErr", 
        "syntax": "exception xml.dom.DomstringSizeErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.getAttribute": {
        "descr": "Return the value of the attribute named by name as a string. If no such attribute exists, an empty string is returned, as if the attribute had no value.", 
        "name": "xml.dom.Element.getAttribute", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.getAttribute", 
        "syntax": "Element.getAttribute(name)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.getAttributeNS": {
        "descr": "Return the value of the attribute named by namespaceURI and localName as a string. If no such attribute exists, an empty string is returned, as if the attribute had no value.", 
        "name": "xml.dom.Element.getAttributeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.getAttributeNS", 
        "syntax": "Element.getAttributeNS(namespaceURI, localName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.getAttributeNode": {
        "descr": "Return the Attr node for the attribute named by attrname.", 
        "name": "xml.dom.Element.getAttributeNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.getAttributeNode", 
        "syntax": "Element.getAttributeNode(attrname)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.getAttributeNodeNS": {
        "descr": "Return an attribute value as a node, given a namespaceURI and localName.", 
        "name": "xml.dom.Element.getAttributeNodeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.getAttributeNodeNS", 
        "syntax": "Element.getAttributeNodeNS(namespaceURI, localName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.getElementsByTagName": {
        "descr": "Same as equivalent method in the Document class.", 
        "name": "xml.dom.Element.getElementsByTagName", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.getElementsByTagName", 
        "syntax": "Element.getElementsByTagName(tagName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.getElementsByTagNameNS": {
        "descr": "Same as equivalent method in the Document class.", 
        "name": "xml.dom.Element.getElementsByTagNameNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.getElementsByTagNameNS", 
        "syntax": "Element.getElementsByTagNameNS(namespaceURI, localName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.hasAttribute": {
        "descr": "Returns true if the element has an attribute named by name.", 
        "name": "xml.dom.Element.hasAttribute", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.hasAttribute", 
        "syntax": "Element.hasAttribute(name)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.hasAttributeNS": {
        "descr": "Returns true if the element has an attribute named by namespaceURI and localName.", 
        "name": "xml.dom.Element.hasAttributeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.hasAttributeNS", 
        "syntax": "Element.hasAttributeNS(namespaceURI, localName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.removeAttribute": {
        "descr": "Remove an attribute by name. If there is no matching attribute, a NotFoundErr is raised.", 
        "name": "xml.dom.Element.removeAttribute", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.removeAttribute", 
        "syntax": "Element.removeAttribute(name)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.removeAttributeNS": {
        "descr": "Remove an attribute by name. Note that it uses a localName, not a qname. No exception is raised if there is no matching attribute.", 
        "name": "xml.dom.Element.removeAttributeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.removeAttributeNS", 
        "syntax": "Element.removeAttributeNS(namespaceURI, localName)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.removeAttributeNode": {
        "descr": "Remove and return oldAttr from the attribute list, if present. If oldAttr is not present, NotFoundErr is raised.", 
        "name": "xml.dom.Element.removeAttributeNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.removeAttributeNode", 
        "syntax": "Element.removeAttributeNode(oldAttr)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.setAttribute": {
        "descr": "Set an attribute value from a string.", 
        "name": "xml.dom.Element.setAttribute", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.setAttribute", 
        "syntax": "Element.setAttribute(name, value)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.setAttributeNS": {
        "descr": "Set an attribute value from a string, given a namespaceURI and a qname. Note that a qname is the whole attribute name. This is different than above.", 
        "name": "xml.dom.Element.setAttributeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.setAttributeNS", 
        "syntax": "Element.setAttributeNS(namespaceURI, qname, value)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.setAttributeNode": {
        "descr": "Add a new attribute node to the element, replacing an existing attribute if necessary if the name attribute matches. If a replacement occurs, the old attribute node will be returned. If newAttr is already in use, InuseAttributeErr will be raised.", 
        "name": "xml.dom.Element.setAttributeNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.setAttributeNode", 
        "syntax": "Element.setAttributeNode(newAttr)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.setAttributeNodeNS": {
        "descr": "Add a new attribute node to the element, replacing an existing attribute if necessary if the namespaceURI and localName attributes match. If a replacement occurs, the old attribute node will be returned. If newAttr is already in use, InuseAttributeErr will be raised.", 
        "name": "xml.dom.Element.setAttributeNodeNS", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.setAttributeNodeNS", 
        "syntax": "Element.setAttributeNodeNS(newAttr)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Element.tagName": {
        "descr": "The element type name. In a namespace-using document it may have colons in it. The value is a string.", 
        "name": "xml.dom.Element.tagName", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Element.tagName", 
        "syntax": "Element.tagName", 
        "type": "Structured Markup"
    }, 
    "xml.dom.HierarchyRequestErr": {
        "descr": "Raised when an attempt is made to insert a node where the node type is not allowed.", 
        "name": "xml.dom.HierarchyRequestErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.HierarchyRequestErr", 
        "syntax": "exception xml.dom.HierarchyRequestErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.IndexSizeErr": {
        "descr": "Raised when an index or size parameter to a method is negative or exceeds the allowed values.", 
        "name": "xml.dom.IndexSizeErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.IndexSizeErr", 
        "syntax": "exception xml.dom.IndexSizeErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.InuseAttributeErr": {
        "descr": "Raised when an attempt is made to insert an Attr node that is already present elsewhere in the document.", 
        "name": "xml.dom.InuseAttributeErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.InuseAttributeErr", 
        "syntax": "exception xml.dom.InuseAttributeErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.InvalidAccessErr": {
        "descr": "Raised if a parameter or an operation is not supported on the underlying object.", 
        "name": "xml.dom.InvalidAccessErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.InvalidAccessErr", 
        "syntax": "exception xml.dom.InvalidAccessErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.InvalidCharacterErr": {
        "descr": "This exception is raised when a string parameter contains a character that is not permitted in the context it\u2019s being used in by the XML 1.0 recommendation. For example, attempting to create an Element node with a space in the element type name will cause this error to be raised.", 
        "name": "xml.dom.InvalidCharacterErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.InvalidCharacterErr", 
        "syntax": "exception xml.dom.InvalidCharacterErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.InvalidModificationErr": {
        "descr": "Raised when an attempt is made to modify the type of a node.", 
        "name": "xml.dom.InvalidModificationErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.InvalidModificationErr", 
        "syntax": "exception xml.dom.InvalidModificationErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.InvalidStateErr": {
        "descr": "Raised when an attempt is made to use an object that is not defined or is no longer usable.", 
        "name": "xml.dom.InvalidStateErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.InvalidStateErr", 
        "syntax": "exception xml.dom.InvalidStateErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NamedNodeMap.item": {
        "descr": "Return an attribute with a particular index. The order you get the attributes in is arbitrary but will be consistent for the life of a DOM. Each item is an attribute node. Get its value with the value attribute.", 
        "name": "xml.dom.NamedNodeMap.item", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NamedNodeMap.item", 
        "syntax": "NamedNodeMap.item(index)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NamedNodeMap.length": {
        "descr": "The length of the attribute list.", 
        "name": "xml.dom.NamedNodeMap.length", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NamedNodeMap.length", 
        "syntax": "NamedNodeMap.length", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NamespaceErr": {
        "descr": "If an attempt is made to change any object in a way that is not permitted with regard to the Namespaces in XML recommendation, this exception is raised.", 
        "name": "xml.dom.NamespaceErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NamespaceErr", 
        "syntax": "exception xml.dom.NamespaceErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NoDataAllowedErr": {
        "descr": "This is raised if data is specified for a node which does not support data.", 
        "name": "xml.dom.NoDataAllowedErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NoDataAllowedErr", 
        "syntax": "exception xml.dom.NoDataAllowedErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NoModificationAllowedErr": {
        "descr": "Raised on attempts to modify an object where modifications are not allowed (such as for read-only nodes).", 
        "name": "xml.dom.NoModificationAllowedErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NoModificationAllowedErr", 
        "syntax": "exception xml.dom.NoModificationAllowedErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.appendChild": {
        "descr": "Add a new child node to this node at the end of the list of children, returning newChild. If the node was already in the tree, it is removed first.", 
        "name": "xml.dom.Node.appendChild", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.appendChild", 
        "syntax": "Node.appendChild(newChild)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.attributes": {
        "descr": "A NamedNodeMap of attribute objects. Only elements have actual values for this; others provide None for this attribute. This is a read-only attribute.", 
        "name": "xml.dom.Node.attributes", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.attributes", 
        "syntax": "Node.attributes", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.childNodes": {
        "descr": "A list of nodes contained within this node. This is a read-only attribute.", 
        "name": "xml.dom.Node.childNodes", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.childNodes", 
        "syntax": "Node.childNodes", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.cloneNode": {
        "descr": "Clone this node. Setting deep means to clone all child nodes as well. This returns the clone.", 
        "name": "xml.dom.Node.cloneNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.cloneNode", 
        "syntax": "Node.cloneNode(deep)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.firstChild": {
        "descr": "The first child of the node, if there are any, or None. This is a read-only attribute.", 
        "name": "xml.dom.Node.firstChild", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.firstChild", 
        "syntax": "Node.firstChild", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.hasAttributes": {
        "descr": "Returns true if the node has any attributes.", 
        "name": "xml.dom.Node.hasAttributes", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.hasAttributes", 
        "syntax": "Node.hasAttributes()", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.hasChildNodes": {
        "descr": "Returns true if the node has any child nodes.", 
        "name": "xml.dom.Node.hasChildNodes", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.hasChildNodes", 
        "syntax": "Node.hasChildNodes()", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.insertBefore": {
        "descr": "Insert a new child node before an existing child. It must be the case that refChild is a child of this node; if not, ValueError is raised. newChild is returned. If refChild is None, it inserts newChild at the end of the children\u2019s list.", 
        "name": "xml.dom.Node.insertBefore", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.insertBefore", 
        "syntax": "Node.insertBefore(newChild, refChild)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.isSameNode": {
        "descr": "Returns true if other refers to the same node as this node. This is especially useful for DOM implementations which use any sort of proxy architecture (because more than one object can refer to the same node).", 
        "name": "xml.dom.Node.isSameNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.isSameNode", 
        "syntax": "Node.isSameNode(other)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.lastChild": {
        "descr": "The last child of the node, if there are any, or None. This is a read-only attribute.", 
        "name": "xml.dom.Node.lastChild", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.lastChild", 
        "syntax": "Node.lastChild", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.localName": {
        "descr": "The part of the tagName following the colon if there is one, else the entire tagName. The value is a string.", 
        "name": "xml.dom.Node.localName", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.localName", 
        "syntax": "Node.localName", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.namespaceURI": {
        "descr": "The namespace associated with the element name. This will be a string or None. This is a read-only attribute.", 
        "name": "xml.dom.Node.namespaceURI", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.namespaceURI", 
        "syntax": "Node.namespaceURI", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.nextSibling": {
        "descr": "The node that immediately follows this one with the same parent. See also previousSibling. If this is the last child of the parent, this attribute will be None. This is a read-only attribute.", 
        "name": "xml.dom.Node.nextSibling", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.nextSibling", 
        "syntax": "Node.nextSibling", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.nodeName": {
        "descr": "This has a different meaning for each node type; see the DOM specification for details. You can always get the information you would get here from another property such as the tagName property for elements or the name property for attributes. For all node types, the value of this attribute will be either a string or None. This is a read-only attribute.", 
        "name": "xml.dom.Node.nodeName", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.nodeName", 
        "syntax": "Node.nodeName", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.nodeType": {
        "descr": "An integer representing the node type. Symbolic constants for the types are on the Node object: ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, CDATA_SECTION_NODE, ENTITY_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, NOTATION_NODE. This is a read-only attribute.", 
        "name": "xml.dom.Node.nodeType", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.nodeType", 
        "syntax": "Node.nodeType", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.nodeValue": {
        "descr": "This has a different meaning for each node type; see the DOM specification for details. The situation is similar to that with nodeName. The value is a string or None.", 
        "name": "xml.dom.Node.nodeValue", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.nodeValue", 
        "syntax": "Node.nodeValue", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.normalize": {
        "descr": "Join adjacent text nodes so that all stretches of text are stored as single Text instances. This simplifies processing text from a DOM tree for many applications.", 
        "name": "xml.dom.Node.normalize", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.normalize", 
        "syntax": "Node.normalize()", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.parentNode": {
        "descr": "The parent of the current node, or None for the document node. The value is always a Node object or None. For Element nodes, this will be the parent element, except for the root element, in which case it will be the Document object. For Attr nodes, this is always None. This is a read-only attribute.", 
        "name": "xml.dom.Node.parentNode", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.parentNode", 
        "syntax": "Node.parentNode", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.prefix": {
        "descr": "The part of the tagName preceding the colon if there is one, else the empty string. The value is a string, or None", 
        "name": "xml.dom.Node.prefix", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.prefix", 
        "syntax": "Node.prefix", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.previousSibling": {
        "descr": "The node that immediately precedes this one with the same parent. For instance the element with an end-tag that comes just before the self element\u2019s start-tag. Of course, XML documents are made up of more than just elements so the previous sibling could be text, a comment, or something else. If this node is the first child of the parent, this attribute will be None. This is a read-only attribute.", 
        "name": "xml.dom.Node.previousSibling", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.previousSibling", 
        "syntax": "Node.previousSibling", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.removeChild": {
        "descr": "Remove a child node. oldChild must be a child of this node; if not, ValueError is raised. oldChild is returned on success. If oldChild will not be used further, its unlink() method should be called.", 
        "name": "xml.dom.Node.removeChild", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.removeChild", 
        "syntax": "Node.removeChild(oldChild)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Node.replaceChild": {
        "descr": "Replace an existing node with a new node. It must be the case that oldChild is a child of this node; if not, ValueError is raised.", 
        "name": "xml.dom.Node.replaceChild", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Node.replaceChild", 
        "syntax": "Node.replaceChild(newChild, oldChild)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NodeList.item": {
        "descr": "Return the i\u2018th item from the sequence, if there is one, or None. The index i is not allowed to be less then zero or greater than or equal to the length of the sequence.", 
        "name": "xml.dom.NodeList.item", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NodeList.item", 
        "syntax": "NodeList.item(i)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NodeList.length": {
        "descr": "The number of nodes in the sequence.", 
        "name": "xml.dom.NodeList.length", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NodeList.length", 
        "syntax": "NodeList.length", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NotFoundErr": {
        "descr": "Exception when a node does not exist in the referenced context. For example, NamedNodeMap.removeNamedItem() will raise this if the node passed in does not exist in the map.", 
        "name": "xml.dom.NotFoundErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NotFoundErr", 
        "syntax": "exception xml.dom.NotFoundErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.NotSupportedErr": {
        "descr": "Raised when the implementation does not support the requested type of object or operation.", 
        "name": "xml.dom.NotSupportedErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.NotSupportedErr", 
        "syntax": "exception xml.dom.NotSupportedErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.ProcessingInstruction.data": {
        "descr": "The content of the processing instruction following the first whitespace character.", 
        "name": "xml.dom.ProcessingInstruction.data", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.ProcessingInstruction.data", 
        "syntax": "ProcessingInstruction.data", 
        "type": "Structured Markup"
    }, 
    "xml.dom.ProcessingInstruction.target": {
        "descr": "The content of the processing instruction up to the first whitespace character. This is a read-only attribute.", 
        "name": "xml.dom.ProcessingInstruction.target", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.ProcessingInstruction.target", 
        "syntax": "ProcessingInstruction.target", 
        "type": "Structured Markup"
    }, 
    "xml.dom.SyntaxErr": {
        "descr": "Raised when an invalid or illegal string is specified.", 
        "name": "xml.dom.SyntaxErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.SyntaxErr", 
        "syntax": "exception xml.dom.SyntaxErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.Text.data": {
        "descr": "The content of the text node as a string.", 
        "name": "xml.dom.Text.data", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.Text.data", 
        "syntax": "Text.data", 
        "type": "Structured Markup"
    }, 
    "xml.dom.WrongDocumentErr": {
        "descr": "Raised when a node is inserted in a different document than it currently belongs to, and the implementation does not support migrating the node from one document to the other.", 
        "name": "xml.dom.WrongDocumentErr", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.WrongDocumentErr", 
        "syntax": "exception xml.dom.WrongDocumentErr", 
        "type": "Structured Markup"
    }, 
    "xml.dom.getDOMImplementation": {
        "descr": "Return a suitable DOM implementation. The name is either well-known, the module name of a DOM implementation, or None. If it is not None, imports the corresponding module and returns a DOMImplementation object if the import succeeds. If no name is given, and if the environment variable PYTHON_DOM is set, this variable is used to find the implementation.", 
        "name": "xml.dom.getDOMImplementation", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.getDOMImplementation", 
        "syntax": "xml.dom.getDOMImplementation(name=None, features=())", 
        "type": "Structured Markup"
    }, 
    "xml.dom.minidom.Node.toprettyxml": {
        "descr": "Return a pretty-printed version of the document. indent specifies the indentation string and defaults to a tabulator; newl specifies the string emitted at the end of each line and defaults to \\n.", 
        "name": "xml.dom.minidom.Node.toprettyxml", 
        "params": [], 
        "path": "python/library/xml.dom.minidom#xml.dom.minidom.Node.toprettyxml", 
        "syntax": "Node.toprettyxml(indent=\"\", newl=\"\", encoding=\"\")", 
        "type": "Structured Markup"
    }, 
    "xml.dom.minidom.Node.toxml": {
        "descr": "Return a string or byte string containing the XML represented by the DOM node.", 
        "name": "xml.dom.minidom.Node.toxml", 
        "params": [], 
        "path": "python/library/xml.dom.minidom#xml.dom.minidom.Node.toxml", 
        "syntax": "Node.toxml(encoding=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.minidom.Node.unlink": {
        "descr": "Break internal references within the DOM so that it will be garbage collected on versions of Python without cyclic GC. Even when cyclic GC is available, using this can make large amounts of memory available sooner, so calling this on DOM objects as soon as they are no longer needed is good practice. This only needs to be called on the Document object, but may be called on child nodes to discard children of that node.", 
        "name": "xml.dom.minidom.Node.unlink", 
        "params": [], 
        "path": "python/library/xml.dom.minidom#xml.dom.minidom.Node.unlink", 
        "syntax": "Node.unlink()", 
        "type": "Structured Markup"
    }, 
    "xml.dom.minidom.Node.writexml": {
        "descr": "Write XML to the writer object. The writer should have a write() method which matches that of the file object interface. The indent parameter is the indentation of the current node. The addindent parameter is the incremental indentation to use for subnodes of the current one. The newl parameter specifies the string to use to terminate newlines.", 
        "name": "xml.dom.minidom.Node.writexml", 
        "params": [], 
        "path": "python/library/xml.dom.minidom#xml.dom.minidom.Node.writexml", 
        "syntax": "Node.writexml(writer, indent=\"\", addindent=\"\", newl=\"\")", 
        "type": "Structured Markup"
    }, 
    "xml.dom.minidom.parse": {
        "descr": "Return a Document from the given input. filename_or_file may be either a file name, or a file-like object. parser, if given, must be a SAX2 parser object. This function will change the document handler of the parser and activate namespace support; other parser configuration (like setting an entity resolver) must have been done in advance.", 
        "name": "xml.dom.minidom.parse", 
        "params": [], 
        "path": "python/library/xml.dom.minidom#xml.dom.minidom.parse", 
        "syntax": "xml.dom.minidom.parse(filename_or_file, parser=None, bufsize=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.minidom.parseString": {
        "descr": "Return a Document that represents the string. This method creates a io.StringIO object for the string and passes that on to parse().", 
        "name": "xml.dom.minidom.parseString", 
        "params": [], 
        "path": "python/library/xml.dom.minidom#xml.dom.minidom.parseString", 
        "syntax": "xml.dom.minidom.parseString(string, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.DOMEventStream": {
        "descr": "Return a tuple containing event and the current node as xml.dom.minidom.Document if event equals START_DOCUMENT, xml.dom.minidom.Element if event equals START_ELEMENT or END_ELEMENT or xml.dom.minidom.Text if event equals CHARACTERS. The current node does not contain informations about its children, unless expandNode() is called.", 
        "name": "xml.dom.pulldom.DOMEventStream", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream", 
        "syntax": "class xml.dom.pulldom.DOMEventStream(stream, parser, bufsize)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.DOMEventStream.expandNode": {
        "descr": "Expands all children of node into node. Example:", 
        "name": "xml.dom.pulldom.DOMEventStream.expandNode", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream.expandNode", 
        "syntax": "expandNode(node)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.DOMEventStream.getEvent": {
        "descr": "Return a tuple containing event and the current node as xml.dom.minidom.Document if event equals START_DOCUMENT, xml.dom.minidom.Element if event equals START_ELEMENT or END_ELEMENT or xml.dom.minidom.Text if event equals CHARACTERS. The current node does not contain informations about its children, unless expandNode() is called.", 
        "name": "xml.dom.pulldom.DOMEventStream.getEvent", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream.getEvent", 
        "syntax": "getEvent()", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.DOMEventStream.reset": {
        "descr": "", 
        "name": "xml.dom.pulldom.DOMEventStream.reset", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream.reset", 
        "syntax": "reset()", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.PullDom": {
        "descr": "Subclass of xml.sax.handler.ContentHandler.", 
        "name": "xml.dom.pulldom.PullDom", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.PullDom", 
        "syntax": "class xml.dom.pulldom.PullDom(documentFactory=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.SAX2DOM": {
        "descr": "Subclass of xml.sax.handler.ContentHandler.", 
        "name": "xml.dom.pulldom.SAX2DOM", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.SAX2DOM", 
        "syntax": "class xml.dom.pulldom.SAX2DOM(documentFactory=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.default_bufsize": {
        "descr": "Default value for the bufsize parameter to parse().", 
        "name": "xml.dom.pulldom.default_bufsize", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.default_bufsize", 
        "syntax": "xml.dom.pulldom.default_bufsize", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.parse": {
        "descr": "Return a DOMEventStream from the given input. stream_or_string may be either a file name, or a file-like object. parser, if given, must be a XMLReader object. This function will change the document handler of the parser and activate namespace support; other parser configuration (like setting an entity resolver) must have been done in advance.", 
        "name": "xml.dom.pulldom.parse", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.parse", 
        "syntax": "xml.dom.pulldom.parse(stream_or_string, parser=None, bufsize=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.pulldom.parseString": {
        "descr": "Return a DOMEventStream that represents the (Unicode) string.", 
        "name": "xml.dom.pulldom.parseString", 
        "params": [], 
        "path": "python/library/xml.dom.pulldom#xml.dom.pulldom.parseString", 
        "syntax": "xml.dom.pulldom.parseString(string, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.dom.registerDOMImplementation": {
        "descr": "Register the factory function with the name name. The factory function should return an object which implements the DOMImplementation interface. The factory function can return the same object every time, or a new one for each call, as appropriate for the specific implementation (e.g. if that implementation supports some customization).", 
        "name": "xml.dom.registerDOMImplementation", 
        "params": [], 
        "path": "python/library/xml.dom#xml.dom.registerDOMImplementation", 
        "syntax": "xml.dom.registerDOMImplementation(name, factory)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Comment": {
        "descr": "Comment element factory. This factory function creates a special element that will be serialized as an XML comment by the standard serializer. The comment string can be either a bytestring or a Unicode string. text is a string containing the comment string. Returns an element instance representing a comment.", 
        "name": "xml.etree.ElementTree.Comment", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Comment", 
        "syntax": "xml.etree.ElementTree.Comment(text=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element": {
        "descr": "Element class. This class defines the Element interface, and provides a reference implementation of this interface.", 
        "name": "xml.etree.ElementTree.Element", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element", 
        "syntax": "class xml.etree.ElementTree.Element(tag, attrib={}, **extra)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.append": {
        "descr": "Adds the element subelement to the end of this element\u2019s internal list of subelements. Raises TypeError if subelement is not an Element.", 
        "name": "xml.etree.ElementTree.Element.append", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.append", 
        "syntax": "append(subelement)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.attrib": {
        "descr": "A dictionary containing the element\u2019s attributes. Note that while the attrib value is always a real mutable Python dictionary, an ElementTree implementation may choose to use another internal representation, and create the dictionary only if someone asks for it. To take advantage of such implementations, use the dictionary methods below whenever possible.", 
        "name": "xml.etree.ElementTree.Element.attrib", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.attrib", 
        "syntax": "attrib", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.clear": {
        "descr": "Resets an element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to None.", 
        "name": "xml.etree.ElementTree.Element.clear", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.clear", 
        "syntax": "clear()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.extend": {
        "descr": "Appends subelements from a sequence object with zero or more elements. Raises TypeError if a subelement is not an Element.", 
        "name": "xml.etree.ElementTree.Element.extend", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.extend", 
        "syntax": "extend(subelements)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.find": {
        "descr": "Finds the first subelement matching match. match may be a tag name or a path. Returns an element instance or None. namespaces is an optional mapping from namespace prefix to full name.", 
        "name": "xml.etree.ElementTree.Element.find", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.find", 
        "syntax": "find(match, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.findall": {
        "descr": "Finds all matching subelements, by tag name or path. Returns a list containing all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name.", 
        "name": "xml.etree.ElementTree.Element.findall", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.findall", 
        "syntax": "findall(match, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.findtext": {
        "descr": "Finds text for the first subelement matching match. match may be a tag name or a path. Returns the text content of the first matching element, or default if no element was found. Note that if the matching element has no text content an empty string is returned. namespaces is an optional mapping from namespace prefix to full name.", 
        "name": "xml.etree.ElementTree.Element.findtext", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.findtext", 
        "syntax": "findtext(match, default=None, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.get": {
        "descr": "Gets the element attribute named key.", 
        "name": "xml.etree.ElementTree.Element.get", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.get", 
        "syntax": "get(key, default=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.getchildren": {
        "descr": "Deprecated since version 3.2: Use list(elem) or iteration.", 
        "name": "xml.etree.ElementTree.Element.getchildren", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.getchildren", 
        "syntax": "getchildren()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.getiterator": {
        "descr": "Deprecated since version 3.2: Use method Element.iter() instead.", 
        "name": "xml.etree.ElementTree.Element.getiterator", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.getiterator", 
        "syntax": "getiterator(tag=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.insert": {
        "descr": "Inserts subelement at the given position in this element. Raises TypeError if subelement is not an Element.", 
        "name": "xml.etree.ElementTree.Element.insert", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.insert", 
        "syntax": "insert(index, subelement)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.items": {
        "descr": "Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order.", 
        "name": "xml.etree.ElementTree.Element.items", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.items", 
        "syntax": "items()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.iter": {
        "descr": "Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not None or '*', only elements whose tag equals tag are returned from the iterator. If the tree structure is modified during iteration, the result is undefined.", 
        "name": "xml.etree.ElementTree.Element.iter", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.iter", 
        "syntax": "iter(tag=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.iterfind": {
        "descr": "Finds all matching subelements, by tag name or path. Returns an iterable yielding all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name.", 
        "name": "xml.etree.ElementTree.Element.iterfind", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.iterfind", 
        "syntax": "iterfind(match, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.itertext": {
        "descr": "Creates a text iterator. The iterator loops over this element and all subelements, in document order, and returns all inner text.", 
        "name": "xml.etree.ElementTree.Element.itertext", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.itertext", 
        "syntax": "itertext()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.keys": {
        "descr": "Returns the elements attribute names as a list. The names are returned in an arbitrary order.", 
        "name": "xml.etree.ElementTree.Element.keys", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.keys", 
        "syntax": "keys()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.makeelement": {
        "descr": "Creates a new element object of the same type as this element. Do not call this method, use the SubElement() factory function instead.", 
        "name": "xml.etree.ElementTree.Element.makeelement", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.makeelement", 
        "syntax": "makeelement(tag, attrib)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.remove": {
        "descr": "Removes subelement from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents.", 
        "name": "xml.etree.ElementTree.Element.remove", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.remove", 
        "syntax": "remove(subelement)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.set": {
        "descr": "Set the attribute key on the element to value.", 
        "name": "xml.etree.ElementTree.Element.set", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.set", 
        "syntax": "set(key, value)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.tag": {
        "descr": "A string identifying what kind of data this element represents (the element type, in other words).", 
        "name": "xml.etree.ElementTree.Element.tag", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.tag", 
        "syntax": "tag", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.tail": {
        "descr": "The tail attribute can be used to hold additional data associated with the element. This attribute is usually a string but may be any application-specific object. If the element is created from an XML file the attribute will contain any text found after the element\u2019s end tag and before the next tag.", 
        "name": "xml.etree.ElementTree.Element.tail", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.tail", 
        "syntax": "tail", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.Element.text": {
        "descr": "The text attribute can be used to hold additional data associated with the element. As the name implies this attribute is usually a string but may be any application-specific object. If the element is created from an XML file the attribute will contain any text found between the element tags.", 
        "name": "xml.etree.ElementTree.Element.text", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.Element.text", 
        "syntax": "text", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree": {
        "descr": "ElementTree wrapper class. This class represents an entire element hierarchy, and adds some extra support for serialization to and from standard XML.", 
        "name": "xml.etree.ElementTree.ElementTree", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree", 
        "syntax": "class xml.etree.ElementTree.ElementTree(element=None, file=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree._setroot": {
        "descr": "Replaces the root element for this tree. This discards the current contents of the tree, and replaces it with the given element. Use with care. element is an element instance.", 
        "name": "xml.etree.ElementTree.ElementTree._setroot", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree._setroot", 
        "syntax": "_setroot(element)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.find": {
        "descr": "Same as Element.find(), starting at the root of the tree.", 
        "name": "xml.etree.ElementTree.ElementTree.find", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.find", 
        "syntax": "find(match, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.findall": {
        "descr": "Same as Element.findall(), starting at the root of the tree.", 
        "name": "xml.etree.ElementTree.ElementTree.findall", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.findall", 
        "syntax": "findall(match, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.findtext": {
        "descr": "Same as Element.findtext(), starting at the root of the tree.", 
        "name": "xml.etree.ElementTree.ElementTree.findtext", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.findtext", 
        "syntax": "findtext(match, default=None, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.getiterator": {
        "descr": "Deprecated since version 3.2: Use method ElementTree.iter() instead.", 
        "name": "xml.etree.ElementTree.ElementTree.getiterator", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.getiterator", 
        "syntax": "getiterator(tag=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.getroot": {
        "descr": "Returns the root element for this tree.", 
        "name": "xml.etree.ElementTree.ElementTree.getroot", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.getroot", 
        "syntax": "getroot()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.iter": {
        "descr": "Creates and returns a tree iterator for the root element. The iterator loops over all elements in this tree, in section order. tag is the tag to look for (default is to return all elements)", 
        "name": "xml.etree.ElementTree.ElementTree.iter", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.iter", 
        "syntax": "iter(tag=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.iterfind": {
        "descr": "Same as Element.iterfind(), starting at the root of the tree.", 
        "name": "xml.etree.ElementTree.ElementTree.iterfind", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.iterfind", 
        "syntax": "iterfind(match, namespaces=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.parse": {
        "descr": "Loads an external XML section into this element tree. source is a file name or file object. parser is an optional parser instance. If not given, the standard XMLParser parser is used. Returns the section root element.", 
        "name": "xml.etree.ElementTree.ElementTree.parse", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.parse", 
        "syntax": "parse(source, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ElementTree.write": {
        "descr": "Writes the element tree to a file, as XML. file is a file name, or a file object opened for writing. encoding [1] is the output encoding (default is US-ASCII). xml_declaration controls if an XML declaration should be added to the file. Use False for never, True for always, None for only if not US-ASCII or UTF-8 or Unicode (default is None). default_namespace sets the default XML namespace (for \u201cxmlns\u201d). method is either \"xml\", \"html\" or \"text\" (default is \"xml\").", 
        "name": "xml.etree.ElementTree.ElementTree.write", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.write", 
        "syntax": "write(file, encoding=\"us-ascii\", xml_declaration=None, default_namespace=None, method=\"xml\")", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ParseError": {
        "descr": "XML parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a user-friendly error message. In addition, it will have the following attributes available:", 
        "name": "xml.etree.ElementTree.ParseError", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ParseError", 
        "syntax": "class xml.etree.ElementTree.ParseError", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ParseError.code": {
        "descr": "A numeric error code from the expat parser. See the documentation of xml.parsers.expat for the list of error codes and their meanings.", 
        "name": "xml.etree.ElementTree.ParseError.code", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ParseError.code", 
        "syntax": "code", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ParseError.position": {
        "descr": "A tuple of line, column numbers, specifying where the error occurred.", 
        "name": "xml.etree.ElementTree.ParseError.position", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ParseError.position", 
        "syntax": "position", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.ProcessingInstruction": {
        "descr": "PI element factory. This factory function creates a special element that will be serialized as an XML processing instruction. target is a string containing the PI target. text is a string containing the PI contents, if given. Returns an element instance, representing a processing instruction.", 
        "name": "xml.etree.ElementTree.ProcessingInstruction", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.ProcessingInstruction", 
        "syntax": "xml.etree.ElementTree.ProcessingInstruction(target, text=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.QName": {
        "descr": "QName wrapper. This can be used to wrap a QName attribute value, in order to get proper namespace handling on output. text_or_uri is a string containing the QName value, in the form {uri}local, or, if the tag argument is given, the URI part of a QName. If tag is given, the first argument is interpreted as an URI, and this argument is interpreted as a local name. QName instances are opaque.", 
        "name": "xml.etree.ElementTree.QName", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.QName", 
        "syntax": "class xml.etree.ElementTree.QName(text_or_uri, tag=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.SubElement": {
        "descr": "Subelement factory. This function creates an element instance, and appends it to an existing element.", 
        "name": "xml.etree.ElementTree.SubElement", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.SubElement", 
        "syntax": "xml.etree.ElementTree.SubElement(parent, tag, attrib={}, **extra)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.TreeBuilder": {
        "descr": "Generic element structure builder. This builder converts a sequence of start, data, and end method calls to a well-formed element structure. You can use this class to build an element structure using a custom XML parser, or a parser for some other XML-like format. element_factory, when given, must be a callable accepting two positional arguments: a tag and a dict of attributes. It is expected to return a new element instance.", 
        "name": "xml.etree.ElementTree.TreeBuilder", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder", 
        "syntax": "class xml.etree.ElementTree.TreeBuilder(element_factory=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.TreeBuilder.close": {
        "descr": "Flushes the builder buffers, and returns the toplevel document element. Returns an Element instance.", 
        "name": "xml.etree.ElementTree.TreeBuilder.close", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.close", 
        "syntax": "close()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.TreeBuilder.data": {
        "descr": "Adds text to the current element. data is a string. This should be either a bytestring, or a Unicode string.", 
        "name": "xml.etree.ElementTree.TreeBuilder.data", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.data", 
        "syntax": "data(data)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.TreeBuilder.doctype": {
        "descr": "Handles a doctype declaration. name is the doctype name. pubid is the public identifier. system is the system identifier. This method does not exist on the default TreeBuilder class.", 
        "name": "xml.etree.ElementTree.TreeBuilder.doctype", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.doctype", 
        "syntax": "doctype(name, pubid, system)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.TreeBuilder.end": {
        "descr": "Closes the current element. tag is the element name. Returns the closed element.", 
        "name": "xml.etree.ElementTree.TreeBuilder.end", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.end", 
        "syntax": "end(tag)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.TreeBuilder.start": {
        "descr": "Opens a new element. tag is the element name. attrs is a dictionary containing element attributes. Returns the opened element.", 
        "name": "xml.etree.ElementTree.TreeBuilder.start", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.start", 
        "syntax": "start(tag, attrs)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.XML": {
        "descr": "Parses an XML section from a string constant. This function can be used to embed \u201cXML literals\u201d in Python code. text is a string containing XML data. parser is an optional parser instance. If not given, the standard XMLParser parser is used. Returns an Element instance.", 
        "name": "xml.etree.ElementTree.XML", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.XML", 
        "syntax": "xml.etree.ElementTree.XML(text, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.XMLID": {
        "descr": "Parses an XML section from a string constant, and also returns a dictionary which maps from element id:s to elements. text is a string containing XML data. parser is an optional parser instance. If not given, the standard XMLParser parser is used. Returns a tuple containing an Element instance and a dictionary.", 
        "name": "xml.etree.ElementTree.XMLID", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.XMLID", 
        "syntax": "xml.etree.ElementTree.XMLID(text, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.XMLParser": {
        "descr": "Element structure builder for XML source data, based on the expat parser. html are predefined HTML entities. This flag is not supported by the current implementation. target is the target object. If omitted, the builder uses an instance of the standard TreeBuilder class. encoding [1] is optional. If given, the value overrides the encoding specified in the XML file.", 
        "name": "xml.etree.ElementTree.XMLParser", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser", 
        "syntax": "class xml.etree.ElementTree.XMLParser(html=0, target=None, encoding=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.XMLParser.close": {
        "descr": "Finishes feeding data to the parser. Returns the result of calling the close() method of the target passed during construction; by default, this is the toplevel document element.", 
        "name": "xml.etree.ElementTree.XMLParser.close", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser.close", 
        "syntax": "close()", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.XMLParser.doctype": {
        "descr": "Deprecated since version 3.2: Define the TreeBuilder.doctype() method on a custom TreeBuilder target.", 
        "name": "xml.etree.ElementTree.XMLParser.doctype", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser.doctype", 
        "syntax": "doctype(name, pubid, system)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.XMLParser.feed": {
        "descr": "Feeds data to the parser. data is encoded data.", 
        "name": "xml.etree.ElementTree.XMLParser.feed", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser.feed", 
        "syntax": "feed(data)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.dump": {
        "descr": "Writes an element tree or element structure to sys.stdout. This function should be used for debugging only.", 
        "name": "xml.etree.ElementTree.dump", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.dump", 
        "syntax": "xml.etree.ElementTree.dump(elem)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.fromstring": {
        "descr": "Parses an XML section from a string constant. Same as XML(). text is a string containing XML data. Returns an Element instance.", 
        "name": "xml.etree.ElementTree.fromstring", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.fromstring", 
        "syntax": "xml.etree.ElementTree.fromstring(text)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.fromstringlist": {
        "descr": "Parses an XML document from a sequence of string fragments. sequence is a list or other sequence containing XML data fragments. parser is an optional parser instance. If not given, the standard XMLParser parser is used. Returns an Element instance.", 
        "name": "xml.etree.ElementTree.fromstringlist", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.fromstringlist", 
        "syntax": "xml.etree.ElementTree.fromstringlist(sequence, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.iselement": {
        "descr": "Checks if an object appears to be a valid element object. element is an element instance. Returns a true value if this is an element object.", 
        "name": "xml.etree.ElementTree.iselement", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.iselement", 
        "syntax": "xml.etree.ElementTree.iselement(element)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.iterparse": {
        "descr": "Parses an XML section into an element tree incrementally, and reports what\u2019s going on to the user. source is a filename or file object containing XML data. events is a tuple of events to report back. The supported events are the strings \"start\", \"end\", \"start-ns\" and \"end-ns\" (the \u201cns\u201d events are used to get detailed namespace information). If events is omitted, only \"end\" events are reported. parser is an optional parser instance. If not given, the standard XMLParser parser is used. parser can only use the default TreeBuilder as a target. Returns an iterator providing (event, elem) pairs.", 
        "name": "xml.etree.ElementTree.iterparse", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.iterparse", 
        "syntax": "xml.etree.ElementTree.iterparse(source, events=None, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.parse": {
        "descr": "Parses an XML section into an element tree. source is a filename or file object containing XML data. parser is an optional parser instance. If not given, the standard XMLParser parser is used. Returns an ElementTree instance.", 
        "name": "xml.etree.ElementTree.parse", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.parse", 
        "syntax": "xml.etree.ElementTree.parse(source, parser=None)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.register_namespace": {
        "descr": "Registers a namespace prefix. The registry is global, and any existing mapping for either the given prefix or the namespace URI will be removed. prefix is a namespace prefix. uri is a namespace uri. Tags and attributes in this namespace will be serialized with the given prefix, if at all possible.", 
        "name": "xml.etree.ElementTree.register_namespace", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.register_namespace", 
        "syntax": "xml.etree.ElementTree.register_namespace(prefix, uri)", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.tostring": {
        "descr": "Generates a string representation of an XML element, including all subelements. element is an Element instance. encoding [1] is the output encoding (default is US-ASCII). Use encoding=\"unicode\" to generate a Unicode string (otherwise, a bytestring is generated). method is either \"xml\", \"html\" or \"text\" (default is \"xml\"). Returns an (optionally) encoded string containing the XML data.", 
        "name": "xml.etree.ElementTree.tostring", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.tostring", 
        "syntax": "xml.etree.ElementTree.tostring(element, encoding=\"us-ascii\", method=\"xml\")", 
        "type": "Structured Markup"
    }, 
    "xml.etree.ElementTree.tostringlist": {
        "descr": "Generates a string representation of an XML element, including all subelements. element is an Element instance. encoding [1] is the output encoding (default is US-ASCII). Use encoding=\"unicode\" to generate a Unicode string (otherwise, a bytestring is generated). method is either \"xml\", \"html\" or \"text\" (default is \"xml\"). Returns a list of (optionally) encoded strings containing the XML data. It does not guarantee any specific sequence, except that b\"\".join(tostringlist(element)) == tostring(element).", 
        "name": "xml.etree.ElementTree.tostringlist", 
        "params": [], 
        "path": "python/library/xml.etree.elementtree#xml.etree.ElementTree.tostringlist", 
        "syntax": "xml.etree.ElementTree.tostringlist(element, encoding=\"us-ascii\", method=\"xml\")", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.ErrorString": {
        "descr": "Returns an explanatory string for a given error number errno.", 
        "name": "xml.parsers.expat.ErrorString", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.ErrorString", 
        "syntax": "xml.parsers.expat.ErrorString(errno)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.ExpatError": {
        "descr": "The exception raised when Expat reports an error. See section ExpatError Exceptions for more information on interpreting Expat errors.", 
        "name": "xml.parsers.expat.ExpatError", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.ExpatError", 
        "syntax": "exception xml.parsers.expat.ExpatError", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.ExpatError.code": {
        "descr": "Expat\u2019s internal error number for the specific error. The errors.messages dictionary maps these error numbers to Expat\u2019s error messages. For example:", 
        "name": "xml.parsers.expat.ExpatError.code", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.ExpatError.code", 
        "syntax": "ExpatError.code", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.ExpatError.lineno": {
        "descr": "Line number on which the error was detected. The first line is numbered 1.", 
        "name": "xml.parsers.expat.ExpatError.lineno", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.ExpatError.lineno", 
        "syntax": "ExpatError.lineno", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.ExpatError.offset": {
        "descr": "Character offset into the line where the error occurred. The first column is numbered 0.", 
        "name": "xml.parsers.expat.ExpatError.offset", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.ExpatError.offset", 
        "syntax": "ExpatError.offset", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.ParserCreate": {
        "descr": "Creates and returns a new xmlparser object. encoding, if specified, must be a string naming the encoding used by the XML data. Expat doesn\u2019t support as many encodings as Python does, and its repertoire of encodings can\u2019t be extended; it supports UTF-8, UTF-16, ISO-8859-1 (Latin1), and ASCII. If encoding [1] is given it will override the implicit or explicit encoding of the document.", 
        "name": "xml.parsers.expat.ParserCreate", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.ParserCreate", 
        "syntax": "xml.parsers.expat.ParserCreate(encoding=None, namespace_separator=None)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.XMLParserType": {
        "descr": "The type of the return values from the ParserCreate() function.", 
        "name": "xml.parsers.expat.XMLParserType", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.XMLParserType", 
        "syntax": "xml.parsers.expat.XMLParserType", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.error": {
        "descr": "Alias for ExpatError.", 
        "name": "xml.parsers.expat.error", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.error", 
        "syntax": "exception xml.parsers.expat.error", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.errors.codes": {
        "descr": "A dictionary mapping numeric error codes to their string descriptions.", 
        "name": "xml.parsers.expat.errors.codes", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.errors.codes", 
        "syntax": "xml.parsers.expat.errors.codes", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.errors.messages": {
        "descr": "A dictionary mapping string descriptions to their error codes.", 
        "name": "xml.parsers.expat.errors.messages", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.errors.messages", 
        "syntax": "xml.parsers.expat.errors.messages", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.AttlistDeclHandler": {
        "descr": "Called for each declared attribute for an element type. If an attribute list declaration declares three attributes, this handler is called three times, once for each attribute. elname is the name of the element to which the declaration applies and attname is the name of the attribute declared. The attribute type is a string passed as type; the possible values are 'CDATA', 'ID', 'IDREF', ... default gives the default value for the attribute used when the attribute is not specified by the document instance, or None if there is no default value (#IMPLIED values). If the attribute is required to be given in the document instance, required will be true. This requires Expat version 1.95.0 or newer.", 
        "name": "xml.parsers.expat.xmlparser.AttlistDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.AttlistDeclHandler", 
        "syntax": "xmlparser.AttlistDeclHandler(elname, attname, type, default, required)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.CharacterDataHandler": {
        "descr": "Called for character data. This will be called for normal character data, CDATA marked content, and ignorable whitespace. Applications which must distinguish these cases can use the StartCdataSectionHandler, EndCdataSectionHandler, and ElementDeclHandler callbacks to collect the required information.", 
        "name": "xml.parsers.expat.xmlparser.CharacterDataHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.CharacterDataHandler", 
        "syntax": "xmlparser.CharacterDataHandler(data)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.CommentHandler": {
        "descr": "Called for comments. data is the text of the comment, excluding the leading '<!--' and trailing '-->'.", 
        "name": "xml.parsers.expat.xmlparser.CommentHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.CommentHandler", 
        "syntax": "xmlparser.CommentHandler(data)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.CurrentByteIndex": {
        "descr": "Current byte index in the parser input.", 
        "name": "xml.parsers.expat.xmlparser.CurrentByteIndex", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.CurrentByteIndex", 
        "syntax": "xmlparser.CurrentByteIndex", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.CurrentColumnNumber": {
        "descr": "Current column number in the parser input.", 
        "name": "xml.parsers.expat.xmlparser.CurrentColumnNumber", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.CurrentColumnNumber", 
        "syntax": "xmlparser.CurrentColumnNumber", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.CurrentLineNumber": {
        "descr": "Current line number in the parser input.", 
        "name": "xml.parsers.expat.xmlparser.CurrentLineNumber", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.CurrentLineNumber", 
        "syntax": "xmlparser.CurrentLineNumber", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.DefaultHandler": {
        "descr": "Called for any characters in the XML document for which no applicable handler has been specified. This means characters that are part of a construct which could be reported, but for which no handler has been supplied.", 
        "name": "xml.parsers.expat.xmlparser.DefaultHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.DefaultHandler", 
        "syntax": "xmlparser.DefaultHandler(data)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.DefaultHandlerExpand": {
        "descr": "This is the same as the DefaultHandler(), but doesn\u2019t inhibit expansion of internal entities. The entity reference will not be passed to the default handler.", 
        "name": "xml.parsers.expat.xmlparser.DefaultHandlerExpand", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.DefaultHandlerExpand", 
        "syntax": "xmlparser.DefaultHandlerExpand(data)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ElementDeclHandler": {
        "descr": "Called once for each element type declaration. name is the name of the element type, and model is a representation of the content model.", 
        "name": "xml.parsers.expat.xmlparser.ElementDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ElementDeclHandler", 
        "syntax": "xmlparser.ElementDeclHandler(name, model)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.EndCdataSectionHandler": {
        "descr": "Called at the end of a CDATA section.", 
        "name": "xml.parsers.expat.xmlparser.EndCdataSectionHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.EndCdataSectionHandler", 
        "syntax": "xmlparser.EndCdataSectionHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.EndDoctypeDeclHandler": {
        "descr": "Called when Expat is done parsing the document type declaration. This requires Expat version 1.2 or newer.", 
        "name": "xml.parsers.expat.xmlparser.EndDoctypeDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.EndDoctypeDeclHandler", 
        "syntax": "xmlparser.EndDoctypeDeclHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.EndElementHandler": {
        "descr": "Called for the end of every element.", 
        "name": "xml.parsers.expat.xmlparser.EndElementHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.EndElementHandler", 
        "syntax": "xmlparser.EndElementHandler(name)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.EndNamespaceDeclHandler": {
        "descr": "Called when the closing tag is reached for an element that contained a namespace declaration. This is called once for each namespace declaration on the element in the reverse of the order for which the StartNamespaceDeclHandler was called to indicate the start of each namespace declaration\u2019s scope. Calls to this handler are made after the corresponding EndElementHandler for the end of the element.", 
        "name": "xml.parsers.expat.xmlparser.EndNamespaceDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.EndNamespaceDeclHandler", 
        "syntax": "xmlparser.EndNamespaceDeclHandler(prefix)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.EntityDeclHandler": {
        "descr": "Called for all entity declarations. For parameter and internal entities, value will be a string giving the declared contents of the entity; this will be None for external entities. The notationName parameter will be None for parsed entities, and the name of the notation for unparsed entities. is_parameter_entity will be true if the entity is a parameter entity or false for general entities (most applications only need to be concerned with general entities). This is only available starting with version 1.95.0 of the Expat library.", 
        "name": "xml.parsers.expat.xmlparser.EntityDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.EntityDeclHandler", 
        "syntax": "xmlparser.EntityDeclHandler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ErrorByteIndex": {
        "descr": "Byte index at which an error occurred.", 
        "name": "xml.parsers.expat.xmlparser.ErrorByteIndex", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ErrorByteIndex", 
        "syntax": "xmlparser.ErrorByteIndex", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ErrorCode": {
        "descr": "Numeric code specifying the problem. This value can be passed to the ErrorString() function, or compared to one of the constants defined in the errors object.", 
        "name": "xml.parsers.expat.xmlparser.ErrorCode", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ErrorCode", 
        "syntax": "xmlparser.ErrorCode", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ErrorColumnNumber": {
        "descr": "Column number at which an error occurred.", 
        "name": "xml.parsers.expat.xmlparser.ErrorColumnNumber", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ErrorColumnNumber", 
        "syntax": "xmlparser.ErrorColumnNumber", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ErrorLineNumber": {
        "descr": "Line number at which an error occurred.", 
        "name": "xml.parsers.expat.xmlparser.ErrorLineNumber", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ErrorLineNumber", 
        "syntax": "xmlparser.ErrorLineNumber", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ExternalEntityParserCreate": {
        "descr": "Create a \u201cchild\u201d parser which can be used to parse an external parsed entity referred to by content parsed by the parent parser. The context parameter should be the string passed to the ExternalEntityRefHandler() handler function, described below. The child parser is created with the ordered_attributes and specified_attributes set to the values of this parser.", 
        "name": "xml.parsers.expat.xmlparser.ExternalEntityParserCreate", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ExternalEntityParserCreate", 
        "syntax": "xmlparser.ExternalEntityParserCreate(context[, encoding])", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ExternalEntityRefHandler": {
        "descr": "Called for references to external entities. base is the current base, as set by a previous call to SetBase(). The public and system identifiers, systemId and publicId, are strings if given; if the public identifier is not given, publicId will be None. The context value is opaque and should only be used as described below.", 
        "name": "xml.parsers.expat.xmlparser.ExternalEntityRefHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ExternalEntityRefHandler", 
        "syntax": "xmlparser.ExternalEntityRefHandler(context, base, systemId, publicId)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.GetBase": {
        "descr": "Returns a string containing the base set by a previous call to SetBase(), or None if SetBase() hasn\u2019t been called.", 
        "name": "xml.parsers.expat.xmlparser.GetBase", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.GetBase", 
        "syntax": "xmlparser.GetBase()", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.GetInputContext": {
        "descr": "Returns the input data that generated the current event as a string. The data is in the encoding of the entity which contains the text. When called while an event handler is not active, the return value is None.", 
        "name": "xml.parsers.expat.xmlparser.GetInputContext", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.GetInputContext", 
        "syntax": "xmlparser.GetInputContext()", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.NotStandaloneHandler": {
        "descr": "Called if the XML document hasn\u2019t been declared as being a standalone document. This happens when there is an external subset or a reference to a parameter entity, but the XML declaration does not set standalone to yes in an XML declaration. If this handler returns 0, then the parser will raise an XML_ERROR_NOT_STANDALONE error. If this handler is not set, no exception is raised by the parser for this condition.", 
        "name": "xml.parsers.expat.xmlparser.NotStandaloneHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.NotStandaloneHandler", 
        "syntax": "xmlparser.NotStandaloneHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.NotationDeclHandler": {
        "descr": "Called for notation declarations. notationName, base, and systemId, and publicId are strings if given. If the public identifier is omitted, publicId will be None.", 
        "name": "xml.parsers.expat.xmlparser.NotationDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.NotationDeclHandler", 
        "syntax": "xmlparser.NotationDeclHandler(notationName, base, systemId, publicId)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.Parse": {
        "descr": "Parses the contents of the string data, calling the appropriate handler functions to process the parsed data. isfinal must be true on the final call to this method. data can be the empty string at any time.", 
        "name": "xml.parsers.expat.xmlparser.Parse", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.Parse", 
        "syntax": "xmlparser.Parse(data[, isfinal])", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ParseFile": {
        "descr": "Parse XML data reading from the object file. file only needs to provide the read(nbytes) method, returning the empty string when there\u2019s no more data.", 
        "name": "xml.parsers.expat.xmlparser.ParseFile", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ParseFile", 
        "syntax": "xmlparser.ParseFile(file)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ProcessingInstructionHandler": {
        "descr": "Called for every processing instruction.", 
        "name": "xml.parsers.expat.xmlparser.ProcessingInstructionHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ProcessingInstructionHandler", 
        "syntax": "xmlparser.ProcessingInstructionHandler(target, data)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.SetBase": {
        "descr": "Sets the base to be used for resolving relative URIs in system identifiers in declarations. Resolving relative identifiers is left to the application: this value will be passed through as the base argument to the ExternalEntityRefHandler(), NotationDeclHandler(), and UnparsedEntityDeclHandler() functions.", 
        "name": "xml.parsers.expat.xmlparser.SetBase", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.SetBase", 
        "syntax": "xmlparser.SetBase(base)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.SetParamEntityParsing": {
        "descr": "Control parsing of parameter entities (including the external DTD subset). Possible flag values are XML_PARAM_ENTITY_PARSING_NEVER, XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and XML_PARAM_ENTITY_PARSING_ALWAYS. Return true if setting the flag was successful.", 
        "name": "xml.parsers.expat.xmlparser.SetParamEntityParsing", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.SetParamEntityParsing", 
        "syntax": "xmlparser.SetParamEntityParsing(flag)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.StartCdataSectionHandler": {
        "descr": "Called at the start of a CDATA section. This and EndCdataSectionHandler are needed to be able to identify the syntactical start and end for CDATA sections.", 
        "name": "xml.parsers.expat.xmlparser.StartCdataSectionHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.StartCdataSectionHandler", 
        "syntax": "xmlparser.StartCdataSectionHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.StartDoctypeDeclHandler": {
        "descr": "Called when Expat begins parsing the document type declaration (<!DOCTYPE ...). The doctypeName is provided exactly as presented. The systemId and publicId parameters give the system and public identifiers if specified, or None if omitted. has_internal_subset will be true if the document contains and internal document declaration subset. This requires Expat version 1.2 or newer.", 
        "name": "xml.parsers.expat.xmlparser.StartDoctypeDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.StartDoctypeDeclHandler", 
        "syntax": "xmlparser.StartDoctypeDeclHandler(doctypeName, systemId, publicId, has_internal_subset)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.StartElementHandler": {
        "descr": "Called for the start of every element. name is a string containing the element name, and attributes is the element attributes. If ordered_attributes is true, this is a list (see ordered_attributes for a full description). Otherwise it\u2019s a dictionary mapping names to values.", 
        "name": "xml.parsers.expat.xmlparser.StartElementHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.StartElementHandler", 
        "syntax": "xmlparser.StartElementHandler(name, attributes)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.StartNamespaceDeclHandler": {
        "descr": "Called when an element contains a namespace declaration. Namespace declarations are processed before the StartElementHandler is called for the element on which declarations are placed.", 
        "name": "xml.parsers.expat.xmlparser.StartNamespaceDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.StartNamespaceDeclHandler", 
        "syntax": "xmlparser.StartNamespaceDeclHandler(prefix, uri)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler": {
        "descr": "Called for unparsed (NDATA) entity declarations. This is only present for version 1.2 of the Expat library; for more recent versions, use EntityDeclHandler instead. (The underlying function in the Expat library has been declared obsolete.)", 
        "name": "xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler", 
        "syntax": "xmlparser.UnparsedEntityDeclHandler(entityName, base, systemId, publicId, notationName)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.UseForeignDTD": {
        "descr": "Calling this with a true value for flag (the default) will cause Expat to call the ExternalEntityRefHandler with None for all arguments to allow an alternate DTD to be loaded. If the document does not contain a document type declaration, the ExternalEntityRefHandler will still be called, but the StartDoctypeDeclHandler and EndDoctypeDeclHandler will not be called.", 
        "name": "xml.parsers.expat.xmlparser.UseForeignDTD", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.UseForeignDTD", 
        "syntax": "xmlparser.UseForeignDTD([flag])", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.XmlDeclHandler": {
        "descr": "Called when the XML declaration is parsed. The XML declaration is the (optional) declaration of the applicable version of the XML recommendation, the encoding of the document text, and an optional \u201cstandalone\u201d declaration. version and encoding will be strings, and standalone will be 1 if the document is declared standalone, 0 if it is declared not to be standalone, or -1 if the standalone clause was omitted. This is only available with Expat version 1.95.0 or newer.", 
        "name": "xml.parsers.expat.xmlparser.XmlDeclHandler", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.XmlDeclHandler", 
        "syntax": "xmlparser.XmlDeclHandler(version, encoding, standalone)", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.buffer_size": {
        "descr": "The size of the buffer used when buffer_text is true. A new buffer size can be set by assigning a new integer value to this attribute. When the size is changed, the buffer will be flushed.", 
        "name": "xml.parsers.expat.xmlparser.buffer_size", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.buffer_size", 
        "syntax": "xmlparser.buffer_size", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.buffer_text": {
        "descr": "Setting this to true causes the xmlparser object to buffer textual content returned by Expat to avoid multiple calls to the CharacterDataHandler() callback whenever possible. This can improve performance substantially since Expat normally breaks character data into chunks at every line ending. This attribute is false by default, and may be changed at any time.", 
        "name": "xml.parsers.expat.xmlparser.buffer_text", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.buffer_text", 
        "syntax": "xmlparser.buffer_text", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.buffer_used": {
        "descr": "If buffer_text is enabled, the number of bytes stored in the buffer. These bytes represent UTF-8 encoded text. This attribute has no meaningful interpretation when buffer_text is false.", 
        "name": "xml.parsers.expat.xmlparser.buffer_used", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.buffer_used", 
        "syntax": "xmlparser.buffer_used", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.ordered_attributes": {
        "descr": "Setting this attribute to a non-zero integer causes the attributes to be reported as a list rather than a dictionary. The attributes are presented in the order found in the document text. For each attribute, two list entries are presented: the attribute name and the attribute value. (Older versions of this module also used this format.) By default, this attribute is false; it may be changed at any time.", 
        "name": "xml.parsers.expat.xmlparser.ordered_attributes", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.ordered_attributes", 
        "syntax": "xmlparser.ordered_attributes", 
        "type": "Structured Markup"
    }, 
    "xml.parsers.expat.xmlparser.specified_attributes": {
        "descr": "If set to a non-zero integer, the parser will report only those attributes which were specified in the document instance and not those which were derived from attribute declarations. Applications which set this need to be especially careful to use what additional information is available from the declarations as needed to comply with the standards for the behavior of XML processors. By default, this attribute is false; it may be changed at any time.", 
        "name": "xml.parsers.expat.xmlparser.specified_attributes", 
        "params": [], 
        "path": "python/library/pyexpat#xml.parsers.expat.xmlparser.specified_attributes", 
        "syntax": "xmlparser.specified_attributes", 
        "type": "Structured Markup"
    }, 
    "xml.sax.SAXException": {
        "descr": "Encapsulate an XML error or warning. This class can contain basic error or warning information from either the XML parser or the application: it can be subclassed to provide additional functionality or to add localization. Note that although the handlers defined in the ErrorHandler interface receive instances of this exception, it is not required to actually raise the exception \u2014 it is also useful as a container for information.", 
        "name": "xml.sax.SAXException", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.SAXException", 
        "syntax": "exception xml.sax.SAXException(msg, exception=None)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.SAXException.getException": {
        "descr": "Return an encapsulated exception object, or None.", 
        "name": "xml.sax.SAXException.getException", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.SAXException.getException", 
        "syntax": "SAXException.getException()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.SAXException.getMessage": {
        "descr": "Return a human-readable message describing the error condition.", 
        "name": "xml.sax.SAXException.getMessage", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.SAXException.getMessage", 
        "syntax": "SAXException.getMessage()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.SAXNotRecognizedException": {
        "descr": "Subclass of SAXException raised when a SAX XMLReader is confronted with an unrecognized feature or property. SAX applications and extensions may use this class for similar purposes.", 
        "name": "xml.sax.SAXNotRecognizedException", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.SAXNotRecognizedException", 
        "syntax": "exception xml.sax.SAXNotRecognizedException(msg, exception=None)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.SAXNotSupportedException": {
        "descr": "Subclass of SAXException raised when a SAX XMLReader is asked to enable a feature that is not supported, or to set a property to a value that the implementation does not support. SAX applications and extensions may use this class for similar purposes.", 
        "name": "xml.sax.SAXNotSupportedException", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.SAXNotSupportedException", 
        "syntax": "exception xml.sax.SAXNotSupportedException(msg, exception=None)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.SAXParseException": {
        "descr": "Subclass of SAXException raised on parse errors. Instances of this class are passed to the methods of the SAX ErrorHandler interface to provide information about the parse error. This class supports the SAX Locator interface as well as the SAXException interface.", 
        "name": "xml.sax.SAXParseException", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.SAXParseException", 
        "syntax": "exception xml.sax.SAXParseException(msg, exception, locator)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler": {
        "descr": "This is the main callback interface in SAX, and the one most important to applications. The order of events in this interface mirrors the order of the information in the document.", 
        "name": "xml.sax.handler.ContentHandler", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler", 
        "syntax": "class xml.sax.handler.ContentHandler", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.characters": {
        "descr": "Receive notification of character data.", 
        "name": "xml.sax.handler.ContentHandler.characters", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.characters", 
        "syntax": "ContentHandler.characters(content)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.endDocument": {
        "descr": "Receive notification of the end of a document.", 
        "name": "xml.sax.handler.ContentHandler.endDocument", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.endDocument", 
        "syntax": "ContentHandler.endDocument()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.endElement": {
        "descr": "Signals the end of an element in non-namespace mode.", 
        "name": "xml.sax.handler.ContentHandler.endElement", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.endElement", 
        "syntax": "ContentHandler.endElement(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.endElementNS": {
        "descr": "Signals the end of an element in namespace mode.", 
        "name": "xml.sax.handler.ContentHandler.endElementNS", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.endElementNS", 
        "syntax": "ContentHandler.endElementNS(name, qname)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.endPrefixMapping": {
        "descr": "End the scope of a prefix-URI mapping.", 
        "name": "xml.sax.handler.ContentHandler.endPrefixMapping", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.endPrefixMapping", 
        "syntax": "ContentHandler.endPrefixMapping(prefix)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.ignorableWhitespace": {
        "descr": "Receive notification of ignorable whitespace in element content.", 
        "name": "xml.sax.handler.ContentHandler.ignorableWhitespace", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.ignorableWhitespace", 
        "syntax": "ContentHandler.ignorableWhitespace(whitespace)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.processingInstruction": {
        "descr": "Receive notification of a processing instruction.", 
        "name": "xml.sax.handler.ContentHandler.processingInstruction", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.processingInstruction", 
        "syntax": "ContentHandler.processingInstruction(target, data)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.setDocumentLocator": {
        "descr": "Called by the parser to give the application a locator for locating the origin of document events.", 
        "name": "xml.sax.handler.ContentHandler.setDocumentLocator", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.setDocumentLocator", 
        "syntax": "ContentHandler.setDocumentLocator(locator)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.skippedEntity": {
        "descr": "Receive notification of a skipped entity.", 
        "name": "xml.sax.handler.ContentHandler.skippedEntity", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.skippedEntity", 
        "syntax": "ContentHandler.skippedEntity(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.startDocument": {
        "descr": "Receive notification of the beginning of a document.", 
        "name": "xml.sax.handler.ContentHandler.startDocument", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.startDocument", 
        "syntax": "ContentHandler.startDocument()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.startElement": {
        "descr": "Signals the start of an element in non-namespace mode.", 
        "name": "xml.sax.handler.ContentHandler.startElement", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.startElement", 
        "syntax": "ContentHandler.startElement(name, attrs)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.startElementNS": {
        "descr": "Signals the start of an element in namespace mode.", 
        "name": "xml.sax.handler.ContentHandler.startElementNS", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.startElementNS", 
        "syntax": "ContentHandler.startElementNS(name, qname, attrs)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ContentHandler.startPrefixMapping": {
        "descr": "Begin the scope of a prefix-URI Namespace mapping.", 
        "name": "xml.sax.handler.ContentHandler.startPrefixMapping", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ContentHandler.startPrefixMapping", 
        "syntax": "ContentHandler.startPrefixMapping(prefix, uri)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.DTDHandler": {
        "descr": "Handle DTD events.", 
        "name": "xml.sax.handler.DTDHandler", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.DTDHandler", 
        "syntax": "class xml.sax.handler.DTDHandler", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.DTDHandler.notationDecl": {
        "descr": "Handle a notation declaration event.", 
        "name": "xml.sax.handler.DTDHandler.notationDecl", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.DTDHandler.notationDecl", 
        "syntax": "DTDHandler.notationDecl(name, publicId, systemId)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.DTDHandler.unparsedEntityDecl": {
        "descr": "Handle an unparsed entity declaration event.", 
        "name": "xml.sax.handler.DTDHandler.unparsedEntityDecl", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.DTDHandler.unparsedEntityDecl", 
        "syntax": "DTDHandler.unparsedEntityDecl(name, publicId, systemId, ndata)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.EntityResolver": {
        "descr": "Basic interface for resolving entities. If you create an object implementing this interface, then register the object with your Parser, the parser will call the method in your object to resolve all external entities.", 
        "name": "xml.sax.handler.EntityResolver", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.EntityResolver", 
        "syntax": "class xml.sax.handler.EntityResolver", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.EntityResolver.resolveEntity": {
        "descr": "Resolve the system identifier of an entity and return either the system identifier to read from as a string, or an InputSource to read from. The default implementation returns systemId.", 
        "name": "xml.sax.handler.EntityResolver.resolveEntity", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.EntityResolver.resolveEntity", 
        "syntax": "EntityResolver.resolveEntity(publicId, systemId)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ErrorHandler": {
        "descr": "Interface used by the parser to present error and warning messages to the application. The methods of this object control whether errors are immediately converted to exceptions or are handled in some other way.", 
        "name": "xml.sax.handler.ErrorHandler", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ErrorHandler", 
        "syntax": "class xml.sax.handler.ErrorHandler", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ErrorHandler.error": {
        "descr": "Called when the parser encounters a recoverable error. If this method does not raise an exception, parsing may continue, but further document information should not be expected by the application. Allowing the parser to continue may allow additional errors to be discovered in the input document.", 
        "name": "xml.sax.handler.ErrorHandler.error", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ErrorHandler.error", 
        "syntax": "ErrorHandler.error(exception)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ErrorHandler.fatalError": {
        "descr": "Called when the parser encounters an error it cannot recover from; parsing is expected to terminate when this method returns.", 
        "name": "xml.sax.handler.ErrorHandler.fatalError", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ErrorHandler.fatalError", 
        "syntax": "ErrorHandler.fatalError(exception)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.ErrorHandler.warning": {
        "descr": "Called when the parser presents minor warning information to the application. Parsing is expected to continue when this method returns, and document information will continue to be passed to the application. Raising an exception in this method will cause parsing to end.", 
        "name": "xml.sax.handler.ErrorHandler.warning", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.ErrorHandler.warning", 
        "syntax": "ErrorHandler.warning(exception)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.all_features": {
        "descr": "List of all features.", 
        "name": "xml.sax.handler.all_features", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.all_features", 
        "syntax": "xml.sax.handler.all_features", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.all_properties": {
        "descr": "List of all known property names.", 
        "name": "xml.sax.handler.all_properties", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.all_properties", 
        "syntax": "xml.sax.handler.all_properties", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.feature_external_ges": {
        "descr": "", 
        "name": "xml.sax.handler.feature_external_ges", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.feature_external_ges", 
        "syntax": "xml.sax.handler.feature_external_ges", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.feature_external_pes": {
        "descr": "", 
        "name": "xml.sax.handler.feature_external_pes", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.feature_external_pes", 
        "syntax": "xml.sax.handler.feature_external_pes", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.feature_namespace_prefixes": {
        "descr": "", 
        "name": "xml.sax.handler.feature_namespace_prefixes", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.feature_namespace_prefixes", 
        "syntax": "xml.sax.handler.feature_namespace_prefixes", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.feature_namespaces": {
        "descr": "", 
        "name": "xml.sax.handler.feature_namespaces", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.feature_namespaces", 
        "syntax": "xml.sax.handler.feature_namespaces", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.feature_string_interning": {
        "descr": "", 
        "name": "xml.sax.handler.feature_string_interning", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.feature_string_interning", 
        "syntax": "xml.sax.handler.feature_string_interning", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.feature_validation": {
        "descr": "", 
        "name": "xml.sax.handler.feature_validation", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.feature_validation", 
        "syntax": "xml.sax.handler.feature_validation", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.property_declaration_handler": {
        "descr": "", 
        "name": "xml.sax.handler.property_declaration_handler", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.property_declaration_handler", 
        "syntax": "xml.sax.handler.property_declaration_handler", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.property_dom_node": {
        "descr": "", 
        "name": "xml.sax.handler.property_dom_node", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.property_dom_node", 
        "syntax": "xml.sax.handler.property_dom_node", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.property_lexical_handler": {
        "descr": "", 
        "name": "xml.sax.handler.property_lexical_handler", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.property_lexical_handler", 
        "syntax": "xml.sax.handler.property_lexical_handler", 
        "type": "Structured Markup"
    }, 
    "xml.sax.handler.property_xml_string": {
        "descr": "", 
        "name": "xml.sax.handler.property_xml_string", 
        "params": [], 
        "path": "python/library/xml.sax.handler#xml.sax.handler.property_xml_string", 
        "syntax": "xml.sax.handler.property_xml_string", 
        "type": "Structured Markup"
    }, 
    "xml.sax.make_parser": {
        "descr": "Create and return a SAX XMLReader object. The first parser found will be used. If parser_list is provided, it must be a sequence of strings which name modules that have a function named create_parser(). Modules listed in parser_list will be used before modules in the default list of parsers.", 
        "name": "xml.sax.make_parser", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.make_parser", 
        "syntax": "xml.sax.make_parser(parser_list=[])", 
        "type": "Structured Markup"
    }, 
    "xml.sax.parse": {
        "descr": "Create a SAX parser and use it to parse a document. The document, passed in as filename_or_stream, can be a filename or a file object. The handler parameter needs to be a SAX ContentHandler instance. If error_handler is given, it must be a SAX ErrorHandler instance; if omitted, SAXParseException will be raised on all errors. There is no return value; all work must be done by the handler passed in.", 
        "name": "xml.sax.parse", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.parse", 
        "syntax": "xml.sax.parse(filename_or_stream, handler, error_handler=handler.ErrorHandler())", 
        "type": "Structured Markup"
    }, 
    "xml.sax.parseString": {
        "descr": "Similar to parse(), but parses from a buffer string received as a parameter.", 
        "name": "xml.sax.parseString", 
        "params": [], 
        "path": "python/library/xml.sax#xml.sax.parseString", 
        "syntax": "xml.sax.parseString(string, handler, error_handler=handler.ErrorHandler())", 
        "type": "Structured Markup"
    }, 
    "xml.sax.saxutils.XMLFilterBase": {
        "descr": "This class is designed to sit between an XMLReader and the client application\u2019s event handlers. By default, it does nothing but pass requests up to the reader and events on to the handlers unmodified, but subclasses can override specific methods to modify the event stream or the configuration requests as they pass through.", 
        "name": "xml.sax.saxutils.XMLFilterBase", 
        "params": [], 
        "path": "python/library/xml.sax.utils#xml.sax.saxutils.XMLFilterBase", 
        "syntax": "class xml.sax.saxutils.XMLFilterBase(base)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.saxutils.XMLGenerator": {
        "descr": "This class implements the ContentHandler interface by writing SAX events back into an XML document. In other words, using an XMLGenerator as the content handler will reproduce the original document being parsed. out should be a file-like object which will default to sys.stdout. encoding is the encoding of the output stream which defaults to 'iso-8859-1'. short_empty_elements controls the formatting of elements that contain no content: if False (the default) they are emitted as a pair of start/end tags, if set to True they are emitted as a single self-closed tag.", 
        "name": "xml.sax.saxutils.XMLGenerator", 
        "params": [], 
        "path": "python/library/xml.sax.utils#xml.sax.saxutils.XMLGenerator", 
        "syntax": "class xml.sax.saxutils.XMLGenerator(out=None, encoding='iso-8859-1', short_empty_elements=False)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.saxutils.escape": {
        "descr": "Escape '&', '<', and '>' in a string of data.", 
        "name": "xml.sax.saxutils.escape", 
        "params": [], 
        "path": "python/library/xml.sax.utils#xml.sax.saxutils.escape", 
        "syntax": "xml.sax.saxutils.escape(data, entities={})", 
        "type": "Structured Markup"
    }, 
    "xml.sax.saxutils.prepare_input_source": {
        "descr": "This function takes an input source and an optional base URL and returns a fully resolved InputSource object ready for reading. The input source can be given as a string, a file-like object, or an InputSource object; parsers will use this function to implement the polymorphic source argument to their parse() method.", 
        "name": "xml.sax.saxutils.prepare_input_source", 
        "params": [], 
        "path": "python/library/xml.sax.utils#xml.sax.saxutils.prepare_input_source", 
        "syntax": "xml.sax.saxutils.prepare_input_source(source, base='')", 
        "type": "Structured Markup"
    }, 
    "xml.sax.saxutils.quoteattr": {
        "descr": "Similar to escape(), but also prepares data to be used as an attribute value. The return value is a quoted version of data with any additional required replacements. quoteattr() will select a quote character based on the content of data, attempting to avoid encoding any quote characters in the string. If both single- and double-quote characters are already in data, the double-quote characters will be encoded and data will be wrapped in double-quotes. The resulting string can be used directly as an attribute value:", 
        "name": "xml.sax.saxutils.quoteattr", 
        "params": [], 
        "path": "python/library/xml.sax.utils#xml.sax.saxutils.quoteattr", 
        "syntax": "xml.sax.saxutils.quoteattr(data, entities={})", 
        "type": "Structured Markup"
    }, 
    "xml.sax.saxutils.unescape": {
        "descr": "Unescape '&amp;', '<', and '>' in a string of data.", 
        "name": "xml.sax.saxutils.unescape", 
        "params": [], 
        "path": "python/library/xml.sax.utils#xml.sax.saxutils.unescape", 
        "syntax": "xml.sax.saxutils.unescape(data, entities={})", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Attributes.getLength": {
        "descr": "Return the number of attributes.", 
        "name": "xml.sax.xmlreader.Attributes.getLength", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Attributes.getLength", 
        "syntax": "Attributes.getLength()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Attributes.getNames": {
        "descr": "Return the names of the attributes.", 
        "name": "xml.sax.xmlreader.Attributes.getNames", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Attributes.getNames", 
        "syntax": "Attributes.getNames()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Attributes.getType": {
        "descr": "Returns the type of the attribute name, which is normally 'CDATA'.", 
        "name": "xml.sax.xmlreader.Attributes.getType", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Attributes.getType", 
        "syntax": "Attributes.getType(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Attributes.getValue": {
        "descr": "Return the value of attribute name.", 
        "name": "xml.sax.xmlreader.Attributes.getValue", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Attributes.getValue", 
        "syntax": "Attributes.getValue(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.AttributesImpl": {
        "descr": "This is an implementation of the Attributes interface (see section The Attributes Interface). This is a dictionary-like object which represents the element attributes in a startElement() call. In addition to the most useful dictionary operations, it supports a number of other methods as described by the interface. Objects of this class should be instantiated by readers; attrs must be a dictionary-like object containing a mapping from attribute names to attribute values.", 
        "name": "xml.sax.xmlreader.AttributesImpl", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.AttributesImpl", 
        "syntax": "class xml.sax.xmlreader.AttributesImpl(attrs)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.AttributesNS.getNameByQName": {
        "descr": "Return the (namespace, localname) pair for a qualified name.", 
        "name": "xml.sax.xmlreader.AttributesNS.getNameByQName", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getNameByQName", 
        "syntax": "AttributesNS.getNameByQName(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.AttributesNS.getQNameByName": {
        "descr": "Return the qualified name for a (namespace, localname) pair.", 
        "name": "xml.sax.xmlreader.AttributesNS.getQNameByName", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getQNameByName", 
        "syntax": "AttributesNS.getQNameByName(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.AttributesNS.getQNames": {
        "descr": "Return the qualified names of all attributes.", 
        "name": "xml.sax.xmlreader.AttributesNS.getQNames", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getQNames", 
        "syntax": "AttributesNS.getQNames()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.AttributesNS.getValueByQName": {
        "descr": "Return the value for a qualified name.", 
        "name": "xml.sax.xmlreader.AttributesNS.getValueByQName", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getValueByQName", 
        "syntax": "AttributesNS.getValueByQName(name)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.AttributesNSImpl": {
        "descr": "Namespace-aware variant of AttributesImpl, which will be passed to startElementNS(). It is derived from AttributesImpl, but understands attribute names as two-tuples of namespaceURI and localname. In addition, it provides a number of methods expecting qualified names as they appear in the original document. This class implements the AttributesNS interface (see section The AttributesNS Interface).", 
        "name": "xml.sax.xmlreader.AttributesNSImpl", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.AttributesNSImpl", 
        "syntax": "class xml.sax.xmlreader.AttributesNSImpl(attrs, qnames)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.IncrementalParser": {
        "descr": "In some cases, it is desirable not to parse an input source at once, but to feed chunks of the document as they get available. Note that the reader will normally not read the entire file, but read it in chunks as well; still parse() won\u2019t return until the entire document is processed. So these interfaces should be used if the blocking behaviour of parse() is not desirable.", 
        "name": "xml.sax.xmlreader.IncrementalParser", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser", 
        "syntax": "class xml.sax.xmlreader.IncrementalParser", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.IncrementalParser.close": {
        "descr": "Assume the end of the document. That will check well-formedness conditions that can be checked only at the end, invoke handlers, and may clean up resources allocated during parsing.", 
        "name": "xml.sax.xmlreader.IncrementalParser.close", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser.close", 
        "syntax": "IncrementalParser.close()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.IncrementalParser.feed": {
        "descr": "Process a chunk of data.", 
        "name": "xml.sax.xmlreader.IncrementalParser.feed", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser.feed", 
        "syntax": "IncrementalParser.feed(data)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.IncrementalParser.reset": {
        "descr": "This method is called after close has been called to reset the parser so that it is ready to parse new documents. The results of calling parse or feed after close without calling reset are undefined.", 
        "name": "xml.sax.xmlreader.IncrementalParser.reset", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser.reset", 
        "syntax": "IncrementalParser.reset()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource": {
        "descr": "Encapsulation of the information needed by the XMLReader to read entities.", 
        "name": "xml.sax.xmlreader.InputSource", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource", 
        "syntax": "class xml.sax.xmlreader.InputSource(system_id=None)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.getByteStream": {
        "descr": "Get the byte stream for this input source.", 
        "name": "xml.sax.xmlreader.InputSource.getByteStream", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.getByteStream", 
        "syntax": "InputSource.getByteStream()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.getCharacterStream": {
        "descr": "Get the character stream for this input source.", 
        "name": "xml.sax.xmlreader.InputSource.getCharacterStream", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.getCharacterStream", 
        "syntax": "InputSource.getCharacterStream()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.getEncoding": {
        "descr": "Get the character encoding of this InputSource.", 
        "name": "xml.sax.xmlreader.InputSource.getEncoding", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.getEncoding", 
        "syntax": "InputSource.getEncoding()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.getPublicId": {
        "descr": "Returns the public identifier of this InputSource.", 
        "name": "xml.sax.xmlreader.InputSource.getPublicId", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.getPublicId", 
        "syntax": "InputSource.getPublicId()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.getSystemId": {
        "descr": "Returns the system identifier of this InputSource.", 
        "name": "xml.sax.xmlreader.InputSource.getSystemId", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.getSystemId", 
        "syntax": "InputSource.getSystemId()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.setByteStream": {
        "descr": "Set the byte stream (a Python file-like object which does not perform byte-to-character conversion) for this input source.", 
        "name": "xml.sax.xmlreader.InputSource.setByteStream", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.setByteStream", 
        "syntax": "InputSource.setByteStream(bytefile)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.setCharacterStream": {
        "descr": "Set the character stream for this input source. (The stream must be a Python 1.6 Unicode-wrapped file-like that performs conversion to strings.)", 
        "name": "xml.sax.xmlreader.InputSource.setCharacterStream", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.setCharacterStream", 
        "syntax": "InputSource.setCharacterStream(charfile)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.setEncoding": {
        "descr": "Sets the character encoding of this InputSource.", 
        "name": "xml.sax.xmlreader.InputSource.setEncoding", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.setEncoding", 
        "syntax": "InputSource.setEncoding(encoding)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.setPublicId": {
        "descr": "Sets the public identifier of this InputSource.", 
        "name": "xml.sax.xmlreader.InputSource.setPublicId", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.setPublicId", 
        "syntax": "InputSource.setPublicId(id)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.InputSource.setSystemId": {
        "descr": "Sets the system identifier of this InputSource.", 
        "name": "xml.sax.xmlreader.InputSource.setSystemId", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.InputSource.setSystemId", 
        "syntax": "InputSource.setSystemId(id)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Locator": {
        "descr": "Interface for associating a SAX event with a document location. A locator object will return valid results only during calls to DocumentHandler methods; at any other time, the results are unpredictable. If information is not available, methods may return None.", 
        "name": "xml.sax.xmlreader.Locator", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Locator", 
        "syntax": "class xml.sax.xmlreader.Locator", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Locator.getColumnNumber": {
        "descr": "Return the column number where the current event ends.", 
        "name": "xml.sax.xmlreader.Locator.getColumnNumber", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Locator.getColumnNumber", 
        "syntax": "Locator.getColumnNumber()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Locator.getLineNumber": {
        "descr": "Return the line number where the current event ends.", 
        "name": "xml.sax.xmlreader.Locator.getLineNumber", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Locator.getLineNumber", 
        "syntax": "Locator.getLineNumber()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Locator.getPublicId": {
        "descr": "Return the public identifier for the current event.", 
        "name": "xml.sax.xmlreader.Locator.getPublicId", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Locator.getPublicId", 
        "syntax": "Locator.getPublicId()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.Locator.getSystemId": {
        "descr": "Return the system identifier for the current event.", 
        "name": "xml.sax.xmlreader.Locator.getSystemId", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.Locator.getSystemId", 
        "syntax": "Locator.getSystemId()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader": {
        "descr": "Base class which can be inherited by SAX parsers.", 
        "name": "xml.sax.xmlreader.XMLReader", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader", 
        "syntax": "class xml.sax.xmlreader.XMLReader", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.getContentHandler": {
        "descr": "Return the current ContentHandler.", 
        "name": "xml.sax.xmlreader.XMLReader.getContentHandler", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getContentHandler", 
        "syntax": "XMLReader.getContentHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.getDTDHandler": {
        "descr": "Return the current DTDHandler.", 
        "name": "xml.sax.xmlreader.XMLReader.getDTDHandler", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getDTDHandler", 
        "syntax": "XMLReader.getDTDHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.getEntityResolver": {
        "descr": "Return the current EntityResolver.", 
        "name": "xml.sax.xmlreader.XMLReader.getEntityResolver", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getEntityResolver", 
        "syntax": "XMLReader.getEntityResolver()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.getErrorHandler": {
        "descr": "Return the current ErrorHandler.", 
        "name": "xml.sax.xmlreader.XMLReader.getErrorHandler", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getErrorHandler", 
        "syntax": "XMLReader.getErrorHandler()", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.getFeature": {
        "descr": "Return the current setting for feature featurename. If the feature is not recognized, SAXNotRecognizedException is raised. The well-known featurenames are listed in the module xml.sax.handler.", 
        "name": "xml.sax.xmlreader.XMLReader.getFeature", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getFeature", 
        "syntax": "XMLReader.getFeature(featurename)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.getProperty": {
        "descr": "Return the current setting for property propertyname. If the property is not recognized, a SAXNotRecognizedException is raised. The well-known propertynames are listed in the module xml.sax.handler.", 
        "name": "xml.sax.xmlreader.XMLReader.getProperty", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getProperty", 
        "syntax": "XMLReader.getProperty(propertyname)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.parse": {
        "descr": "Process an input source, producing SAX events. The source object can be a system identifier (a string identifying the input source \u2013 typically a file name or an URL), a file-like object, or an InputSource object. When parse() returns, the input is completely processed, and the parser object can be discarded or reset. As a limitation, the current implementation only accepts byte streams; processing of character streams is for further study.", 
        "name": "xml.sax.xmlreader.XMLReader.parse", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.parse", 
        "syntax": "XMLReader.parse(source)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setContentHandler": {
        "descr": "Set the current ContentHandler. If no ContentHandler is set, content events will be discarded.", 
        "name": "xml.sax.xmlreader.XMLReader.setContentHandler", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setContentHandler", 
        "syntax": "XMLReader.setContentHandler(handler)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setDTDHandler": {
        "descr": "Set the current DTDHandler. If no DTDHandler is set, DTD events will be discarded.", 
        "name": "xml.sax.xmlreader.XMLReader.setDTDHandler", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setDTDHandler", 
        "syntax": "XMLReader.setDTDHandler(handler)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setEntityResolver": {
        "descr": "Set the current EntityResolver. If no EntityResolver is set, attempts to resolve an external entity will result in opening the system identifier for the entity, and fail if it is not available.", 
        "name": "xml.sax.xmlreader.XMLReader.setEntityResolver", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setEntityResolver", 
        "syntax": "XMLReader.setEntityResolver(handler)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setErrorHandler": {
        "descr": "Set the current error handler. If no ErrorHandler is set, errors will be raised as exceptions, and warnings will be printed.", 
        "name": "xml.sax.xmlreader.XMLReader.setErrorHandler", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setErrorHandler", 
        "syntax": "XMLReader.setErrorHandler(handler)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setFeature": {
        "descr": "Set the featurename to value. If the feature is not recognized, SAXNotRecognizedException is raised. If the feature or its setting is not supported by the parser, SAXNotSupportedException is raised.", 
        "name": "xml.sax.xmlreader.XMLReader.setFeature", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setFeature", 
        "syntax": "XMLReader.setFeature(featurename, value)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setLocale": {
        "descr": "Allow an application to set the locale for errors and warnings.", 
        "name": "xml.sax.xmlreader.XMLReader.setLocale", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setLocale", 
        "syntax": "XMLReader.setLocale(locale)", 
        "type": "Structured Markup"
    }, 
    "xml.sax.xmlreader.XMLReader.setProperty": {
        "descr": "Set the propertyname to value. If the property is not recognized, SAXNotRecognizedException is raised. If the property or its setting is not supported by the parser, SAXNotSupportedException is raised.", 
        "name": "xml.sax.xmlreader.XMLReader.setProperty", 
        "params": [], 
        "path": "python/library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setProperty", 
        "syntax": "XMLReader.setProperty(propertyname, value)", 
        "type": "Structured Markup"
    }, 
    "xmlrpc.client.Binary.data": {
        "descr": "The binary data encapsulated by the Binary instance. The data is provided as a bytes object.", 
        "name": "xmlrpc.client.Binary.data", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.Binary.data", 
        "syntax": "Binary.data", 
        "type": "Internet"
    }, 
    "xmlrpc.client.Binary.decode": {
        "descr": "Accept a base64 bytes object and decode it as the instance\u2019s new data.", 
        "name": "xmlrpc.client.Binary.decode", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.Binary.decode", 
        "syntax": "Binary.decode(bytes)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.Binary.encode": {
        "descr": "Write the XML-RPC base 64 encoding of this binary item to the out stream object.", 
        "name": "xmlrpc.client.Binary.encode", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.Binary.encode", 
        "syntax": "Binary.encode(out)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.DateTime.decode": {
        "descr": "Accept a string as the instance\u2019s new time value.", 
        "name": "xmlrpc.client.DateTime.decode", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.DateTime.decode", 
        "syntax": "DateTime.decode(string)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.DateTime.encode": {
        "descr": "Write the XML-RPC encoding of this DateTime item to the out stream object.", 
        "name": "xmlrpc.client.DateTime.encode", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.DateTime.encode", 
        "syntax": "DateTime.encode(out)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.Fault.faultCode": {
        "descr": "A string indicating the fault type.", 
        "name": "xmlrpc.client.Fault.faultCode", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.Fault.faultCode", 
        "syntax": "Fault.faultCode", 
        "type": "Internet"
    }, 
    "xmlrpc.client.Fault.faultString": {
        "descr": "A string containing a diagnostic message associated with the fault.", 
        "name": "xmlrpc.client.Fault.faultString", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.Fault.faultString", 
        "syntax": "Fault.faultString", 
        "type": "Internet"
    }, 
    "xmlrpc.client.MultiCall": {
        "descr": "Create an object used to boxcar method calls. server is the eventual target of the call. Calls can be made to the result object, but they will immediately return None, and only store the call name and parameters in the MultiCall object. Calling the object itself causes all stored calls to be transmitted as a single system.multicall request. The result of this call is a generator; iterating over this generator yields the individual results.", 
        "name": "xmlrpc.client.MultiCall", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.MultiCall", 
        "syntax": "class xmlrpc.client.MultiCall(server)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ProtocolError.errcode": {
        "descr": "The error code.", 
        "name": "xmlrpc.client.ProtocolError.errcode", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ProtocolError.errcode", 
        "syntax": "ProtocolError.errcode", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ProtocolError.errmsg": {
        "descr": "The error message or diagnostic string.", 
        "name": "xmlrpc.client.ProtocolError.errmsg", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ProtocolError.errmsg", 
        "syntax": "ProtocolError.errmsg", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ProtocolError.headers": {
        "descr": "A dict containing the headers of the HTTP/HTTPS request that triggered the error.", 
        "name": "xmlrpc.client.ProtocolError.headers", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ProtocolError.headers", 
        "syntax": "ProtocolError.headers", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ProtocolError.url": {
        "descr": "The URI or URL that triggered the error.", 
        "name": "xmlrpc.client.ProtocolError.url", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ProtocolError.url", 
        "syntax": "ProtocolError.url", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ServerProxy": {
        "descr": "Changed in version 3.3: The use_builtin_types flag was added.", 
        "name": "xmlrpc.client.ServerProxy", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ServerProxy", 
        "syntax": "class xmlrpc.client.ServerProxy(uri, transport=None, encoding=None, verbose=False, allow_none=False, use_datetime=False, use_builtin_types=False)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ServerProxy.system.listMethods": {
        "descr": "This method returns a list of strings, one for each (non-system) method supported by the XML-RPC server.", 
        "name": "xmlrpc.client.ServerProxy.system.listMethods", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ServerProxy.system.listMethods", 
        "syntax": "ServerProxy.system.listMethods()", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ServerProxy.system.methodHelp": {
        "descr": "This method takes one parameter, the name of a method implemented by the XML-RPC server. It returns a documentation string describing the use of that method. If no such string is available, an empty string is returned. The documentation string may contain HTML markup.", 
        "name": "xmlrpc.client.ServerProxy.system.methodHelp", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ServerProxy.system.methodHelp", 
        "syntax": "ServerProxy.system.methodHelp(name)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.ServerProxy.system.methodSignature": {
        "descr": "This method takes one parameter, the name of a method implemented by the XML-RPC server. It returns an array of possible signatures for this method. A signature is an array of types. The first of these types is the return type of the method, the rest are parameters.", 
        "name": "xmlrpc.client.ServerProxy.system.methodSignature", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.ServerProxy.system.methodSignature", 
        "syntax": "ServerProxy.system.methodSignature(name)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.dumps": {
        "descr": "Convert params into an XML-RPC request. or into a response if methodresponse is true. params can be either a tuple of arguments or an instance of the Fault exception class. If methodresponse is true, only a single value can be returned, meaning that params must be of length 1. encoding, if supplied, is the encoding to use in the generated XML; the default is UTF-8. Python\u2019s None value cannot be used in standard XML-RPC; to allow using it via an extension, provide a true value for allow_none.", 
        "name": "xmlrpc.client.dumps", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.dumps", 
        "syntax": "xmlrpc.client.dumps(params, methodname=None, methodresponse=None, encoding=None, allow_none=False)", 
        "type": "Internet"
    }, 
    "xmlrpc.client.loads": {
        "descr": "Convert an XML-RPC request or response into Python objects, a (params, methodname). params is a tuple of argument; methodname is a string, or None if no method name is present in the packet. If the XML-RPC packet represents a fault condition, this function will raise a Fault exception. The use_builtin_types flag can be used to cause date/time values to be presented as datetime.datetime objects and binary data to be presented as bytes objects; this flag is false by default.", 
        "name": "xmlrpc.client.loads", 
        "params": [], 
        "path": "python/library/xmlrpc.client#xmlrpc.client.loads", 
        "syntax": "xmlrpc.client.loads(data, use_datetime=False, use_builtin_types=False)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.CGIXMLRPCRequestHandler": {
        "descr": "Create a new instance to handle XML-RPC requests in a CGI environment. The allow_none and encoding parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server. The use_builtin_types parameter is passed to the loads() function and controls which types are processed when date/times values or binary data are received; it defaults to false.", 
        "name": "xmlrpc.server.CGIXMLRPCRequestHandler", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler", 
        "syntax": "class xmlrpc.server.CGIXMLRPCRequestHandler(allow_none=False, encoding=None, use_builtin_types=False)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.CGIXMLRPCRequestHandler.handle_request": {
        "descr": "Handle a XML-RPC request. If request_text is given, it should be the POST data provided by the HTTP server, otherwise the contents of stdin will be used.", 
        "name": "xmlrpc.server.CGIXMLRPCRequestHandler.handle_request", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.handle_request", 
        "syntax": "CGIXMLRPCRequestHandler.handle_request(request_text=None)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.CGIXMLRPCRequestHandler.register_function": {
        "descr": "Register a function that can respond to XML-RPC requests. If name is given, it will be the method name associated with function, otherwise function.__name__ will be used. name can be either a normal or Unicode string, and may contain characters not legal in Python identifiers, including the period character.", 
        "name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_function", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_function", 
        "syntax": "CGIXMLRPCRequestHandler.register_function(function, name=None)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.CGIXMLRPCRequestHandler.register_instance": {
        "descr": "Register an object which is used to expose method names which have not been registered using register_function(). If instance contains a _dispatch() method, it is called with the requested method name and the parameters from the request; the return value is returned to the client as the result. If instance does not have a _dispatch() method, it is searched for an attribute matching the name of the requested method; if the requested method name contains periods, each component of the method name is searched for individually, with the effect that a simple hierarchical search is performed. The value found from this search is then called with the parameters from the request, and the return value is passed back to the client.", 
        "name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_instance", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_instance", 
        "syntax": "CGIXMLRPCRequestHandler.register_instance(instance)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.CGIXMLRPCRequestHandler.register_introspection_functions": {
        "descr": "Register the XML-RPC introspection functions system.listMethods, system.methodHelp and system.methodSignature.", 
        "name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_introspection_functions", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_introspection_functions", 
        "syntax": "CGIXMLRPCRequestHandler.register_introspection_functions()", 
        "type": "Internet"
    }, 
    "xmlrpc.server.CGIXMLRPCRequestHandler.register_multicall_functions": {
        "descr": "Register the XML-RPC multicall function system.multicall.", 
        "name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_multicall_functions", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_multicall_functions", 
        "syntax": "CGIXMLRPCRequestHandler.register_multicall_functions()", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocCGIXMLRPCRequestHandler": {
        "descr": "Create a new instance to handle XML-RPC requests in a CGI environment.", 
        "name": "xmlrpc.server.DocCGIXMLRPCRequestHandler", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler", 
        "syntax": "class xmlrpc.server.DocCGIXMLRPCRequestHandler", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_documentation": {
        "descr": "Set the description used in the generated HTML documentation. This description will appear as a paragraph, below the server name, in the documentation.", 
        "name": "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_documentation", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_documentation", 
        "syntax": "DocCGIXMLRPCRequestHandler.set_server_documentation(server_documentation)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_name": {
        "descr": "Set the name used in the generated HTML documentation. This name will appear at the top of the generated documentation inside a \u201ch1\u201d element.", 
        "name": "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_name", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_name", 
        "syntax": "DocCGIXMLRPCRequestHandler.set_server_name(server_name)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_title": {
        "descr": "Set the title used in the generated HTML documentation. This title will be used inside the HTML \u201ctitle\u201d element.", 
        "name": "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_title", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_title", 
        "syntax": "DocCGIXMLRPCRequestHandler.set_server_title(server_title)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocXMLRPCRequestHandler": {
        "descr": "Create a new request handler instance. This request handler supports XML-RPC POST requests, documentation GET requests, and modifies logging so that the logRequests parameter to the DocXMLRPCServer constructor parameter is honored.", 
        "name": "xmlrpc.server.DocXMLRPCRequestHandler", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocXMLRPCRequestHandler", 
        "syntax": "class xmlrpc.server.DocXMLRPCRequestHandler", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocXMLRPCServer": {
        "descr": "Create a new server instance. All parameters have the same meaning as for SimpleXMLRPCServer; requestHandler defaults to DocXMLRPCRequestHandler.", 
        "name": "xmlrpc.server.DocXMLRPCServer", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer", 
        "syntax": "class xmlrpc.server.DocXMLRPCServer(addr, requestHandler=DocXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=True)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocXMLRPCServer.set_server_documentation": {
        "descr": "Set the description used in the generated HTML documentation. This description will appear as a paragraph, below the server name, in the documentation.", 
        "name": "xmlrpc.server.DocXMLRPCServer.set_server_documentation", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer.set_server_documentation", 
        "syntax": "DocXMLRPCServer.set_server_documentation(server_documentation)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocXMLRPCServer.set_server_name": {
        "descr": "Set the name used in the generated HTML documentation. This name will appear at the top of the generated documentation inside a \u201ch1\u201d element.", 
        "name": "xmlrpc.server.DocXMLRPCServer.set_server_name", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer.set_server_name", 
        "syntax": "DocXMLRPCServer.set_server_name(server_name)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.DocXMLRPCServer.set_server_title": {
        "descr": "Set the title used in the generated HTML documentation. This title will be used inside the HTML \u201ctitle\u201d element.", 
        "name": "xmlrpc.server.DocXMLRPCServer.set_server_title", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer.set_server_title", 
        "syntax": "DocXMLRPCServer.set_server_title(server_title)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCRequestHandler": {
        "descr": "Create a new request handler instance. This request handler supports POST requests and modifies logging so that the logRequests parameter to the SimpleXMLRPCServer constructor parameter is honored.", 
        "name": "xmlrpc.server.SimpleXMLRPCRequestHandler", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCRequestHandler", 
        "syntax": "class xmlrpc.server.SimpleXMLRPCRequestHandler", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCRequestHandler.rpc_paths": {
        "descr": "An attribute value that must be a tuple listing valid path portions of the URL for receiving XML-RPC requests. Requests posted to other paths will result in a 404 \u201cno such page\u201d HTTP error. If this tuple is empty, all paths will be considered valid. The default value is ('/', '/RPC2').", 
        "name": "xmlrpc.server.SimpleXMLRPCRequestHandler.rpc_paths", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCRequestHandler.rpc_paths", 
        "syntax": "SimpleXMLRPCRequestHandler.rpc_paths", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCServer": {
        "descr": "Create a new server instance. This class provides methods for registration of functions that can be called by the XML-RPC protocol. The requestHandler parameter should be a factory for request handler instances; it defaults to SimpleXMLRPCRequestHandler. The addr and requestHandler parameters are passed to the socketserver.TCPServer constructor. If logRequests is true (the default), requests will be logged; setting this parameter to false will turn off logging. The allow_none and encoding parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server. The bind_and_activate parameter controls whether server_bind() and server_activate() are called immediately by the constructor; it defaults to true. Setting it to false allows code to manipulate the allow_reuse_address class variable before the address is bound. The use_builtin_types parameter is passed to the loads() function and controls which types are processed when date/times values or binary data are received; it defaults to false.", 
        "name": "xmlrpc.server.SimpleXMLRPCServer", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer", 
        "syntax": "class xmlrpc.server.SimpleXMLRPCServer(addr, requestHandler=SimpleXMLRPCRequestHandler, logRequests=True, allow_none=False, encoding=None, bind_and_activate=True, use_builtin_types=False)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCServer.register_function": {
        "descr": "Register a function that can respond to XML-RPC requests. If name is given, it will be the method name associated with function, otherwise function.__name__ will be used. name can be either a normal or Unicode string, and may contain characters not legal in Python identifiers, including the period character.", 
        "name": "xmlrpc.server.SimpleXMLRPCServer.register_function", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_function", 
        "syntax": "SimpleXMLRPCServer.register_function(function, name=None)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCServer.register_instance": {
        "descr": "Register an object which is used to expose method names which have not been registered using register_function(). If instance contains a _dispatch() method, it is called with the requested method name and the parameters from the request. Its API is def _dispatch(self, method, params) (note that params does not represent a variable argument list). If it calls an underlying function to perform its task, that function is called as func(*params), expanding the parameter list. The return value from _dispatch() is returned to the client as the result. If instance does not have a _dispatch() method, it is searched for an attribute matching the name of the requested method.", 
        "name": "xmlrpc.server.SimpleXMLRPCServer.register_instance", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_instance", 
        "syntax": "SimpleXMLRPCServer.register_instance(instance, allow_dotted_names=False)", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCServer.register_introspection_functions": {
        "descr": "Registers the XML-RPC introspection functions system.listMethods, system.methodHelp and system.methodSignature.", 
        "name": "xmlrpc.server.SimpleXMLRPCServer.register_introspection_functions", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_introspection_functions", 
        "syntax": "SimpleXMLRPCServer.register_introspection_functions()", 
        "type": "Internet"
    }, 
    "xmlrpc.server.SimpleXMLRPCServer.register_multicall_functions": {
        "descr": "Registers the XML-RPC multicall function system.multicall.", 
        "name": "xmlrpc.server.SimpleXMLRPCServer.register_multicall_functions", 
        "params": [], 
        "path": "python/library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_multicall_functions", 
        "syntax": "SimpleXMLRPCServer.register_multicall_functions()", 
        "type": "Internet"
    }, 
    "zfill": {
        "descr": "Return the numeric string left filled with zeros in a string of length width. A sign prefix is handled correctly. The original string is returned if width is less than or equal to len(s).", 
        "name": "str.zfill", 
        "params": [], 
        "path": "python/library/stdtypes#str.zfill", 
        "syntax": "str.zfill(width)", 
        "type": "Built-in Types"
    }, 
    "zip": {
        "descr": "Make an iterator that aggregates elements from each of the iterables.", 
        "name": "zip", 
        "params": [], 
        "path": "python/library/functions#zip", 
        "syntax": "zip(*iterables)", 
        "type": "Built-in Functions"
    }, 
    "zipfile.BadZipFile": {
        "descr": "The error raised for bad ZIP files.", 
        "name": "zipfile.BadZipFile", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.BadZipFile", 
        "syntax": "exception zipfile.BadZipFile", 
        "type": "Data Compression"
    }, 
    "zipfile.BadZipfile": {
        "descr": "Alias of BadZipFile, for compatibility with older Python versions.", 
        "name": "zipfile.BadZipfile", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.BadZipfile", 
        "syntax": "exception zipfile.BadZipfile", 
        "type": "Data Compression"
    }, 
    "zipfile.LargeZipFile": {
        "descr": "The error raised when a ZIP file would require ZIP64 functionality but that has not been enabled.", 
        "name": "zipfile.LargeZipFile", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.LargeZipFile", 
        "syntax": "exception zipfile.LargeZipFile", 
        "type": "Data Compression"
    }, 
    "zipfile.PyZipFile": {
        "descr": "New in version 3.2: The optimize parameter.", 
        "name": "zipfile.PyZipFile", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.PyZipFile", 
        "syntax": "class zipfile.PyZipFile(file, mode='r', compression=ZIP_STORED, allowZip64=False, optimize=-1)", 
        "type": "Data Compression"
    }, 
    "zipfile.PyZipFile.writepy": {
        "descr": "Search for files *.py and add the corresponding file to the archive.", 
        "name": "zipfile.PyZipFile.writepy", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.PyZipFile.writepy", 
        "syntax": "writepy(pathname, basename='')", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile": {
        "descr": "Open a ZIP file, where file can be either a path to a file (a string) or a file-like object. The mode parameter should be 'r' to read an existing file, 'w' to truncate and write a new file, or 'a' to append to an existing file. If mode is 'a' and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as python.exe). If mode is a and the file does not exist at all, it is created. compression is the ZIP compression method to use when writing the archive, and should be ZIP_STORED, ZIP_DEFLATED, ZIP_BZIP2 or ZIP_LZMA; unrecognized values will cause RuntimeError to be raised. If ZIP_DEFLATED, ZIP_BZIP2 or ZIP_LZMA is specified but the corresponded module (zlib, bz2 or lzma) is not available, RuntimeError is also raised. The default is ZIP_STORED. If allowZip64 is True zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 2 GiB. If it is false (the default) zipfile will raise an exception when the ZIP file would require ZIP64 extensions. ZIP64 extensions are disabled by default because the default zip and unzip commands on Unix (the InfoZIP utilities) don\u2019t support these extensions.", 
        "name": "zipfile.ZipFile", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile", 
        "syntax": "class zipfile.ZipFile(file, mode='r', compression=ZIP_STORED, allowZip64=False)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.close": {
        "descr": "Close the archive file. You must call close() before exiting your program or essential records will not be written.", 
        "name": "zipfile.ZipFile.close", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.close", 
        "syntax": "ZipFile.close()", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.comment": {
        "descr": "The comment text associated with the ZIP file. If assigning a comment to a ZipFile instance created with mode \u2018a\u2019 or \u2018w\u2019, this should be a string no longer than 65535 bytes. Comments longer than this will be truncated in the written archive when close() is called.", 
        "name": "zipfile.ZipFile.comment", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.comment", 
        "syntax": "ZipFile.comment", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.debug": {
        "descr": "The level of debug output to use. This may be set from 0 (the default, no output) to 3 (the most output). Debugging information is written to sys.stdout.", 
        "name": "zipfile.ZipFile.debug", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.debug", 
        "syntax": "ZipFile.debug", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.extract": {
        "descr": "Extract a member from the archive to the current working directory; member must be its full name or a ZipInfo object). Its file information is extracted as accurately as possible. path specifies a different directory to extract to. member can be a filename or a ZipInfo object. pwd is the password used for encrypted files.", 
        "name": "zipfile.ZipFile.extract", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.extract", 
        "syntax": "ZipFile.extract(member, path=None, pwd=None)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.extractall": {
        "descr": "Extract all members from the archive to the current working directory. path specifies a different directory to extract to. members is optional and must be a subset of the list returned by namelist(). pwd is the password used for encrypted files.", 
        "name": "zipfile.ZipFile.extractall", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.extractall", 
        "syntax": "ZipFile.extractall(path=None, members=None, pwd=None)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.getinfo": {
        "descr": "Return a ZipInfo object with information about the archive member name. Calling getinfo() for a name not currently contained in the archive will raise a KeyError.", 
        "name": "zipfile.ZipFile.getinfo", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.getinfo", 
        "syntax": "ZipFile.getinfo(name)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.infolist": {
        "descr": "Return a list containing a ZipInfo object for each member of the archive. The objects are in the same order as their entries in the actual ZIP file on disk if an existing archive was opened.", 
        "name": "zipfile.ZipFile.infolist", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.infolist", 
        "syntax": "ZipFile.infolist()", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.namelist": {
        "descr": "Return a list of archive members by name.", 
        "name": "zipfile.ZipFile.namelist", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.namelist", 
        "syntax": "ZipFile.namelist()", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.open": {
        "descr": "Extract a member from the archive as a file-like object (ZipExtFile). name is the name of the file in the archive, or a ZipInfo object. The mode parameter, if included, must be one of the following: 'r' (the default), 'U', or 'rU'. Choosing 'U' or 'rU' will enable universal newlines support in the read-only object. pwd is the password used for encrypted files. Calling open() on a closed ZipFile will raise a RuntimeError.", 
        "name": "zipfile.ZipFile.open", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.open", 
        "syntax": "ZipFile.open(name, mode='r', pwd=None)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.printdir": {
        "descr": "Print a table of contents for the archive to sys.stdout.", 
        "name": "zipfile.ZipFile.printdir", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.printdir", 
        "syntax": "ZipFile.printdir()", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.read": {
        "descr": "Return the bytes of the file name in the archive. name is the name of the file in the archive, or a ZipInfo object. The archive must be open for read or append. pwd is the password used for encrypted files and, if specified, it will override the default password set with setpassword(). Calling read() on a closed ZipFile will raise a RuntimeError.", 
        "name": "zipfile.ZipFile.read", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.read", 
        "syntax": "ZipFile.read(name, pwd=None)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.setpassword": {
        "descr": "Set pwd as default password to extract encrypted files.", 
        "name": "zipfile.ZipFile.setpassword", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.setpassword", 
        "syntax": "ZipFile.setpassword(pwd)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.testzip": {
        "descr": "Read all the files in the archive and check their CRC\u2019s and file headers. Return the name of the first bad file, or else return None. Calling testzip() on a closed ZipFile will raise a RuntimeError.", 
        "name": "zipfile.ZipFile.testzip", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.testzip", 
        "syntax": "ZipFile.testzip()", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.write": {
        "descr": "Write the file named filename to the archive, giving it the archive name arcname (by default, this will be the same as filename, but without a drive letter and with leading path separators removed). If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry. The archive must be open with mode 'w' or 'a' \u2013 calling write() on a ZipFile created with mode 'r' will raise a RuntimeError. Calling write() on a closed ZipFile will raise a RuntimeError.", 
        "name": "zipfile.ZipFile.write", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.write", 
        "syntax": "ZipFile.write(filename, arcname=None, compress_type=None)", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipFile.writestr": {
        "descr": "Write the string bytes to the archive; zinfo_or_arcname is either the file name it will be given in the archive, or a ZipInfo instance. If it\u2019s an instance, at least the filename, date, and time must be given. If it\u2019s a name, the date and time is set to the current date and time. The archive must be opened with mode 'w' or 'a' \u2013 calling writestr() on a ZipFile created with mode 'r' will raise a RuntimeError. Calling writestr() on a closed ZipFile will raise a RuntimeError.", 
        "name": "zipfile.ZipFile.writestr", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipFile.writestr", 
        "syntax": "ZipFile.writestr(zinfo_or_arcname, bytes[, compress_type])", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo": {
        "descr": "Class used to represent information about a member of an archive. Instances of this class are returned by the getinfo() and infolist() methods of ZipFile objects. Most users of the zipfile module will not need to create these, but only use those created by this module. filename should be the full name of the archive member, and date_time should be a tuple containing six fields which describe the time of the last modification to the file; the fields are described in section ZipInfo Objects.", 
        "name": "zipfile.ZipInfo", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo", 
        "syntax": "class zipfile.ZipInfo(filename='NoName', date_time=(1980, 1, 1, 0, 0, 0))", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.CRC": {
        "descr": "CRC-32 of the uncompressed file.", 
        "name": "zipfile.ZipInfo.CRC", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.CRC", 
        "syntax": "ZipInfo.CRC", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.comment": {
        "descr": "Comment for the individual archive member.", 
        "name": "zipfile.ZipInfo.comment", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.comment", 
        "syntax": "ZipInfo.comment", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.compress_size": {
        "descr": "Size of the compressed data.", 
        "name": "zipfile.ZipInfo.compress_size", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.compress_size", 
        "syntax": "ZipInfo.compress_size", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.compress_type": {
        "descr": "Type of compression for the archive member.", 
        "name": "zipfile.ZipInfo.compress_type", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.compress_type", 
        "syntax": "ZipInfo.compress_type", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.create_system": {
        "descr": "System which created ZIP archive.", 
        "name": "zipfile.ZipInfo.create_system", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.create_system", 
        "syntax": "ZipInfo.create_system", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.create_version": {
        "descr": "PKZIP version which created ZIP archive.", 
        "name": "zipfile.ZipInfo.create_version", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.create_version", 
        "syntax": "ZipInfo.create_version", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.date_time": {
        "descr": "The time and date of the last modification to the archive member. This is a tuple of six values:", 
        "name": "zipfile.ZipInfo.date_time", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.date_time", 
        "syntax": "ZipInfo.date_time", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.external_attr": {
        "descr": "External file attributes.", 
        "name": "zipfile.ZipInfo.external_attr", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.external_attr", 
        "syntax": "ZipInfo.external_attr", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.extra": {
        "descr": "Expansion field data. The PKZIP Application Note contains some comments on the internal structure of the data contained in this string.", 
        "name": "zipfile.ZipInfo.extra", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.extra", 
        "syntax": "ZipInfo.extra", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.extract_version": {
        "descr": "PKZIP version needed to extract archive.", 
        "name": "zipfile.ZipInfo.extract_version", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.extract_version", 
        "syntax": "ZipInfo.extract_version", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.file_size": {
        "descr": "Size of the uncompressed file.", 
        "name": "zipfile.ZipInfo.file_size", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.file_size", 
        "syntax": "ZipInfo.file_size", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.filename": {
        "descr": "Name of the file in the archive.", 
        "name": "zipfile.ZipInfo.filename", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.filename", 
        "syntax": "ZipInfo.filename", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.flag_bits": {
        "descr": "ZIP flag bits.", 
        "name": "zipfile.ZipInfo.flag_bits", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.flag_bits", 
        "syntax": "ZipInfo.flag_bits", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.header_offset": {
        "descr": "Byte offset to the file header.", 
        "name": "zipfile.ZipInfo.header_offset", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.header_offset", 
        "syntax": "ZipInfo.header_offset", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.internal_attr": {
        "descr": "Internal attributes.", 
        "name": "zipfile.ZipInfo.internal_attr", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.internal_attr", 
        "syntax": "ZipInfo.internal_attr", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.reserved": {
        "descr": "Must be zero.", 
        "name": "zipfile.ZipInfo.reserved", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.reserved", 
        "syntax": "ZipInfo.reserved", 
        "type": "Data Compression"
    }, 
    "zipfile.ZipInfo.volume": {
        "descr": "Volume number of file header.", 
        "name": "zipfile.ZipInfo.volume", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.ZipInfo.volume", 
        "syntax": "ZipInfo.volume", 
        "type": "Data Compression"
    }, 
    "zipfile.is_zipfile": {
        "descr": "Returns True if filename is a valid ZIP file based on its magic number, otherwise returns False. filename may be a file or file-like object too.", 
        "name": "zipfile.is_zipfile", 
        "params": [], 
        "path": "python/library/zipfile#zipfile.is_zipfile", 
        "syntax": "zipfile.is_zipfile(filename)", 
        "type": "Data Compression"
    }, 
    "zipimport.ZipImportError": {
        "descr": "Exception raised by zipimporter objects. It\u2019s a subclass of ImportError, so it can be caught as ImportError, too.", 
        "name": "zipimport.ZipImportError", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.ZipImportError", 
        "syntax": "exception zipimport.ZipImportError", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter": {
        "descr": "Create a new zipimporter instance. archivepath must be a path to a ZIP file, or to a specific path within a ZIP file. For example, an archivepath of foo/bar.zip/lib will look for modules in the lib directory inside the ZIP file foo/bar.zip (provided that it exists).", 
        "name": "zipimport.zipimporter", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter", 
        "syntax": "class zipimport.zipimporter(archivepath)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.archive": {
        "descr": "The file name of the importer\u2019s associated ZIP file, without a possible subpath.", 
        "name": "zipimport.zipimporter.archive", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.archive", 
        "syntax": "archive", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.find_module": {
        "descr": "Search for a module specified by fullname. fullname must be the fully qualified (dotted) module name. It returns the zipimporter instance itself if the module was found, or None if it wasn\u2019t. The optional path argument is ignored\u2014it\u2019s there for compatibility with the importer protocol.", 
        "name": "zipimport.zipimporter.find_module", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.find_module", 
        "syntax": "find_module(fullname[, path])", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.get_code": {
        "descr": "Return the code object for the specified module. Raise ZipImportError if the module couldn\u2019t be found.", 
        "name": "zipimport.zipimporter.get_code", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.get_code", 
        "syntax": "get_code(fullname)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.get_data": {
        "descr": "Return the data associated with pathname. Raise OSError if the file wasn\u2019t found.", 
        "name": "zipimport.zipimporter.get_data", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.get_data", 
        "syntax": "get_data(pathname)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.get_filename": {
        "descr": "Return the value __file__ would be set to if the specified module was imported. Raise ZipImportError if the module couldn\u2019t be found.", 
        "name": "zipimport.zipimporter.get_filename", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.get_filename", 
        "syntax": "get_filename(fullname)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.get_source": {
        "descr": "Return the source code for the specified module. Raise ZipImportError if the module couldn\u2019t be found, return None if the archive does contain the module, but has no source for it.", 
        "name": "zipimport.zipimporter.get_source", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.get_source", 
        "syntax": "get_source(fullname)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.is_package": {
        "descr": "Return True if the module specified by fullname is a package. Raise ZipImportError if the module couldn\u2019t be found.", 
        "name": "zipimport.zipimporter.is_package", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.is_package", 
        "syntax": "is_package(fullname)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.load_module": {
        "descr": "Load the module specified by fullname. fullname must be the fully qualified (dotted) module name. It returns the imported module, or raises ZipImportError if it wasn\u2019t found.", 
        "name": "zipimport.zipimporter.load_module", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.load_module", 
        "syntax": "load_module(fullname)", 
        "type": "Importing"
    }, 
    "zipimport.zipimporter.prefix": {
        "descr": "The subpath within the ZIP file where modules are searched. This is the empty string for zipimporter objects which point to the root of the ZIP file.", 
        "name": "zipimport.zipimporter.prefix", 
        "params": [], 
        "path": "python/library/zipimport#zipimport.zipimporter.prefix", 
        "syntax": "prefix", 
        "type": "Importing"
    }, 
    "zlib.Compress.compress": {
        "descr": "Compress data, returning a bytes object containing compressed data for at least part of the data in data. This data should be concatenated to the output produced by any preceding calls to the compress() method. Some input may be kept in internal buffers for later processing.", 
        "name": "zlib.Compress.compress", 
        "params": [], 
        "path": "python/library/zlib#zlib.Compress.compress", 
        "syntax": "Compress.compress(data)", 
        "type": "Data Compression"
    }, 
    "zlib.Compress.copy": {
        "descr": "Returns a copy of the compression object. This can be used to efficiently compress a set of data that share a common initial prefix.", 
        "name": "zlib.Compress.copy", 
        "params": [], 
        "path": "python/library/zlib#zlib.Compress.copy", 
        "syntax": "Compress.copy()", 
        "type": "Data Compression"
    }, 
    "zlib.Compress.flush": {
        "descr": "All pending input is processed, and a bytes object containing the remaining compressed output is returned. mode can be selected from the constants Z_SYNC_FLUSH, Z_FULL_FLUSH, or Z_FINISH, defaulting to Z_FINISH. Z_SYNC_FLUSH and Z_FULL_FLUSH allow compressing further bytestrings of data, while Z_FINISH finishes the compressed stream and prevents compressing any more data. After calling flush() with mode set to Z_FINISH, the compress() method cannot be called again; the only realistic action is to delete the object.", 
        "name": "zlib.Compress.flush", 
        "params": [], 
        "path": "python/library/zlib#zlib.Compress.flush", 
        "syntax": "Compress.flush([mode])", 
        "type": "Data Compression"
    }, 
    "zlib.Decompress.copy": {
        "descr": "Returns a copy of the decompression object. This can be used to save the state of the decompressor midway through the data stream in order to speed up random seeks into the stream at a future point.", 
        "name": "zlib.Decompress.copy", 
        "params": [], 
        "path": "python/library/zlib#zlib.Decompress.copy", 
        "syntax": "Decompress.copy()", 
        "type": "Data Compression"
    }, 
    "zlib.Decompress.decompress": {
        "descr": "Decompress data, returning a bytes object containing the uncompressed data corresponding to at least part of the data in string. This data should be concatenated to the output produced by any preceding calls to the decompress() method. Some of the input data may be preserved in internal buffers for later processing.", 
        "name": "zlib.Decompress.decompress", 
        "params": [], 
        "path": "python/library/zlib#zlib.Decompress.decompress", 
        "syntax": "Decompress.decompress(data[, max_length])", 
        "type": "Data Compression"
    }, 
    "zlib.Decompress.eof": {
        "descr": "A boolean indicating whether the end of the compressed data stream has been reached.", 
        "name": "zlib.Decompress.eof", 
        "params": [], 
        "path": "python/library/zlib#zlib.Decompress.eof", 
        "syntax": "Decompress.eof", 
        "type": "Data Compression"
    }, 
    "zlib.Decompress.flush": {
        "descr": "All pending input is processed, and a bytes object containing the remaining uncompressed output is returned. After calling flush(), the decompress() method cannot be called again; the only realistic action is to delete the object.", 
        "name": "zlib.Decompress.flush", 
        "params": [], 
        "path": "python/library/zlib#zlib.Decompress.flush", 
        "syntax": "Decompress.flush([length])", 
        "type": "Data Compression"
    }, 
    "zlib.Decompress.unconsumed_tail": {
        "descr": "A bytes object that contains any data that was not consumed by the last decompress() call because it exceeded the limit for the uncompressed data buffer. This data has not yet been seen by the zlib machinery, so you must feed it (possibly with further data concatenated to it) back to a subsequent decompress() method call in order to get correct output.", 
        "name": "zlib.Decompress.unconsumed_tail", 
        "params": [], 
        "path": "python/library/zlib#zlib.Decompress.unconsumed_tail", 
        "syntax": "Decompress.unconsumed_tail", 
        "type": "Data Compression"
    }, 
    "zlib.Decompress.unused_data": {
        "descr": "A bytes object which contains any bytes past the end of the compressed data. That is, this remains b\"\" until the last byte that contains compression data is available. If the whole bytestring turned out to contain compressed data, this is b\"\", an empty bytes object.", 
        "name": "zlib.Decompress.unused_data", 
        "params": [], 
        "path": "python/library/zlib#zlib.Decompress.unused_data", 
        "syntax": "Decompress.unused_data", 
        "type": "Data Compression"
    }, 
    "zlib.adler32": {
        "descr": "Computes a Adler-32 checksum of data. (An Adler-32 checksum is almost as reliable as a CRC32 but can be computed much more quickly.) If value is present, it is used as the starting value of the checksum; otherwise, a fixed default value is used. This allows computing a running checksum over the concatenation of several inputs. The algorithm is not cryptographically strong, and should not be used for authentication or digital signatures. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm.", 
        "name": "zlib.adler32", 
        "params": [], 
        "path": "python/library/zlib#zlib.adler32", 
        "syntax": "zlib.adler32(data[, value])", 
        "type": "Data Compression"
    }, 
    "zlib.compress": {
        "descr": "Compresses the bytes in data, returning a bytes object containing compressed data. level is an integer from 0 to 9 controlling the level of compression; 1 is fastest and produces the least compression, 9 is slowest and produces the most. 0 is no compression. The default value is 6. Raises the error exception if any error occurs.", 
        "name": "zlib.compress", 
        "params": [], 
        "path": "python/library/zlib#zlib.compress", 
        "syntax": "zlib.compress(data[, level])", 
        "type": "Data Compression"
    }, 
    "zlib.compressobj": {
        "descr": "Returns a compression object, to be used for compressing data streams that won\u2019t fit into memory at once.", 
        "name": "zlib.compressobj", 
        "params": [], 
        "path": "python/library/zlib#zlib.compressobj", 
        "syntax": "zlib.compressobj(level=-1, method=DEFLATED, wbits=15, memlevel=8, strategy=Z_DEFAULT_STRATEGY[, zdict])", 
        "type": "Data Compression"
    }, 
    "zlib.crc32": {
        "descr": "Always returns an unsigned 32-bit integer.", 
        "name": "zlib.crc32", 
        "params": [], 
        "path": "python/library/zlib#zlib.crc32", 
        "syntax": "zlib.crc32(data[, value])", 
        "type": "Data Compression"
    }, 
    "zlib.decompress": {
        "descr": "Decompresses the bytes in data, returning a bytes object containing the uncompressed data. The wbits parameter controls the size of the window buffer, and is discussed further below. If bufsize is given, it is used as the initial size of the output buffer. Raises the error exception if any error occurs.", 
        "name": "zlib.decompress", 
        "params": [], 
        "path": "python/library/zlib#zlib.decompress", 
        "syntax": "zlib.decompress(data[, wbits[, bufsize]])", 
        "type": "Data Compression"
    }, 
    "zlib.decompressobj": {
        "descr": "Returns a decompression object, to be used for decompressing data streams that won\u2019t fit into memory at once.", 
        "name": "zlib.decompressobj", 
        "params": [], 
        "path": "python/library/zlib#zlib.decompressobj", 
        "syntax": "zlib.decompressobj(wbits=15[, zdict])", 
        "type": "Data Compression"
    }, 
    "zlib.error": {
        "descr": "Exception raised on compression and decompression errors.", 
        "name": "zlib.error", 
        "params": [], 
        "path": "python/library/zlib#zlib.error", 
        "syntax": "exception zlib.error", 
        "type": "Data Compression"
    }
}